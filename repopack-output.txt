This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-14T01:20:43.063Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
ares/AdjacencyBonus.ts
ares/AdjacencyCost.ts
ares/AresHandler.ts
ares/AresHazards.ts
ares/AresSetup.ts
awards/Adapter.ts
awards/amazonisPlanitia/Curator.ts
awards/amazonisPlanitia/Engineer.ts
awards/amazonisPlanitia/Historian.ts
awards/amazonisPlanitia/Tourist.ts
awards/amazonisPlanitia/Zoologist.ts
awards/Awards.ts
awards/AwardScorer.ts
awards/Banker.ts
awards/Benefactor.ts
awards/Botanist.ts
awards/Celebrity.ts
awards/Contractor.ts
awards/Coordinator.ts
awards/CosmicSettler.ts
awards/Cultivator.ts
awards/DesertSettler.ts
awards/Edgedancer.ts
awards/Entrepreneur.ts
awards/EstateDealer.ts
awards/Excentric.ts
awards/FundedAward.ts
awards/Hoarder.ts
awards/IAward.ts
awards/Industrialist.ts
awards/Landlord.ts
awards/Magnate.ts
awards/Manufacturer.ts
awards/Miner.ts
awards/Naturalist.ts
awards/Scientist.ts
awards/SpaceBaron.ts
awards/terraCimmeria/Biologist.ts
awards/terraCimmeria/Economizer2.ts
awards/terraCimmeria/Politician.ts
awards/terraCimmeria/Urbanist.ts
awards/terraCimmeria/Warmonger.ts
awards/Thermalist.ts
awards/underworld/EdgeLord.ts
awards/underworld/Kingpin.ts
awards/Venuphile.ts
awards/Voyager.ts
awards/Zoologist.ts
behavior/Behavior.ts
behavior/BehaviorExecutor.ts
behavior/Countable.ts
behavior/Counter.ts
behavior/Executor.ts
behavior/NoAttributes.ts
boards/AmazonisBoard.ts
boards/ArabiaTerraBoard.ts
boards/Board.ts
boards/BoardBuilder.ts
boards/BoardType.ts
boards/ElysiumBoard.ts
boards/HellasBoard.ts
boards/MarsBoard.ts
boards/PlacementType.ts
boards/SerializedBoard.ts
boards/Space.ts
boards/TerraCimmeriaBoard.ts
boards/TerraCimmeriaNovusBoard.ts
boards/TharsisBoard.ts
boards/UtopiaPlanitiaBoard.ts
boards/VastitasBorealisBoard.ts
boards/VastitasBorealisNovusBoard.ts
cards/ActionCard.ts
cards/AllManifests.ts
cards/ares/AresCardManifest.ts
cards/ares/BioengineeringEnclosure.ts
cards/ares/BiofertilizerFacility.ts
cards/ares/ButterflyEffect.ts
cards/ares/CapitalAres.ts
cards/ares/CommercialDistrictAres.ts
cards/ares/DeimosDownAres.ts
cards/ares/DesperateMeasures.ts
cards/ares/EcologicalSurvey.ts
cards/ares/EcologicalZoneAres.ts
cards/ares/GeologicalSurvey.ts
cards/ares/GreatDamAres.ts
cards/ares/IndustrialCenterAres.ts
cards/ares/LavaFlowsAres.ts
cards/ares/MagneticFieldGeneratorsAres.ts
cards/ares/MarketingExperts.ts
cards/ares/MetallicAsteroid.ts
cards/ares/MiningAreaAres.ts
cards/ares/MiningRightsAres.ts
cards/ares/MoholeAreaAres.ts
cards/ares/NaturalPreserveAres.ts
cards/ares/NuclearZoneAres.ts
cards/ares/OceanCity.ts
cards/ares/OceanFarm.ts
cards/ares/OceanSanctuary.ts
cards/ares/RestrictedAreaAres.ts
cards/ares/SolarFarm.ts
cards/ares/SurveyCard.ts
cards/base/AcquiredCompany.ts
cards/base/AdaptationTechnology.ts
cards/base/AdaptedLichen.ts
cards/base/AdvancedAlloys.ts
cards/base/AdvancedEcosystems.ts
cards/base/AerobrakedAmmoniaAsteroid.ts
cards/base/AICentral.ts
cards/base/Algae.ts
cards/base/AntiGravityTechnology.ts
cards/base/Ants.ts
cards/base/AquiferPumping.ts
cards/base/ArchaeBacteria.ts
cards/base/ArcticAlgae.ts
cards/base/ArtificialLake.ts
cards/base/ArtificialPhotosynthesis.ts
cards/base/Asteroid.ts
cards/base/AsteroidMining.ts
cards/base/AsteroidMiningConsortium.ts
cards/base/BeamFromAThoriumAsteroid.ts
cards/base/BigAsteroid.ts
cards/base/BiomassCombustors.ts
cards/base/Birds.ts
cards/base/BlackPolarDust.ts
cards/base/BreathingFilters.ts
cards/base/BribedCommittee.ts
cards/base/BuildingIndustries.ts
cards/base/Bushes.ts
cards/base/BusinessContacts.ts
cards/base/BusinessNetwork.ts
cards/base/CallistoPenalMines.ts
cards/base/Capital.ts
cards/base/CarbonateProcessing.ts
cards/base/CaretakerContract.ts
cards/base/Cartel.ts
cards/base/CEOsFavoriteProject.ts
cards/base/CloudSeeding.ts
cards/base/ColonizerTrainingCamp.ts
cards/base/Comet.ts
cards/base/CommercialDistrict.ts
cards/base/ConvoyFromEuropa.ts
cards/base/CorporateStronghold.ts
cards/base/CupolaCity.ts
cards/base/Decomposers.ts
cards/base/DeepWellHeating.ts
cards/base/DeimosDown.ts
cards/base/DesignedMicroOrganisms.ts
cards/base/DevelopmentCenter.ts
cards/base/DomedCrater.ts
cards/base/DustSeals.ts
cards/base/EarthCatapult.ts
cards/base/EarthOffice.ts
cards/base/EcologicalZone.ts
cards/base/ElectroCatapult.ts
cards/base/EnergySaving.ts
cards/base/EnergyTapping.ts
cards/base/EOSChasmaNationalPark.ts
cards/base/EquatorialMagnetizer.ts
cards/base/ExtremeColdFungus.ts
cards/base/Farming.ts
cards/base/Fish.ts
cards/base/Flooding.ts
cards/base/FoodFactory.ts
cards/base/FueledGenerators.ts
cards/base/FuelFactory.ts
cards/base/FusionPower.ts
cards/base/GanymedeColony.ts
cards/base/GeneRepair.ts
cards/base/GeothermalPower.ts
cards/base/GHGFactories.ts
cards/base/GHGProducingBacteria.ts
cards/base/GiantIceAsteroid.ts
cards/base/GiantSpaceMirror.ts
cards/base/Grass.ts
cards/base/GreatDam.ts
cards/base/GreatEscarpmentConsortium.ts
cards/base/Greenhouses.ts
cards/base/Hackers.ts
cards/base/Heather.ts
cards/base/HeatTrappers.ts
cards/base/Herbivores.ts
cards/base/HiredRaiders.ts
cards/base/IceAsteroid.ts
cards/base/IceCapMelting.ts
cards/base/ImmigrantCity.ts
cards/base/ImmigrationShuttles.ts
cards/base/ImportedGHG.ts
cards/base/ImportedHydrogen.ts
cards/base/ImportedNitrogen.ts
cards/base/ImportOfAdvancedGHG.ts
cards/base/IndenturedWorkers.ts
cards/base/IndustrialCenter.ts
cards/base/IndustrialMicrobes.ts
cards/base/Insects.ts
cards/base/Insulation.ts
cards/base/InterstellarColonyShip.ts
cards/base/InventionContest.ts
cards/base/InventorsGuild.ts
cards/base/InvestmentLoan.ts
cards/base/IoMiningIndustries.ts
cards/base/Ironworks.ts
cards/base/KelpFarming.ts
cards/base/LagrangeObservatory.ts
cards/base/LakeMarineris.ts
cards/base/LandClaim.ts
cards/base/LargeConvoy.ts
cards/base/LavaFlows.ts
cards/base/Lichen.ts
cards/base/LightningHarvest.ts
cards/base/Livestock.ts
cards/base/LocalHeatTrapping.ts
cards/base/LunarBeam.ts
cards/base/MagneticFieldDome.ts
cards/base/MagneticFieldGenerators.ts
cards/base/Mangrove.ts
cards/base/MarsUniversity.ts
cards/base/MartianRails.ts
cards/base/MassConverter.ts
cards/base/MediaArchives.ts
cards/base/MediaGroup.ts
cards/base/MedicalLab.ts
cards/base/MethaneFromTitan.ts
cards/base/MicroMills.ts
cards/base/Mine.ts
cards/base/MineralDeposit.ts
cards/base/MiningArea.ts
cards/base/MiningCard.ts
cards/base/MiningExpedition.ts
cards/base/MiningRights.ts
cards/base/MirandaResort.ts
cards/base/MoholeArea.ts
cards/base/Moss.ts
cards/base/NaturalPreserve.ts
cards/base/NitriteReducingBacteria.ts
cards/base/NitrogenRichAsteroid.ts
cards/base/NitrophilicMoss.ts
cards/base/NoctisCity.ts
cards/base/NoctisFarming.ts
cards/base/NuclearPower.ts
cards/base/NuclearZone.ts
cards/base/OlympusConference.ts
cards/base/OpenCity.ts
cards/base/OptimalAerobraking.ts
cards/base/OreProcessor.ts
cards/base/PermafrostExtraction.ts
cards/base/PeroxidePower.ts
cards/base/Pets.ts
cards/base/PhobosSpaceHaven.ts
cards/base/PhysicsComplex.ts
cards/base/Plantation.ts
cards/base/PowerGrid.ts
cards/base/PowerInfrastructure.ts
cards/base/PowerPlant.ts
cards/base/PowerSupplyConsortium.ts
cards/base/Predators.ts
cards/base/ProtectedHabitats.ts
cards/base/ProtectedValley.ts
cards/base/QuantumExtractor.ts
cards/base/RadChemFactory.ts
cards/base/RadSuits.ts
cards/base/RegolithEaters.ts
cards/base/ReleaseOfInertGases.ts
cards/base/Research.ts
cards/base/ResearchOutpost.ts
cards/base/RestrictedArea.ts
cards/base/RoboticWorkforce.ts
cards/base/RoboticWorkforceBase.ts
cards/base/RoverConstruction.ts
cards/base/Sabotage.ts
cards/base/Satellites.ts
cards/base/SearchForLife.ts
cards/base/SecurityFleet.ts
cards/base/Shuttles.ts
cards/base/SmallAnimals.ts
cards/base/SoilFactory.ts
cards/base/SolarPower.ts
cards/base/SolarWindPower.ts
cards/base/Soletta.ts
cards/base/SpaceElevator.ts
cards/base/SpaceMirrors.ts
cards/base/SpaceStation.ts
cards/base/SpecialDesign.ts
cards/base/Sponsors.ts
cards/base/standardActions/ConvertHeat.ts
cards/base/standardActions/ConvertPlants.ts
cards/base/standardActions/standardProjects/AquiferStandardProject.ts
cards/base/standardActions/standardProjects/AsteroidStandardProject.ts
cards/base/standardActions/standardProjects/CityStandardProject.ts
cards/base/standardActions/standardProjects/GreeneryStandardProject.ts
cards/base/standardActions/standardProjects/PowerPlantStandardProject.ts
cards/base/standardActions/standardProjects/SellPatentsStandardProject.ts
cards/base/StandardTechnology.ts
cards/base/Steelworks.ts
cards/base/StripMine.ts
cards/base/SubterraneanReservoir.ts
cards/base/SymbioticFungus.ts
cards/base/Tardigrades.ts
cards/base/TechnologyDemonstration.ts
cards/base/TectonicStressPower.ts
cards/base/TerraformingGanymede.ts
cards/base/TitaniumMine.ts
cards/base/TollStation.ts
cards/base/TowingAComet.ts
cards/base/TransNeptuneProbe.ts
cards/base/Trees.ts
cards/base/TropicalResort.ts
cards/base/TundraFarming.ts
cards/base/UndergroundCity.ts
cards/base/UndergroundDetonations.ts
cards/base/UrbanizedArea.ts
cards/base/VestaShipyard.ts
cards/base/ViralEnhancers.ts
cards/base/Virus.ts
cards/base/WaterImportFromEuropa.ts
cards/base/WaterSplittingPlant.ts
cards/base/WavePower.ts
cards/base/Windmills.ts
cards/base/Worms.ts
cards/base/Zeppelins.ts
cards/Card.ts
cards/CardRequirementDescriptor.ts
cards/cardSerialization.ts
cards/ceos/Apollo.ts
cards/ceos/Asimov.ts
cards/ceos/Bjorn.ts
cards/ceos/Caesar.ts
cards/ceos/CeoCard.ts
cards/ceos/CeoCardManifest.ts
cards/ceos/Clarke.ts
cards/ceos/CoLeadership.ts
cards/ceos/Duncan.ts
cards/ceos/Ender.ts
cards/ceos/Faraday.ts
cards/ceos/Floyd.ts
cards/ceos/Gaia.ts
cards/ceos/Gordon.ts
cards/ceos/Greta.ts
cards/ceos/HAL9000.ts
cards/ceos/ICeoCard.ts
cards/ceos/Ingrid.ts
cards/ceos/Jansson.ts
cards/ceos/Karen.ts
cards/ceos/Lowell.ts
cards/ceos/Maria.ts
cards/ceos/Musk.ts
cards/ceos/Naomi.ts
cards/ceos/Neil.ts
cards/ceos/Oscar.ts
cards/ceos/Petra.ts
cards/ceos/Quill.ts
cards/ceos/Rogers.ts
cards/ceos/Ryu.ts
cards/ceos/Shara.ts
cards/ceos/Stefan.ts
cards/ceos/Tate.ts
cards/ceos/Ulrich.ts
cards/ceos/VanAllen.ts
cards/ceos/Will.ts
cards/ceos/Xavier.ts
cards/ceos/Xu.ts
cards/ceos/Yvonne.ts
cards/ceos/Zan.ts
cards/chemical/AlchemicReactions.ts
cards/chemical/base/1_SubcrustVaporTrapping.ts
cards/chemical/base/10_ArtificialAsteroid.ts
cards/chemical/base/100_ExplosivesTestSite.ts
cards/chemical/base/101_GrandStadium.ts
cards/chemical/base/102_PolarOutpost.ts
cards/chemical/base/103_RuralHousing.ts
cards/chemical/base/104_TunnelBoring.ts
cards/chemical/base/105_LithiumMine.ts
cards/chemical/base/106_ChasmaExcavation.ts
cards/chemical/base/107_DeepPolarExtraction.ts
cards/chemical/base/108_CallistoOperations.ts
cards/chemical/base/109_SaturnGasMine.ts
cards/chemical/base/11_InstantiatedSolarFlare.ts
cards/chemical/base/110_LaserDrillMining.ts
cards/chemical/base/111_HydrualicMining.ts
cards/chemical/base/112_EnzymaticTreatment.ts
cards/chemical/base/113_RegolithAeration.ts
cards/chemical/base/114_Mixotrophs.ts
cards/chemical/base/115_BotanicalLab.ts
cards/chemical/base/116_IndustrialComposting.ts
cards/chemical/base/117_ExtremeNitrophiles.ts
cards/chemical/base/118_VascularTundraPlants.ts
cards/chemical/base/119_Bamboo.ts
cards/chemical/base/12_AcceleratedImpactor.ts
cards/chemical/base/120_ErosionReducingGreenery.ts
cards/chemical/base/121_ParasiticPlants.ts
cards/chemical/base/122_Wildberries.ts
cards/chemical/base/123_AnaerobicEnergyCropping.ts
cards/chemical/base/124_AdaptedHardwood.ts
cards/chemical/base/125_AquaticBiodomes.ts
cards/chemical/base/126_Conifers.ts
cards/chemical/base/127_WildBarley.ts
cards/chemical/base/128_WetlandsChemical.ts
cards/chemical/base/129_Cacti.ts
cards/chemical/base/13_IronRichAsteroid.ts
cards/chemical/base/130_AdaptedFruitFarming.ts
cards/chemical/base/131_RiceFields.ts
cards/chemical/base/132_CoralReef.ts
cards/chemical/base/133_CyanobacteriaChemical.ts
cards/chemical/base/134_HydroponicsFacility.ts
cards/chemical/base/135_RedAlgae.ts
cards/chemical/base/136_Irrigation.ts
cards/chemical/base/137_Monsoons.ts
cards/chemical/base/138_HeavyRespirators.ts
cards/chemical/base/139_BeeFarming.ts
cards/chemical/base/14_Overgrowth.ts
cards/chemical/base/140_SyntheticGrowthHormones.ts
cards/chemical/base/141_SpaceBasedSolarPower.ts
cards/chemical/base/142_EfficientBatteries.ts
cards/chemical/base/143_LargePowerPlant.ts
cards/chemical/base/144_HydrocarbonSynthesis.ts
cards/chemical/base/145_AtmosphericProcessing.ts
cards/chemical/base/146_UraniumDeposit.ts
cards/chemical/base/147_AlgaeBioreactors.ts
cards/chemical/base/148_MassiveSolarFarm.ts
cards/chemical/base/149_AdvancedHydropower.ts
cards/chemical/base/15_CondensedGasConvoy.ts
cards/chemical/base/150_EnrichmentPlant.ts
cards/chemical/base/151_FuelCellProduction.ts
cards/chemical/base/152_EnergyMohole.ts
cards/chemical/base/153_HighPowerBetavoltaics.ts
cards/chemical/base/154_CentralPowerPlant.ts
cards/chemical/base/155_IsotopeEnrichingBacteria.ts
cards/chemical/base/156_AnaerobicBacteria.ts
cards/chemical/base/157_SolidStateWildEnergy.ts
cards/chemical/base/158_AtmosphericPressureEngine.ts
cards/chemical/base/159_LaserCannon.ts
cards/chemical/base/16_TemporarySmeltingPlant.ts
cards/chemical/base/160_PerfluorocarbonProduction.ts
cards/chemical/base/161_GHGFactoryDistrict.ts
cards/chemical/base/162_NaturalGasExtraction.ts
cards/chemical/base/163_HydrothermalVents.ts
cards/chemical/base/164_OzoneFactories.ts
cards/chemical/base/165_ProbioticTreatment.ts
cards/chemical/base/166_MirandaLabs.ts
cards/chemical/base/167_MarsLifeScienceInstitute.ts
cards/chemical/base/168_SpeciesCryopreservation.ts
cards/chemical/base/17_CyanobacteriaBloom.ts
cards/chemical/base/18_OxygenShipment.ts
cards/chemical/base/19_SpecialAerosols.ts
cards/chemical/base/2_ConvoyFromTitan.ts
cards/chemical/base/20_ImportedFuel.ts
cards/chemical/base/21_AsteroidMiningExpedition.ts
cards/chemical/base/22_LowlandExpedition.ts
cards/chemical/base/23_PowerSurge.ts
cards/chemical/base/24_MinorImpactor.ts
cards/chemical/base/25_ControlledBurn.ts
cards/chemical/base/26_EcologicalShipment.ts
cards/chemical/base/27_PanspermiaSurvey.ts
cards/chemical/base/28_HabitatConservation.ts
cards/chemical/base/29_AsteroidStudy.ts
cards/chemical/base/3_HighSpeedComet.ts
cards/chemical/base/30_NitrogenAsteroids.ts
cards/chemical/base/31_OxygenatedComets.ts
cards/chemical/base/32_KuiperBeltIceAsteroids.ts
cards/chemical/base/33_CeresMiningOperations.ts
cards/chemical/base/34_AmmoniaHeavyAsteroids.ts
cards/chemical/base/35_MTypeAsteroidMining.ts
cards/chemical/base/36_FloatingWeatherProbes.ts
cards/chemical/base/37_ProductionDrones.ts
cards/chemical/base/38_EuropanBacteria.ts
cards/chemical/base/39_Termites.ts
cards/chemical/base/4_TitaniumComet.ts
cards/chemical/base/40_MartianThermophiles.ts
cards/chemical/base/41_MimicryArchaea.ts
cards/chemical/base/42_Macroplankton.ts
cards/chemical/base/43_WaterSplittingMicrobes.ts
cards/chemical/base/44_HalogenReconstructors.ts
cards/chemical/base/45_AntiOxidationBacteria.ts
cards/chemical/base/46_ThallophyteProtists.ts
cards/chemical/base/47_CarbonLatticeMicrobes.ts
cards/chemical/base/48_ElectroplaqueMicrobes.ts
cards/chemical/base/49_LargeAquaticMammals.ts
cards/chemical/base/5_ExpeditionToDione.ts
cards/chemical/base/50_TundraWildlife.ts
cards/chemical/base/51_Raptors.ts
cards/chemical/base/52_FishFarmingLake.ts
cards/chemical/base/53_Cephalopods.ts
cards/chemical/base/54_EndangeredSpeciesRefuge.ts
cards/chemical/base/55_NonHypoxicSmallAnimals.ts
cards/chemical/base/56_SubterranianCreatures.ts
cards/chemical/base/57_AntarcticKrill.ts
cards/chemical/base/58_AncientArthropods.ts
cards/chemical/base/59_AdaptiveBiotics.ts
cards/chemical/base/6_LargeThermalDetonator.ts
cards/chemical/base/60_HabitatDomes.ts
cards/chemical/base/61_Aquaponics.ts
cards/chemical/base/62_SprawlingCity.ts
cards/chemical/base/63_ImperativeSettlement.ts
cards/chemical/base/64_EcoCentral.ts
cards/chemical/base/65_Canals.ts
cards/chemical/base/66_FreightShuttles.ts
cards/chemical/base/67_SiliconFactory.ts
cards/chemical/base/68_AluminumFoundry.ts
cards/chemical/base/69_ThawMining.ts
cards/chemical/base/7_HydrogenFromSaturn.ts
cards/chemical/base/70_EcologicalContract.ts
cards/chemical/base/71_AdvancedGeneticAdaption.ts
cards/chemical/base/72_EssentialSymbiotics.ts
cards/chemical/base/73_MicrobeCultivationFacility.ts
cards/chemical/base/74_Biodomes.ts
cards/chemical/base/75_BiomassReactor.ts
cards/chemical/base/76_LocalTemperatureControl.ts
cards/chemical/base/77_CO2Vents.ts
cards/chemical/base/78_RegolithTreatment.ts
cards/chemical/base/79_EuropaWaterSplitting.ts
cards/chemical/base/8_GiantCarbonateAsteroid.ts
cards/chemical/base/80_BiodiversityContract.ts
cards/chemical/base/81_TemperateRainforest.ts
cards/chemical/base/82_GeneticEngineeringLab.ts
cards/chemical/base/83_OceanographyResearch.ts
cards/chemical/base/84_HeavyAerospaceTech.ts
cards/chemical/base/85_InsulatedCity.ts
cards/chemical/base/86_BuriedSettlement.ts
cards/chemical/base/87_HugeCity.ts
cards/chemical/base/88_MiningCommunity.ts
cards/chemical/base/89_DeepBurrowSettlement.ts
cards/chemical/base/9_CarbonateAsteroid.ts
cards/chemical/base/90_InstituteSettlement.ts
cards/chemical/base/91_MultifunctionalDome.ts
cards/chemical/base/92_IndependentSettlement.ts
cards/chemical/base/93_GeothermalReserviorHeating.ts
cards/chemical/base/94_MunicipalReservior.ts
cards/chemical/base/95_FreshwaterLake.ts
cards/chemical/base/96_HugeGlacier.ts
cards/chemical/base/97_DeepWellPump.ts
cards/chemical/base/98_CommercialImports.ts
cards/chemical/base/99_UrbanDevelopment.ts
cards/chemical/base/Primates.ts
cards/chemical/ChemicalCardManifest.ts
cards/chemical/colonies/ArcticEndoliths.ts
cards/chemical/colonies/AsteroidBeltColony.ts
cards/chemical/colonies/AzaleaBushes.ts
cards/chemical/colonies/BiodiversityBoom.ts
cards/chemical/colonies/BusinessColony.ts
cards/chemical/colonies/CassiniEnterprises.ts
cards/chemical/colonies/CeresLaunchpad.ts
cards/chemical/colonies/ColonyMiningInfrastructure.ts
cards/chemical/colonies/ColonyReforms.ts
cards/chemical/colonies/ColonySpaceMirrors.ts
cards/chemical/colonies/ColonySuppliers.ts
cards/chemical/colonies/CommissionedFleet.ts
cards/chemical/colonies/CoordinatedRaidChemcial.ts
cards/chemical/colonies/DeepJupiterProbe.ts
cards/chemical/colonies/DomeFarmingColony.ts
cards/chemical/colonies/EarthEmbassyChemical.ts
cards/chemical/colonies/EnergyBeamColony.ts
cards/chemical/colonies/FloaterFacility.ts
cards/chemical/colonies/FloatingColony.ts
cards/chemical/colonies/FloatingTechInvestments.ts
cards/chemical/colonies/FloatingTechResearch.ts
cards/chemical/colonies/FuelSubsidies.ts
cards/chemical/colonies/GalileanMiningNetwork.ts
cards/chemical/colonies/GasGiantHabs.ts
cards/chemical/colonies/HemeraBunker.ts
cards/chemical/colonies/HighOrbitResearchStation.ts
cards/chemical/colonies/HyperExtremophileFungi.ts
cards/chemical/colonies/IceMoonCollision.ts
cards/chemical/colonies/IndustrialColony.ts
cards/chemical/colonies/JovianConstructionYard.ts
cards/chemical/colonies/JovianMoonMapping.ts
cards/chemical/colonies/JupiterFloatingCity.ts
cards/chemical/colonies/KuiperBeltColony.ts
cards/chemical/colonies/LargeTradingFleet.ts
cards/chemical/colonies/LunaColonizationInvestments.ts
cards/chemical/colonies/LunarH3Mining.ts
cards/chemical/colonies/LunarPort.ts
cards/chemical/colonies/LunarPowerGrid.ts
cards/chemical/colonies/LunarResort.ts
cards/chemical/colonies/MarketSiphon.ts
cards/chemical/colonies/MercurialSunshade.ts
cards/chemical/colonies/MethaneExports.ts
cards/chemical/colonies/MicrogravityLab.ts
cards/chemical/colonies/MilitarySpaceStation.ts
cards/chemical/colonies/MuseumOfLuna.ts
cards/chemical/colonies/OrbitalBiodomes.ts
cards/chemical/colonies/OuterSolarMission.ts
cards/chemical/colonies/PlanetaryTrade.ts
cards/chemical/colonies/PrivateColony.ts
cards/chemical/colonies/ProductivityQuota.ts
cards/chemical/colonies/ProtoDysonSwarm.ts
cards/chemical/colonies/RemoteMiningBase.ts
cards/chemical/colonies/RemoteTestZone.ts
cards/chemical/colonies/ResearchMissions.ts
cards/chemical/colonies/RimPopulationCenter.ts
cards/chemical/colonies/SelfSufficientColony.ts
cards/chemical/colonies/SlumCity.ts
cards/chemical/colonies/SpaceTethers.ts
cards/chemical/colonies/SponsoredFlight.ts
cards/chemical/colonies/TerrestrialResearchSummit.ts
cards/chemical/colonies/ThermalReservior.ts
cards/chemical/colonies/TitanFuelStation.ts
cards/chemical/colonies/TitanResearchOutpost.ts
cards/chemical/colonies/WaterFromTitan.ts
cards/chemical/colonies/WaypointColony.ts
cards/chemical/colonies/Wildflowers.ts
cards/chemical/corpera/1_AquiferRelocation.ts
cards/chemical/corpera/10_PublicRecords.ts
cards/chemical/corpera/11_AcidRain.ts
cards/chemical/corpera/12_PowerFailure.ts
cards/chemical/corpera/13_AstrophysicsCenter.ts
cards/chemical/corpera/14_CentaurLandings.ts
cards/chemical/corpera/15_VestaObservatory.ts
cards/chemical/corpera/16_MeasurementDrones.ts
cards/chemical/corpera/17_AdvancedBiomachinery.ts
cards/chemical/corpera/18_LongTermEvolutionStudy.ts
cards/chemical/corpera/19_ScientificLogs.ts
cards/chemical/corpera/2_SpeculativeMarkets.ts
cards/chemical/corpera/20_ConstructionCenter.ts
cards/chemical/corpera/21_HomeworldHeadquarters.ts
cards/chemical/corpera/22_MartianInvestments.ts
cards/chemical/corpera/23_LaserLightsails.ts
cards/chemical/corpera/24_SponsoredResearchFirm.ts
cards/chemical/corpera/25_JovianSuppliers.ts
cards/chemical/corpera/26_OlympusArchives.ts
cards/chemical/corpera/27_NeuralEnchancement.ts
cards/chemical/corpera/28_Superpolymers.ts
cards/chemical/corpera/29_AlloyFactory.ts
cards/chemical/corpera/3_ResearchGrant.ts
cards/chemical/corpera/30_NovaFoundry.ts
cards/chemical/corpera/31_KugelblitzEngine.ts
cards/chemical/corpera/32_ExoticMatterReactor.ts
cards/chemical/corpera/33_SolarStation.ts
cards/chemical/corpera/34_UndergroundTestSite.ts
cards/chemical/corpera/35_StandardAlloys.ts
cards/chemical/corpera/36_OverseerCommittee.ts
cards/chemical/corpera/4_SmallSupplyDrop.ts
cards/chemical/corpera/5_HermesMission.ts
cards/chemical/corpera/6_AssetLiquidation.ts
cards/chemical/corpera/7_Parasite.ts
cards/chemical/corpera/8_RoboticsExhibition.ts
cards/chemical/corpera/9_PatentTrading.ts
cards/chemical/corpera/AcquiredResearchFirm.ts
cards/chemical/corpera/ArtificialMicrobialLife.ts
cards/chemical/corpera/CashCrops.ts
cards/chemical/corpera/ChemicalPlant.ts
cards/chemical/corpera/ColdFusionPower.ts
cards/chemical/corpera/CommunicationsHub.ts
cards/chemical/corpera/ConcreteFactory.ts
cards/chemical/corpera/ContractedConstruction.ts
cards/chemical/corpera/Crowdfunding.ts
cards/chemical/corpera/ExplosiveMining.ts
cards/chemical/corpera/ExtremePowerEfficiency.ts
cards/chemical/corpera/GalileanGovernor.ts
cards/chemical/corpera/GreatHarbor.ts
cards/chemical/corpera/InterstallarProbe.ts
cards/chemical/corpera/LuxuryResort.ts
cards/chemical/corpera/ManufacturingPlant.ts
cards/chemical/corpera/MartianBanking.ts
cards/chemical/corpera/MediaConglomerate.ts
cards/chemical/corpera/MilitaryBase.ts
cards/chemical/corpera/MilitarySpacePort.ts
cards/chemical/corpera/MolecularScienceLab.ts
cards/chemical/corpera/MountaintopRemoval.ts
cards/chemical/corpera/NuclearForcePower.ts
cards/chemical/corpera/PrintManufacturing.ts
cards/chemical/corpera/ProjectAdvancement.ts
cards/chemical/corpera/SaltMine.ts
cards/chemical/corpera/ScientificMegaopolis.ts
cards/chemical/corpera/ScientificSupport.ts
cards/chemical/corpera/SeedSuppliers.ts
cards/chemical/corpera/Shipyard.ts
cards/chemical/corpera/SteelExports.ts
cards/chemical/corpera/SuccessfulCommerce.ts
cards/chemical/corpera/TheoryOfEverything.ts
cards/chemical/corpera/TitanTradeHub.ts
cards/chemical/corpera/UpperMantleBoring.ts
cards/chemical/corpera/ViralAmeboid.ts
cards/chemical/corpera/VolcanicFoundry.ts
cards/chemical/globalevents/AbstinanceBonus.ts
cards/chemical/globalevents/AnticorrosiveMaterials.ts
cards/chemical/globalevents/ChemicalPollution.ts
cards/chemical/globalevents/ColonizationOfMercury.ts
cards/chemical/globalevents/ColonyProductivity.ts
cards/chemical/globalevents/CommandEconomy.ts
cards/chemical/globalevents/CommunityServicesEvent.ts
cards/chemical/globalevents/ConstitutionalReformation.ts
cards/chemical/globalevents/Cyberattacks.ts
cards/chemical/globalevents/DegredationOfVenus.ts
cards/chemical/globalevents/EcologicalSupport.ts
cards/chemical/globalevents/EcologyProjects.ts
cards/chemical/globalevents/EconomicDepression.ts
cards/chemical/globalevents/EcosystemDisruption.ts
cards/chemical/globalevents/EgalitarianMovements.ts
cards/chemical/globalevents/EradicationOfGeneticIllness.ts
cards/chemical/globalevents/ExtinctionEvent.ts
cards/chemical/globalevents/Famine.ts
cards/chemical/globalevents/FloaterTechnologyEvent.ts
cards/chemical/globalevents/FoodSupply.ts
cards/chemical/globalevents/HeatFirstInitiative.ts
cards/chemical/globalevents/Insurgency.ts
cards/chemical/globalevents/IntellectualistMovement.ts
cards/chemical/globalevents/InterplanetaryCommunities.ts
cards/chemical/globalevents/InterstallarColonization.ts
cards/chemical/globalevents/JovianWar.ts
cards/chemical/globalevents/LaborRevolt.ts
cards/chemical/globalevents/LandDelegation.ts
cards/chemical/globalevents/LandRun.ts
cards/chemical/globalevents/LowlandFlooding.ts
cards/chemical/globalevents/MagneticFieldFailure.ts
cards/chemical/globalevents/MandatoryInsurance.ts
cards/chemical/globalevents/MarsStockExchange.ts
cards/chemical/globalevents/MicrobialBoom.ts
cards/chemical/globalevents/MiningIndustries.ts
cards/chemical/globalevents/NanotechInnovation.ts
cards/chemical/globalevents/PesticideApplication.ts
cards/chemical/globalevents/PowerFailureEvent.ts
cards/chemical/globalevents/PowerGenerationSubsidies.ts
cards/chemical/globalevents/PowerSurplus.ts
cards/chemical/globalevents/PreferentialLoans.ts
cards/chemical/globalevents/RedTourism.ts
cards/chemical/globalevents/RedUprising.ts
cards/chemical/globalevents/RefugeeCrisis.ts
cards/chemical/globalevents/RevisedPatentLaw.ts
cards/chemical/globalevents/RimShortages.ts
cards/chemical/globalevents/SevereMarsquake.ts
cards/chemical/globalevents/SocietiesOfVenus.ts
cards/chemical/globalevents/SpaceTravelLimitations.ts
cards/chemical/globalevents/TaxationOfVenus.ts
cards/chemical/globalevents/TechnologicalRegression.ts
cards/chemical/globalevents/TradeEmbargo.ts
cards/chemical/globalevents/VenusianEcosystems.ts
cards/chemical/globalevents/VenusMining.ts
cards/chemical/globalevents/WildfiresEvent.ts
cards/chemical/pathfinders/PublicSpaceline.ts
cards/chemical/preludes/1_ResearchBase.ts
cards/chemical/preludes/10_WildlifeSponsors.ts
cards/chemical/preludes/11_BlueprintAI.ts
cards/chemical/preludes/12_Bioplastics.ts
cards/chemical/preludes/13_InfrastructureSupport.ts
cards/chemical/preludes/14_IndustryAllies.ts
cards/chemical/preludes/15_NuclearFuelMining.ts
cards/chemical/preludes/16_LunarMiningIndustries.ts
cards/chemical/preludes/17_LaserMining.ts
cards/chemical/preludes/18_CyanobacteriaPods.ts
cards/chemical/preludes/19_GlacialAlgae.ts
cards/chemical/preludes/2_HeavyMetalComet.ts
cards/chemical/preludes/20_AmmoniaAsteroid.ts
cards/chemical/preludes/21_AdaptedVascularGreenery.ts
cards/chemical/preludes/22_EcologicalReserve.ts
cards/chemical/preludes/23_ProtistLifeforms.ts
cards/chemical/preludes/24_PowerCore.ts
cards/chemical/preludes/25_EnergyBeam.ts
cards/chemical/preludes/26_ThermalPlant.ts
cards/chemical/preludes/27_AdvancedHeatingTech.ts
cards/chemical/preludes/28_TerritoryOccupation.ts
cards/chemical/preludes/29_RareMineralReserve.ts
cards/chemical/preludes/3_LegalExperts.ts
cards/chemical/preludes/30_CorporateEspionage.ts
cards/chemical/preludes/31_VenusFirstChemical.ts
cards/chemical/preludes/32_AirScrappingOperations.ts
cards/chemical/preludes/33_TerrestrialPlanetMission.ts
cards/chemical/preludes/34_HydrogenBombardmentChemical.ts
cards/chemical/preludes/35_ExperimentalOrganisms.ts
cards/chemical/preludes/36_VenusianIndustries.ts
cards/chemical/preludes/37_VenusGHGExports.ts
cards/chemical/preludes/38_SisterPlanetResearch.ts
cards/chemical/preludes/39_FloatingCity.ts
cards/chemical/preludes/4_MaterialLoan.ts
cards/chemical/preludes/40_EarlyColony.ts
cards/chemical/preludes/41_IsolatedEcologyResearch.ts
cards/chemical/preludes/42_JovianProjectBase.ts
cards/chemical/preludes/43_InterplanetaryTradingPort.ts
cards/chemical/preludes/44_TradingNetwork.ts
cards/chemical/preludes/45_GasMine.ts
cards/chemical/preludes/46_PhobosSpacePort.ts
cards/chemical/preludes/47_TitanSettlement.ts
cards/chemical/preludes/48_TradeInfrastructure.ts
cards/chemical/preludes/5_ResearchLoan.ts
cards/chemical/preludes/6_EntertainmentIndustry.ts
cards/chemical/preludes/7_CoerciveDealings.ts
cards/chemical/preludes/8_AquaponicsFacility.ts
cards/chemical/preludes/9_NoctisSettlement.ts
cards/chemical/preludes/ByElectionChemical.ts
cards/chemical/preludes/CommitteeRepresentative.ts
cards/chemical/preludes/ContractedIntelligenceAgency.ts
cards/chemical/preludes/CorporateAlliance.ts
cards/chemical/preludes/ExecutiveOrderChemical.ts
cards/chemical/preludes/GreenMarsInitiative.ts
cards/chemical/preludes/IntellectualistMovements.ts
cards/chemical/preludes/MartianRepublic.ts
cards/chemical/preludes/PartyInsiders.ts
cards/chemical/preludes/PoliticalUprisingChemical.ts
cards/chemical/preludes/PreservationistCampaign.ts
cards/chemical/rebalance/Corp_ RecyclonRB.ts
cards/chemical/rebalance/Corp_AphroditeRB.ts
cards/chemical/rebalance/Corp_ArcadianCommunitiesRB.ts
cards/chemical/rebalance/Corp_ArklightRB.ts
cards/chemical/rebalance/Corp_AstrodrillRB.ts
cards/chemical/rebalance/Corp_CelesticRB.ts
cards/chemical/rebalance/Corp_CheungShingMARSRB.ts
cards/chemical/rebalance/Corp_FactorumRB.ts
cards/chemical/rebalance/Corp_HelionRB.ts
cards/chemical/rebalance/Corp_InterplanetaryCinematicsRB.ts
cards/chemical/rebalance/Corp_InventrixRB.ts
cards/chemical/rebalance/Corp_MiningGuildRB.ts
cards/chemical/rebalance/Corp_MorningStarIncRB.ts
cards/chemical/rebalance/Corp_PhoboLogRB.ts
cards/chemical/rebalance/Corp_PointLunaRB.ts
cards/chemical/rebalance/Corp_PolyphemosRB.ts
cards/chemical/rebalance/Corp_PoseidonRB.ts
cards/chemical/rebalance/Corp_PristarRB.ts
cards/chemical/rebalance/Corp_RobinsonIndustriesRB.ts
cards/chemical/rebalance/Corp_SpliceRB.ts
cards/chemical/rebalance/Corp_StormCraftIncorporatedRB.ts
cards/chemical/rebalance/Corp_TerralabsResearchRB.ts
cards/chemical/rebalance/Corp_TharsisRepublicRB.ts
cards/chemical/rebalance/Corp_ThorgateRB.ts
cards/chemical/rebalance/Prelude_ MoholeExcavationRB.ts
cards/chemical/rebalance/Prelude_BiofuelsRB.ts
cards/chemical/rebalance/Prelude_BiosphereSupportRB.ts
cards/chemical/rebalance/Prelude_DomeFarmingRB.ts
cards/chemical/rebalance/Prelude_EarlySettlementRB.ts
cards/chemical/rebalance/Prelude_EccentricSponsorRB.ts
cards/chemical/rebalance/Prelude_GalileanMiningRB.ts
cards/chemical/rebalance/Prelude_HugeAsteroidRB.ts
cards/chemical/rebalance/Prelude_IoResearchOutpostRB.ts
cards/chemical/rebalance/Prelude_LoanRB.ts
cards/chemical/rebalance/Prelude_MartianIndustriesRB.ts
cards/chemical/rebalance/Prelude_MetalsCompanyRB.ts
cards/chemical/rebalance/Prelude_MoholeRB.ts
cards/chemical/rebalance/Prelude_NitrogenShipmentRB.ts
cards/chemical/rebalance/Prelude_OrbitalConstructionYardRB.ts
cards/chemical/rebalance/Prelude_PolarIndustriesRB.ts
cards/chemical/rebalance/Prelude_SelfSufficientSettlementRB.ts
cards/chemical/rebalance/Prelude_SmeltingPlantRB.ts
cards/chemical/rebalance/Prelude_SocietySupportRB.ts
cards/chemical/rebalance/Project_AdvancedAlloysRB.ts
cards/chemical/rebalance/Project_AerobrakedAmmoniaAsteroidRB.ts
cards/chemical/rebalance/Project_AsteroidHollowingRB.ts
cards/chemical/rebalance/Project_BactoviralResearchRB.ts
cards/chemical/rebalance/Project_BlackPolarDustRB.ts
cards/chemical/rebalance/Project_BuildingIndustriesRB.ts
cards/chemical/rebalance/Project_CartelRB.ts
cards/chemical/rebalance/Project_CloudSeedingRB.ts
cards/chemical/rebalance/Project_CommunityServicesRB.ts
cards/chemical/rebalance/Project_CorporateStrongholdRB.ts
cards/chemical/rebalance/Project_CuttingEdgeTechnologyRB.ts
cards/chemical/rebalance/Project_EarthCatapultRB.ts
cards/chemical/rebalance/Project_EarthOfficeRB.ts
cards/chemical/rebalance/Project_EnergyMarketRB.ts
cards/chemical/rebalance/Project_EnergySavingRB.ts
cards/chemical/rebalance/Project_ExtractorBalloonsRB.ts
cards/chemical/rebalance/Project_ForcedPrecipitationRB.ts
cards/chemical/rebalance/Project_GHGImportFromVenusRB.ts
cards/chemical/rebalance/Project_GMOContractRB.ts
cards/chemical/rebalance/Project_HackersRB.ts
cards/chemical/rebalance/Project_HeatTrappersRB.ts
cards/chemical/rebalance/Project_IndustrialCenterAresRB.ts
cards/chemical/rebalance/Project_InsectsRB.ts
cards/chemical/rebalance/Project_JetStreamMicroscrappersRB.ts
cards/chemical/rebalance/Project_MarsUniversityRB.ts
cards/chemical/rebalance/Project_MassConverterRB.ts
cards/chemical/rebalance/Project_MeatIndustryRB.ts
cards/chemical/rebalance/Project_MicroMillsRB.ts
cards/chemical/rebalance/Project_OrbitalCleanupRB.ts
cards/chemical/rebalance/Project_OutdoorSportsRB.ts
cards/chemical/rebalance/Project_ReleaseOfInertGasesRB.ts
cards/chemical/rebalance/Project_ResearchOutpostRB.ts
cards/chemical/rebalance/Project_RotatorImpactsRB.ts
cards/chemical/rebalance/Project_SkyDocksRB.ts
cards/chemical/rebalance/Project_SnowAlgaeRB.ts
cards/chemical/rebalance/Project_SoilFactoryRB.ts
cards/chemical/rebalance/Project_SolarPowerRB.ts
cards/chemical/rebalance/Project_SpinoffDepartmentRB.ts
cards/chemical/rebalance/Project_StratopolisRB.ts
cards/chemical/rebalance/Project_StripMineRB.ts
cards/chemical/rebalance/Project_TitanAirScrappingRB.ts
cards/chemical/rebalance/Project_TollStationRB.ts
cards/chemical/rebalance/Project_TopsoilContractRB.ts
cards/chemical/rebalance/Project_TropicalResortRB.ts
cards/chemical/rebalance/Project_UndergroundCityRB.ts
cards/chemical/rebalance/Project_UndergroundDetonationsRB.ts
cards/chemical/rebalance/Project_ViralEnhancersRB.ts
cards/chemical/rebalance/Project_WarpDriveRB.ts
cards/chemical/rebalance/Project_ZeppelinsRB.ts
cards/chemical/turmoil/AcquiredBioengineeringFirm.ts
cards/chemical/turmoil/AcquiredConsultingFirm.ts
cards/chemical/turmoil/AuthoritarianState.ts
cards/chemical/turmoil/CommitteeCoalition.ts
cards/chemical/turmoil/CorporateCitadel.ts
cards/chemical/turmoil/DemocraticReform.ts
cards/chemical/turmoil/DesignedOrganisms.ts
cards/chemical/turmoil/DirectedSabotageImpact.ts
cards/chemical/turmoil/EnergyLab.ts
cards/chemical/turmoil/ExoplanetLanding.ts
cards/chemical/turmoil/FirstMartianMemorial.ts
cards/chemical/turmoil/FusionBombing.ts
cards/chemical/turmoil/HybridVessels.ts
cards/chemical/turmoil/InaugurationCeremony.ts
cards/chemical/turmoil/IndustryDevelopment.ts
cards/chemical/turmoil/InterplanetaryDiplomacy.ts
cards/chemical/turmoil/IonizingRadiationBeam.ts
cards/chemical/turmoil/Kickbacks.ts
cards/chemical/turmoil/LegalFirm.ts
cards/chemical/turmoil/MartianResearchNetwork.ts
cards/chemical/turmoil/MediaManipulation.ts
cards/chemical/turmoil/MedicalInstitute.ts
cards/chemical/turmoil/MicrobialSupport.ts
cards/chemical/turmoil/PoliticalDonations.ts
cards/chemical/turmoil/Preservationism.ts
cards/chemical/turmoil/PreservationistSettlement.ts
cards/chemical/turmoil/PrimalNationalPark.ts
cards/chemical/turmoil/ReducedSnowCoverage.ts
cards/chemical/turmoil/RemoteAreaSuppliers.ts
cards/chemical/turmoil/ShortTermBonuses.ts
cards/chemical/turmoil/SocialWelfare.ts
cards/chemical/turmoil/TellurianEcosystems.ts
cards/chemical/turmoil/TerraformingUnion.ts
cards/chemical/turmoil/VenusSocietySupport.ts
cards/chemical/turmoil/WorldGovernmentDiplomats.ts
cards/chemical/UNMISponsorship.ts
cards/chemical/venus/AerialMassDrivers.ts
cards/chemical/venus/AirborneMicrobes.ts
cards/chemical/venus/AtenGroupMining.ts
cards/chemical/venus/AtmoshpericSolarCollectors.ts
cards/chemical/venus/AtmosphereLiftingDetonations.ts
cards/chemical/venus/BasaltMining.ts
cards/chemical/venus/BioengineeringStudies.ts
cards/chemical/venus/BiomechanicalFoliage.ts
cards/chemical/venus/CapitalOfVenus.ts
cards/chemical/venus/CarbonFixingMicrobes.ts
cards/chemical/venus/CarbonSolidifcation.ts
cards/chemical/venus/CollaborationProject.ts
cards/chemical/venus/CondenstationCatalysts.ts
cards/chemical/venus/ConsistentBombardment.ts
cards/chemical/venus/ConvoyToVenus.ts
cards/chemical/venus/DanuMontesRover.ts
cards/chemical/venus/DesignedFlyers.ts
cards/chemical/venus/DeuteriumFusion.ts
cards/chemical/venus/DistirbutionCenter.ts
cards/chemical/venus/DryIceRings.ts
cards/chemical/venus/DwarfPlanetCollision.ts
cards/chemical/venus/EclipseStation.ts
cards/chemical/venus/EndemicVenusianArchaea.ts
cards/chemical/venus/FloaterAcquisition.ts
cards/chemical/venus/FloaterDocks.ts
cards/chemical/venus/FloatingArchitechture.ts
cards/chemical/venus/FloatingBiodomes.ts
cards/chemical/venus/FloatingPowerStation.ts
cards/chemical/venus/FloatingResearchBase.ts
cards/chemical/venus/HugeWaterShipments.ts
cards/chemical/venus/HydrogenInjection.ts
cards/chemical/venus/IonicGasSequestration.ts
cards/chemical/venus/IshtarComplex.ts
cards/chemical/venus/LakeOfAphrodite.ts
cards/chemical/venus/LocalDecompression.ts
cards/chemical/venus/LocalMagneticShielding.ts
cards/chemical/venus/LowLevelScrappers.ts
cards/chemical/venus/MesosphereShades.ts
cards/chemical/venus/NearMissRotaryAsteroid.ts
cards/chemical/venus/NeutralizerDrones.ts
cards/chemical/venus/NitrogenFromVenus.ts
cards/chemical/venus/OvdaCity.ts
cards/chemical/venus/PanSolarMining.ts
cards/chemical/venus/PHNeutralizers.ts
cards/chemical/venus/PhontoicMetamaterials.ts
cards/chemical/venus/RhizobiomeResearch.ts
cards/chemical/venus/SkyCommunications.ts
cards/chemical/venus/StellarCruisers.ts
cards/chemical/venus/SulphurProcessing.ts
cards/chemical/venus/SuperCarbonCollectors.ts
cards/chemical/venus/SurfaceHabs.ts
cards/chemical/venus/SwarmShaders.ts
cards/chemical/venus/TerrestrialAlliance.ts
cards/chemical/venus/TheBehemoth.ts
cards/chemical/venus/ThemisBiodomes.ts
cards/chemical/venus/TowersOfFreyja.ts
cards/chemical/venus/UltralightFloaters.ts
cards/chemical/venus/UndergroundVenusBase.ts
cards/chemical/venus/VeneraOutpost.ts
cards/chemical/venus/VenusBiolab.ts
cards/chemical/venus/VenusGeologicalSurvey.ts
cards/chemical/venus/VenusianFungi.ts
cards/chemical/venus/VenusMiningExpedition.ts
cards/chemical/venus/VenusMiningIndustries.ts
cards/chemical/venus/VenusPlantation.ts
cards/chemical/venus/VenusPowerPlant.ts
cards/chemical/venus/VenusSolarWaystation.ts
cards/chemical/venus/VenusSurfaceDwellers.ts
cards/chemical/venus/VenusTourism.ts
cards/chemical/venus/VortexEngine.ts
cards/chemical/venus/WorkerDrones.ts
cards/chemical/venus/WorldGovernmentOffices.ts
cards/chemical/VenusTradeStation.ts
cards/colonies/Airliners.ts
cards/colonies/AirRaid.ts
cards/colonies/Aridor.ts
cards/colonies/Arklight.ts
cards/colonies/AtmoCollectors.ts
cards/colonies/BuildColonyStandardProject.ts
cards/colonies/ColoniesCardManifest.ts
cards/colonies/CommunityServices.ts
cards/colonies/Conscription.ts
cards/colonies/CoronaExtractor.ts
cards/colonies/CryoSleep.ts
cards/colonies/EarthElevator.ts
cards/colonies/EcologyResearch.ts
cards/colonies/FloaterLeasing.ts
cards/colonies/FloaterPrototypes.ts
cards/colonies/FloaterTechnology.ts
cards/colonies/GalileanWaystation.ts
cards/colonies/HeavyTaxation.ts
cards/colonies/IceMoonColony.ts
cards/colonies/ImpactorSwarm.ts
cards/colonies/InterplanetaryColonyShip.ts
cards/colonies/JovianLanterns.ts
cards/colonies/JupiterFloatingStation.ts
cards/colonies/LunaGovernor.ts
cards/colonies/LunarExports.ts
cards/colonies/LunarMining.ts
cards/colonies/MarketManipulation.ts
cards/colonies/MartianZoo.ts
cards/colonies/MiningColony.ts
cards/colonies/MinorityRefuge.ts
cards/colonies/MolecularPrinting.ts
cards/colonies/NitrogenFromTitan.ts
cards/colonies/PioneerSettlement.ts
cards/colonies/Polyphemos.ts
cards/colonies/Poseidon.ts
cards/colonies/ProductiveOutpost.ts
cards/colonies/QuantumCommunications.ts
cards/colonies/RedSpotObservatory.ts
cards/colonies/RefugeeCamps.ts
cards/colonies/ResearchColony.ts
cards/colonies/RimFreighters.ts
cards/colonies/SkyDocks.ts
cards/colonies/SolarProbe.ts
cards/colonies/SolarReflectors.ts
cards/colonies/SpacePort.ts
cards/colonies/SpacePortColony.ts
cards/colonies/SpinoffDepartment.ts
cards/colonies/StormCraftIncorporated.ts
cards/colonies/SubZeroSaltFish.ts
cards/colonies/TitanAirScrapping.ts
cards/colonies/TitanFloatingLaunchPad.ts
cards/colonies/TitanShuttles.ts
cards/colonies/TradeEnvoys.ts
cards/colonies/TradingColony.ts
cards/colonies/UrbanDecomposers.ts
cards/colonies/WarpDrive.ts
cards/community/AerospaceMission.ts
cards/community/AgricolaInc.ts
cards/community/Athena.ts
cards/community/ByElection.ts
cards/community/CommunityCardManifest.ts
cards/community/CuriosityII.ts
cards/community/Eris.ts
cards/community/ExecutiveOrder.ts
cards/community/Hygiea.ts
cards/community/Iapetus.ts
cards/community/Incite.ts
cards/community/JunkVentures.ts
cards/community/LeadershipSummit.ts
cards/community/Leavitt.ts
cards/community/Mercury.ts
cards/community/Midas.ts
cards/community/Pallas.ts
cards/community/Playwrights.ts
cards/community/PoliticalUprising.ts
cards/community/ProjectWorkshop.ts
cards/community/ResearchGrant.ts
cards/community/ScienceTagCard.ts
cards/community/SpecialDesignProxy.ts
cards/community/Titania.ts
cards/community/TradeAdvance.ts
cards/community/UnitedNationsMissionOne.ts
cards/community/ValuableGases.ts
cards/community/Venus.ts
cards/corporation/BeginnerCorporation.ts
cards/corporation/CorporationCard.ts
cards/corporation/CrediCor.ts
cards/corporation/EcoLine.ts
cards/corporation/Helion.ts
cards/corporation/ICorporationCard.ts
cards/corporation/InterplanetaryCinematics.ts
cards/corporation/Inventrix.ts
cards/corporation/MiningGuild.ts
cards/corporation/PhoboLog.ts
cards/corporation/SaturnSystems.ts
cards/corporation/Teractor.ts
cards/corporation/TharsisRepublic.ts
cards/corporation/Thorgate.ts
cards/corporation/UnitedNationsMarsInitiative.ts
cards/Deck.ts
cards/ICard.ts
cards/ICardFactory.ts
cards/IProjectCard.ts
cards/IStandardActionCard.ts
cards/IStandardProjectCard.ts
cards/ModuleManifest.ts
cards/moon/AIControlledMineNetwork.ts
cards/moon/AlgaeBioreactors.ts
cards/moon/AncientShipyards.ts
cards/moon/AnOfferYouCantRefuse.ts
cards/moon/ArchimedesHydroponicsStation.ts
cards/moon/AristarchusRoadNetwork.ts
cards/moon/BasicInfrastructure.ts
cards/moon/ColonistShuttles.ts
cards/moon/CopernicusSolarArrays.ts
cards/moon/CopernicusTower.ts
cards/moon/CoreMine.ts
cards/moon/CosmicRadiation.ts
cards/moon/CrescentResearchAssociation.ts
cards/moon/DarksideIncubationPlant.ts
cards/moon/DarksideMeteorBombardment.ts
cards/moon/DarksideMiningSyndicate.ts
cards/moon/DarksideObservatory.ts
cards/moon/DarksideSmugglersUnion.ts
cards/moon/DeepLunarMining.ts
cards/moon/EarthEmbassy.ts
cards/moon/FirstLunarSettlement.ts
cards/moon/GeodesicTents.ts
cards/moon/GrandLunaAcademy.ts
cards/moon/Habitat14.ts
cards/moon/HE3FusionPlant.ts
cards/moon/HE3Lobbyists.ts
cards/moon/HE3ProductionQuotas.ts
cards/moon/HE3Refinery.ts
cards/moon/HeavyDutyRovers.ts
cards/moon/HeliostatMirrorArray.ts
cards/moon/HostileTakeover.ts
cards/moon/HypersensitiveSiliconChipFactory.ts
cards/moon/ImprovedMoonConcrete.ts
cards/moon/IntragenSanctuaryHeadquarters.ts
cards/moon/IronExtractionCenter.ts
cards/moon/LTFHeadquarters.ts
cards/moon/LTFPrivileges.ts
cards/moon/LunaArchives.ts
cards/moon/LunaConference.ts
cards/moon/LunaEcumenopolis.ts
cards/moon/LunaFirstIncorporated.ts
cards/moon/LunaHyperloopCorporation.ts
cards/moon/LunaMiningHub.ts
cards/moon/LunaPoliticalInstitute.ts
cards/moon/LunaProjectOffice.ts
cards/moon/LunarDustProcessingPlant.ts
cards/moon/LunaResort.ts
cards/moon/LunarIndustryComplex.ts
cards/moon/LunarMineUrbanization.ts
cards/moon/LunarObservationPost.ts
cards/moon/LunarPlanningOffice.ts
cards/moon/LunarSecurityStations.ts
cards/moon/LunarSteel.ts
cards/moon/LunarTradeFleet.ts
cards/moon/LunaSenate.ts
cards/moon/LunaStagingStation.ts
cards/moon/LunaTradeFederation.ts
cards/moon/LunaTradeStation.ts
cards/moon/LunaTrainStation.ts
cards/moon/MareImbriumMine.ts
cards/moon/MareNectarisMine.ts
cards/moon/MareNubiumMine.ts
cards/moon/MareSerenitatisMine.ts
cards/moon/MarketCard.ts
cards/moon/MartianEmbassy.ts
cards/moon/MicrosingularityPlant.ts
cards/moon/MiningComplex.ts
cards/moon/MiningRobotsManufCenter.ts
cards/moon/MomentumViriumHabitat.ts
cards/moon/MoonCardManifest.ts
cards/moon/MooncrateBlockFactory.ts
cards/moon/MooncrateConvoysToMars.ts
cards/moon/MoonHabitatStandardProject.ts
cards/moon/MoonMineStandardProject.ts
cards/moon/MoonRoadStandardProject.ts
cards/moon/MoonStandardProjectVariants1.ts
cards/moon/MoonStandardProjectVariants2.ts
cards/moon/MoonTether.ts
cards/moon/NanotechIndustries.ts
cards/moon/NewColonyPlanningInitiatives.ts
cards/moon/OffWorldCityLiving.ts
cards/moon/OrbitalPowerGrid.ts
cards/moon/PreliminaryDarkside.ts
cards/moon/PrideoftheEarthArkship.ts
cards/moon/ProcessorFactory.ts
cards/moon/RevoltingColonists.ts
cards/moon/RoadPiracy.ts
cards/moon/RoverDriversUnion.ts
cards/moon/RustEatingBacteria.ts
cards/moon/SinusIrdiumRoadNetwork.ts
cards/moon/SmallDutyRovers.ts
cards/moon/SolarPanelFoundry.ts
cards/moon/SphereHabitats.ts
cards/moon/StagingStationBehemoth.ts
cards/moon/SteelMarketMonopolists.ts
cards/moon/SubterraneanHabitats.ts
cards/moon/SyndicatePirateRaids.ts
cards/moon/TempestConsultancy.ts
cards/moon/TheArchaicFoundationInstitute.ts
cards/moon/TheDarksideofTheMoonSyndicate.ts
cards/moon/TheGrandLunaCapitalGroup.ts
cards/moon/TheWomb.ts
cards/moon/ThoriumRush.ts
cards/moon/TitaniumExtractionCenter.ts
cards/moon/TitaniumMarketMonopolists.ts
cards/moon/TychoRoadNetwork.ts
cards/moon/UndergroundDetonators.ts
cards/moon/UndermoonDrugLordsNetwork.ts
cards/moon/WaterTreatmentComplex.ts
cards/moon/WeGrowAsOne.ts
cards/Options.ts
cards/pathfinders/AdhaiHighOrbitConstructions.ts
cards/pathfinders/AdvancedPowerGrid.ts
cards/pathfinders/AgroDrones.ts
cards/pathfinders/Ambient.ts
cards/pathfinders/Anthozoa.ts
cards/pathfinders/AsteroidResources.ts
cards/pathfinders/Aurorai.ts
cards/pathfinders/BalancedDevelopment.ts
cards/pathfinders/BioSol.ts
cards/pathfinders/BotanicalExperience.ts
cards/pathfinders/BreedingFarms.ts
cards/pathfinders/CassiniStation.ts
cards/pathfinders/CeresSpaceport.ts
cards/pathfinders/CharityDonation.ts
cards/pathfinders/Chimera.ts
cards/pathfinders/CO2Reducers.ts
cards/pathfinders/CollegiumCopernicus.ts
cards/pathfinders/CommunicationBoom.ts
cards/pathfinders/CommunicationCenter.ts
cards/pathfinders/ConstantStruggle.ts
cards/pathfinders/ControlledBloom.ts
cards/pathfinders/CoordinatedRaid.ts
cards/pathfinders/Crashlanding.ts
cards/pathfinders/CrewTraining.ts
cards/pathfinders/Cryptocurrency.ts
cards/pathfinders/CultivationOfVenus.ts
cards/pathfinders/Cyanobacteria.ts
cards/pathfinders/DataLeak.ts
cards/pathfinders/DeclarationOfIndependence.ts
cards/pathfinders/DeepSpaceOperations.ts
cards/pathfinders/DesignCompany.ts
cards/pathfinders/DesignedOrganisms.ts
cards/pathfinders/DustStorm.ts
cards/pathfinders/DysonScreens.ts
cards/pathfinders/EarlyExpedition.ts
cards/pathfinders/EconomicEspionage.ts
cards/pathfinders/EconomicHelp.ts
cards/pathfinders/ExpeditionToTheSurfaceVenus.ts
cards/pathfinders/ExperiencedMartians.ts
cards/pathfinders/FlatMarsTheory.ts
cards/pathfinders/FloaterUrbanism.ts
cards/pathfinders/GagarinMobileBase.ts
cards/pathfinders/GeologicalExpedition.ts
cards/pathfinders/HabitatMarte.ts
cards/pathfinders/HighTempSuperconductors.ts
cards/pathfinders/HuygensObservatory.ts
cards/pathfinders/HydrogenBombardment.ts
cards/pathfinders/HydrogenProcessingPlant.ts
cards/pathfinders/IapetusII.ts
cards/pathfinders/ICloneTagCard.ts
cards/pathfinders/InterplanetaryTransport.ts
cards/pathfinders/Kickstarter.ts
cards/pathfinders/LastResortIngenuity.ts
cards/pathfinders/LeavittII.ts
cards/pathfinders/LobbyHalls.ts
cards/pathfinders/LunarEmbassy.ts
cards/pathfinders/LuxuryEstate.ts
cards/pathfinders/MagneticFieldStimulationDelays.ts
cards/pathfinders/MarsDirect.ts
cards/pathfinders/MarsFrontierAlliance.ts
cards/pathfinders/MarsMaths.ts
cards/pathfinders/MartianCulture.ts
cards/pathfinders/MartianDustProcessingPlant.ts
cards/pathfinders/MartianInsuranceGroup.ts
cards/pathfinders/MartianMonuments.ts
cards/pathfinders/MartianNatureWonders.ts
cards/pathfinders/MartianRepository.ts
cards/pathfinders/MicrobiologyPatents.ts
cards/pathfinders/MindSetMars.ts
cards/pathfinders/MuseumofEarlyColonisation.ts
cards/pathfinders/NewVenice.ts
cards/pathfinders/NobelLabs.ts
cards/pathfinders/Odyssey.ts
cards/pathfinders/OrbitalLaboratories.ts
cards/pathfinders/OumuamuaTypeObjectSurvey.ts
cards/pathfinders/OzoneGenerators.ts
cards/pathfinders/PathfindersCardManifest.ts
cards/pathfinders/PersonalAgenda.ts
cards/pathfinders/Polaris.ts
cards/pathfinders/Pollinators.ts
cards/pathfinders/PowerPlant.ts
cards/pathfinders/PrefabricationofHumanHabitats.ts
cards/pathfinders/PrivateSecurity.ts
cards/pathfinders/PublicSponsoredGrant.ts
cards/pathfinders/RareEarthElements.ts
cards/pathfinders/RedCity.ts
cards/pathfinders/ResearchGrant.ts
cards/pathfinders/ReturntoAbandonedTechnology.ts
cards/pathfinders/RichDeposits.ts
cards/pathfinders/Ringcom.ts
cards/pathfinders/RobinHaulings.ts
cards/pathfinders/SecretLabs.ts
cards/pathfinders/SmallComet.ts
cards/pathfinders/SmallOpenPitMine.ts
cards/pathfinders/SocialEvents.ts
cards/pathfinders/SoilDetoxification.ts
cards/pathfinders/Solarpedia.ts
cards/pathfinders/SolarStorm.ts
cards/pathfinders/SolBank.ts
cards/pathfinders/SoylentSeedlingSystems.ts
cards/pathfinders/SpaceDebrisCleaningOperation.ts
cards/pathfinders/SpaceRaceToMars.ts
cards/pathfinders/SpaceRelay.ts
cards/pathfinders/SpecializedSettlement.ts
cards/pathfinders/Steelaris.ts
cards/pathfinders/StrategicBasePlanning.ts
cards/pathfinders/SurveyMission.ts
cards/pathfinders/TerraformingControlStation.ts
cards/pathfinders/TerraformingRobots.ts
cards/pathfinders/TheNewSpaceRace.ts
cards/pathfinders/ThinkTank.ts
cards/pathfinders/TiredEarth.ts
cards/pathfinders/ValuableGases.ts
cards/pathfinders/VeneraBase.ts
cards/pathfinders/VenusFirst.ts
cards/pathfinders/VitalColony.ts
cards/pathfinders/Wetlands.ts
cards/prelude/AcquiredSpaceAgency.ts
cards/prelude/AlliedBanks.ts
cards/prelude/AquiferTurbines.ts
cards/prelude/Biofuels.ts
cards/prelude/Biolab.ts
cards/prelude/BiosphereSupport.ts
cards/prelude/BufferGasStandardProject.ts
cards/prelude/BusinessEmpire.ts
cards/prelude/CheungShingMARS.ts
cards/prelude/DomeFarming.ts
cards/prelude/Donation.ts
cards/prelude/EarlySettlement.ts
cards/prelude/EccentricSponsor.ts
cards/prelude/EcologyExperts.ts
cards/prelude/ExperimentalForest.ts
cards/prelude/GalileanMining.ts
cards/prelude/GreatAquifer.ts
cards/prelude/HousePrinting.ts
cards/prelude/HugeAsteroid.ts
cards/prelude/IoResearchOutpost.ts
cards/prelude/IPreludeCard.ts
cards/prelude/LavaTubeSettlement.ts
cards/prelude/Loan.ts
cards/prelude/MartianIndustries.ts
cards/prelude/MartianSurvey.ts
cards/prelude/MetalRichAsteroid.ts
cards/prelude/MetalsCompany.ts
cards/prelude/MiningOperations.ts
cards/prelude/Mohole.ts
cards/prelude/MoholeExcavation.ts
cards/prelude/NitrogenShipment.ts
cards/prelude/OrbitalConstructionYard.ts
cards/prelude/PointLuna.ts
cards/prelude/PolarIndustries.ts
cards/prelude/PowerGeneration.ts
cards/prelude/PreludeCard.ts
cards/prelude/PreludeCardManifest.ts
cards/prelude/Psychrophiles.ts
cards/prelude/ResearchCoordination.ts
cards/prelude/ResearchNetwork.ts
cards/prelude/RobinsonIndustries.ts
cards/prelude/SelfSufficientSettlement.ts
cards/prelude/SFMemorial.ts
cards/prelude/SmeltingPlant.ts
cards/prelude/SocietySupport.ts
cards/prelude/SpaceHotels.ts
cards/prelude/Supplier.ts
cards/prelude/SupplyDrop.ts
cards/prelude/UNMIContractor.ts
cards/prelude/ValleyTrust.ts
cards/prelude/Vitor.ts
cards/prelude2/ActivePreludeCard.ts
cards/prelude2/AppliedScience.ts
cards/prelude2/AtmosphericEnhancers.ts
cards/prelude2/CeresTechMarket.ts
cards/prelude2/CloudTourism.ts
cards/prelude2/ColonyTradeHub.ts
cards/prelude2/CorridorsOfPower.ts
cards/prelude2/Ecotec.ts
cards/prelude2/FocusedOrganization.ts
cards/prelude2/GhgShipment.ts
cards/prelude2/IshtarExpedition.ts
cards/prelude2/L1TradeTerminal.ts
cards/prelude2/NirgalEnterprises.ts
cards/prelude2/NobelPrize.ts
cards/prelude2/OldMiningColony.ts
cards/prelude2/PalladinShipping.ts
cards/prelude2/Prelude2CardManifest.ts
cards/prelude2/RedAppeasement.ts
cards/prelude2/SagittaFrontierServices.ts
cards/prelude2/SpaceCorridors.ts
cards/prelude2/Spire.ts
cards/prelude2/SponsoringNation.ts
cards/prelude2/SummitLogistics.ts
cards/promo/16Psyche.ts
cards/promo/Advertising.ts
cards/promo/AntidesertificationTechniques.ts
cards/promo/AqueductSystems.ts
cards/promo/ArcadianCommunities.ts
cards/promo/AsteroidDeflectionSystem.ts
cards/promo/AsteroidHollowing.ts
cards/promo/AsteroidRights.ts
cards/promo/AstraMechanica.ts
cards/promo/Astrodrill.ts
cards/promo/BactoviralResearch.ts
cards/promo/BioPrintingFacility.ts
cards/promo/CarbonNanosystems.ts
cards/promo/CityPark.ts
cards/promo/CometAiming.ts
cards/promo/CorporateArchives.ts
cards/promo/CrashSiteCleanup.ts
cards/promo/CuttingEdgeTechnology.ts
cards/promo/CyberiaSystems.ts
cards/promo/DeimosDownPromo.ts
cards/promo/DirectedHeatUsage.ts
cards/promo/DirectedImpactors.ts
cards/promo/DiversitySupport.ts
cards/promo/DoubleDown.ts
cards/promo/DuskLaserMining.ts
cards/promo/EnergyMarket.ts
cards/promo/Factorum.ts
cards/promo/FieldCappedCity.ts
cards/promo/FloydContinuum.ts
cards/promo/GiantSolarCollector.ts
cards/promo/GreatDamPromo.ts
cards/promo/Harvest.ts
cards/promo/HeadStart.ts
cards/promo/HermeticOrderofMars.ts
cards/promo/HiTechLab.ts
cards/promo/HomeostasisBureau.ts
cards/promo/IcyImpactors.ts
cards/promo/ImportedNutrients.ts
cards/promo/InterplanetaryTrade.ts
cards/promo/JovianEmbassy.ts
cards/promo/KaguyaTech.ts
cards/promo/KuiperCooperative.ts
cards/promo/LawSuit.ts
cards/promo/MagneticFieldGeneratorsPromo.ts
cards/promo/MagneticShield.ts
cards/promo/MarsNomads.ts
cards/promo/MartianLumberCorp.ts
cards/promo/MeatIndustry.ts
cards/promo/Meltworks.ts
cards/promo/MercurianAlloys.ts
cards/promo/Merger.ts
cards/promo/MoholeLake.ts
cards/promo/MonsInsurance.ts
cards/promo/NeptunianPowerConsultants.ts
cards/promo/NewPartner.ts
cards/promo/OrbitalCleanup.ts
cards/promo/OutdoorSports.ts
cards/promo/Penguins.ts
cards/promo/PharmacyUnion.ts
cards/promo/Philares.ts
cards/promo/Potatoes.ts
cards/promo/ProjectInspection.ts
cards/promo/PromoCardManifest.ts
cards/promo/Recyclon.ts
cards/promo/RedShips.ts
cards/promo/RegoPlastics.ts
cards/promo/RobotPollinators.ts
cards/promo/SaturnSurfing.ts
cards/promo/SelfReplicatingRobots.ts
cards/promo/SmallAsteroid.ts
cards/promo/SnowAlgae.ts
cards/promo/SoilEnrichment.ts
cards/promo/SolarLogistics.ts
cards/promo/Splice.ts
cards/promo/StanfordTorus.ts
cards/promo/StJosephOfCupertinoMission.ts
cards/promo/SubCrustMeasurements.ts
cards/promo/Supercapacitors.ts
cards/promo/Supermarkets.ts
cards/promo/Teslaract.ts
cards/promo/TopsoilContract.ts
cards/promo/TychoMagnetics.ts
cards/ProxyCard.ts
cards/render/CardRenderDynamicVictoryPoints.ts
cards/render/CardRenderer.ts
cards/render/CardRenderItem.ts
cards/render/CardRenderSymbol.ts
cards/requirements/CardRequirement.ts
cards/requirements/CardRequirements.ts
cards/requirements/ChairmanRequirement.ts
cards/requirements/CitiesRequirement.ts
cards/requirements/ColoniesRequirement.ts
cards/requirements/CorruptionRequirement.ts
cards/requirements/ExcavationRequirement.ts
cards/requirements/FloatersRequirement.ts
cards/requirements/GlobalParameterRequirement.ts
cards/requirements/GreeneriesRequirement.ts
cards/requirements/HabitatRateRequirement.ts
cards/requirements/HabitatTilesRequirement.ts
cards/requirements/InequalityRequirement.ts
cards/requirements/LogisticsRateRequirement.ts
cards/requirements/MiningRateRequirement.ts
cards/requirements/MiningTilesRequirement.ts
cards/requirements/OceanRequirement.ts
cards/requirements/OxygenRequirement.ts
cards/requirements/PartyLeadersRequirement.ts
cards/requirements/PartyRequirement.ts
cards/requirements/ProductionRequirement.ts
cards/requirements/RaisedTRRequirement.ts
cards/requirements/RemovedPlantsRequirement.ts
cards/requirements/ResourceTypeRequirement.ts
cards/requirements/RoadTilesRequirement.ts
cards/requirements/SumTagsCardRequirement.ts
cards/requirements/TagCardRequirement.ts
cards/requirements/TemperatureRequirement.ts
cards/requirements/TRRequirement.ts
cards/requirements/UniqueTagsCardRequirement.ts
cards/requirements/VenusRequirement.ts
cards/SerializedDeck.ts
cards/StandardActionCard.ts
cards/StandardCardManifests.ts
cards/StandardProjectCard.ts
cards/starwars/BeholdTheEmperor.ts
cards/starwars/CloneTroopers.ts
cards/starwars/CloudCity.ts
cards/starwars/ForestMoon.ts
cards/starwars/ReySkywalker.ts
cards/starwars/StarwarsCardManifest.ts
cards/starwars/TakondaCastle.ts
cards/starwars/ToolWithTheFirstOrder.ts
cards/starwars/ToscheStation.ts
cards/starwars/TradeEmbargo.ts
cards/turmoil/AerialLenses.ts
cards/turmoil/BannedDelegate.ts
cards/turmoil/CulturalMetropolis.ts
cards/turmoil/DiasporaMovement.ts
cards/turmoil/EventAnalysts.ts
cards/turmoil/GMOContract.ts
cards/turmoil/LakefrontResorts.ts
cards/turmoil/MartianMediaCenter.ts
cards/turmoil/ParliamentHall.ts
cards/turmoil/PoliticalAlliance.ts
cards/turmoil/Pristar.ts
cards/turmoil/PROffice.ts
cards/turmoil/PublicCelebrations.ts
cards/turmoil/Recruitment.ts
cards/turmoil/RedTourismWave.ts
cards/turmoil/SeptumTribus.ts
cards/turmoil/SponsoredMohole.ts
cards/turmoil/SupportedResearch.ts
cards/turmoil/TerralabsResearch.ts
cards/turmoil/TurmoilCardManifest.ts
cards/turmoil/UtopiaInvest.ts
cards/turmoil/VoteOfNoConfidence.ts
cards/turmoil/WildlifeDome.ts
cards/underworld/AeronGenomics.ts
cards/underworld/AntiTrustCrackdown.ts
cards/underworld/AnubisSecurities.ts
cards/underworld/ArboristCollective.ts
cards/underworld/ArtesianAquifer.ts
cards/underworld/BatteryFactory.ts
cards/underworld/BatteryShipment.ts
cards/underworld/BehemothExcavator.ts
cards/underworld/Casino.ts
cards/underworld/CaveCity.ts
cards/underworld/CentralReservoir.ts
cards/underworld/ChemicalFactory.ts
cards/underworld/CloudVortexOutpost.ts
cards/underworld/CollusionStandardProject.ts
cards/underworld/ConcessionRights.ts
cards/underworld/CorporateBlackmail.ts
cards/underworld/CorporateTheft.ts
cards/underworld/CraterSurvey.ts
cards/underworld/CutThroatBudgeting.ts
cards/underworld/Deepmining.ts
cards/underworld/Deepnuking.ts
cards/underworld/DeepwaterDome.ts
cards/underworld/DemetronLabs.ts
cards/underworld/EarthquakeMachine.ts
cards/underworld/ElectionSponsorship.ts
cards/underworld/ExcavateStandardProject.ts
cards/underworld/ExcavatorLeasing.ts
cards/underworld/ExpeditionVehicles.ts
cards/underworld/FabricatedScandal.ts
cards/underworld/FairTradeComplaint.ts
cards/underworld/ForestTunnels.ts
cards/underworld/FreeTradePort.ts
cards/underworld/FriendsInHighPlaces.ts
cards/underworld/GaiaCity.ts
cards/underworld/GanymedeTradingCompany.ts
cards/underworld/GeologicalExpertise.ts
cards/underworld/GeologicalSurvey.ts
cards/underworld/GeologistTeam.ts
cards/underworld/GeoscanSatellite.ts
cards/underworld/GeothermalNetwork.ts
cards/underworld/GlobalAudit.ts
cards/underworld/GreyMarketExploitation.ts
cards/underworld/GuerillaEcologists.ts
cards/underworld/Hackers.ts
cards/underworld/Hadesphere.ts
cards/underworld/HecateSpeditions.ts
cards/underworld/HenkeiGenetics.ts
cards/underworld/HiredRaiders.ts
cards/underworld/HyperspaceDrivePrototype.ts
cards/underworld/ImportedHeavyMachinery.ts
cards/underworld/InducedTremor.ts
cards/underworld/InfrastructureOverload.ts
cards/underworld/InheritedFortune.ts
cards/underworld/InvestigativeJournalism.ts
cards/underworld/InvestorPlaza.ts
cards/underworld/JensonBoyleCo.ts
cards/underworld/Keplertec.ts
cards/underworld/KingdomofTauraro.ts
cards/underworld/LaborTrafficking.ts
cards/underworld/LaggingRegulation.ts
cards/underworld/Landfill.ts
cards/underworld/LobbyingNetwork.ts
cards/underworld/ManMadeVolcano.ts
cards/underworld/MartianExpress.ts
cards/underworld/MediaStir.ts
cards/underworld/MicroGeodesics.ts
cards/underworld/Microgravimetry.ts
cards/underworld/MicroprobingTechnology.ts
cards/underworld/MigrationUnderground.ts
cards/underworld/MiningMarketInsider.ts
cards/underworld/Monopoly.ts
cards/underworld/Nanofoundry.ts
cards/underworld/NarrativeSpin.ts
cards/underworld/Neutrinograph.ts
cards/underworld/Nightclubs.ts
cards/underworld/OffWorldTaxHaven.ts
cards/underworld/OldWorldMafia.ts
cards/underworld/OrbitalLaserDrill.ts
cards/underworld/PatentManipulation.ts
cards/underworld/PersonalSpacecruiser.ts
cards/underworld/PlanetaryRightsBuyout.ts
cards/underworld/PlantTax.ts
cards/underworld/PriceWars.ts
cards/underworld/PrivateInvestigator.ts
cards/underworld/PrivateMilitaryContractor.ts
cards/underworld/PrivateResorts.ts
cards/underworld/Prospecting.ts
cards/underworld/PublicSpaceline.ts
cards/underworld/RecklessDetonation.ts
cards/underworld/ResearchDevelopmentHub.ts
cards/underworld/RobotMoles.ts
cards/underworld/Scapegoat.ts
cards/underworld/SearchforLifeUnderground.ts
cards/underworld/SecretResearch.ts
cards/underworld/SeismicPredictions.ts
cards/underworld/ServerSabotage.ts
cards/underworld/SoilExport.ts
cards/underworld/SpacePrivateers.ts
cards/underworld/SpaceWargames.ts
cards/underworld/StagedProtests.ts
cards/underworld/StandardTechnology.ts
cards/underworld/StarVegas.ts
cards/underworld/StemFieldSubsidies.ts
cards/underworld/SubnauticPirates.ts
cards/underworld/SubterraneanSea.ts
cards/underworld/ThiolavaVents.ts
cards/underworld/TitanManufacturingColony.ts
cards/underworld/TunnelBoringMachine.ts
cards/underworld/TunnelingOperation.ts
cards/underworld/TunnelingSubcontractor.ts
cards/underworld/UndergroundAmusementPark.ts
cards/underworld/UndergroundHabitat.ts
cards/underworld/UndergroundRailway.ts
cards/underworld/UndergroundResearchCenter.ts
cards/underworld/UndergroundSettlement.ts
cards/underworld/UndergroundShelters.ts
cards/underworld/UndergroundSmugglingRing.ts
cards/underworld/UnderworldCardManifest.ts
cards/underworld/Voltagon.ts
cards/underworld/VoltaicMetallurgy.ts
cards/underworld/VolunteerMiningInitiative.ts
cards/underworld/Whales.ts
cards/venusNext/AerialMappers.ts
cards/venusNext/AerosportTournament.ts
cards/venusNext/AirScrappingExpedition.ts
cards/venusNext/AirScrappingStandardProject.ts
cards/venusNext/AirScrappingStandardProjectVariant.ts
cards/venusNext/Aphrodite.ts
cards/venusNext/AtalantaPlanitiaLab.ts
cards/venusNext/Atmoscoop.ts
cards/venusNext/Celestic.ts
cards/venusNext/CometForVenus.ts
cards/venusNext/CorroderSuits.ts
cards/venusNext/DawnCity.ts
cards/venusNext/DeuteriumExport.ts
cards/venusNext/Dirigibles.ts
cards/venusNext/ExtractorBalloons.ts
cards/venusNext/Extremophiles.ts
cards/venusNext/floaterCards.ts
cards/venusNext/FloatingHabs.ts
cards/venusNext/ForcedPrecipitation.ts
cards/venusNext/FreyjaBiodomes.ts
cards/venusNext/GHGImportFromVenus.ts
cards/venusNext/GiantSolarShade.ts
cards/venusNext/Gyropolis.ts
cards/venusNext/HydrogenToVenus.ts
cards/venusNext/IoSulphurResearch.ts
cards/venusNext/IshtarMining.ts
cards/venusNext/JetStreamMicroscrappers.ts
cards/venusNext/LocalShading.ts
cards/venusNext/LunaMetropolis.ts
cards/venusNext/LuxuryFoods.ts
cards/venusNext/Manutech.ts
cards/venusNext/MaxwellBase.ts
cards/venusNext/MiningQuota.ts
cards/venusNext/MorningStarInc.ts
cards/venusNext/NeutralizerFactory.ts
cards/venusNext/Omnicourt.ts
cards/venusNext/OrbitalReflectors.ts
cards/venusNext/RotatorImpacts.ts
cards/venusNext/SisterPlanetSupport.ts
cards/venusNext/Solarnet.ts
cards/venusNext/SpinInducingAsteroid.ts
cards/venusNext/SponsoredAcademies.ts
cards/venusNext/Stratopolis.ts
cards/venusNext/StratosphericBirds.ts
cards/venusNext/SulphurEatingBacteria.ts
cards/venusNext/SulphurExports.ts
cards/venusNext/TerraformingContract.ts
cards/venusNext/Thermophiles.ts
cards/venusNext/VenusCardManifest.ts
cards/venusNext/VenusGovernor.ts
cards/venusNext/VenusianAnimals.ts
cards/venusNext/VenusianInsects.ts
cards/venusNext/VenusianPlants.ts
cards/venusNext/VenusMagnetizer.ts
cards/venusNext/VenusSoils.ts
cards/venusNext/VenusWaystation.ts
cards/venusNext/Viron.ts
cards/venusNext/WaterToVenus.ts
CeoExtension.ts
colonies/Callisto.ts
colonies/Ceres.ts
colonies/ColoniesHandler.ts
colonies/Colony.ts
colonies/ColonyDealer.ts
colonies/ColonyDeserializer.ts
colonies/ColonyManifest.ts
colonies/Deimos.ts
colonies/Enceladus.ts
colonies/Europa.ts
colonies/Ganymede.ts
colonies/IColony.ts
colonies/IColonyTrader.ts
colonies/Io.ts
colonies/Luna.ts
colonies/Miranda.ts
colonies/Pluto.ts
colonies/Titan.ts
colonies/Triton.ts
createCard.ts
database/Cache.ts
database/CacheConfig.ts
database/Cloner.ts
database/Database.ts
database/GameLoader.ts
database/IDatabase.ts
database/IGameLoader.ts
database/LocalFilesystem.ts
database/LocalStorage.ts
database/PostgreSQL.ts
database/SQLite.ts
database/utils.ts
deferredActions/AddResourcesToCard.ts
deferredActions/AddResourcesToCards.ts
deferredActions/BuildColony.ts
deferredActions/ChooseAlliedParty.ts
deferredActions/ChooseCards.ts
deferredActions/ChoosePolicyBonus.ts
deferredActions/ChoosePoliticalAgenda.ts
deferredActions/CorrosiveRainDeferredAction.ts
deferredActions/DecreaseAnyProduction.ts
deferredActions/DeferredAction.ts
deferredActions/DeferredActionsQueue.ts
deferredActions/DiscardCards.ts
deferredActions/DrawCards.ts
deferredActions/DrawCeoCardFromDeck.ts
deferredActions/GainProduction.ts
deferredActions/GainResources.ts
deferredActions/GainStock.ts
deferredActions/GiveColonyBonus.ts
deferredActions/IncreaseColonyTrack.ts
deferredActions/LoseProduction.ts
deferredActions/PlaceCityTile.ts
deferredActions/PlaceGreeneryTile.ts
deferredActions/PlaceHazardTile.ts
deferredActions/PlaceOceanTile.ts
deferredActions/PlaceTile.ts
deferredActions/PlayProjectCard.ts
deferredActions/Priority.ts
deferredActions/RemoveAnyPlants.ts
deferredActions/RemoveColonyFromGame.ts
deferredActions/RemoveOceanTile.ts
deferredActions/RemoveResources.ts
deferredActions/RemoveResourcesFromCard.ts
deferredActions/RunNTimes.ts
deferredActions/SelectPaymentDeferred.ts
deferredActions/SelectProductionToLoseDeferred.ts
deferredActions/SelectResourceTypeDeferred.ts
deferredActions/SendDelegateToArea.ts
deferredActions/ShiftAresGlobalParametersDeferred.ts
deferredActions/StealResources.ts
Draft.ts
Game.ts
game/calculateVictoryPoints.ts
game/GameOptions.ts
game/VictoryPointsBreakdown.ts
GameCards.ts
GameSetup.ts
IGame.ts
inputs/AndOptions.ts
inputs/GainResources.ts
inputs/InputError.ts
inputs/OptionsPlayerInput.ts
inputs/OrOptions.ts
inputs/SelectAmount.ts
inputs/SelectCard.ts
inputs/SelectColony.ts
inputs/SelectDelegate.ts
inputs/SelectGlobalEvent.ts
inputs/SelectInitialCards.ts
inputs/SelectOption.ts
inputs/SelectParty.ts
inputs/SelectPayment.ts
inputs/SelectPlayer.ts
inputs/SelectProductionToLose.ts
inputs/SelectProjectCardToPlay.ts
inputs/SelectResource.ts
inputs/SelectResources.ts
inputs/SelectSpace.ts
inputs/ShiftAresGlobalParameters.ts
inputs/titles.ts
inputs/UndoActionOption.ts
IPlayer.ts
LogHelper.ts
ma/MilestoneAwardSelector.ts
ma/MilestoneAwardSynergies.ts
milestones/amazonisPlanitia/Colonizer.ts
milestones/amazonisPlanitia/Farmer.ts
milestones/amazonisPlanitia/Minimalist.ts
milestones/amazonisPlanitia/Terran.ts
milestones/amazonisPlanitia/Tropicalist.ts
milestones/Builder.ts
milestones/Businessperson.ts
milestones/Capitalist.ts
milestones/ClaimedMilestone.ts
milestones/Diversifier.ts
milestones/Ecologist.ts
milestones/Economizer.ts
milestones/Electrician.ts
milestones/Energizer.ts
milestones/Gardener.ts
milestones/Generalist.ts
milestones/Hoverlord.ts
milestones/IMilestone.ts
milestones/Irrigator.ts
milestones/LandSpecialist.ts
milestones/Legend.ts
milestones/Martian.ts
milestones/Mayor.ts
milestones/Milestones.ts
milestones/Networker.ts
milestones/Pioneer.ts
milestones/Planner.ts
milestones/PolarExplorer.ts
milestones/RimSettler.ts
milestones/Smith.ts
milestones/Specialist.ts
milestones/Tactician.ts
milestones/terraCimmeria/Collector.ts
milestones/terraCimmeria/Firestarter.ts
milestones/terraCimmeria/Gambler.ts
milestones/terraCimmeria/Spacefarer.ts
milestones/terraCimmeria/TerraPioneer.ts
milestones/Terraformer.ts
milestones/Tradesman.ts
milestones/Tycoon.ts
milestones/underworld/Risktaker.ts
milestones/underworld/Tunneler.ts
models/ModelUtils.ts
models/PathfindersModel.ts
models/ServerModel.ts
models/TurmoilModel.ts
moon/BasePlaceMoonTile.ts
moon/FullMoon.ts
moon/Lunarchitect.ts
moon/LunarMagnate.ts
moon/MoonBoard.ts
moon/MoonCards.ts
moon/MoonData.ts
moon/MoonExpansion.ts
moon/OneGiantStep.ts
moon/PlaceMoonHabitatTile.ts
moon/PlaceMoonMineTile.ts
moon/PlaceMoonRoadTile.ts
moon/PlaceSpecialMoonTile.ts
moon/SellSteel.ts
moon/SerializedMoonData.ts
pathfinders/CrashlandingBonus.ts
pathfinders/DeclareCloneTag.ts
pathfinders/GrantResourceDeferred.ts
pathfinders/PathfindersData.ts
pathfinders/PathfindersExpansion.ts
pathfinders/SerializedPathfindersData.ts
Player.ts
player/Colonies.ts
player/GenerationData.ts
player/Production.ts
player/Stock.ts
player/Tags.ts
PlayerInput.ts
preludes/PreludesExpansion.ts
Request.ts
Response.ts
routes/ApiCloneableGame.ts
routes/ApiGame.ts
routes/ApiGameHistory.ts
routes/ApiGameLogs.ts
routes/ApiGames.ts
routes/ApiIPs.ts
routes/ApiMetrics.ts
routes/ApiPlayer.ts
routes/ApiSpectator.ts
routes/ApiStats.ts
routes/ApiWaitingFor.ts
routes/Autopass.ts
routes/BufferCache.ts
routes/ContentType.ts
routes/Game.ts
routes/GameLogs.ts
routes/GamesOverview.ts
routes/Handler.ts
routes/IHandler.ts
routes/Load.ts
routes/LoadGame.ts
routes/PlayerInput.ts
routes/Reset.ts
routes/ServeApp.ts
routes/ServeAsset.ts
SerializedCard.ts
SerializedColony.ts
SerializedGame.ts
SerializedPlayer.ts
server.ts
server/AppError.ts
server/heroku.ts
server/IPBlocklist.ts
server/IPTracker.ts
server/QuotaHandler.ts
server/requestProcessor.ts
server/responses.ts
SpaceName.ts
Tile.ts
tools/analyze_ma.html
tools/analyze_ma.ts
tools/check_locales.ts
tools/create_game_ids_table.ts
tools/dump_log.ts
tools/export_card_rendering.ts
tools/export_game.sh
tools/export_game.ts
tools/gzip.js
tools/ma_synergies.ts
tools/read_turmoil.ts
tools/README.md
turmoil/AlliedParty.ts
turmoil/Bonus.ts
turmoil/ChooseRulingPartyDeferred.ts
turmoil/globalEvents/AquiferReleasedByPublicCouncil.ts
turmoil/globalEvents/AsteroidMining.ts
turmoil/globalEvents/CelebrityLeaders.ts
turmoil/globalEvents/CloudSocieties.ts
turmoil/globalEvents/CorrosiveRain.ts
turmoil/globalEvents/Diversity.ts
turmoil/globalEvents/DryDeserts.ts
turmoil/globalEvents/EcoSabotage.ts
turmoil/globalEvents/Election.ts
turmoil/globalEvents/GenerousFunding.ts
turmoil/globalEvents/GlobalDustStorm.ts
turmoil/globalEvents/GlobalEvent.ts
turmoil/globalEvents/GlobalEventDealer.ts
turmoil/globalEvents/HomeworldSupport.ts
turmoil/globalEvents/IGlobalEvent.ts
turmoil/globalEvents/ImprovedEnergyTemplates.ts
turmoil/globalEvents/InterplanetaryTrade.ts
turmoil/globalEvents/JovianTaxRights.ts
turmoil/globalEvents/MicrogravityHealthProblems.ts
turmoil/globalEvents/MinersOnStrike.ts
turmoil/globalEvents/MudSlides.ts
turmoil/globalEvents/Pandemic.ts
turmoil/globalEvents/ParadigmBreakdown.ts
turmoil/globalEvents/Productivity.ts
turmoil/globalEvents/RedInfluence.ts
turmoil/globalEvents/Revolution.ts
turmoil/globalEvents/Riots.ts
turmoil/globalEvents/Sabotage.ts
turmoil/globalEvents/ScientificCommunity.ts
turmoil/globalEvents/SerializedGlobalEventDealer.ts
turmoil/globalEvents/SnowCover.ts
turmoil/globalEvents/SolarFlare.ts
turmoil/globalEvents/SolarnetShutdown.ts
turmoil/globalEvents/SpinoffProducts.ts
turmoil/globalEvents/SponsoredProjects.ts
turmoil/globalEvents/StrongSociety.ts
turmoil/globalEvents/SuccessfulOrganisms.ts
turmoil/globalEvents/VenusInfrastructure.ts
turmoil/globalEvents/VolcanicEruptions.ts
turmoil/globalEvents/WarOnEarth.ts
turmoil/parties/Greens.ts
turmoil/parties/IParty.ts
turmoil/parties/Kelvinists.ts
turmoil/parties/MarsFirst.ts
turmoil/parties/Party.ts
turmoil/parties/PartyHooks.ts
turmoil/parties/Reds.ts
turmoil/parties/Scientists.ts
turmoil/parties/Unity.ts
turmoil/Policy.ts
turmoil/PoliticalAgendas.ts
turmoil/SerializedTurmoil.ts
turmoil/Turmoil.ts
turmoil/TurmoilHandler.ts
underworld/ErodeSpacesDeferred.ts
underworld/ExcavateSpaceDeferred.ts
underworld/ExcavateSpacesDeferred.ts
underworld/IdentifySpacesDeferred.ts
underworld/UnderworldData.ts
underworld/UnderworldExpansion.ts
utils/durations.ts
utils/server-ids.ts
utils/server.ts
utils/shuffle.ts
utils/timer.ts
venusNext/GrantVenusAltTrackBonusDeferred.ts

================================================================
Repository Files
================================================================

================
File: ares/AdjacencyBonus.ts
================
import {SpaceBonus} from '../../common/boards/SpaceBonus';

export type AdjacencyBonus = {
  bonus: Array<SpaceBonus | 'callback'>;
  // Additional placement costs (specifically Nuclear Zone)
  cost ?: number;
}

================
File: ares/AdjacencyCost.ts
================
export type AdjacencyCost = {
  megacredits: number;
  production: number;
}

================
File: ares/AresHandler.ts
================
import {CardName} from '../../common/cards/CardName';
import {IGame} from '../IGame';
import {SelectCard} from '../inputs/SelectCard';
import {Space} from '../boards/Space';
import {IPlayer} from '../IPlayer';
import {CardResource} from '../../common/CardResource';
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {HazardSeverity, hazardSeverity} from '../../common/AresTileType';
import {OCEAN_UPGRADE_TILES, TileType, tileTypeToString} from '../../common/TileType';
import {Tile} from '../Tile';
import {AresData, MilestoneCount} from '../../common/ares/AresData';
import {AdjacencyCost} from './AdjacencyCost';
import {MultiSet} from 'mnemonist';
import {Phase} from '../../common/Phase';
import {SelectPaymentDeferred} from '../deferredActions/SelectPaymentDeferred';
import {SelectProductionToLoseDeferred} from '../deferredActions/SelectProductionToLoseDeferred';
import {_AresHazardPlacement} from './AresHazards';
import {CrashlandingBonus} from '../pathfinders/CrashlandingBonus';
import {Board} from '../boards/Board';

export class AresHandler {
  private constructor() {}

  public static ifAres(game: IGame, cb: (aresData: AresData) => void) {
    if (game.gameOptions.aresExtension) {
      if (game.aresData === undefined) throw new Error('Assertion failure: game.aresData is undefined');
      cb(game.aresData);
    }
  }

  public static earnAdjacencyBonuses(player: IPlayer, space: Space, options?: {giveAresTileOwnerBonus?: boolean}) {
    for (const adjacentSpace of player.game.board.getAdjacentSpaces(space)) {
      this.earnAdacencyBonus(space, adjacentSpace, player, options?.giveAresTileOwnerBonus);
    }
  }

  // |player| placed a tile at |space| next to |adjacentSpace|.
  // Returns true if the adjacent space contains a bonus for adjacency.
  private static earnAdacencyBonus(newTileSpace: Space, adjacentSpace: Space, player: IPlayer, giveAresTileOwnerBonus: boolean = true): void {
    if (adjacentSpace.adjacency === undefined || adjacentSpace.adjacency.bonus.length === 0) {
      return;
    }
    const adjacentPlayer = adjacentSpace.player;
    if (adjacentPlayer === undefined) {
      throw new Error(`A tile with an adjacency bonus must have an owner (${adjacentSpace.x}, ${adjacentSpace.y}, ${adjacentSpace.adjacency.bonus}`);
    }

    const addResourceToCard = function(player: IPlayer, resourceType: CardResource, resourceAsText: string) {
      const availableCards = player.getResourceCards(resourceType);
      if (availableCards.length === 0) {
        return;
      } else if (availableCards.length === 1) {
        player.addResourceTo(availableCards[0], {log: true});
      } else if (availableCards.length > 1) {
        player.defer(new SelectCard(
          'Select a card to add an ' + resourceAsText,
          'Add ' + resourceAsText + 's',
          availableCards)
          .andThen((selected) => {
            player.addResourceTo(selected[0], {log: true});
            return undefined;
          }));
      }
    };

    const bonuses = new MultiSet<SpaceBonus>();

    for (const bonus of adjacentSpace.adjacency.bonus) {
      if (bonus !== 'callback') {
        bonuses.add(bonus);
        continue;
      }
      // Special case for Crashlanding
      const cardName = adjacentSpace.tile?.card;
      if (cardName !== CardName.CRASHLANDING) {
        throw new Error('\'callback\' only applies to Crashlanding now.');
      }
      const adjacentBonuses =
        CrashlandingBonus.onTilePlacedAdjacentToCrashlanding(
          player.game, adjacentSpace, newTileSpace);
      adjacentBonuses.forEach((bonus) => bonuses.add(bonus));
    }

    for (const [bonus, qty] of bonuses.multiplicities()) {
      for (let idx = 0; idx < qty; idx++) {
        switch (bonus) {
        case SpaceBonus.ANIMAL:
          addResourceToCard(player, CardResource.ANIMAL, 'animal');
          break;

        case SpaceBonus.MEGACREDITS:
          player.megaCredits++;
          break;

        case SpaceBonus.ENERGY:
          player.energy++;
          break;

        case SpaceBonus.MICROBE:
          addResourceToCard(player, CardResource.MICROBE, 'microbe');
          break;

        default:
          player.game.grantSpaceBonus(player, bonus);
          break;
        }
      }
    }

    const bonusText = Array.from(bonuses.multiplicities())
      .map(([bonus, count]) => `${count} ${SpaceBonus.toString(bonus)}`)
      .join(', ');
    const tileText = adjacentSpace.tile !== undefined ? tileTypeToString[adjacentSpace.tile.tileType] : 'no tile';
    player.game.log('${0} gains ${1} for placing next to ${2}', (b) => b.player(player).string(bonusText).string(tileText));

    if (giveAresTileOwnerBonus) {
      let ownerBonus = 1;
      if (adjacentPlayer.cardIsInEffect(CardName.MARKETING_EXPERTS)) {
        ownerBonus = 2;
      }

      adjacentPlayer.megaCredits += ownerBonus;
      player.game.log('${0} gains ${1} M€ for a tile placed next to ${2}', (b) => b.player(adjacentPlayer).number(ownerBonus).string(tileText));
    }
  }

  public static maybeIncrementMilestones(aresData: AresData, player: IPlayer, space: Space) {
    const hasAdjacencyBonus = player.game.board.getAdjacentSpaces(space).some((adjacentSpace) => {
      return (adjacentSpace.adjacency?.bonus?? []).length > 0;
    });

    if (hasAdjacencyBonus) {
      const entry : MilestoneCount | undefined = aresData.milestoneResults.find((e) => e.id === player.id);
      if (entry === undefined) {
        throw new Error('Player ID not in the Ares milestone results map: ' + player.id);
      }
      entry.count++;
    }
  }

  public static hasHazardTile(space: Space): boolean {
    return hazardSeverity(space.tile?.tileType) !== HazardSeverity.NONE;
  }

  private static computeAdjacencyCosts(player: IPlayer, space: Space, subjectToHazardAdjacency: boolean): AdjacencyCost {
    if (player.isCorporation(CardName.ATHENA)) {
      subjectToHazardAdjacency = false;
    }

    const game = player.game;
    // Summing up production cost isn't really the way to do it, because each tile could
    // reduce different production costs. Oh well.
    let megaCreditCost = 0;
    let productionCost = 0;
    game.board.getAdjacentSpaces(space).forEach((adjacentSpace) => {
      megaCreditCost += adjacentSpace.adjacency?.cost || 0;
      if (subjectToHazardAdjacency === true) {
        const severity = hazardSeverity(adjacentSpace.tile?.tileType);
        switch (severity) {
        case HazardSeverity.MILD:
          productionCost += 1;
          break;
        case HazardSeverity.SEVERE:
          productionCost += 2;
          break;
        }
      }
    });

    const severity = hazardSeverity(space.tile?.tileType);
    switch (severity) {
    case HazardSeverity.MILD:
      megaCreditCost += 8;
      break;
    case HazardSeverity.SEVERE:
      megaCreditCost += 16;
      break;
    }

    return {megacredits: megaCreditCost, production: productionCost};
  }

  public static assertCanPay(player: IPlayer, space: Space, subjectToHazardAdjacency: boolean): AdjacencyCost {
    if (player.game.phase === Phase.SOLAR) {
      return {megacredits: 0, production: 0};
    }
    const cost = AresHandler.computeAdjacencyCosts(player, space, subjectToHazardAdjacency);

    // Make this more sophisticated, a player can pay for different adjacencies
    // with different production units, and, a severe hazard can't split payments.
    const availableProductionUnits = (player.production.megacredits + 5) +
            player.production.steel +
            player.production.titanium +
            player.production.plants +
            player.production.energy +
            player.production.heat;

    if (availableProductionUnits >= cost.production && player.canAfford(cost.megacredits)) {
      return cost;
    }
    if (cost.production > 0) {
      throw new Error(`Placing here costs ${cost.production} units of production and ${cost.megacredits} M€`);
    }
    if (cost.megacredits > 0) {
      throw new Error(`Placing here costs ${cost.megacredits} M€`);
    }
    return cost;
  }

  public static payAdjacencyAndHazardCosts(player: IPlayer, space: Space, subjectToHazardAdjacency: boolean) {
    const cost = this.assertCanPay(player, space, subjectToHazardAdjacency);

    if (cost.production > 0) {
      // TODO(kberg): don't send interrupt if total is available.
      player.game.defer(new SelectProductionToLoseDeferred(player, cost.production));
    }
    if (cost.megacredits > 0) {
      player.game.log('${0} placing a tile here costs ${1} M€', (b) => b.player(player).number(cost.megacredits));
      player.game.defer(new SelectPaymentDeferred(player, cost.megacredits, {title: 'Select how to pay additional placement costs.'}));
    }
  }

  // Returns true if |newTile| can cover |boardTile|.
  public static canCover(space: Space, newTile: Tile): boolean {
    if (space.tile === undefined) {
      return true;
    }

    // A hazard protected by the Desperate Measures action can't be covered.
    if (AresHandler.hasHazardTile(space) && space.tile.protectedHazard !== true) {
      return true;
    }
    if (space.tile.tileType === TileType.OCEAN && OCEAN_UPGRADE_TILES.has(newTile.tileType)) {
      return true;
    }
    return false;
  }

  public static onTemperatureChange(game: IGame, aresData: AresData) {
    _AresHazardPlacement.onTemperatureChange(game, aresData);
  }

  public static onOceanPlaced(aresData: AresData, player: IPlayer) {
    _AresHazardPlacement.onOceanPlaced(aresData, player);
  }

  public static onOxygenChange(game: IGame, aresData: AresData) {
    _AresHazardPlacement.onOxygenChange(game, aresData);
  }

  public static grantBonusForRemovingHazard(player: IPlayer, initialTileType: TileType | undefined) {
    if (player.game.phase === Phase.SOLAR) {
      return;
    }
    let steps: number;
    switch (initialTileType) {
    case TileType.DUST_STORM_MILD:
    case TileType.EROSION_MILD:
      steps = 1;
      break;

    case TileType.DUST_STORM_SEVERE:
    case TileType.EROSION_SEVERE:
      steps = 2;
      break;

    default:
      return;
    }
    player.increaseTerraformRating(steps);
    player.game.log('${0}\'s TR increases ${1} step(s) for removing ${2}', (b) => b.player(player).number(steps).tileType(initialTileType));
  }

  public static anyAdjacentSpaceGivesBonus(board: Board, space: Space, bonus: SpaceBonus): boolean {
    return board.getAdjacentSpaces(space).some((adj) => adj.adjacency?.bonus.includes(bonus));
  }
}

================
File: ares/AresHazards.ts
================
import {Space} from '../boards/Space';
import {IGame} from '../IGame';
import {LogHelper} from '../LogHelper';
import {Phase} from '../../common/Phase';
import {IPlayer} from '../IPlayer';
import {TileType} from '../../common/TileType';
import {AresData, HazardConstraint} from '../../common/ares/AresData';

/**
 * Package-private support for placing and upgrading hazard tiles.
 */
export class _AresHazardPlacement {
  public static putHazardAt(space: Space, tileType: TileType) {
    space.tile = {tileType: tileType, protectedHazard: false};
  }

  public static randomlyPlaceHazard(game: IGame, tileType: TileType, direction: 1 | -1, cardCount: 1 | 2 = 1) {
    const space = game.getSpaceByOffset(direction, tileType, cardCount);
    this.putHazardAt(space, tileType);
    return space;
  }

  public static makeSevere(game: IGame, from: TileType, to: TileType) {
    game.board.spaces
      .filter((s) => s.tile?.tileType === from)
      .forEach((s) => {
        if (s.tile !== undefined) {
          s.tile.tileType = to;
        }
      });

    game.log('${0} have upgraded to ${1}', (b) => b.tileType(from).tileType(to));
  }

  public static onTemperatureChange(game: IGame, aresData: AresData) {
    // This will have no effect if the erosions don't exist, but that's OK --
    // the check for placing erosions will take this into account.
    this.testConstraint(
      aresData.hazardData.severeErosionTemperature,
      game.getTemperature(),
      () => {
        this.makeSevere(game, TileType.EROSION_MILD, TileType.EROSION_SEVERE);
      },
    );
  }

  public static onOceanPlaced(aresData: AresData, player: IPlayer) {
    this.testToPlaceErosionTiles(aresData, player);
    this.testToRemoveDustStorms(aresData, player);
  }

  public static onOxygenChange(game: IGame, aresData: AresData) {
    this.testConstraint(aresData.hazardData.severeDustStormOxygen, game.getOxygenLevel(), () => {
      this.makeSevere(game, TileType.DUST_STORM_MILD, TileType.DUST_STORM_SEVERE);
    });
  }

  private static testToPlaceErosionTiles(aresData: AresData, player: IPlayer) {
    if (player.game.gameOptions.aresHazards === false) {
      return;
    }

    this.testConstraint(
      aresData.hazardData.erosionOceanCount,
      player.game.board.getOceanSpaces().length,
      () => {
        let type = TileType.EROSION_MILD;
        if (aresData.hazardData.severeErosionTemperature.available !== true) {
          type = TileType.EROSION_SEVERE;
        }

        const space1 = this.randomlyPlaceHazard(player.game, type, 1);
        const space2 = this.randomlyPlaceHazard(player.game, type, -1);
        [space1, space2].forEach((space) => {
          LogHelper.logTilePlacement(player, space, type);
        });
      },
    );
  }

  private static testToRemoveDustStorms(aresData: AresData, player: IPlayer) {
    this.testConstraint(
      aresData.hazardData.removeDustStormsOceanCount,
      player.game.board.getOceanSpaces().length,
      () => {
        player.game.board.spaces.forEach((space) => {
          if (space.tile?.tileType === TileType.DUST_STORM_MILD || space.tile?.tileType === TileType.DUST_STORM_SEVERE) {
            if (space.tile.protectedHazard !== true) {
              space.tile = undefined;
            }
          }
        });

        if (player.game.phase !== Phase.SOLAR) {
          player.increaseTerraformRating();
          player.game.log('${0}\'s TR increases 1 step for eliminating dust storms.', (b) => b.player(player));
        }
      },
    );
  }

  private static testConstraint(constraint: HazardConstraint, testValue: number, cb: () => void) {
    if (!constraint.available) {
      return;
    }
    if (testValue >= constraint.threshold) {
      cb();
      constraint.available = false;
    }
  }
}

================
File: ares/AresSetup.ts
================
import {IPlayer} from '../IPlayer';
import {AresData} from '../../common/ares/AresData';
import {IGame} from '../IGame';
import {TileType} from '../../common/TileType';
import {_AresHazardPlacement} from './AresHazards';

export class AresSetup {
  private constructor() {}

  public static initialData(includeHazards: boolean, players: IPlayer[]): AresData {
    return {
      includeHazards: includeHazards,
      hazardData: {
        erosionOceanCount: {threshold: 3, available: true}, // oceans: add erosion tiles
        removeDustStormsOceanCount: {threshold: 6, available: true}, // oceans: remove dust storms
        severeErosionTemperature: {threshold: -4, available: true}, // temperatore: severe erosion
        severeDustStormOxygen: {threshold: 5, available: true}, // oxygen: severe dust storms
      },
      milestoneResults: players.map((p) => {
        return {id: p.id, count: 0};
      }),
    };
  }

  public static setupHazards(game: IGame, playerCount: number) {
    // The number of dust storms depends on the player count.
    // I made up that the solo player has 3 dust storms. The rules
    // don't take solo into account, nor if you played with more than
    // five players.
    if (playerCount >= 5) {
      _AresHazardPlacement.randomlyPlaceHazard(game, TileType.DUST_STORM_MILD, 1, 2);
    } else if (playerCount === 4) {
      _AresHazardPlacement.randomlyPlaceHazard(game, TileType.DUST_STORM_MILD, 1);
      _AresHazardPlacement.randomlyPlaceHazard(game, TileType.DUST_STORM_MILD, -1);
    } else if (playerCount <= 3) {
      _AresHazardPlacement.randomlyPlaceHazard(game, TileType.DUST_STORM_MILD, 1, 2);
      _AresHazardPlacement.randomlyPlaceHazard(game, TileType.DUST_STORM_MILD, 1);
      _AresHazardPlacement.randomlyPlaceHazard(game, TileType.DUST_STORM_MILD, -1);
    }
  }
}

================
File: awards/Adapter.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {CardType} from '../../common/cards/CardType';

export class Adapter implements IAward {
  public readonly name = 'Adapter';
  public readonly description = 'Have the most cards with requirements in play';

  public getScore(player: IPlayer): number {
    const validCards = player.playedCards.filter((card) => {
      // TODO(kberg): Adapter is not compatible with corps that turn events up (eg Odyssey)
      return card.type !== CardType.EVENT && card.requirements.length > 0;
    });

    return validCards.length;
  }
}

================
File: awards/amazonisPlanitia/Curator.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {IAward} from '../IAward';

export class Curator implements IAward {
  public readonly name = 'Curator';
  public readonly description = 'Have the most tags of any one type in play';

  public getScore(player: IPlayer): number {
    let max = 0;
    for (const tagString in Tag) {
      if (Object.prototype.hasOwnProperty.call(Tag, tagString)) {
        const tag: Tag = (<any>Tag)[tagString];
        if (tag === Tag.EVENT) continue;
        const count = player.tags.count(tag, 'award');
        if (count > max) max = count;
      }
    }

    return max;
  }
}

================
File: awards/amazonisPlanitia/Engineer.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {IAward} from '../IAward';
import {ICard} from '../../cards/ICard';

/**
 * The list of cards that have bespoke code to change production.
 *
 * Public for testing.
 */
export const BESPOKE_PRODUCTION_CARDS: ReadonlyArray<CardName> = [
  // Base + Corp Era
  CardName.ARTIFICIAL_PHOTOSYNTHESIS,
  CardName.ASTEROID_MINING_CONSORTIUM,
  CardName.ENERGY_TAPPING,
  CardName.GREAT_ESCARPMENT_CONSORTIUM,
  CardName.INSULATION,
  CardName.NITROGEN_RICH_ASTEROID,
  CardName.POWER_SUPPLY_CONSORTIUM,
  // Colonies
  CardName.COMMUNITY_SERVICES,
  CardName.ECOLOGY_RESEARCH,
  CardName.LUNAR_EXPORTS,
  CardName.MINORITY_REFUGE,
  CardName.PIONEER_SETTLEMENT,
  CardName.QUANTUM_COMMUNICATIONS,
  // Promo
  CardName.INTERPLANETARY_TRADE,
  // Moon
  CardName.DARKSIDE_MINING_SYNDICATE,
  CardName.ROVER_DRIVERS_UNION,
  CardName.LUNA_FIRST_INCORPORATED,
  // Pathfinders
  CardName.RARE_EARTH_ELEMENTS,
  CardName.MICROBIOLOGY_PATENTS,
  CardName.OUMUAMUA_TYPE_OBJECT_SURVEY,
  CardName.SMALL_OPEN_PIT_MINE,
] as const;

// Mapping from [CardName => boolean] indicating whether a card is eligible for Engineer.
// This map serves as a lazy cache, evaluated as new cards come in.
const map = new Map<CardName, boolean>(BESPOKE_PRODUCTION_CARDS.map((name) => [name, true]));

export class Engineer implements IAward {
  public readonly name = 'Engineer';
  public readonly description = 'Have the most cards in play that directly alter your own production';

  public getScore(player: IPlayer): number {
    return player.tableau.filter((card) => {
      const eligible = map.get(card.name);
      if (eligible !== undefined) {
        return eligible;
      }
      const val = Engineer.autoInclude(card);
      map.set(card.name, val);
      return val;
    }).length;
  }

  /**
   * Returns true if `card`'s definition shows that it increases production, and is eligible for
   * this award.
   */
  public static autoInclude(card: ICard) {
    if (card.productionBox !== undefined) {
      return true;
    }
    const production = card.behavior?.production;
    if (production !== undefined) {
      return Object.keys(production).length > 0;
    }
    return false;
  }
}

================
File: awards/amazonisPlanitia/Historian.ts
================
import {IPlayer} from '../../IPlayer';
import {IAward} from '../IAward';

export class Historian implements IAward {
  public readonly name = 'Historian';
  public readonly description = 'Have the most cards in your event pile';

  public getScore(player: IPlayer): number {
    return player.getPlayedEventsCount();
  }
}

================
File: awards/amazonisPlanitia/Tourist.ts
================
import {RedTourismWave} from '../../cards/turmoil/RedTourismWave';
import {IPlayer} from '../../IPlayer';
import {IAward} from '../IAward';

export class Tourist implements IAward {
  public readonly name = 'Tourist';
  public readonly description = 'Have the most empty spaces adjacent to your tiles';

  public getScore(player: IPlayer): number {
    return RedTourismWave.getAdjacentEmptySpacesCount(player);
  }
}

================
File: awards/amazonisPlanitia/Zoologist.ts
================
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {IAward} from '../IAward';

export class Zoologist2 implements IAward {
  public readonly name = 'A. Zoologist';
  public readonly description = 'Own the most animal and microbe resources';

  public getScore(player: IPlayer): number {
    const resourceTypes = [CardResource.ANIMAL, CardResource.MICROBE];
    let score = 0;

    player.getCardsWithResources().filter((card) => card.resourceType !== undefined && resourceTypes.includes(card.resourceType)).forEach((card) => {
      score += card.resourceCount;
    });

    return score;
  }
}

================
File: awards/Awards.ts
================
import {Landlord} from './Landlord';
import {Banker} from './Banker';
import {Scientist} from './Scientist';
import {Thermalist} from './Thermalist';
import {Miner} from './Miner';
import {Venuphile} from './Venuphile';
import {IAward} from './IAward';
import {Industrialist} from './Industrialist';
import {Celebrity} from './Celebrity';
import {DesertSettler} from './DesertSettler';
import {EstateDealer} from './EstateDealer';
import {Benefactor} from './Benefactor';
import {Cultivator} from './Cultivator';
import {Magnate} from './Magnate';
import {SpaceBaron} from './SpaceBaron';
import {Excentric} from './Excentric';
import {Contractor} from './Contractor';
import {Entrepreneur} from './Entrepreneur';
import {FullMoon} from '../moon/FullMoon';
import {LunarMagnate} from '../moon/LunarMagnate';
import {CosmicSettler} from './CosmicSettler';
import {Botanist} from './Botanist';
import {Coordinator} from './Coordinator';
import {Zoologist} from './Zoologist';
import {Manufacturer} from './Manufacturer';
import {Adapter} from './Adapter';
import {Edgedancer} from './Edgedancer';
import {Hoarder} from './Hoarder';
import {Naturalist} from './Naturalist';
import {Voyager} from './Voyager';
import {Curator} from './amazonisPlanitia/Curator';
import {Engineer} from './amazonisPlanitia/Engineer';
import {Historian} from './amazonisPlanitia/Historian';
import {Tourist} from './amazonisPlanitia/Tourist';
import {Biologist} from './terraCimmeria/Biologist';
import {Economizer2} from './terraCimmeria/Economizer2';
import {Politician} from './terraCimmeria/Politician';
import {Urbanist} from './terraCimmeria/Urbanist';
import {Warmonger} from './terraCimmeria/Warmonger';
import {Zoologist2} from './amazonisPlanitia/Zoologist';
import {Kingpin} from './underworld/Kingpin';
import {EdgeLord} from './underworld/EdgeLord';

export const THARSIS_AWARDS = [
  new Landlord(),
  new Scientist(),
  new Banker(),
  new Thermalist(),
  new Miner(),
];

export const VENUS_AWARDS = [
  new Venuphile(),
];

export const ELYSIUM_AWARDS = [
  new Celebrity(),
  new Industrialist(),
  new DesertSettler(),
  new EstateDealer(),
  new Benefactor(),
];

export const UTOPIA_PLANITIA_AWARDS = [
  // new Suburbian(),
  // new Investor(),
  // new Botanist(),
  // new Incorporator(),
  // new Metropolist(),
];

export const HELLAS_AWARDS = [
  new Cultivator(),
  new Magnate(),
  new SpaceBaron(),
  new Excentric(),
  new Contractor(),
];

export const ARES_AWARDS = [
  new Entrepreneur(),
];

export const MOON_AWARDS = [
  new FullMoon(),
  new LunarMagnate(),
];

export const AMAZONIS_PLANITIA_AWARDS = [
  new Curator(),
  new Engineer(),
  new Historian(),
  new Tourist(),
  new Zoologist2(),
];

export const ARABIA_TERRA_AWARDS = [
  new CosmicSettler(),
  new Botanist(),
  new Coordinator(),
  new Zoologist(),
  new Manufacturer(),
];

export const TERRA_CIMMERIA_AWARDS = [
  new Biologist(),
  new Economizer2(),
  new Politician(),
  new Urbanist(),
  new Warmonger(),
];

export const VASTITAS_BOREALIS_AWARDS = [
  new Adapter(),
  new Edgedancer(),
  new Hoarder(),
  new Naturalist(),
  new Voyager(),
];

export const UNDERWORLD_AWARDS = [
  new Kingpin(),
  new EdgeLord(),
];

export const ALL_AWARDS = [
  ...THARSIS_AWARDS,
  ...ELYSIUM_AWARDS,
  ...HELLAS_AWARDS,
  ...UTOPIA_PLANITIA_AWARDS,
  ...VENUS_AWARDS,
  ...ARES_AWARDS,
  ...MOON_AWARDS,
  ...AMAZONIS_PLANITIA_AWARDS,
  ...ARABIA_TERRA_AWARDS,
  ...TERRA_CIMMERIA_AWARDS,
  ...VASTITAS_BOREALIS_AWARDS,
  ...UNDERWORLD_AWARDS,
];

// Remove namespace and rename function
export namespace Awards {
  export const ALL = ALL_AWARDS;

  export function getByName(name: string): IAward {
    const award = ALL_AWARDS.find((a) => a.name === name);
    if (award) {
      return award;
    }
    throw new Error(`Award ${name} not found.`);
  }
}

================
File: awards/AwardScorer.ts
================
import {PlayerId} from '../../common/Types';
import {IGame} from '../IGame';
import {IPlayer} from '../IPlayer';
import {IAward} from './IAward';
import {CardName} from '../../common/cards/CardName';
import {ASIMOV_AWARD_BONUS} from '../../common/constants';

export class AwardScorer {
  private scores: Map<PlayerId, number> = new Map();
  constructor(game: IGame, award: IAward) {
    for (const player of game.getPlayers()) {
      let score = award.getScore(player);
      // CEO Asimov Award Score Hook
      if (player.cardIsInEffect(CardName.ASIMOV)) score += ASIMOV_AWARD_BONUS;
      this.scores.set(player.id, score);
    }
  }

  public get(player: IPlayer): number {
    // Ideally throw when player does not match, but this is OK.
    return this.scores.get(player.id) ?? 0;
  }
}

================
File: awards/Banker.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';

export class Banker implements IAward {
  public readonly name = 'Banker';
  public readonly description = 'Have the most M€ production';
  public getScore(player: IPlayer): number {
    return player.production.megacredits;
  }
}

================
File: awards/Benefactor.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';

export class Benefactor implements IAward {
  public readonly name = 'Benefactor';
  public readonly description = 'Have the highest terraform rating';
  public getScore(player: IPlayer): number {
    return player.getTerraformRating();
  }
}

================
File: awards/Botanist.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';

export class Botanist implements IAward {
  public readonly name = 'Botanist';
  public readonly description = 'Have the most plant production';
  public getScore(player: IPlayer): number {
    return player.production.plants;
  }
}

================
File: awards/Celebrity.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {CardType} from '../../common/cards/CardType';

export class Celebrity implements IAward {
  public readonly name = 'Celebrity';
  public readonly description = 'Have the most project cards in play with a base cost of at least 20 M€ (not events.)';
  public getScore(player: IPlayer): number {
    return player.playedCards
      .filter((card) => (card.cost >= 20) && (card.type === CardType.ACTIVE || card.type === CardType.AUTOMATED)).length;
  }
}

================
File: awards/Contractor.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';

export class Contractor implements IAward {
  public readonly name = 'Contractor';
  public readonly description = 'Have the most building tags in play';
  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.BUILDING, 'award');
  }
}

================
File: awards/Coordinator.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';

export class Coordinator implements IAward {
  public readonly name = 'Coordinator';
  public readonly description = 'Have the most cards in your event pile';

  public getScore(player: IPlayer): number {
    return player.getPlayedEventsCount();
  }
}

================
File: awards/CosmicSettler.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';

export class CosmicSettler implements IAward {
  public readonly name = 'Cosmic Settler';
  public readonly description = 'Own the most cities not on Mars';
  public getScore(player: IPlayer): number {
    return player.game.board.getCitiesOffMars(player).length;
  }
}

================
File: awards/Cultivator.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';

export class Cultivator implements IAward {
  public readonly name = 'Cultivator';
  public readonly description = 'Own the most greenery tiles';
  public getScore(player: IPlayer): number {
    return player.game.board.getGreeneries(player).length;
  }
}

================
File: awards/DesertSettler.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {isHazardTileType} from '../../common/AresTileType';
import {Board} from '../boards/Board';

export class DesertSettler implements IAward {
  public readonly name = 'Desert Settler';
  public readonly description = 'Own the most tiles south of the equator (the four bottom rows)';
  public getScore(player: IPlayer): number {
    return player.game.board.spaces
      .filter(Board.ownedBy(player))
      .filter((space) =>
        space.tile !== undefined &&
          isHazardTileType(space.tile.tileType) === false &&
          space.y >= 5 && space.y <= 8).length;
  }
}

================
File: awards/Edgedancer.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {isHazardTileType} from '../../common/AresTileType';

export class Edgedancer implements IAward {
  public readonly name = 'Edgedancer';
  public readonly description = 'Own the most tiles on the edges of the board';

  public getScore(player: IPlayer): number {
    return player.game.board.getEdges()
      .filter((space) => space.player !== undefined &&
        space.player === player &&
        space.tile !== undefined &&
        isHazardTileType(space.tile.tileType) === false).length;
  }
}

================
File: awards/Entrepreneur.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {Board} from '../boards/Board';

export class Entrepreneur implements IAward {
  public readonly name = 'Entrepreneur';
  public readonly description = 'Own the most tiles that grant adjacency bonuses';
  public getScore(player: IPlayer): number {
    return player.game.board.spaces
      .filter(Board.ownedBy(player))
      .filter((space) => (space.adjacency && space.adjacency.bonus.length > 0)).length;
  }
}

================
File: awards/EstateDealer.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {isHazardTileType} from '../../common/AresTileType';
import {Board} from '../boards/Board';

export class EstateDealer implements IAward {
  public readonly name = 'Estate Dealer';
  public readonly description = 'Own the most tiles adjacent to ocean tiles';
  public getScore(player: IPlayer): number {
    return player.game.board.spaces.filter((space) =>
      space.player === player &&
        space.tile !== undefined &&
        isHazardTileType(space.tile.tileType) === false &&
        player.game.board.getAdjacentSpaces(space).some((space) => Board.isOceanSpace(space)),
    ).length;
  }
}

================
File: awards/Excentric.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';

export class Excentric implements IAward {
  public readonly name = 'Excentric';
  public readonly description = 'Have the most resources on cards in play';
  public getScore(player: IPlayer): number {
    let score = 0;

    player.getCardsWithResources().forEach((card) => {
      score += card.resourceCount;
    });

    return score;
  }
}

================
File: awards/FundedAward.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {PlayerId} from '../../common/Types';
import {AwardName} from '../../common/ma/AwardName';

export type FundedAward = {
  award: IAward;
  player: IPlayer;
}

export type SerializedFundedAward = {
  name?: AwardName;
  playerId?: PlayerId;
}

export function serializeFundedAwards(fundedAwards: Array<FundedAward>) : Array<SerializedFundedAward> {
  return fundedAwards.map((fundedAward) => {
    return {
      name: fundedAward.award.name,
      playerId: fundedAward.player.id,
    };
  });
}

export function deserializeFundedAwards(
  fundedAwards: Array<SerializedFundedAward>,
  players: Array<IPlayer>,
  awards: Array<IAward>): Array<FundedAward> {
  // Remove duplicates
  const aw = new Set<AwardName>();
  const filtered = [];
  for (const fundedAward of fundedAwards) {
    const name = fundedAward.name;
    if (name === undefined) {
      throw new Error('Award name not found');
    }
    const playerId = fundedAward.playerId;
    if (playerId === undefined) {
      throw new Error(`Player ID not found when rebuilding funded award ${name}`);
    }

    if (aw.has(name)) {
      console.error('Found duplicate award: ' + name);
      continue;
    } else {
      filtered.push({name, playerId});
      aw.add(name);
    }
  }

  return filtered.map((element: SerializedFundedAward) => {
    const awardName = element.name;
    const award: IAward | undefined = awards.find((award) => award.name === awardName);
    if (award === undefined) {
      throw new Error(`Award ${awardName} not found when rebuilding Funded Award`);
    }

    const playerId = element.playerId;
    const player = players.find((player) => player.id === playerId);
    if (player === undefined) {
      throw new Error(`Player ${playerId} not found when rebuilding Funded Award ${awardName}`);
    }

    return {award, player};
  });
}

================
File: awards/Hoarder.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';

export class Hoarder implements IAward {
  public readonly name = 'Hoarder';
  public readonly description = 'Have the most cards in hand';

  public getScore(player: IPlayer): number {
    return player.cardsInHand.length;
  }
}

================
File: awards/IAward.ts
================
import {AwardName} from '../../common/ma/AwardName';
import {IPlayer} from '../IPlayer';

export interface IAward {
    name: AwardName;
    description: string;
    getScore(player: IPlayer): number;
}

================
File: awards/Industrialist.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';

export class Industrialist implements IAward {
  public readonly name = 'Industrialist';
  public readonly description = 'Have most steel and energy';
  public getScore(player: IPlayer): number {
    if (player.game.isDoneWithFinalProduction()) {
      return player.steel + player.energy;
    } else {
      return player.steel + player.production.steel + player.production.energy;
    }
  }
}

================
File: awards/Landlord.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {TileType} from '../../common/TileType';
import {isHazardTileType} from '../../common/AresTileType';
import {MoonExpansion} from '../moon/MoonExpansion';

export class Landlord implements IAward {
  public readonly name = 'Landlord';
  public readonly description = 'Own the most tiles';
  public getScore(player: IPlayer): number {
    const marsSpaces = player.game.board.spaces.filter(
      // Don't simplifiy this to "space.tile?.tileType !== TileType.OCEAN" because that will make
      // Land Claim a valid space for Landlord.
      (space) => space.tile !== undefined && isHazardTileType(space.tile.tileType) === false && space.tile.tileType !== TileType.OCEAN && space.player === player).length;

    const moonSpaces = MoonExpansion.ifElseMoon(player.game,
      (moonData) => moonData.moon.spaces.filter(
        (space) => space.tile !== undefined && space.player === player).length,
      () => 0);

    return marsSpaces + moonSpaces;
  }
}

================
File: awards/Magnate.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {CardType} from '../../common/cards/CardType';

export class Magnate implements IAward {
  public readonly name = 'Magnate';
  public readonly description = 'Have the most automated (green) project cards in play';
  public getScore(player: IPlayer): number {
    return player.playedCards
      .filter((card) => card.type === CardType.AUTOMATED).length;
  }
}

================
File: awards/Manufacturer.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {CardType} from '../../common/cards/CardType';

export class Manufacturer implements IAward {
  public readonly name = 'Manufacturer';
  public readonly description = 'Have the most active (blue) project cards in play';
  public getScore(player: IPlayer): number {
    return player.playedCards.filter((card) => card.type === CardType.ACTIVE).length;
  }
}

================
File: awards/Miner.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';

export class Miner implements IAward {
  public readonly name = 'Miner';
  public readonly description = 'Have the most steel and titanium';
  public getScore(player: IPlayer): number {
    if (player.game.isDoneWithFinalProduction()) {
      return player.steel + player.titanium;
    } else {
      return player.steel + player.production.steel + player.titanium + player.production.titanium;
    }
  }
}

================
File: awards/Naturalist.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';

export class Naturalist implements IAward {
  public readonly name = 'Naturalist';
  public readonly description = 'Have the most plant and heat production';

  public getScore(player: IPlayer): number {
    return player.production.heat + player.production.plants;
  }
}

================
File: awards/Scientist.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';

export class Scientist implements IAward {
  public readonly name = 'Scientist';
  public readonly description = 'Have the most science tags in play';
  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.SCIENCE, 'award');
  }
}

================
File: awards/SpaceBaron.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';

export class SpaceBaron implements IAward {
  public readonly name = 'Space Baron';
  public readonly description = 'Have the most space tags in play';
  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.SPACE, 'award');
  }
}

================
File: awards/terraCimmeria/Biologist.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {IAward} from '../IAward';

export class Biologist implements IAward {
  public readonly name = 'Biologist';
  public readonly description = 'Have the most animal, plant, and microbe tags in play';

  public getScore(player: IPlayer): number {
    return player.tags.multipleCount([Tag.MICROBE, Tag.PLANT, Tag.ANIMAL], 'award');
  }
}

================
File: awards/terraCimmeria/Economizer2.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {IAward} from '../IAward';

export class Economizer2 implements IAward {
  public readonly name = 'T. Economizer';
  public readonly description = 'Have the most project cards in play with a base cost of 10 M€ or less (not events.)';

  public getScore(player: IPlayer): number {
    const validCardTypes = [CardType.ACTIVE, CardType.AUTOMATED];
    return player.playedCards
      .filter((card) => (card.cost <= 10) && validCardTypes.includes(card.type)).length;
  }
}

================
File: awards/terraCimmeria/Politician.ts
================
import {IPlayer} from '../../IPlayer';
import {IAward} from '../IAward';

export class Politician implements IAward {
  public readonly name = 'Politician';
  public readonly description = 'Place the most delegates';

  public getScore(player: IPlayer): number {
    return player.totalDelegatesPlaced;
  }
}

================
File: awards/terraCimmeria/Urbanist.ts
================
import {Board} from '../../boards/Board';
import {IPlayer} from '../../IPlayer';
import {TileType} from '../../../common/TileType';
import {IAward} from '../IAward';
import {Space} from '../../boards/Space';

export class Urbanist implements IAward {
  public readonly name = 'Urbanist';
  public readonly description = 'Have the most VP from city tile adjacencies on Mars';

  public getScore(player: IPlayer): number {
    let score = 0;

    player.game.board.spaces.forEach((space) => {
      if (Board.isCitySpace(space) && space.player?.id === player.id) {
        // Victory points for greenery tiles adjacent to cities
        switch (space.tile?.tileType) {
        case TileType.CITY:
        case TileType.OCEAN_CITY:
          score += this.countGreeneries(player, space);
          break;
        case TileType.CAPITAL:
          score += this.countGreeneries(player, space) + this.getVictoryPoints(player, space);
          break;
        case TileType.RED_CITY:
          score += this.getVictoryPoints(player, space);
          break;
        default:
          throw new Error('foo');
        }
      }
    });

    return score;
  }

  private countGreeneries(player: IPlayer, space: Space) {
    let score = 0;
    const adjacent = player.game.board.getAdjacentSpaces(space);
    for (const adj of adjacent) {
      if (Board.isGreenerySpace(adj)) {
        score++;
      }
    }
    return score;
  }

  private getVictoryPoints(player: IPlayer, space: Space) {
    const card = player.playedCards.find((c) => c.name === space?.tile?.card);
    if (card !== undefined) {
      return card.getVictoryPoints(player);
    }
    return 0;
  }
}

================
File: awards/terraCimmeria/Warmonger.ts
================
import {ICard} from '../../cards/ICard';
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {IAward} from '../IAward';
import {CardType} from '../../../common/cards/CardType';

export class Warmonger implements IAward {
  public readonly name = 'Warmonger';
  public readonly description = 'Play the most cards that reduce other players\' resources or production';

  public getScore(player: IPlayer): number {
    const score = player.tableau.filter((card) => {
      if (Warmonger.attackCards.includes(card.name)) return true;
      return Warmonger.autoInclude(card);
    }).length;

    return score;
  }

  public static autoInclude(card: ICard) {
    if (card.type === CardType.EVENT) {
      return;
    }
    if (card.behavior !== undefined) {
      const behavior = card.behavior;
      if (behavior.removeAnyPlants !== undefined) return true;
      if (behavior.decreaseAnyProduction !== undefined) return true;
    }
    return false;
  }

  // This is the list of cards that have bespoke attack code.
  // public for testing.
  public static attackCards: ReadonlyArray<CardName> = [
    // Base + Corp Era
    CardName.ANTS,
    CardName.ASTEROID_MINING_CONSORTIUM,
    CardName.ENERGY_TAPPING,
    CardName.GREAT_ESCARPMENT_CONSORTIUM,
    CardName.HACKERS,
    CardName.POWER_SUPPLY_CONSORTIUM,
    CardName.PREDATORS,
    // Venus
    // Colonies
    // Turmoil
    // Promo
    CardName.MONS_INSURANCE,
    // Moon
    CardName.ANCIENT_SHIPYARDS,
    CardName.THE_DARKSIDE_OF_THE_MOON_SYNDICATE,
    // Pathfinders
    // CEOs
    CardName.BJORN,
    // Star Wars
    CardName.CLONE_TROOPERS,
    // Underworld
    CardName.CLASS_ACTION_LAWSUIT,
    CardName.HACKERS_UNDERWORLD,
    CardName.INVESTIGATIVE_JOURNALISM,
    CardName.SPACE_PRIVATEERS,
  ] as const;
}

================
File: awards/Thermalist.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';

export class Thermalist implements IAward {
  public readonly name = 'Thermalist';
  public readonly description = 'Have the most heat';
  public getScore(player: IPlayer): number {
    if (player.game.isDoneWithFinalProduction()) {
      return player.heat;
    } else {
      return player.energy + player.heat + player.production.heat;
    }
  }
}

================
File: awards/underworld/EdgeLord.ts
================
import {IAward} from '../IAward';
import {IPlayer} from '../../IPlayer';

export class EdgeLord implements IAward {
  public readonly name = 'EdgeLord';
  public readonly description = 'Have the highest number of excavation markers on the edges of the board.';
  public getScore(player: IPlayer): number {
    return player.game.board.getEdges().filter((space) => space.excavator === player).length;
  }
}

================
File: awards/underworld/Kingpin.ts
================
import {IAward} from '../IAward';
import {IPlayer} from '../../IPlayer';

export class Kingpin implements IAward {
  public readonly name = 'Kingpin';
  public readonly description = 'Play the highest number of cards with a corruption requirement of at least 1. (Event cards count)';
  public getScore(player: IPlayer): number {
    return player.playedCards
      .filter((card) => card.requirements
        .some((requirement) => (requirement.corruption ?? 0) > 0)).length;
  }
}

================
File: awards/Venuphile.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';

export class Venuphile implements IAward {
  public readonly name = 'Venuphile';
  public readonly description = 'Have the most Venus tags in play';
  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.VENUS, 'award');
  }
}

================
File: awards/Voyager.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';

export class Voyager implements IAward {
  public readonly name = 'Voyager';
  public readonly description = 'Have the most Jovian tags in play';

  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.JOVIAN, 'award');
  }
}

================
File: awards/Zoologist.ts
================
import {IAward} from './IAward';
import {IPlayer} from '../IPlayer';
import {CardResource} from '../../common/CardResource';

export class Zoologist implements IAward {
  public readonly name = 'Zoologist';
  public readonly description = 'Have the most animal resources';
  public getScore(player: IPlayer): number {
    return player.getResourceCount(CardResource.ANIMAL);
  }
}

================
File: behavior/Behavior.ts
================
// import {SpaceType} from '../../common/boards/SpaceType';
import {CardResource} from '../../common/CardResource';
import {CardType} from '../../common/cards/CardType';
import {Resource} from '../../common/Resource';
import {Tag} from '../../common/cards/Tag';
// import {SpaceId} from '../../common/Types';
// import {CardResource} from '../../common/CardResource';
// import {TileType} from '../../common/TileType';
import {SpaceId} from '../../common/Types';
import {MoonSpaces} from '../../common/moon/MoonSpaces';
import {TileType} from '../../common/TileType';
import {Countable, CountableUnits} from './Countable';
import {PlacementType} from '../boards/PlacementType';
import {AdjacencyBonus} from '../ares/AdjacencyBonus';
import {Units} from '../../common/Units';
import {NoAttributes} from './NoAttributes';
import {PartyName} from '@/common/turmoil/PartyName';

type ValueOf<Obj> = Obj[keyof Obj];
type OneOnly<Obj, Key extends keyof Obj> = { [key in Exclude<keyof Obj, Key>]: null } & Pick<Obj, Key>;
type OneOfByKey<Obj> = { [key in keyof Obj]: OneOnly<Obj, key> };
export type OneOfType<Obj> = ValueOf<OneOfByKey<Obj>>;


export type Spend = Units & {
  /** units or a number of resources from the card. */
  resourcesHere: number,

  /** 1 resource of a type from any card. */
  resourceFromAnyCard: {
    type: CardResource,
  },

  /** corruption from your personal supply. */
  corruption: number,
}

/** A set of steps that an action can perform in any specific order. */
export type Behavior = {
  /** Select one of these actions */
  or?: OrBehavior;

  /**
   * Spend one of resources before taking the action.
   *
   * This is specifically designed to spend only one resource type.
   */
  spend?: Partial<OneOfType<Spend>>;

  /** Gain or lose production */
  production?: Partial<CountableUnits>;
  /** Gain or lose stock */
  stock?: Partial<CountableUnits>;

  /** Gain n standard resources */
  standardResource?: number | {
    /** Number of resources to gain. */
    count: number,
    /** Must all resources be the same type? Default is true. */
    same?: boolean,
  };

  /** Add resources to this card itself */
  addResources?: Countable;

  /** Add resources to any cards */
  addResourcesToAnyCard?: AddResource | Array<Omit<AddResource, 'mustHaveCard'>>;

  // /** Remove resources from any card */
  // removeResourcesFromAnyCard?: Omit<AddResource, 'mustHaveCard'>; // This Omit thing isn't right.

  /** Decrease any production */
  decreaseAnyProduction?: DecreaseAnyProduction;
  removeAnyPlants?: number,

  /** Gain units of TR */
  // TODO(kberg) permit losing TR for TerralabsResearch
  tr?: Countable;

  /** Raise certain global parameters. */
  global?: {
    temperature?: -2 | -1 | 1 | 2 | 3;
    oxygen?: 2 | 1 | -1 | -2;
    venus?: 3 | 2 | 1 | -1;
  },

  city?: {
    space?: SpaceId,
    on?: PlacementType,
  },
  /** Places a greenery tile and also raises the oxygen. */
  greenery?: {
    on?: PlacementType,
  },
  ocean?: {
    count?: 2,
    on?: PlacementType,
  },

  tile?: {
    type: TileType,
    on: PlacementType,
    adjacencyBonus?: AdjacencyBonus,
    title?: string,
  },

  /** Remove plants from any player. Typical for asteroid cards. */
  // removePlants: number,

  /** Remove resources from any player.
  // removeAnyResource: {type: CardResource, count: number},

  /** Raise the titanium and steel value. On discard, reduce them. */
  titanumValue?: 1;
  steelValue?: 1;

  /** Draw this many cards from the deck. */
  drawCard?: number | DrawCard,

  /** Greeneries cost one plant less. */
  greeneryDiscount?: 1,

  //andy test heat discount
  heatDiscount?: 1,
  
  // spendResourcesHere: number,
  // spendResource: {type: CardResource, count: number},
  // tile: {type: TileType, space?: SpaceId, spaceType?: SpaceType};
  colonies?: {
    buildColony?: {
      allowDuplicates?: boolean,
    },

    /** Add this many trade fleets to your armada. */
    addTradeFleet?: number,

    /** When trading increase the colony track this many steps. */
    tradeDiscount?: number,

    /** When trading increase the colony track this many steps. */
    tradeOffset?: number,
  }

  turmoil?: {
    influenceBonus?: 1,
    sendDelegates?: {
      count: number,
      manyParties?: boolean,
      party?: PartyName,
    },
  },

  /* Used with Supercapacitors and Power Core */
  optionalEnergyConversion?: boolean;

  moon?: {
    /** Places a habitat tile and also raises the habitat rate */
    habitatTile?: PlaceMoonTile,
    /** Places a mine tile and also raises the mining rate */
    mineTile?: PlaceMoonTile,
    /** Places a road tile and also raises the logistics rate */
    roadTile?: PlaceMoonTile,
    /** Places a special tile on the Moon. */
    tile?: PlaceMoonTile & {type: TileType},
    habitatRate?: number,
    miningRate?: number,
    logisticsRate?: number,
  },

  underworld?: {
    identify?: Countable,
    excavate?: number | {count: Countable, ignorePlacementRestrictions?: boolean},
    corruption?: Countable,
    markThisGeneration?: NoAttributes,
  },

  /**
   * Log a message using a parameterized string replacement. This is not a normal template.
   *
   * Template does not accept traditional parameters ${0} and ${1}, but rather
   * variables like ${player} and ${card}. These are the only values that can be
   * replaced since this is the only context known at execution time.
   */
  log?: string,
}

export interface PlaceMoonTile {
  space?: MoonSpaces;
}

export interface DrawCard {
  count: Countable,
  /** The number of cards to keep, should be between [1..count-1] */
  keep?: number,
  /** When true, player may keep the card if they choose to pay for it. (e.g. 3MC.) */
  pay?: boolean,

  /** Discard cards without this tag */
  tag?: Tag,
  /** Discard cards not of this type */
  type?: CardType,
  /** Discard cards without this type of resource. */
  resource?: CardResource,
}

export interface AddResource {
  count: Countable,
  type?: CardResource,
  tag?: Tag,
  /**
   * If true, then there must be a card that matches this requirement to take the action.
   *
   * While the game allows players to take an action that places a resource even though
   * there might not be a card to accept it, that can often make for players wasting
   * resources without realizing it. In other words, a true value is a break from the standard rules.
   */
  mustHaveCard?: boolean,

  /** When > 0, only cards with at least `min` resources count. */
  min?: number,

  /** When true, include self-replicating robots cards. */
  robotCards?: true,

  /** If true, if only one card matches, apply immediately without asking. */
  // WARNING: I don't think this is actually used.
  autoSelect?: boolean,
}

export interface DecreaseAnyProduction {
  count: number;
  type: Resource;
}

export interface TitledBehavior extends Behavior {
  title: string;
}

export interface OrBehavior {
  behaviors: Array<TitledBehavior>;
  autoSelect?: boolean;
}

================
File: behavior/BehaviorExecutor.ts
================
import {ICard} from '../cards/ICard';
import {CanAffordOptions, IPlayer} from '../IPlayer';
import {Behavior} from './Behavior';
import {TRSource} from '../../common/cards/TRSource';
import {ICounter} from './Counter';

export interface BehaviorExecutor {
  canExecute(behavior: Behavior, player: IPlayer, card: ICard, canAffordOptions?: CanAffordOptions): boolean;
  execute(behavior: Behavior, player: IPlayer, card: ICard): void;
  onDiscard(behavior: Behavior, player: IPlayer, _card: ICard): void;
  toTRSource(behavior: Behavior, ctx: ICounter): TRSource;
}

let _behaviorExecutor: BehaviorExecutor | undefined = undefined;

export function registerBehaviorExecutor(behaviorExecutor: BehaviorExecutor) {
  if (_behaviorExecutor !== undefined) {
    throw new Error('Cannot re-register the behavior executor.');
  }
  _behaviorExecutor = behaviorExecutor;
}

export function getBehaviorExecutor(): BehaviorExecutor {
  if (_behaviorExecutor === undefined) {
    throw new Error('no behavior executor registered.');
  }
  return _behaviorExecutor;
}

================
File: behavior/Countable.ts
================
import {Units} from '../../common/Units';
import {OneOrArray} from '../../common/utils/types';
import {Tag} from '../../common/cards/Tag';
import {NoAttributes} from './NoAttributes';

/**
 * Describes something that can be counted.
 */
export type _Countable = {
  start?: number;

  /**
   * Count the number of tags on the players' played cards.
   *
   * If `all` or `others` is set, then either all tags, or everyone else's tags, are counted.
   *
   * This is counting tags as if the player was taking an action (for example,
   * a player's wild tags count, events are ignored.)
   */
  tag?: OneOrArray<Tag>,
  cities?: {where?: 'onmars' | 'offmars' | 'everywhere'},
  greeneries?: NoAttributes,
  oceans?: NoAttributes,
  /** Count the number of resources on this card. */
  resourcesHere?: NoAttributes,
  /** Count the number of floaters on all cards. */
  floaters?: NoAttributes,
  colonies?: {
    colonies?: {},
  },
  moon?: {
    habitatRate?: NoAttributes,
    miningRate?: NoAttributes,
    logisticRate?: NoAttributes,
    habitat?: NoAttributes,
    mine?: NoAttributes,
    road?: NoAttributes,
  },
  underworld?: {
    corruption?: NoAttributes,
    excavationMarkers?: NoAttributes,
  },

  all?: boolean; // (Note for later: Tags and Cities have different defaults. THIS IS NOT GOOD, IS IT?)
  others?: true; // For tags this has a behavior.

  /**
   * Multiply the sum by this value.
   *
   * For example, `{cities: {}, each: 2}` would count all the cities on the board, and multiply that value by 2.
   */
  each?: number;

  /**
   * Divide the sum by this value. Round down.
   *
   * For example, `{tags: Tag.MOON, per: 3}` would count all moon tags, and then divide by 3.
   *
   * `each` is applied before `per`, so `{tags: Tag.MOON, each: 2, per: 3}` would provide 2/3 the value
   * of moon tags.
   */
  per?: number;
};

export type Countable = number | _Countable;

/**
 * A companion to Units with countable values.
 */
export type CountableUnits = {[k in keyof Units]: Countable}

================
File: behavior/Counter.ts
================
import {Units} from '../../common/Units';
import {TileType} from '../../common/TileType';
import {ICard} from '../cards/ICard';
import {IPlayer} from '../IPlayer';
import {Countable, CountableUnits} from './Countable';
import {hasIntersection} from '../../common/utils/utils';
import {MoonExpansion} from '../moon/MoonExpansion';
import {CardResource} from '../../common/CardResource';
import * as utils from '../../common/utils/utils'; // Since there's already a sum variable.

/**
 * Counts things in game state.
 */
export interface ICounter {
  count(countable: Countable, context?: 'default' | 'vps'): number;
  countUnits(countableUnits: Partial<CountableUnits>): Units;
}

/**
 * Counts things in game state.
 *
 * The constructor accepts the game state, which is essentially the player, and the card being played or acted upon.
 */
export class Counter {
  /**
   * True if the `this.card` is still in the player's hand.
   *
   * Many cards that counts tags have this "+1" that includes itself. That's because the
   * card isn't already in the playedCards pile. If it was, we wouldn't need this additional bit of
   * playedCard.
   *
   * The other part of why includeCard is interesting is sometimes this counting is related to a card
   * being replayed via Robotic Workforce. In that case, the card is already played.
   *
   * Counter is not meant to be kept between game states, so dispose of this after making calcuations.
   */
  private cardIsUnplayed: boolean;

  public constructor(private player: IPlayer, private card: ICard) {
    this.cardIsUnplayed = !player.cardIsInEffect(card.name);
  }

  public count(countable: Countable, context: 'default' | 'vps' = 'default'): number {
    if (typeof(countable) === 'number') {
      return countable;
    }

    let sum = countable.start ?? 0;

    const player = this.player;
    const card = this.card;
    const game = player.game;

    if (countable.cities !== undefined) {
      const p = (countable.all === false) ? player : undefined;
      switch (countable.cities.where) {
      case 'offmars':
        sum = game.board.getCitiesOffMars(p).length;
        break;
      case 'onmars':
        sum += game.board.getCitiesOnMars(p).length;
        break;
      case 'everywhere':
      default:
        sum += game.board.getCities(p).length;
      }
    }

    if (countable.oceans !== undefined) {
      sum += game.board.getOceanSpaces({upgradedOceans: true, wetlands: true}).length;
    }

    if (countable.floaters !== undefined) {
      sum += player.getResourceCount(CardResource.FLOATER);
    }

    if (countable.greeneries !== undefined) {
      const p = (countable.all === false) ? player : undefined;
      sum += game.board.getGreeneries(p).length;
    }
    if (countable.tag !== undefined) {
      const tag = countable.tag;

      if (Array.isArray(tag)) { // Multiple tags
        // These two error cases could be coded up, but they don't have a case just yet, and if they do come
        // up, better for the code to error than silently ignore it.
        if (this.cardIsUnplayed && hasIntersection(tag, card.tags)) {
          throw new Error(`Not supporting the case counting tags ${tag} when played card tags are ${card.tags}`);
        }
        if (countable.others === true) {
          throw new Error('Not counting others\' multiple Tags.');
        }

        sum += player.tags.multipleCount(tag);
      } else { // Single tag
        if (countable.others !== true) { // Just count player's own tags.
          sum += player.tags.count(tag, context === 'vps' ? 'raw' : context);

          if (this.cardIsUnplayed) { // And include the card itself if it isn't already on the tableau.
            sum += card.tags.filter((t) => t === tag).length;
          }
        }

        // When counting all the other players' tags, just count raw, so as to disregard their wild tags.
        if (countable.all === true || countable.others === true) {
          player.getOpponents()
            .forEach((p) => sum += p.tags.count(tag, 'raw'));
        }
      }
    }

    if (countable.resourcesHere !== undefined) {
      sum += card.resourceCount;
    }

    if (countable.colonies !== undefined) {
      player.game.colonies.forEach((colony) => {
        if (countable.all) {
          sum += colony.colonies.length;
        } else {
          sum += colony.colonies.filter((colony) => colony === player.id).length;
        }
      });
    }

    if (countable.moon !== undefined) {
      const moon = countable.moon;
      MoonExpansion.ifMoon(game, (moonData) => {
        if (moon.habitatRate) {
          sum += moonData.habitatRate;
        }
        if (moon.miningRate) {
          sum += moonData.miningRate;
        }
        if (moon.logisticRate) {
          sum += moonData.logisticRate;
        }
      });
      if (moon.habitat) {
        sum += MoonExpansion.spaces(game, TileType.MOON_HABITAT, {surfaceOnly: true}).length;
      }
      if (moon.mine) {
        sum += MoonExpansion.spaces(game, TileType.MOON_MINE, {surfaceOnly: true}).length;
      }
      if (moon.road) {
        sum += MoonExpansion.spaces(game, TileType.MOON_ROAD, {surfaceOnly: true}).length;
      }
    }

    if (countable.underworld !== undefined) {
      const underworld = countable.underworld;
      if (underworld.corruption !== undefined) {
        if (countable.all === true) {
          sum += utils.sum(game.getPlayers().map((p) => p.underworldData.corruption));
        } else {
          sum += player.underworldData.corruption;
        }
      }
      if (underworld.excavationMarkers !== undefined) {
        if (countable.all) {
          sum += player.game.board.spaces.filter((space) => space.excavator !== undefined).length;
        } else {
          sum += player.game.board.spaces.filter((space) => space.excavator === player).length;
        }
      }
    }

    if (countable.each !== undefined) {
      sum = sum * countable.each;
    }
    if (countable.per !== undefined) {
      sum = Math.floor(sum / countable.per);
    }
    return sum;
  }

  public countUnits(countableUnits: Partial<CountableUnits>): Units {
    const units: Units = {...Units.EMPTY};
    for (const key of Object.keys(units)) {
      const safeKey = key as keyof CountableUnits;
      const countable = countableUnits[safeKey] ?? 0;
      units[safeKey] = this.count(countable);
    }
    return units;
  }
}

================
File: behavior/Executor.ts
================
import {Units} from '../../common/Units';
import {ICard} from '../cards/ICard';
import {TRSource} from '../../common/cards/TRSource';
import {AddResourcesToCard} from '../deferredActions/AddResourcesToCard';
import {BuildColony} from '../deferredActions/BuildColony';
import {DecreaseAnyProduction} from '../deferredActions/DecreaseAnyProduction';
import {PlaceCityTile} from '../deferredActions/PlaceCityTile';
import {PlaceGreeneryTile} from '../deferredActions/PlaceGreeneryTile';
import {PlaceOceanTile} from '../deferredActions/PlaceOceanTile';
import {RemoveAnyPlants} from '../deferredActions/RemoveAnyPlants';
import {MoonExpansion} from '../moon/MoonExpansion';
import {PlaceMoonHabitatTile} from '../moon/PlaceMoonHabitatTile';
import {PlaceMoonMineTile} from '../moon/PlaceMoonMineTile';
import {PlaceMoonRoadTile} from '../moon/PlaceMoonRoadTile';
import {PlaceSpecialMoonTile} from '../moon/PlaceSpecialMoonTile';
import {CanAffordOptions, IPlayer} from '../IPlayer';
import {Behavior} from './Behavior';
import {Counter, ICounter} from './Counter';
import {Turmoil} from '../turmoil/Turmoil';
import {SendDelegateToArea} from '../deferredActions/SendDelegateToArea';
import {BehaviorExecutor} from './BehaviorExecutor';
import {PlaceTile} from '../deferredActions/PlaceTile';
import {Resource} from '../../common/Resource';
import {SelectPaymentDeferred} from '../deferredActions/SelectPaymentDeferred';
import {OrOptions} from '../inputs/OrOptions';
import {SelectOption} from '../inputs/SelectOption';
import {Payment} from '../../common/inputs/Payment';
import {SelectResources} from '../inputs/SelectResources';
import {TITLES} from '../inputs/titles';
import {message} from '../logs/MessageBuilder';
import {IdentifySpacesDeferred} from '../underworld/IdentifySpacesDeferred';
import {ExcavateSpacesDeferred} from '../underworld/ExcavateSpacesDeferred';
import {UnderworldExpansion} from '../underworld/UnderworldExpansion';
import {SelectResource} from '../inputs/SelectResource';
import {RemoveResourcesFromCard} from '../deferredActions/RemoveResourcesFromCard';
import {isIProjectCard} from '../cards/IProjectCard';
import {MAXIMUM_HABITAT_RATE, MAXIMUM_LOGISTICS_RATE, MAXIMUM_MINING_RATE, MAX_OCEAN_TILES, MAX_OXYGEN_LEVEL, MAX_TEMPERATURE, MAX_VENUS_SCALE} from '../../common/constants';
import {CardName} from '../../common/cards/CardName';
import {asArray} from '../../common/utils/utils';

export class Executor implements BehaviorExecutor {
  public canExecute(behavior: Behavior, player: IPlayer, card: ICard, canAffordOptions?: CanAffordOptions) {
    const ctx = new Counter(player, card);
    const asTrSource = this.toTRSource(behavior, ctx);
    const game = player.game;

    if (behavior.production && !player.production.canAdjust(ctx.countUnits(behavior.production))) {
      return false;
    }

    if (behavior.or) {
      if (!behavior.or.behaviors.some((behavior) => this.canExecute(behavior, player, card, canAffordOptions))) {
        return false;
      }
    }

    if (behavior.global !== undefined) {
      const g = behavior.global;
      if (g.temperature !== undefined && game.getTemperature() >= MAX_TEMPERATURE) {
        card.warnings.add('maxtemp');
      }
      if (g.oxygen !== undefined && game.getOxygenLevel() >= MAX_OXYGEN_LEVEL) {
        card.warnings.add('maxoxygen');
      }
      if (g.venus !== undefined && game.getVenusScaleLevel() >= MAX_VENUS_SCALE) {
        card.warnings.add('maxvenus');
      }
    }

    if (behavior.ocean !== undefined && game.board.getOceanSpaces().length >= MAX_OCEAN_TILES) {
      card.warnings.add('maxoceans');
    }

    if (behavior.stock !== undefined) {
      const stock = behavior.stock;
      // Only supporting positive values for now.
      // (Also supporting Countable because it's a pain.)
      if (Units.keys.some((key) => {
        const v = stock[key];
        return (typeof v === 'number') ? v < 0 : false;
      })) {
        throw new Error('Not supporting negative units for now: ' + card.name);
      }

      // if (!player.hasUnits(behavior.stock)) {
      //   return false;
      // }
    }

    // TODO(kberg): Spend is not combined with PredictedCost.
    if (behavior.spend !== undefined) {
      const spend = behavior.spend;
      if (spend.megacredits && !player.canAfford(spend.megacredits)) {
        return false;
      }
      if (spend.steel && player.steel < spend.steel) {
        return false;
      }
      if (spend.titanium && player.titanium < spend.titanium) {
        return false;
      }
      if (spend.plants && player.plants < spend.plants) {
        return false;
      }
      if (spend.energy && player.energy < spend.energy) {
        return false;
      }
      if (spend.heat) {
        if (player.availableHeat() < spend.heat) {
          return false;
        }
        if (!player.canAfford({
          cost: 0,
          reserveUnits: Units.of({heat: spend.heat}),
          tr: asTrSource,
        })) {
          return false;
        }
      }
      if (spend.resourcesHere && card.resourceCount < spend.resourcesHere) {
        return false;
      }
      if (spend.resourceFromAnyCard && player.getCardsWithResources(spend.resourceFromAnyCard.type).length === 0) {
        return false;
      }
      if (spend.corruption && player.underworldData.corruption < spend.corruption) {
        return false;
      }
    }

    if (behavior.decreaseAnyProduction !== undefined) {
      if (!game.isSoloMode()) {
        const dap = behavior.decreaseAnyProduction;
        const targets = game.getPlayers().filter((p) => p.canHaveProductionReduced(dap.type, dap.count, player));

        if (targets.length === 0) {
          return false;
        }
        if (targets.length === 1 && targets[0] === player) {
          card.warnings.add('decreaseOwnProduction');
        }
      }
    }

    if (behavior.colonies?.buildColony !== undefined) {
      if (player.colonies.getPlayableColonies(behavior.colonies.buildColony.allowDuplicates).length === 0) {
        return false;
      }
    }

    if (behavior.city !== undefined) {
      if (behavior.city.space === undefined) {
        if (game.board.getAvailableSpacesForType(player, behavior.city.on ?? 'city', canAffordOptions).length === 0) {
          return false;
        }
      } else {
        // Special case for Star Vegas. The space may already be occupied.
        if (game.board.getSpaceOrThrow(behavior.city.space).tile !== undefined) {
          return false;
        }
      }
    }

    if (behavior.greenery !== undefined) {
      if (game.board.getAvailableSpacesForType(player, behavior.greenery.on ?? 'greenery', canAffordOptions).length === 0) {
        return false;
      }
    }

    if (behavior.tile !== undefined) {
      if (game.board.getAvailableSpacesForType(player, behavior.tile.on, canAffordOptions).length === 0) {
        return false;
      }
    }

    if (behavior.addResourcesToAnyCard !== undefined) {
      const arctac = behavior.addResourcesToAnyCard;
      if (!Array.isArray(arctac) && arctac.mustHaveCard === true) {
        const action = new AddResourcesToCard(player, arctac.type, {
          count: ctx.count(arctac.count),
          restrictedTag: arctac.tag,
          min: arctac.min,
          robotCards: arctac.robotCards !== undefined,
        });
        const cards = action.getCards();
        if (cards.length === 0) {
          return false;
        }
        // Not playable if the behavior is based on spending a resource
        // from itself to add to itself, like Applied Science.
        if (cards.length === 1 && (behavior.spend?.resourcesHere ?? 0 > 0)) {
          // TODO(kberg): also check wither arctac.min + spend is enough.
          // but that's just to make this future-proof.
          if (cards[0]?.name === card.name) {
            return false;
          }
        }
      }
    }

    // if (behavior.removeResourcesFromAnyCard !== undefined) {
    //   const rrfac = behavior.removeResourcesFromAnyCard;
    //   if (rrfac.tag !== undefined || rrfac.count !== 1) {
    //     throw new Error('Tag and sophisticated counts are not yet implemented.');
    //   }
    //   if (player.getCardsWithResources(behavior.removeResourcesFromAnyCard.type).length === 0) {
    //     return false;
    //   }
    // }

    if (behavior.turmoil) {
      if (behavior.turmoil.sendDelegates) {
        if (Turmoil.getTurmoil(game).getAvailableDelegateCount(player) < behavior.turmoil.sendDelegates.count) {
          return false;
        }
      }
    }

    if (behavior.moon !== undefined) {
      const moon = behavior.moon;
      const moonData = MoonExpansion.moonData(game);
      if (moon.habitatTile !== undefined && moon.habitatTile.space === undefined) {
        if (moonData.moon.getAvailableSpacesOnLand(player).length === 0) {
          return false;
        }
      }
      if (moon.mineTile !== undefined && moon.mineTile.space === undefined) {
        if (moonData.moon.getAvailableSpacesForMine(player).length === 0) {
          return false;
        }
      }
      if (moon.roadTile !== undefined && moon.roadTile.space === undefined) {
        if (moonData.moon.getAvailableSpacesOnLand(player).length === 0) {
          return false;
        }
      }
      if ((moon.habitatRate ?? 0) >= MAXIMUM_HABITAT_RATE) {
        card.warnings.add('maxHabitatRate');
      }
      if ((moon.miningRate ?? 0) >= MAXIMUM_MINING_RATE) {
        card.warnings.add('maxMiningRate');
      }
      if ((moon.logisticsRate ?? 0) >= MAXIMUM_LOGISTICS_RATE) {
        card.warnings.add('maxLogisticsRate');
      }
    }

    if (behavior.underworld !== undefined) {
      const underworld = behavior.underworld;
      if (underworld.identify !== undefined) {
        if (card.name === CardName.NEUTRINOGRAPH || player.cardIsInEffect(CardName.NEUTRINOGRAPH)) {
          // Special case for Neutrinograph. Excavatable spaces are ones that are unidentified or reidentifiable.
          if (UnderworldExpansion.excavatableSpaces(player).length === 0) {
            return false;
          }
        } else {
          if (UnderworldExpansion.identifiableSpaces(player).length === 0) {
            return false;
          }
        }
      }
    }
    return true;
  }

  public execute(behavior: Behavior, player: IPlayer, card: ICard) {
    const ctx = new Counter(player, card);

    if (behavior.or !== undefined) {
      const options = behavior.or.behaviors
        .filter((behavior) => this.canExecute(behavior, player, card))
        .map((behavior) => {
          return new SelectOption(behavior.title)
            .andThen(() => {
              this.execute(behavior, player, card);
              return undefined;
            });
        });

      // TODO(kberg): move this behavior to OrOptions?
      if (options.length === 1 && behavior.or.autoSelect === true) {
        options[0].cb(undefined);
      } else {
        player.defer(new OrOptions(...options));
      }
    }

    if (behavior.spend !== undefined) {
      const spend = behavior.spend;
      const remainder = {...behavior};
      delete remainder['spend'];

      if (spend.megacredits) {
        player.game.defer(new SelectPaymentDeferred(player, spend.megacredits, {
          title: TITLES.payForCardAction(card.name),
        })).andThen(() => this.execute(remainder, player, card));
        // Exit early as the rest of handled by the deferred action.
        return;
      }
      // player.pay triggers Sol Bank.
      player.pay(Payment.of({
        steel: spend.steel ?? 0,
        titanium: spend.titanium ?? 0,
      }));
      if (spend.plants) {
        player.stock.deduct(Resource.PLANTS, spend.plants);
      }
      if (spend.energy) {
        player.stock.deduct(Resource.ENERGY, spend.energy);
      }
      if (spend.heat) {
        player.defer(player.spendHeat(spend.heat, () => {
          this.execute(remainder, player, card);
          return undefined;
        }));
        // Exit early as the rest of handled by the deferred action.
        return;
      }
      if (spend.resourcesHere) {
        player.removeResourceFrom(card, spend.resourcesHere);
      }
      if (spend.resourceFromAnyCard) {
        player.game.defer(new RemoveResourcesFromCard(player, spend.resourceFromAnyCard.type, 1, {source: 'self', blockable: false}))
          .andThen(() => this.execute(remainder, player, card));
        // Exit early as the rest of handled by the deferred action.
        return;
      }
      if (spend.corruption) {
        UnderworldExpansion.loseCorruption(player, spend.corruption);
      }
    }

    if (behavior.production !== undefined) {
      const units = ctx.countUnits(behavior.production);
      player.production.adjust(units, {log: true});
    }
    if (behavior.stock) {
      const units = ctx.countUnits(behavior.stock);
      player.stock.addUnits(units, {log: true});
    }
    if (behavior.standardResource) {
      const entry = behavior.standardResource;
      const count = typeof(entry) === 'number' ? entry : entry.count;
      const same = typeof(entry) === 'number' ? true : entry.same ?? true;
      if (same === false) {
        player.defer(
          new SelectResources(message('Gain ${0} standard resources', (b) => b.number(count)), count)
            .andThen((units) => {
              player.stock.addUnits(units, {log: true});
              return undefined;
            }));
      } else {
        player.defer(
          new SelectResource(message('Gain ${0} units of a standard resource', (b) => b.number(count)))
            .andThen((unit) => {
              player.stock.add(Units.ResourceMap[unit], count, {log: true});
              return undefined;
            }));
      }
    }
    if (behavior.steelValue === 1) {
      player.increaseSteelValue();
    }
    if (behavior.titanumValue === 1) {
      player.increaseTitaniumValue();
    }

    if (behavior?.greeneryDiscount) {
      player.plantsNeededForGreenery -= behavior.greeneryDiscount;
    }
    //andy test
    if (behavior?.heatDiscount) {
      player.heatNeededForTemperature -= behavior.heatDiscount;
    }
  
    if (behavior.drawCard !== undefined) {
      const drawCard = behavior.drawCard;
      if (typeof(drawCard) === 'number') {
        player.drawCard(drawCard);
      } else {
        // This conditional could probably be removed, using the else clause for both.
        if (drawCard.keep === undefined && drawCard.pay === undefined) {
          player.drawCard(ctx.count(drawCard.count), {tag: drawCard.tag, resource: drawCard.resource, cardType: drawCard.type});
        } else {
          player.drawCardKeepSome(ctx.count(drawCard.count), {
            tag: drawCard.tag,
            resource: drawCard.resource,
            cardType: drawCard.type,
            keepMax: drawCard.keep,
            paying: drawCard.pay,
          });
        }
      }
    }

    if (behavior.global !== undefined) {
      const g = behavior.global;
      if (g.temperature !== undefined) player.game.increaseTemperature(player, g.temperature);
      if (g.oxygen !== undefined) player.game.increaseOxygenLevel(player, g.oxygen);
      if (g.venus !== undefined) player.game.increaseVenusScaleLevel(player, g.venus);
    }

    if (behavior.tr !== undefined) {
      player.increaseTerraformRating(ctx.count(behavior.tr));
    }
    const addResources = behavior.addResources;
    if (addResources !== undefined) {
      const count = ctx.count(addResources);
      player.defer(() => {
        player.addResourceTo(card, {qty: count, log: true});
        return undefined;
      });
    }

    if (behavior.addResourcesToAnyCard) {
      const array = asArray(behavior.addResourcesToAnyCard);
      for (const arctac of array) {
        const count = ctx.count(arctac.count);
        if (count > 0) {
          player.game.defer(
            new AddResourcesToCard(
              player,
              arctac.type,
              {
                count,
                restrictedTag: arctac.tag,
                min: arctac.min,
                robotCards: arctac.robotCards !== undefined,
              }));
        }
      }
    }

    // if (behavior.removeResourcesFromAnyCard !== undefined) {
    //   throw new Error('not yet');
    // }

    if (behavior.decreaseAnyProduction !== undefined) {
      player.game.defer(new DecreaseAnyProduction(player, behavior.decreaseAnyProduction.type, {count: behavior.decreaseAnyProduction.count}));
    }
    if (behavior.removeAnyPlants !== undefined) {
      player.game.defer(new RemoveAnyPlants(player, behavior.removeAnyPlants));
    }
    if (behavior.colonies !== undefined) {
      const colonies = behavior.colonies;
      if (colonies.buildColony !== undefined) {
        player.game.defer(new BuildColony(player, {allowDuplicate: colonies.buildColony.allowDuplicates}));
      }
      if (colonies.addTradeFleet !== undefined) {
        for (let idx = 0; idx < colonies.addTradeFleet; idx++) {
          player.colonies.increaseFleetSize();
        }
      }
      if (colonies.tradeDiscount !== undefined) {
        player.colonies.tradeDiscount += colonies.tradeDiscount;
      }
      if (colonies.tradeOffset !== undefined) {
        player.colonies.tradeOffset += colonies.tradeOffset;
      }
    }

    if (behavior.ocean !== undefined) {
      if (behavior.ocean.count === 2) {
        player.game.defer(new PlaceOceanTile(player, {title: 'Select space for first ocean'}));
        player.game.defer(new PlaceOceanTile(player, {title: 'Select space for second ocean'}));
      } else {
        player.game.defer(new PlaceOceanTile(player, {on: behavior.ocean.on}));
      }
    }
    if (behavior.city !== undefined) {
      if (behavior.city.space !== undefined) {
        const space = player.game.board.getSpaceOrThrow(behavior.city.space);
        player.game.addCity(player, space);
        if (space.tile !== undefined) { // Should never be undefined
          space.tile.card = card.name;
        }
      } else {
        player.game.defer(new PlaceCityTile(player, {on: behavior.city.on}));
      }
    }
    if (behavior.greenery !== undefined) {
      player.game.defer(new PlaceGreeneryTile(player, behavior.greenery.on));
    }
    if (behavior.tile !== undefined) {
      const tile = behavior.tile;
      player.game.defer(new PlaceTile(player, {
        tile: {
          tileType: tile.type,
          card: card.name,
        },
        on: tile.on,
        title: tile.title ?? message('Select space for ${0} tile', (b) => b.cardName(card.name)),
        adjacencyBonus: tile.adjacencyBonus,
      }));
    }

    if (behavior.turmoil) {
      const turmoil = Turmoil.getTurmoil(player.game);
      if (behavior.turmoil.influenceBonus === 1) {
        turmoil.addInfluenceBonus(player);
      }

      if (behavior.turmoil.sendDelegates) {
        const sendDelegates = behavior.turmoil.sendDelegates;
        if (sendDelegates.party !== undefined) {
          for (let i = 0; i < sendDelegates.count; i++) {
            turmoil.sendDelegateToParty(player, sendDelegates.party, player.game);
          }
        } else if (sendDelegates.manyParties) {
          for (let i = 0; i < sendDelegates.count; i++) {
            player.game.defer(new SendDelegateToArea(player, 'Select where to send delegate'));
          }
        } else {
          player.game.defer(new SendDelegateToArea(player, `Select where to send ${sendDelegates.count} delegates`, {count: sendDelegates.count}));
        }
      }
    }

    if (behavior.optionalEnergyConversion) {
      player.optionalEnergyConversion = true;
    }

    if (behavior.moon !== undefined) {
      const moon = behavior.moon;
      if (moon.habitatTile !== undefined) {
        if (moon.habitatTile.space === undefined) {
          player.game.defer(new PlaceMoonHabitatTile(player));
        } else {
          MoonExpansion.addHabitatTile(player, moon.habitatTile.space, card?.name);
          MoonExpansion.raiseHabitatRate(player);
        }
      }
      if (moon.mineTile !== undefined) {
        if (moon.mineTile.space === undefined) {
          player.game.defer(new PlaceMoonMineTile(player));
        } else {
          MoonExpansion.addMineTile(player, moon.mineTile.space, card?.name);
          MoonExpansion.raiseMiningRate(player);
        }
      }
      if (moon.roadTile !== undefined) {
        if (moon.roadTile.space === undefined) {
          player.game.defer(new PlaceMoonRoadTile(player));
        } else {
          MoonExpansion.addRoadTile(player, moon.roadTile.space, card?.name);
          MoonExpansion.raiseLogisticRate(player);
        }
      }
      if (moon.tile !== undefined) {
        if (moon.tile.space !== undefined) {
          MoonExpansion.addTile(player, moon.tile.space, {tileType: moon.tile.type, card: card?.name});
        } else {
          player.game.defer(new PlaceSpecialMoonTile(player, {tileType: moon.tile.type, card: card?.name}));
        }
      }
      if (moon.habitatRate !== undefined) MoonExpansion.raiseHabitatRate(player, moon.habitatRate);
      if (moon.miningRate !== undefined) MoonExpansion.raiseMiningRate(player, moon.miningRate);
      if (moon.logisticsRate !== undefined) MoonExpansion.raiseLogisticRate(player, moon.logisticsRate);
    }

    if (behavior.underworld !== undefined) {
      const underworld = behavior.underworld;
      if (underworld.identify !== undefined) {
        player.game.defer(new IdentifySpacesDeferred(player, ctx.count(underworld.identify)));
      }
      if (underworld.excavate !== undefined) {
        const excavate = underworld.excavate;
        if (typeof(excavate) === 'number') {
          player.game.defer(new ExcavateSpacesDeferred(player, excavate));
        } else {
          player.game.defer(new ExcavateSpacesDeferred(player, ctx.count(excavate.count), excavate.ignorePlacementRestrictions));
        }
      }
      if (underworld.corruption !== undefined) {
        UnderworldExpansion.gainCorruption(player, ctx.count(underworld.corruption), {log: true});
      }
      if (underworld.markThisGeneration !== undefined) {
        if (isIProjectCard(card)) {
          card.generationUsed = player.game.generation;
        }
      }
    }

    if (behavior.log !== undefined) {
      this.log(behavior.log, player, card);
    }
  }

  private log(message: string, player: IPlayer, card: ICard) {
    const replaced = message
      .replaceAll('${player}', '${0}')
      .replaceAll('${card}', '${1}');
    player.game.log(replaced, (b) => b.player(player).card(card));
  }

  public onDiscard(behavior: Behavior, player: IPlayer, _card: ICard) {
    if (behavior.steelValue === 1) {
      player.decreaseSteelValue();
    }
    if (behavior.titanumValue === 1) {
      player.decreaseTitaniumValue();
    }

    if (behavior?.greeneryDiscount) {
      player.plantsNeededForGreenery += behavior.greeneryDiscount;
    }

    if (behavior.colonies !== undefined) {
      const colonies = behavior.colonies;
      if (colonies.addTradeFleet !== undefined) {
        for (let idx = 0; idx < colonies.addTradeFleet; idx++) {
          player.colonies.decreaseFleetSize();
        }
      }
      if (colonies.tradeDiscount !== undefined) {
        player.colonies.tradeDiscount -= colonies.tradeDiscount;
      }
      if (colonies.tradeOffset !== undefined) {
        player.colonies.tradeOffset -= colonies.tradeOffset;
      }
    }
    if (!player.tableau.some((card) => card.behavior?.optionalEnergyConversion === true)) {
      player.optionalEnergyConversion = false;
    }
  }

  public toTRSource(behavior: Behavior, ctx: ICounter): TRSource {
    let tr: number | undefined = undefined;
    if (behavior.tr !== undefined) {
      if (typeof(behavior.tr) === 'number') {
        tr = behavior.tr;
      } else {
        tr = ctx.count(behavior.tr);
      }
    }
    const trSource: TRSource = {
      tr: tr,
      temperature: behavior.global?.temperature,
      oxygen: (behavior.global?.oxygen ?? 0) + (behavior.greenery !== undefined ? 1 : 0),
      venus: behavior.global?.venus,
      oceans: behavior.ocean !== undefined ? (behavior.ocean.count ?? 1) : undefined,

      moonHabitat: (behavior.moon?.habitatRate ?? 0) + (behavior.moon?.habitatTile !== undefined ? 1 : 0),
      moonMining: (behavior.moon?.miningRate ?? 0) + (behavior.moon?.mineTile !== undefined ? 1 : 0),
      moonLogistics: (behavior.moon?.logisticsRate ?? 0) + (behavior.moon?.roadTile !== undefined ? 1 : 0),
    };
    return trSource;
  }
}

================
File: behavior/NoAttributes.ts
================
export interface NoAttributes {
  _unused?: never,
}

================
File: boards/AmazonisBoard.ts
================
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {BoardBuilder} from './BoardBuilder';
import {SpaceName} from '../SpaceName';
import {Random} from '../../common/utils/Random';
import {GameOptions} from '../game/GameOptions';
import {MarsBoard} from './MarsBoard';
import {Space} from './Space';

export class AmazonisBoard extends MarsBoard {
  public static newInstance(gameOptions: GameOptions, rng: Random): AmazonisBoard {
    const builder = new BoardBuilder(gameOptions.venusNextExtension, gameOptions.pathfindersExpansion, gameOptions.chemicalExpansion);

    const PLANT = SpaceBonus.PLANT;
    const STEEL = SpaceBonus.STEEL;
    const DRAW_CARD = SpaceBonus.DRAW_CARD;
    const TITANIUM = SpaceBonus.TITANIUM;
    const MICROBE = SpaceBonus.MICROBE;
    const ANIMAL = SpaceBonus.ANIMAL;
    const HEAT = SpaceBonus.HEAT;

    // y=0
    builder.land().ocean(PLANT).land(PLANT, PLANT, PLANT).land(MICROBE).land(ANIMAL);
    // y=1
    builder.ocean(TITANIUM).land(MICROBE, MICROBE).land().land().ocean(DRAW_CARD, DRAW_CARD).ocean();
    // y=2
    builder.land(PLANT, PLANT).land(STEEL, PLANT).land(STEEL, HEAT).land(HEAT, PLANT).land(ANIMAL).land().land(MICROBE);
    // y=3
    builder.land().ocean(PLANT).land().land(PLANT).land(HEAT, PLANT).land(STEEL).land(PLANT).ocean(STEEL, PLANT);
    // y=4
    builder.land(PLANT).land(PLANT).land().land(HEAT, HEAT).restricted().doNotShuffleLastSpace()
      .land(HEAT, HEAT).land(PLANT, PLANT).land().land(TITANIUM, TITANIUM);
    // y=5
    builder.ocean(PLANT, PLANT).land(PLANT).land(STEEL).land(HEAT, PLANT).land(PLANT).land(DRAW_CARD).land().ocean(PLANT);
    // y=6
    builder.ocean(PLANT).land().land(MICROBE).land(HEAT, PLANT).land().land(PLANT, PLANT).ocean(PLANT, PLANT);
    // y=7
    builder.land(TITANIUM).ocean(PLANT).land(STEEL).land().land(ANIMAL).land(PLANT);
    // y=8
    builder.land().land(DRAW_CARD).land(STEEL).ocean(PLANT).land(STEEL, STEEL);

    if (gameOptions.shuffleMapOption) {
      builder.shuffle(rng, SpaceName.MEDUSAE_FOSSAE, SpaceName.ALBOR_THOLUS, SpaceName.ANSERIS_MONS, SpaceName.PINDUS_MONS, SpaceName.ULYSSES_THOLUS);
    }

    const spaces = builder.build();
    return new AmazonisBoard(spaces);
  }

  public constructor(spaces: ReadonlyArray<Space>) {
    super(spaces, undefined, [
      SpaceName.ALBOR_THOLUS,
      SpaceName.ANSERIS_MONS,
      SpaceName.PINDUS_MONS,
      SpaceName.ULYSSES_THOLUS,
    ]);
  }
}

================
File: boards/ArabiaTerraBoard.ts
================
import {GameOptions} from '../game/GameOptions';
import {IPlayer} from '../IPlayer';
import {Random} from '../../common/utils/Random';
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {SpaceName} from '../SpaceName';
import {SpaceType} from '../../common/boards/SpaceType';
import {BoardBuilder} from './BoardBuilder';
import {Space} from './Space';
import {MarsBoard} from './MarsBoard';

export class ArabiaTerraBoard extends MarsBoard {
  public static newInstance(gameOptions: GameOptions, rng: Random): ArabiaTerraBoard {
    const builder = new BoardBuilder(gameOptions.venusNextExtension, gameOptions.pathfindersExpansion, gameOptions.chemicalExpansion);

    const PLANT = SpaceBonus.PLANT;
    const STEEL = SpaceBonus.STEEL;
    const DRAW_CARD = SpaceBonus.DRAW_CARD;
    const TITANIUM = SpaceBonus.TITANIUM;
    const MICROBE = SpaceBonus.MICROBE;
    const DATA = SpaceBonus.DATA;
    const ENERGY_PRODUCTION = SpaceBonus.ENERGY_PRODUCTION;
    const SCIENCE = SpaceBonus.SCIENCE;

    // y=0
    builder.ocean().ocean(PLANT).land().land().ocean(DRAW_CARD, DRAW_CARD);
    // y=1
    builder.ocean(MICROBE, MICROBE, DRAW_CARD).ocean(PLANT).land(PLANT, PLANT).land().land(PLANT).land(PLANT);
    // y=2
    builder.land(PLANT, STEEL).ocean(PLANT).land(DATA, DATA, DRAW_CARD).land(STEEL).land(STEEL).land(STEEL, PLANT).cove(STEEL, TITANIUM);
    // y=3
    builder.land(PLANT, PLANT).land(PLANT).ocean(PLANT, PLANT).land().land().land().land(STEEL, STEEL).land();
    // y=4
    builder.land().land().ocean(STEEL).cove(ENERGY_PRODUCTION).ocean(PLANT, PLANT).land(SCIENCE, DRAW_CARD, STEEL).land().land().land();
    // y=5
    builder.land(PLANT).land(PLANT).ocean(STEEL, STEEL).land(PLANT).land(STEEL).land().cove(PLANT, TITANIUM).land(PLANT);
    // y=6
    builder.cove(PLANT, TITANIUM).ocean(PLANT, PLANT).cove(PLANT, PLANT).land(PLANT).land(STEEL).land(PLANT, TITANIUM).land(TITANIUM, TITANIUM);
    // y=7
    builder.ocean(PLANT, PLANT).land(PLANT).land(STEEL, DRAW_CARD).land(STEEL, STEEL).land(STEEL).land(DRAW_CARD);
    // y=8
    builder.land().land().land().land().land(STEEL);

    if (gameOptions.shuffleMapOption) {
      builder.shuffle(rng, SpaceName.TIKHONAROV, SpaceName.LADON, SpaceName.FLAUGERGUES, SpaceName.CHARYBDIS);
    }

    const spaces = builder.build();
    return new ArabiaTerraBoard(spaces);
  }

  public constructor(spaces: ReadonlyArray<Space>) {
    super(spaces, undefined, [
      SpaceName.TIKHONAROV,
      SpaceName.LADON,
      SpaceName.FLAUGERGUES,
      SpaceName.CHARYBDIS,
    ]);
  }

  public override getSpaces(spaceType: SpaceType): Array<Space> {
    switch (spaceType) {
    case SpaceType.LAND:
    case SpaceType.OCEAN:
      return this.spaces.filter((space) => space.spaceType === spaceType || space.spaceType === SpaceType.COVE);
    default:
      return this.spaces.filter((space) => space.spaceType === spaceType);
    }
  }

  public override getAvailableSpacesForOcean(player: IPlayer): readonly Space[] {
    // Nomads can be found on cove spaces
    return super.getAvailableSpacesForOcean(player)
      .filter((space) => space.id !== player.game.nomadSpace);
  }
}

================
File: boards/Board.ts
================
import {Space} from './Space';
import {CanAffordOptions, IPlayer} from '../IPlayer';
import {PlayerId, SpaceId} from '../../common/Types';
import {SpaceType} from '../../common/boards/SpaceType';
import {BASE_OCEAN_TILES, CITY_TILES, GREENERY_TILES, OCEAN_TILES, TileType} from '../../common/TileType';
import {SerializedBoard, SerializedSpace} from './SerializedBoard';
import {CardName} from '../../common/cards/CardName';
import {AresHandler} from '../ares/AresHandler';
import {Units} from '../../common/Units';
import {HazardSeverity, hazardSeverity, isHazardTileType} from '../../common/AresTileType';
import {TRSource} from '../../common/cards/TRSource';
import {sum} from '../../common/utils/utils';

export type SpaceCosts = {
  stock: Units,
  production: number,
  tr: TRSource,
};

/**
 * A representation of any hex board. This is normally Mars (Tharsis, Hellas, Elysium) but can also be The Moon.
 *
 * It also includes additional spaces, known as Colonies, that are not adjacent to other spaces.
 */
export abstract class Board {
  private maxX: number = 0;
  private maxY: number = 0;
  private map: Map<SpaceId, Space> = new Map();

  // stores adjacent spaces in clockwise order starting from the top left
  private readonly adjacentSpaces = new Map<SpaceId, ReadonlyArray<Space>>();

  protected constructor(
    public readonly spaces: ReadonlyArray<Space>,
    public readonly noctisCitySpaceId: SpaceId | undefined,
    public readonly volcanicSpaceIds: ReadonlyArray<SpaceId>) {
    this.maxX = Math.max(...spaces.map((s) => s.x));
    this.maxY = Math.max(...spaces.map((s) => s.y));
    spaces.forEach((space) => {
      const adjacentSpaces = this.computeAdjacentSpaces(space);
      const filtered = adjacentSpaces.filter((space) => space !== undefined);
      // "as ReadonlyArray<Space> is OK because the line above filters out the undefined values."
      this.adjacentSpaces.set(space.id, filtered as ReadonlyArray<Space>);
      this.map.set(space.id, space);
    });
  }

  /* Returns the space given a Space ID. */
  public getSpaceOrThrow(id: SpaceId): Space {
    const space = this.map.get(id);
    if (space === undefined) {
      throw new Error(`Can't find space with id ${id}`);
    }
    return space;
  }

  protected computeAdjacentSpaces(space: Space): ReadonlyArray<Space | undefined> {
    // Expects an odd number of rows. If a funny shape appears, it can be addressed.
    const middleRow = this.maxY / 2;
    if (space.spaceType !== SpaceType.COLONY) {
      if (space.y < 0 || space.y > this.maxY) {
        throw new Error('Unexpected space y value: ' + space.y);
      }
      if (space.x < 0 || space.x > this.maxX) {
        throw new Error('Unexpected space x value: ' + space.x);
      }
      const leftSpace: Array<number> = [space.x - 1, space.y];
      const rightSpace: Array<number> = [space.x + 1, space.y];
      const topLeftSpace: Array<number> = [space.x, space.y - 1];
      const topRightSpace: Array<number> = [space.x, space.y - 1];
      const bottomLeftSpace: Array<number> = [space.x, space.y + 1];
      const bottomRightSpace: Array<number> = [space.x, space.y + 1];
      if (space.y < middleRow) {
        bottomLeftSpace[0]--;
        topRightSpace[0]++;
      } else if (space.y === middleRow) {
        bottomRightSpace[0]++;
        topRightSpace[0]++;
      } else {
        bottomRightSpace[0]++;
        topLeftSpace[0]--;
      }
      // Coordinates are in clockwise order. Order only ever matters during solo game set-up when
      // placing starting forests. Since that is the only case where ordering matters, it is
      // adopted here.
      const coords = [
        topLeftSpace,
        topRightSpace,
        rightSpace,
        bottomRightSpace,
        bottomLeftSpace,
        leftSpace,
      ];
      const spaces = coords.map(([x, y]) =>
        this.spaces.find((adj) =>
          adj.x === x && adj.y === y &&
          space !== adj && adj.spaceType !== SpaceType.COLONY,
        ));
      return spaces;
    }
    return [];
  }

  // Returns adjacent spaces in clockwise order starting from the top left.
  public getAdjacentSpaces(space: Space): ReadonlyArray<Space> {
    const spaces = this.adjacentSpaces.get(space.id);
    if (spaces === undefined) {
      throw new Error(`Unexpected space ID ${space.id}`);
    }
    return spaces;
  }

  //  Returns spaces in order from the top left.
  //
  //   0 1
  //  5 x 2
  //   4 3
  //
  // If there is no space in that spot, the index is undefined.
  // If the space is invalid or is a colony, this returns an unreliable value.
  public getAdjacentSpacesClockwise(space: Space): ReadonlyArray<Space | undefined> {
    return this.computeAdjacentSpaces(space);
  }

  public getSpaceByTileCard(cardName: CardName): Space | undefined {
    return this.spaces.find((space) => space.tile?.card === cardName);
  }

  public getSpaces(spaceType: SpaceType, _player: IPlayer): ReadonlyArray<Space> {
    return this.spaces.filter((space) => space.spaceType === spaceType);
  }

  /**
   * Update `costs` with any costs for this `space`.
   *
   * @returns `true` when costs has changed, `false` when it has not.
   */
  protected spaceCosts(_space: Space): SpaceCosts {
    return {stock: {...Units.EMPTY}, production: 0, tr: {}};
  }

  private computeAdditionalCosts(space: Space, aresExtension: boolean): SpaceCosts {
    const costs: SpaceCosts = this.spaceCosts(space);

    if (aresExtension === false) {
      return costs;
    }

    switch (hazardSeverity(space.tile?.tileType)) {
    case HazardSeverity.MILD:
      costs.stock.megacredits += 8;
      break;
    case HazardSeverity.SEVERE:
      costs.stock.megacredits += 16;
      break;
    }

    for (const adjacentSpace of this.getAdjacentSpaces(space)) {
      switch (hazardSeverity(adjacentSpace.tile?.tileType)) {
      case HazardSeverity.MILD:
        costs.production += 1;
        break;
      case HazardSeverity.SEVERE:
        costs.production += 2;
        break;
      }
      if (adjacentSpace.adjacency !== undefined) {
        const adjacency = adjacentSpace.adjacency;
        costs.stock.megacredits += adjacency.cost ?? 0;
        // TODO(kberg): offset costs with heat and MC bonuses.
        // for (const bonus of adjacency.bonus) {
        //   case (bonus) {
        //     switch SpaceBonus.MEGACREDITS:
        //       costs.stock.megacredits--;
        //     switch SpaceBonus.MEGACREDITS:
        //       costs.stock.megacredits--;
        //   }
        // }
      }
    }
    return costs;
  }

  public canAfford(player: IPlayer, space: Space, canAffordOptions?: CanAffordOptions) {
    const additionalCosts = this.computeAdditionalCosts(space, player.game.gameOptions.aresExtension);
    if (additionalCosts.stock.megacredits > 0) {
      const plan: CanAffordOptions = canAffordOptions !== undefined ? {...canAffordOptions} : {cost: 0, tr: {}};
      plan.cost += additionalCosts.stock.megacredits;
      plan.tr = additionalCosts.tr;

      const afford = player.canAfford(plan);
      if (afford === false) {
        return false;
      }
    }
    if (additionalCosts.production > 0) {
      // +5 because megacredits goes to -5
      const availableProduction = sum(Units.values(player.production)) + 5;
      return availableProduction > additionalCosts.production;
    }
    return true;
  }

  public getAvailableSpacesOnLand(player: IPlayer, canAffordOptions?: CanAffordOptions): ReadonlyArray<Space> {
    // Does this also apply to cove spaces?
    const landSpaces = this.getSpaces(SpaceType.LAND, player).filter((space) => {
      // A space is available if it doesn't have a player marker on it, or it belongs to |player|
      if (space.player !== undefined && space.player !== player) {
        return false;
      }

      if (space.id === this.noctisCitySpaceId) {
        return false;
      }

      const playableSpace = space.tile === undefined || (AresHandler.hasHazardTile(space) && space.tile?.protectedHazard !== true);

      if (!playableSpace) {
        return false;
      }

      if (space.id === player.game.nomadSpace) {
        return false;
      }

      return this.canAfford(player, space, canAffordOptions);
    });
    return landSpaces;
  }


  // |distance| represents the number of eligible spaces from the top left (or bottom right)
  // to count. So distance 0 means the first available space.
  // If |direction| is 1, count from the top left. If -1, count from the other end of the map.
  // |player| will be an additional space filter (which basically supports Land Claim)
  // |predicate| allows callers to provide additional filtering of eligible spaces.
  public getNthAvailableLandSpace(
    distance: number,
    direction: -1 | 1,
    player: IPlayer | undefined = undefined,
    predicate: (value: Space) => boolean = (_x) => true): Space {
    const spaces = this.spaces.filter((space) => {
      return this.canPlaceTile(space) && (space.player === undefined || space.player === player);
    }).filter(predicate);
    let idx = (direction === 1) ? distance : (spaces.length - (distance + 1));
    if (spaces.length === 0) {
      throw new Error('no spaces available');
    }
    while (idx < 0) {
      idx += spaces.length;
    }
    while (idx >= spaces.length) {
      idx -= spaces.length;
    }
    return spaces[idx];
  }

  public canPlaceTile(space: Space): boolean {
    return space.tile === undefined && space.spaceType === SpaceType.LAND && space.id !== this.noctisCitySpaceId;
  }

  public static isCitySpace(space: Space): boolean {
    return space.tile !== undefined && CITY_TILES.has(space.tile.tileType);
  }

  // Returns true when the space has an ocean tile or any derivative tiles (ocean city, wetlands)
  public static isOceanSpace(space: Space): boolean {
    return space.tile !== undefined && OCEAN_TILES.has(space.tile.tileType);
  }

  /**
   *  Returns true when the space is an ocean tile that is not used to cover another ocean.
   *
   * Used for benefits associated with "when a player places an ocean tile"
   */
  public static isUncoveredOceanSpace(space: Space): boolean {
    return space.tile !== undefined && BASE_OCEAN_TILES.has(space.tile.tileType);
  }

  public static isGreenerySpace(space: Space): boolean {
    return space.tile !== undefined && GREENERY_TILES.has(space.tile.tileType);
  }

  public static ownedBy(player: IPlayer): (space: Space) => boolean {
    return (space: Space) => space.player?.id === player.id;
  }

  public static spaceOwnedBy(space: Space, player: IPlayer): boolean {
    return Board.ownedBy(player)(space);
  }

  public getHazards(): ReadonlyArray<Space> {
    return this.spaces.filter((space) => space.tile && isHazardTileType(space.tile.tileType));
  }

  public serialize(): SerializedBoard {
    return {
      spaces: this.spaces.map((space) => {
        const serialized: SerializedSpace = {
          id: space.id,
          spaceType: space.spaceType,
          tile: space.tile,
          player: space.player?.id,
          bonus: space.bonus,
          adjacency: space.adjacency,
          x: space.x,
          y: space.y,
        };
        if (space.undergroundResources !== undefined) {
          serialized.undergroundResources = space.undergroundResources;
        }
        if (space.excavator !== undefined) {
          serialized.excavator = space.excavator.id;
        }
        if (space.coOwner !== undefined) {
          serialized.coOwner = space.coOwner.id;
        }

        return serialized;
      }),
    };
  }

  private static findPlayer(players: ReadonlyArray<IPlayer>, playerId: PlayerId | undefined) {
    return players.find((p) => p.id === playerId);
  }

  public static deserializeSpace(serialized: SerializedSpace, players: ReadonlyArray<IPlayer>): Space {
    const player = this.findPlayer(players, serialized.player);
    const excavator = this.findPlayer(players, serialized.excavator);
    const coOwner = this.findPlayer(players, serialized.coOwner);
    const space: Space = {
      id: serialized.id,
      spaceType: serialized.spaceType,
      bonus: serialized.bonus,
      x: serialized.x,
      y: serialized.y,
    };

    if (serialized.tile !== undefined) {
      space.tile = serialized.tile;
    }
    if (player !== undefined) {
      space.player = player;
    }
    if (serialized.adjacency !== undefined) {
      space.adjacency = serialized.adjacency;
    }
    if (serialized.undergroundResources !== undefined) {
      space.undergroundResources = serialized.undergroundResources;
    }
    if (excavator !== undefined) {
      space.excavator = excavator;
    }
    if (coOwner !== undefined) {
      space.coOwner = coOwner;
    }
    return space;
  }

  public static deserialize(board: SerializedBoard, players: ReadonlyArray<IPlayer>): {spaces: Array<Space>} {
    const spaces = board.spaces.map((space) => Board.deserializeSpace(space, players));
    return {spaces};
  }
}

export function playerTileFn(player: IPlayer) {
  return (space: Space) => space.player?.id === player.id;
}

export function isSpecialTile(tileType: TileType | undefined): boolean {
  switch (tileType) {
  case TileType.GREENERY:
  case TileType.OCEAN:
  case TileType.CITY:
  case TileType.MOON_HABITAT:
  case TileType.MOON_MINE:
  case TileType.MOON_ROAD:
  case TileType.EROSION_MILD: // Hazard tiles are "special" but they don't count for the typical intent of what a special tile represents.
  case TileType.EROSION_SEVERE:
  case TileType.DUST_STORM_MILD:
  case TileType.DUST_STORM_SEVERE:
  case undefined:
    return false;
  default:
    return true;
  }
}

export function isSpecialTileSpace(space: Space): boolean {
  return isSpecialTile(space.tile?.tileType);
}

================
File: boards/BoardBuilder.ts
================
import {Space} from './Space';
import {SpaceId, isSpaceId, safeCast} from '../../common/Types';
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {SpaceName} from '../SpaceName';
import {SpaceType} from '../../common/boards/SpaceType';
import {Random} from '../../common/utils/Random';
import {inplaceShuffle} from '../utils/shuffle';

function colonySpace(id: SpaceId): Space {
  return {id, spaceType: SpaceType.COLONY, x: -1, y: -1, bonus: []};
}

export class BoardBuilder {
  // This builder assumes the map has nine rows, of tile counts [5,6,7,8,9,8,7,6,5].
  //
  // "Son I am able, " she said "though you scare me."
  // "Watch, " said I
  // "Beloved, " I said "watch me scare you though." said she,
  // "Able am I, Son."

  private spaceTypes: Array<SpaceType> = [];
  private bonuses: Array<Array<SpaceBonus>> = [];
  private spaces: Array<Space> = [];
  private unshufflableSpaces: Array<number> = [];

  constructor(private includeVenus: boolean, private includePathfinders: boolean, private includeChemical: boolean) {
  }

  ocean(...bonus: Array<SpaceBonus>): this {
    this.spaceTypes.push(SpaceType.OCEAN);
    this.bonuses.push(bonus);
    return this;
  }

  cove(...bonus: Array<SpaceBonus>): this {
    this.spaceTypes.push(SpaceType.COVE);
    this.bonuses.push(bonus);
    return this;
  }

  land(...bonus: Array<SpaceBonus>): this {
    this.spaceTypes.push(SpaceType.LAND);
    this.bonuses.push(bonus);
    return this;
  }

  restricted(): this {
    this.spaceTypes.push(SpaceType.RESTRICTED);
    this.bonuses.push([]);
    return this;
  }

  doNotShuffleLastSpace(): this {
    this.unshufflableSpaces.push(this.spaceTypes.length - 1);
    return this;
  }


  build(): Array<Space> {
    this.spaces.push(colonySpace(SpaceName.GANYMEDE_COLONY));
    this.spaces.push(colonySpace(SpaceName.PHOBOS_SPACE_HAVEN));

    const tilesPerRow = [5, 6, 7, 8, 9, 8, 7, 6, 5];
    const idOffset = this.spaces.length + 1;
    let idx = 0;

    for (let row = 0; row < 9; row++) {
      const tilesInThisRow = tilesPerRow[row];
      const xOffset = 9 - tilesInThisRow;
      for (let i = 0; i < tilesInThisRow; i++) {
        const spaceId = idx + idOffset;
        const xCoordinate = xOffset + i;
        const space = {
          id: BoardBuilder.spaceId(spaceId),
          spaceType: this.spaceTypes[idx],
          x: xCoordinate,
          y: row,
          bonus: this.bonuses[idx],
        };
        this.spaces.push(space);
        idx++;
      }
    }

    this.spaces.push(colonySpace(SpaceName.STANFORD_TORUS));
    if (this.includeVenus) {
      this.spaces.push(
        colonySpace(SpaceName.DAWN_CITY),
        colonySpace(SpaceName.LUNA_METROPOLIS),
        colonySpace(SpaceName.MAXWELL_BASE),
        colonySpace(SpaceName.STRATOPOLIS),
      );
    }
    if (this.includePathfinders) {
      this.spaces.push(
        // Space.colony(SpaceName.MARTIAN_TRANSHIPMENT_STATION),
        colonySpace(SpaceName.CERES_SPACEPORT),
        colonySpace(SpaceName.DYSON_SCREENS),
        colonySpace(SpaceName.LUNAR_EMBASSY),
        colonySpace(SpaceName.VENERA_BASE),
      );
    }
    if (this.includeChemical) {
      this.spaces.push(
        colonySpace(SpaceName.TOWERS_OF_FREYJA),
        colonySpace(SpaceName.OVDA_CITY),
        colonySpace(SpaceName.CAPITAL_OF_VENUS),
        colonySpace(SpaceName.JUPITER_FLOATING_CITY),
      );
    }
    return this.spaces;
  }

  /*
  public shuffleArray(rng: Random, array: Array<unknown>): void {
    // Reversing the indexes so the elements are pulled from the right.
    // Reversing the result so elements are listed left to right.
    const spliced = this.unshufflableSpaces.reverse().map((idx) => array.splice(idx, 1)[0]).reverse();
    for (let i = array.length - 1; i > 0; i--) {
      const j = rng.nextInt(i + 1);
      [array[i], array[j]] = [array[j], array[i]];
    }
    for (let idx = 0; idx < this.unshufflableSpaces.length; idx++) {
      array.splice(this.unshufflableSpaces[idx], 0, spliced[idx]);
    }
  }
*/

  // Shuffle the ocean spaces and bonus spaces. But protect the land spaces supplied by
  // |lands| so that those IDs most definitely have land spaces.
  public shuffle(rng: Random, ...preservedSpaceIds: Array<SpaceName>) {
    const preservedSpaces = [...this.unshufflableSpaces];
    for (const spaceId of preservedSpaceIds) {
      const idx = Number(spaceId) - 3;
      if (!preservedSpaces.includes(idx)) {
        preservedSpaces.push(idx);
      }
    }
    preservedSpaces.sort((a, b) => a - b);
    preservingShuffle(this.spaceTypes, preservedSpaces, rng);
    preservingShuffle(this.bonuses, this.unshufflableSpaces, rng);
    return;
  }

  private static spaceId(id: number): SpaceId {
    let strId = id.toString();
    if (id < 10) {
      strId = '0'+strId;
    }
    return safeCast(strId, isSpaceId);
  }
}

export function preservingShuffle(array: Array<unknown>, preservedIndexes: ReadonlyArray<number>, rng: Random): void {
  // Reversing the indexes so the elements are pulled from the right.
  // Reversing the result so elements are listed left to right.
  const forward = [...preservedIndexes].sort((a, b) => a - b);
  const backward = [...forward].reverse();
  const spliced = backward.map((idx) => array.splice(idx, 1)[0]).reverse();
  inplaceShuffle(array, rng);
  for (let idx = 0; idx < forward.length; idx++) {
    array.splice(forward[idx], 0, spliced[idx]);
  }
}

================
File: boards/BoardType.ts
================
export enum BoardType {
  MARS = 'mars',
  MOON = 'moon'
}

================
File: boards/ElysiumBoard.ts
================
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {SpaceName} from '../SpaceName';
import {BoardBuilder} from './BoardBuilder';
import {Random} from '../../common/utils/Random';
import {GameOptions} from '../game/GameOptions';
import {MarsBoard} from './MarsBoard';
import {Space} from './Space';

export class ElysiumBoard extends MarsBoard {
  public static newInstance(gameOptions: GameOptions, rng: Random): ElysiumBoard {
    const builder = new BoardBuilder(gameOptions.venusNextExtension, gameOptions.pathfindersExpansion, gameOptions.chemicalExpansion);

    const PLANT = SpaceBonus.PLANT;
    const STEEL = SpaceBonus.STEEL;
    const DRAW_CARD = SpaceBonus.DRAW_CARD;
    const TITANIUM = SpaceBonus.TITANIUM;

    // y=0
    builder.ocean().ocean(TITANIUM).ocean(DRAW_CARD).ocean(STEEL).land(DRAW_CARD);
    // y=1
    builder.land(TITANIUM).land().land().ocean().ocean().land(STEEL, STEEL);
    // y=2
    builder.land(TITANIUM, TITANIUM).land().land(DRAW_CARD).land().ocean(PLANT).ocean().land(DRAW_CARD, DRAW_CARD, DRAW_CARD);
    // y=3
    builder.land(PLANT).land(PLANT).land(PLANT).ocean(PLANT, PLANT).land(PLANT).ocean(PLANT).ocean(PLANT).land(PLANT, STEEL);
    // y=4
    builder.land(PLANT, PLANT).land(PLANT, PLANT).land(PLANT, PLANT).ocean(PLANT, PLANT).land(PLANT, PLANT).land(PLANT, PLANT, PLANT).land(PLANT, PLANT).land(PLANT, PLANT).land(PLANT, TITANIUM);
    // y=5
    builder.land(STEEL).land(PLANT).land(PLANT).land(PLANT).land(PLANT).land(PLANT).land(PLANT).land();
    // y=6
    builder.land(TITANIUM).land(STEEL).land().land().land(STEEL).land().land();
    // y=7
    builder.land(STEEL, STEEL).land().land().land().land(STEEL, STEEL).land();
    // y=8
    builder.land(STEEL).land().land(DRAW_CARD).land(DRAW_CARD).land(STEEL, STEEL);

    if (gameOptions.shuffleMapOption) {
      builder.shuffle(rng, SpaceName.HECATES_THOLUS, SpaceName.ELYSIUM_MONS, SpaceName.ARSIA_MONS_ELYSIUM, SpaceName.OLYMPUS_MONS);
    }
    const spaces = builder.build();
    return new ElysiumBoard(spaces);
  }

  public constructor(spaces: ReadonlyArray<Space>) {
    super(spaces, undefined, [
      SpaceName.ARSIA_MONS_ELYSIUM,
      SpaceName.ELYSIUM_MONS,
      SpaceName.HECATES_THOLUS,
      SpaceName.OLYMPUS_MONS,
    ]);
  }
}

================
File: boards/HellasBoard.ts
================
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {SpaceName} from '../SpaceName';
import {SpaceCosts} from './Board';
import {Space} from './Space';
import {HELLAS_BONUS_OCEAN_COST} from '../../common/constants';
import {BoardBuilder} from './BoardBuilder';
import {Random} from '../../common/utils/Random';
import {GameOptions} from '../game/GameOptions';
import {MarsBoard} from './MarsBoard';

export class HellasBoard extends MarsBoard {
  public static newInstance(gameOptions: GameOptions, rng: Random): HellasBoard {
    const builder = new BoardBuilder(gameOptions.venusNextExtension, gameOptions.pathfindersExpansion, gameOptions.chemicalExpansion);

    const PLANT = SpaceBonus.PLANT;
    const STEEL = SpaceBonus.STEEL;
    const DRAW_CARD = SpaceBonus.DRAW_CARD;
    const HEAT = SpaceBonus.HEAT;
    const TITANIUM = SpaceBonus.TITANIUM;

    // y=0
    builder.ocean(PLANT, PLANT).land(PLANT, PLANT).land(PLANT, PLANT).land(PLANT, STEEL).land(PLANT);
    // y=1
    builder.ocean(PLANT, PLANT).land(PLANT, PLANT).land(PLANT).land(PLANT, STEEL).land(PLANT).land(PLANT);
    // y=2
    builder.ocean(PLANT).land(PLANT).land(STEEL).land(STEEL).land().land(PLANT, PLANT).land(PLANT, DRAW_CARD);
    // y=3
    builder.ocean(PLANT).land(PLANT).land(STEEL).land(STEEL, STEEL).land(STEEL).ocean(PLANT).ocean(PLANT).land(PLANT);
    // y=4
    builder.land(DRAW_CARD).land().land().land(STEEL, STEEL).land().ocean(DRAW_CARD).ocean(HEAT, HEAT, HEAT).ocean().land(PLANT);
    // y=5
    builder.land(TITANIUM).land().land(STEEL).land().land().ocean().ocean(STEEL).land();
    // y=6
    builder.ocean(TITANIUM, TITANIUM).land().land().land(DRAW_CARD).land().land().land(TITANIUM);
    // y=7
    builder.land(STEEL).land(DRAW_CARD).land(HEAT, HEAT).land(HEAT, HEAT).land(TITANIUM).land(TITANIUM);
    // y=8
    builder.land().land(HEAT, HEAT).land(SpaceBonus.OCEAN).doNotShuffleLastSpace().land(HEAT, HEAT).land();

    if (gameOptions.shuffleMapOption) {
      builder.shuffle(rng);
    }

    const spaces = builder.build();
    return new HellasBoard(spaces);
  }

  public constructor(spaces: ReadonlyArray<Space>) {
    super(spaces, undefined, []);
  }

  public override spaceCosts(space: Space): SpaceCosts {
    const costs = super.spaceCosts(space);
    if (space.id === SpaceName.HELLAS_OCEAN_TILE) {
      costs.stock.megacredits = HELLAS_BONUS_OCEAN_COST;
      costs.tr.oceans = 1;
    }
    return costs;
  }
}

================
File: boards/MarsBoard.ts
================
import {OCEAN_UPGRADE_TILES, TileType} from '../../common/TileType';
import {SpaceType} from '../../common/boards/SpaceType';
import {CanAffordOptions, IPlayer} from '../IPlayer';
import {Board} from './Board';
import {Space} from './Space';
import {PlacementType} from './PlacementType';
import {AresHandler} from '../ares/AresHandler';
import {CardName} from '../../common/cards/CardName';
import {SpaceId} from '../../common/Types';

export class MarsBoard extends Board {
  private readonly edges: ReadonlyArray<Space>;

  protected constructor(
    spaces: ReadonlyArray<Space>,
    noctisCitySpaceId: SpaceId | undefined,
    volcanicSpaceIds: ReadonlyArray<SpaceId>) {
    super(spaces, noctisCitySpaceId, volcanicSpaceIds);
    this.edges = this.computeEdges();
  }

  public getCitiesOffMars(player?: IPlayer): Array<Space> {
    return this.getCities(player).filter((space) => space.spaceType === SpaceType.COLONY);
  }

  public getCitiesOnMars(player?: IPlayer): Array<Space> {
    return this.getCities(player).filter((space) => space.spaceType !== SpaceType.COLONY);
  }

  public getCities(player?: IPlayer): Array<Space> {
    let cities = this.spaces.filter(Board.isCitySpace);
    if (player !== undefined) cities = cities.filter(Board.ownedBy(player));
    return cities;
  }

  public getGreeneries(player?: IPlayer): Array<Space> {
    let greeneries = this.spaces.filter((space) => Board.isGreenerySpace(space));
    if (player !== undefined) greeneries = greeneries.filter(Board.ownedBy(player));
    return greeneries;
  }

  public getAvailableSpacesForType(player: IPlayer, type: PlacementType, canAffordOptions?: CanAffordOptions | undefined): ReadonlyArray<Space> {
    switch (type) {
    case 'land': return this.getAvailableSpacesOnLand(player, canAffordOptions);
    case 'ocean': return this.getAvailableSpacesForOcean(player);
    case 'greenery': return this.getAvailableSpacesForGreenery(player, canAffordOptions);
    case 'city': return this.getAvailableSpacesForCity(player, canAffordOptions);
    case 'isolated': return this.getAvailableIsolatedSpaces(player, canAffordOptions);
    case 'volcanic': return this.getAvailableVolcanicSpaces(player, canAffordOptions);
    case 'upgradeable-ocean': return this.getOceanSpaces({upgradedOceans: false});
    default: throw new Error('unknown type ' + type);
    }
  }

  /*
   * Returns spaces on the board with ocean tiless.
   *
   * The default condition is to return those oceans used to count toward the global parameter, so
   * upgraded oceans are included, but Wetlands is not. That's why the boolean values have different defaults.
   */
  public getOceanSpaces(include?: {upgradedOceans?: boolean, wetlands?: boolean}): ReadonlyArray<Space> {
    const spaces = this.spaces.filter((space) => {
      if (!Board.isOceanSpace(space)) return false;
      if (space.tile?.tileType === undefined) return false;
      const tileType = space.tile.tileType;
      if (OCEAN_UPGRADE_TILES.has(tileType)) {
        return include?.upgradedOceans ?? true;
      }
      if (tileType === TileType.WETLANDS) {
        return include?.wetlands ?? false;
      }
      return true;
    });
    return spaces;
  }

  public getAvailableSpacesForCity(player: IPlayer, canAffordOptions?: CanAffordOptions): ReadonlyArray<Space> {
    const spacesOnLand = this.getAvailableSpacesOnLand(player, canAffordOptions);
    // Gordon CEO can ignore placement restrictions for Cities+Greenery
    if (player.cardIsInEffect(CardName.GORDON)) {
      return spacesOnLand;
    }
    // Kingdom of Tauraro can place cities next to cities, but also must place them
    // next to tiles they own, if possible.
    if (player.isCorporation(CardName.KINGDOM_OF_TAURARO)) {
      const spacesNextToMySpaces = spacesOnLand.filter(
        (space) => this.getAdjacentSpaces(space).some(
          (adj) => adj.tile !== undefined && adj.player === player));

      return (spacesNextToMySpaces.length > 0) ? spacesNextToMySpaces : spacesOnLand;
    }
    // A city cannot be adjacent to another city
    return spacesOnLand.filter(
      (space) => this.getAdjacentSpaces(space).some((adjacentSpace) => Board.isCitySpace(adjacentSpace)) === false,
    );
  }

  public getAvailableSpacesForGreenery(player: IPlayer, canAffordOptions?: CanAffordOptions): ReadonlyArray<Space> {
    let spacesOnLand = this.getAvailableSpacesOnLand(player, canAffordOptions);
    // Gordon CEO can ignore placement restrictions for Cities+Greenery
    if (player.cardIsInEffect(CardName.GORDON)) return spacesOnLand;
    // Spaces next to Red City are always unavialable.
    if (player.game.gameOptions.pathfindersExpansion === true) {
      spacesOnLand = spacesOnLand.filter((space) => {
        return !this.getAdjacentSpaces(space).some((neighbor) => neighbor.tile?.tileType === TileType.RED_CITY);
      });
    }

    const spacesForGreenery = spacesOnLand
      .filter((space) => this.getAdjacentSpaces(space).find((adj) => adj.tile !== undefined && adj.player === player && adj.tile.tileType !== TileType.OCEAN) !== undefined);

    // Spaces next to tiles you own
    if (spacesForGreenery.length > 0) {
      return spacesForGreenery;
    }
    // Place anywhere if no space owned
    return spacesOnLand;
  }

  public getAvailableSpacesForOcean(player: IPlayer): ReadonlyArray<Space> {
    return this.getSpaces(SpaceType.OCEAN, player)
      .filter(
        (space) => space.tile === undefined &&
                      (space.player === undefined || space.player === player),
      );
  }

  private computeEdges(): ReadonlyArray<Space> {
    return this.spaces.filter((space) => {
      if (space.y === 0 || space.y === 8 || space.x === 8) {
        return true;
      }
      // left side is tricky.
      // top-left is easy with math. Look at the map.
      if (space.y + space.x === 4) {
        return true;
      }
      // bottom-left is also easy with math. Look at the map.
      if (space.y - space.x === 4) {
        return true;
      }
      return false;
    });
  }

  public getEdges(): ReadonlyArray<Space> {
    return this.edges;
  }

  public getAvailableIsolatedSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): ReadonlyArray<Space> {
    return this.getAvailableSpacesOnLand(player, canAffordOptions)
      .filter((space: Space) => this.getAdjacentSpaces(space).every((space) => space.tile === undefined));
  }

  public getAvailableVolcanicSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): ReadonlyArray<Space> {
    const volcanicSpaceIds = this.volcanicSpaceIds;

    const spaces = this.getAvailableSpacesOnLand(player, canAffordOptions);
    if (volcanicSpaceIds.length > 0) {
      return spaces.filter((space) => volcanicSpaceIds.includes(space.id));
    }
    return spaces;
  }

  /**
   * Almost the same as getAvailableSpacesOnLand, but doesn't apply to any player.
   */
  public getNonReservedLandSpaces(): ReadonlyArray<Space> {
    return this.spaces.filter((space) => {
      if (space.id === this.noctisCitySpaceId) {
        return false;
      }
      return (space.spaceType === SpaceType.LAND || space.spaceType === SpaceType.COVE) &&
        (space.tile === undefined || AresHandler.hasHazardTile(space)) &&
        space.player === undefined;
    });
  }
}

================
File: boards/PlacementType.ts
================
export type PlacementType =
  'land' |
  'ocean' |
  'greenery' |
  'city' |
  'isolated' |
  'volcanic' |
  'upgradeable-ocean';

================
File: boards/SerializedBoard.ts
================
import {AdjacencyBonus} from '../ares/AdjacencyBonus';
import {Tile} from '../Tile';
import {PlayerId} from '../../common/Types';
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {SpaceType} from '../../common/boards/SpaceType';
import {SpaceId} from '../../common/Types';
import {UndergroundResourceToken} from '../../common/underworld/UndergroundResourceToken';

export interface SerializedBoard {
  spaces: Array<SerializedSpace>;
}

export interface SerializedSpace {
  id: SpaceId;
  spaceType: SpaceType;
  tile?: Tile;
  player?: PlayerId;
  bonus: Array<SpaceBonus>;
  adjacency?: AdjacencyBonus,
  x: number;
  y: number;
  undergroundResources?: UndergroundResourceToken;
  excavator?: PlayerId;
  coOwner?: PlayerId;
}

================
File: boards/Space.ts
================
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {SpaceType} from '../../common/boards/SpaceType';
import {Tile} from '../Tile';
import {AdjacencyBonus} from '../ares/AdjacencyBonus';
import {SpaceId} from '../../common/Types';
import {IPlayer} from '../IPlayer';
import {UndergroundResourceToken} from '../../common/underworld/UndergroundResourceToken';

export type Space = {
  /** The unique ID of this space*/
  readonly id: SpaceId;
  /** The x-coordinate of this space, or -1 if it is not the main board (e.g. colony) */
  readonly x: number;
  /** The y-coordinate of this space, or -1 if it is not the main board (e.g. colony) */
  readonly y: number;

  /** The type of space: ocean, space colony, etc. */
  spaceType: SpaceType;
  /** The tile placed on top of the space. Could be a hazard tile. */
  tile?: Tile;
  /** The player who owns this tile. Will show a token, even the neutral player */
  player?: IPlayer;
  /** The bonuses granted to a player for placing a tile on this space. */
  bonus: Array<SpaceBonus>;
  /** The bonuses granted to players when placing tiles NEXT TO this space. */
  adjacency?: AdjacencyBonus,

  /** Optional underworld expansion resource token. */
  undergroundResources?: UndergroundResourceToken;
  /** Optional underworld player who excavated this resource token. */
  excavator?: IPlayer;

  /** This tile's co-owner. Used for The Moon's Hostile Takeover card. */
  coOwner?: IPlayer;
}

================
File: boards/TerraCimmeriaBoard.ts
================
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {BoardBuilder} from './BoardBuilder';
import {SpaceName} from '../SpaceName';
import {Random} from '../../common/utils/Random';
import {Space} from './Space';
import {GameOptions} from '../game/GameOptions';
import {MarsBoard} from './MarsBoard';

export class TerraCimmeriaBoard extends MarsBoard {
  public static newInstance(gameOptions: GameOptions, rng: Random): TerraCimmeriaBoard {
    const builder = new BoardBuilder(gameOptions.venusNextExtension, gameOptions.pathfindersExpansion, gameOptions.chemicalExpansion);

    const PLANT = SpaceBonus.PLANT;
    const STEEL = SpaceBonus.STEEL;
    const DRAW_CARD = SpaceBonus.DRAW_CARD;
    const TITANIUM = SpaceBonus.TITANIUM;
    const ENERGY = SpaceBonus.ENERGY;

    // y=0
    builder.ocean().land(PLANT).land(STEEL).land(PLANT, PLANT).ocean(PLANT, PLANT);
    // y=1
    builder.ocean(TITANIUM, TITANIUM).land().land().land(PLANT).land(PLANT, STEEL).ocean(PLANT);
    // y=2
    builder.land().land(PLANT).land(ENERGY, ENERGY, ENERGY).land().land(PLANT).land(PLANT).land(PLANT);
    // y=3
    builder.land(STEEL, STEEL).land(PLANT, PLANT).land().land(ENERGY, ENERGY).land().land().land(DRAW_CARD).land();
    // y=4
    builder.land().land(PLANT, ENERGY).land(ENERGY, ENERGY).land(STEEL).land(STEEL)
      .land(DRAW_CARD).land().land(STEEL).ocean(DRAW_CARD);
    // y=5
    builder.land(DRAW_CARD, DRAW_CARD).land().land(TITANIUM).land().land().land(STEEL, STEEL).land().land(STEEL, STEEL);
    // y=6
    builder.land().land(TITANIUM).land(PLANT).land(PLANT, STEEL, STEEL).land(PLANT, PLANT).land(PLANT).ocean(PLANT, PLANT);
    // y=7
    builder.ocean(STEEL, STEEL).land(PLANT).land(TITANIUM).land(DRAW_CARD).land(PLANT).ocean(PLANT);
    // y=8
    builder.ocean(PLANT, PLANT).ocean(PLANT, PLANT).ocean(PLANT, PLANT).land(PLANT).ocean(PLANT, PLANT);

    if (gameOptions.shuffleMapOption) {
      builder.shuffle(rng,
        SpaceName.ALBOR_THOLUS_TERRACIMMERIA,
        SpaceName.APOLLINARIS_MONS,
        SpaceName.HADRIACUS_MONS,
        SpaceName.TYRRHENUS_MONS);
    }

    const spaces = builder.build();
    return new TerraCimmeriaBoard(spaces);
  }

  public constructor(spaces: ReadonlyArray<Space>) {
    super(spaces, undefined, [
      SpaceName.ALBOR_THOLUS_TERRACIMMERIA,
      SpaceName.APOLLINARIS_MONS,
      SpaceName.HADRIACUS_MONS,
      SpaceName.TYRRHENUS_MONS,
    ]);
  }
}

================
File: boards/TerraCimmeriaNovusBoard.ts
================
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {BoardBuilder} from './BoardBuilder';
import {Random} from '../../common/utils/Random';
import {GameOptions} from '../game/GameOptions';
import {SpaceId} from '../../common/Types';
import {MarsBoard} from './MarsBoard';
import {Space} from './Space';
import {CanAffordOptions, IPlayer} from '../IPlayer';
import {TERRA_CIMMERIA_COLONY_COST} from '../../common/constants';

const VOLCANIC_SPACE_IDS: ReadonlyArray<SpaceId> = ['05', '21', '27', '38'];
const CURIOSITY_SPACE_ID: SpaceId = '16';
export class TerraCimmeriaNovusBoard extends MarsBoard {
  public static newInstance(gameOptions: GameOptions, rng: Random): TerraCimmeriaNovusBoard {
    const builder = new BoardBuilder(gameOptions.venusNextExtension, gameOptions.pathfindersExpansion, gameOptions.chemicalExpansion);

    const PLANT = SpaceBonus.PLANT;
    const STEEL = SpaceBonus.STEEL;
    const DRAW_CARD = SpaceBonus.DRAW_CARD;
    const TITANIUM = SpaceBonus.TITANIUM;
    const COLONY = SpaceBonus.COLONY;

    // y=0
    builder.ocean().land(PLANT).land(STEEL).land(PLANT).ocean(PLANT, PLANT);
    // y=1
    builder.ocean(TITANIUM, TITANIUM).land().land().land().land(PLANT, STEEL).ocean(PLANT);
    // y=2
    builder.land().land().land(COLONY).doNotShuffleLastSpace().land().land().land(PLANT).land();
    // y=3
    builder.land(STEEL).land().land(STEEL).land().land(STEEL, STEEL).land().land(TITANIUM, TITANIUM).land(DRAW_CARD);
    // y=4
    builder.land().land().land().land(STEEL).land(STEEL).land(DRAW_CARD).land().land(STEEL, DRAW_CARD).ocean();
    // y=5
    builder.land(DRAW_CARD, DRAW_CARD).land().land(TITANIUM, STEEL, STEEL).land().land(TITANIUM).land(STEEL, STEEL).land().land(STEEL, STEEL);
    // y=6
    builder.land(PLANT, PLANT).land(TITANIUM).land().land(PLANT, STEEL, STEEL).land(PLANT, PLANT).land(PLANT).ocean(PLANT, PLANT);
    // y=7
    builder.ocean().land(PLANT).land(TITANIUM).land(DRAW_CARD).land(PLANT, PLANT).ocean(PLANT, PLANT);
    // y=8
    builder.ocean(PLANT, PLANT).ocean(PLANT).ocean(PLANT).land(PLANT).ocean(PLANT);

    if (gameOptions.shuffleMapOption) {
      builder.shuffle(rng);
    }
    const spaces = builder.build();

    // Remove colony bonuses when colonies is not in the game.
    if (gameOptions.coloniesExtension !== true) {
      spaces.forEach((space) => space.bonus = space.bonus.filter((bonus) => bonus !== COLONY));
    }
    return new TerraCimmeriaNovusBoard(spaces);
  }

  public constructor(spaces: ReadonlyArray<Space>) {
    super(spaces, undefined, VOLCANIC_SPACE_IDS);
  }

  public override spaceCosts(space: Space) {
    const costs = super.spaceCosts(space);
    if (space.bonus.includes(SpaceBonus.COLONY)) {
      costs.stock.megacredits = TERRA_CIMMERIA_COLONY_COST;
    }
    return costs;
  }

  public override getAvailableSpacesOnLand(player: IPlayer, canAffordOptions?: CanAffordOptions) {
    return super.getAvailableSpacesOnLand(player, canAffordOptions).filter((space) => {
      if (space.id === CURIOSITY_SPACE_ID) {
        if (player.colonies.getPlayableColonies().length === 0) {
          return false;
        }
      }
      return true;
    });
  }
}

================
File: boards/TharsisBoard.ts
================
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {SpaceName} from '../SpaceName';
import {Space} from './Space';
import {BoardBuilder} from './BoardBuilder';
import {Random} from '../../common/utils/Random';
import {GameOptions} from '../game/GameOptions';
import {MarsBoard} from './MarsBoard';

export class TharsisBoard extends MarsBoard {
  public static newInstance(gameOptions: GameOptions, rng: Random): TharsisBoard {
    const builder = new BoardBuilder(gameOptions.venusNextExtension, gameOptions.pathfindersExpansion, gameOptions.chemicalExpansion);

    const PLANT = SpaceBonus.PLANT;
    const STEEL = SpaceBonus.STEEL;
    const DRAW_CARD = SpaceBonus.DRAW_CARD;
    const TITANIUM = SpaceBonus.TITANIUM;

    // y=0
    builder.land(STEEL, STEEL).ocean(STEEL, STEEL).land().ocean(DRAW_CARD).ocean();
    // y=1
    builder.land().land(STEEL).land().land().land().ocean(DRAW_CARD, DRAW_CARD);
    // y=2
    builder.land(DRAW_CARD).land().land().land().land().land().land(STEEL);
    // y=3
    builder.land(PLANT, TITANIUM).land(PLANT).land(PLANT).land(PLANT).land(PLANT, PLANT).land(PLANT).land(PLANT).ocean(PLANT, PLANT);
    // y=4
    builder.land(PLANT, PLANT).land(PLANT, PLANT).land(PLANT, PLANT).ocean(PLANT, PLANT).ocean(PLANT, PLANT)
      .ocean(PLANT, PLANT).land(PLANT, PLANT).land(PLANT, PLANT).land(PLANT, PLANT);
    // y=5
    builder.land(PLANT).land(PLANT, PLANT).land(PLANT).land(PLANT).land(PLANT).ocean(PLANT).ocean(PLANT).ocean(PLANT);
    // y=6
    builder.land().land().land().land().land().land(PLANT).land();
    // y=7
    builder.land(STEEL, STEEL).land().land(DRAW_CARD).land(DRAW_CARD).land().land(TITANIUM);
    // y=8
    builder.land(STEEL).land(STEEL, STEEL).land().land().ocean(TITANIUM, TITANIUM);

    if (gameOptions.shuffleMapOption) {
      builder.shuffle(rng, SpaceName.NOCTIS_CITY, SpaceName.THARSIS_THOLUS, SpaceName.ASCRAEUS_MONS, SpaceName.ARSIA_MONS, SpaceName.PAVONIS_MONS);
    }
    const spaces = builder.build();
    return new TharsisBoard(spaces);
  }

  public constructor(spaces: ReadonlyArray<Space>) {
    super(spaces, SpaceName.NOCTIS_CITY, [
      SpaceName.ASCRAEUS_MONS,
      SpaceName.ARSIA_MONS,
      SpaceName.PAVONIS_MONS,
      SpaceName.THARSIS_THOLUS,
    ]);
  }
}

================
File: boards/UtopiaPlanitiaBoard.ts
================
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {BoardBuilder} from './BoardBuilder';
import {Random} from '../../common/utils/Random';
import {GameOptions} from '../game/GameOptions';
import {MarsBoard} from './MarsBoard';
import {Space} from './Space';

export class UtopiaPlanitiaBoard extends MarsBoard {
  public static newInstance(gameOptions: GameOptions, rng: Random): UtopiaPlanitiaBoard {
    const builder = new BoardBuilder(gameOptions.venusNextExtension, gameOptions.pathfindersExpansion, gameOptions.chemicalExpansion);

    const PLANT = SpaceBonus.PLANT;
    const STEEL = SpaceBonus.STEEL;
    const ENERGY = SpaceBonus.ENERGY;
    const DRAW_CARD = SpaceBonus.DRAW_CARD;
    const TITANIUM = SpaceBonus.TITANIUM;

    // y=0
    builder.land().land().land(ENERGY, ENERGY).land().land();
    // y=1
    builder.land().land(STEEL, STEEL).land(ENERGY, ENERGY).land(ENERGY, ENERGY, DRAW_CARD).land().land();
    // y=2
    builder.ocean(PLANT, PLANT, PLANT).land().land(STEEL).land().land().land(DRAW_CARD, DRAW_CARD, TITANIUM).land(TITANIUM, TITANIUM);
    // y=3
    builder.ocean(PLANT, DRAW_CARD).land(PLANT).land(PLANT).land(PLANT, PLANT).ocean(PLANT, PLANT).ocean(PLANT).ocean(PLANT).land(PLANT);
    // y=4
    builder.land().land().land().land(PLANT).land(PLANT).land(PLANT, PLANT).land().ocean().land(PLANT, TITANIUM);
    // y=5
    builder.land(STEEL).land(STEEL, STEEL).ocean(PLANT, PLANT).land(PLANT, PLANT).land().land().land(STEEL, STEEL).land();
    // y=6
    builder.land(STEEL).land().ocean().ocean(PLANT, PLANT).land().land().land();
    // y=7
    builder.land().land(DRAW_CARD, DRAW_CARD).ocean().ocean(PLANT, PLANT).land(STEEL, TITANIUM).land(PLANT, PLANT);
    // y=8
    builder.land().land().land(STEEL, STEEL).ocean(PLANT).land(PLANT);

    if (gameOptions.shuffleMapOption) {
      builder.shuffle(rng);
    }
    const spaces = builder.build();
    return new UtopiaPlanitiaBoard(spaces);
  }

  public constructor(spaces: ReadonlyArray<Space>) {
    super(spaces, undefined, []);
  }
}

================
File: boards/VastitasBorealisBoard.ts
================
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {SpaceName} from '../SpaceName';
import {SpaceCosts} from './Board';
import {Space} from './Space';
import {BoardBuilder} from './BoardBuilder';
import {Random} from '../../common/utils/Random';
import {GameOptions} from '../game/GameOptions';
import {VASTITAS_BOREALIS_BONUS_TEMPERATURE_COST} from '../../common/constants';
import {MarsBoard} from './MarsBoard';

export class VastitasBorealisBoard extends MarsBoard {
  public static newInstance(gameOptions: GameOptions, rng: Random): VastitasBorealisBoard {
    const builder = new BoardBuilder(gameOptions.venusNextExtension, gameOptions.pathfindersExpansion, gameOptions.chemicalExpansion);

    const PLANT = SpaceBonus.PLANT;
    const STEEL = SpaceBonus.STEEL;
    const DRAW_CARD = SpaceBonus.DRAW_CARD;
    const HEAT = SpaceBonus.HEAT;
    const TITANIUM = SpaceBonus.TITANIUM;
    const TEMPERATURE = SpaceBonus.TEMPERATURE;

    // y=0
    builder.land(STEEL, STEEL).land(PLANT).land().land().land(TITANIUM, TITANIUM);
    // y=1
    builder.land(STEEL, STEEL).land(STEEL).land().land().land(TITANIUM).land(PLANT);
    // y=2
    builder.land(TITANIUM).land().land().land().land(DRAW_CARD).ocean(PLANT, DRAW_CARD).ocean(PLANT);
    // y=3
    builder.land(STEEL, TITANIUM).land(STEEL, DRAW_CARD).land(STEEL).ocean(HEAT, HEAT).ocean(HEAT, HEAT).ocean().ocean(PLANT, PLANT).land(STEEL, PLANT);
    // y=4
    builder.land().land().land().ocean(HEAT, HEAT).land(TEMPERATURE).doNotShuffleLastSpace().land(STEEL).land().land(PLANT).ocean(TITANIUM);
    // y=5
    builder.land(PLANT).land().land(PLANT).ocean(HEAT, HEAT).land(HEAT, HEAT).land().land(PLANT).land(TITANIUM, PLANT);
    // y=6
    builder.land(PLANT, PLANT).land().ocean().land().land(STEEL, PLANT).land(PLANT).land(PLANT, PLANT);
    // y=7
    builder.ocean(PLANT).land().land(DRAW_CARD).land(STEEL).land().land(PLANT, PLANT);
    // y=8
    builder.ocean(PLANT, PLANT).land().land(PLANT).land(PLANT, PLANT).land(STEEL, PLANT);

    if (gameOptions.shuffleMapOption) {
      builder.shuffle(rng,
        SpaceName.ELYSIUM_MONS_VASTITAS_BOREALIS,
        SpaceName.ALBA_FOSSAE,
        SpaceName.CERANIUS_FOSSAE,
        SpaceName.ALBA_MONS);
    }

    const spaces = builder.build();
    return new VastitasBorealisBoard(spaces);
  }

  public constructor(spaces: ReadonlyArray<Space>) {
    super(spaces, undefined, [
      SpaceName.ELYSIUM_MONS_VASTITAS_BOREALIS,
      SpaceName.ALBA_FOSSAE,
      SpaceName.CERANIUS_FOSSAE,
      SpaceName.ALBA_MONS,
    ]);
  }

  public override spaceCosts(space: Space): SpaceCosts {
    const costs = super.spaceCosts(space);
    if (space.id === SpaceName.VASTITAS_BOREALIS_NORTH_POLE) {
      costs.stock.megacredits = VASTITAS_BOREALIS_BONUS_TEMPERATURE_COST;
      costs.tr.temperature = 1;
    }
    return costs;
  }
}

================
File: boards/VastitasBorealisNovusBoard.ts
================
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {CanAffordOptions, IPlayer} from '../IPlayer';
import {BoardBuilder} from './BoardBuilder';
import {Random} from '../../common/utils/Random';
import {GameOptions} from '../game/GameOptions';
import {MarsBoard} from './MarsBoard';
import {Turmoil} from '../turmoil/Turmoil';
import {SpaceName} from '../SpaceName';
import {Space} from './Space';
import {VASTITAS_BOREALIS_BONUS_TEMPERATURE_COST} from '../../common/constants';
import {SpaceCosts} from './Board';

export class VastitasBorealisNovusBoard extends MarsBoard {
  public static newInstance(gameOptions: GameOptions, rng: Random): VastitasBorealisNovusBoard {
    const builder = new BoardBuilder(gameOptions.venusNextExtension, gameOptions.pathfindersExpansion, gameOptions.chemicalExpansion);

    const PLANT = SpaceBonus.PLANT;
    const STEEL = SpaceBonus.STEEL;
    const HEAT = SpaceBonus.HEAT;
    const DRAW_CARD = SpaceBonus.DRAW_CARD;
    const TITANIUM = SpaceBonus.TITANIUM;
    const TEMPERATURE = SpaceBonus.TEMPERATURE;
    const DELEGATE = SpaceBonus.DELEGATE;

    // y=0
    builder.land(PLANT).land().land(STEEL).land().land();
    // y=1
    builder.land(PLANT, PLANT).land(PLANT, PLANT).land().land().land(PLANT).land(DRAW_CARD);
    // y=2
    builder.land(DRAW_CARD).ocean(PLANT, PLANT).ocean(PLANT, PLANT).land(PLANT, PLANT).land(PLANT).land().land();
    // y=3
    builder.land(STEEL, STEEL).land(TITANIUM).ocean(PLANT, PLANT).land(PLANT).land().land(DRAW_CARD).land(PLANT).land(DELEGATE);
    // y=4
    builder.land().land().ocean(PLANT).land(PLANT, PLANT).land(TEMPERATURE).ocean(PLANT, PLANT).ocean(PLANT, PLANT).ocean(PLANT, PLANT).land(DRAW_CARD, DRAW_CARD);
    // y=5
    builder.land(DRAW_CARD, DRAW_CARD).land().land(PLANT).ocean(HEAT, HEAT).ocean(HEAT, HEAT, PLANT).ocean(DRAW_CARD).land(PLANT).land(TITANIUM, TITANIUM);
    // y=6
    builder.land(TITANIUM).land(STEEL).ocean().ocean(HEAT, HEAT).land(PLANT, PLANT).land(PLANT).land();
    // y=7
    builder.land(PLANT).land().land(PLANT).land(PLANT, STEEL).land(STEEL).land(PLANT);
    // y=8
    builder.land(DELEGATE).land().land(DRAW_CARD).land(STEEL).land(TITANIUM);

    if (gameOptions.shuffleMapOption) {
      builder.shuffle(rng,
        SpaceName.VASTITAS_BOREALIS_NOVUS_HECATES_THOLUS,
        SpaceName.VASTITAS_BOREALIS_NOVUS_ELYSIUM_MONS,
        SpaceName.VASTITAS_BOREALIS_NOVUS_ALBA_MONS,
        SpaceName.VASTITAS_BOREALIS_NOVUS_URANIUS_THOULS,
      );
    }
    const spaces = builder.build();
    return new VastitasBorealisNovusBoard(spaces);
  }

  public constructor(spaces: ReadonlyArray<Space>) {
    super(spaces, undefined, [SpaceName.VASTITAS_BOREALIS_NOVUS_HECATES_THOLUS,
      SpaceName.VASTITAS_BOREALIS_NOVUS_ELYSIUM_MONS,
      SpaceName.VASTITAS_BOREALIS_NOVUS_ALBA_MONS,
      SpaceName.VASTITAS_BOREALIS_NOVUS_URANIUS_THOULS,
    ]);
  }

  public override getAvailableSpacesOnLand(player: IPlayer, canAffordOptions?: CanAffordOptions) {
    return super.getAvailableSpacesOnLand(player, canAffordOptions).filter((space) => {
      if (space.bonus.includes(SpaceBonus.DELEGATE)) {
        return Turmoil.ifTurmoilElse(
          player.game,
          (turmoil) => turmoil.hasDelegatesInReserve(player),
          () => true);
      }
      return true;
    });
  }

  public override spaceCosts(space: Space): SpaceCosts {
    const costs = super.spaceCosts(space);
    if (space.bonus.includes(SpaceBonus.TEMPERATURE)) {
      costs.stock.megacredits = VASTITAS_BOREALIS_BONUS_TEMPERATURE_COST;
      costs.tr.temperature = 1;
    }
    return costs;
  }
}

================
File: cards/ActionCard.ts
================
import {Behavior} from '../behavior/Behavior';
import {IPlayer} from '../IPlayer';
import {Card, StaticCardProperties} from './Card';
import {getBehaviorExecutor} from '../behavior/BehaviorExecutor';

// Same as StaticCardProperties, but action is expected.
export interface StaticActionCardProperties extends StaticCardProperties {
  action: Behavior;
}

/**
 * A Card that has a data-defined behavior in `action`.
 */
// TODO(kberg): Find a way to use mixins to share this with ActiveCorporationCard and ActivePreludeCard
export abstract class ActionCard extends Card {
  // Add actionBehavior to StaticCardProperties, otherwise this will multiple memory consumption.
  constructor(properties: StaticActionCardProperties) {
    super(properties);
  }
  public canAct(player: IPlayer) {
    if (this.properties.action === undefined) {
      throw new Error('action not defined');
    }
    if (!getBehaviorExecutor().canExecute(this.properties.action, player, this)) {
      return false;
    }
    return this.bespokeCanAct(player);
  }

  public action(player: IPlayer) {
    if (this.properties.action === undefined) {
      throw new Error('action not defined');
    }
    getBehaviorExecutor().execute(this.properties.action, player, this);
    return this.bespokeAction(player);
  }

  public bespokeCanAct(_player: IPlayer): boolean {
    return true;
  }

  public bespokeAction(_player: IPlayer) {
    return undefined;
  }
}

================
File: cards/AllManifests.ts
================
import {ARES_CARD_MANIFEST} from './ares/AresCardManifest';
import {ModuleManifest} from './ModuleManifest';
import {COLONIES_CARD_MANIFEST} from './colonies/ColoniesCardManifest';
import {COMMUNITY_CARD_MANIFEST} from './community/CommunityCardManifest';
import {PRELUDE_CARD_MANIFEST} from './prelude/PreludeCardManifest';
import {PROMO_CARD_MANIFEST} from './promo/PromoCardManifest';
import {CEO_CARD_MANIFEST} from './ceos/CeoCardManifest';
import {
  BASE_CARD_MANIFEST,
  CORP_ERA_CARD_MANIFEST,
} from './StandardCardManifests';
import {TURMOIL_CARD_MANIFEST} from './turmoil/TurmoilCardManifest';
import {VENUS_CARD_MANIFEST} from './venusNext/VenusCardManifest';
import {MOON_CARD_MANIFEST} from './moon/MoonCardManifest';
import {PATHFINDERS_CARD_MANIFEST} from './pathfinders/PathfindersCardManifest';
import {PRELUDE2_CARD_MANIFEST} from './prelude2/Prelude2CardManifest';
import {STAR_WARS_CARD_MANIFEST} from './starwars/StarwarsCardManifest';
import {UNDERWORLD_CARD_MANIFEST} from './underworld/UnderworldCardManifest';
import {CHEMICAL_CARD_MANIFEST} from './chemical/ChemicalCardManifest';

export const ALL_MODULE_MANIFESTS: Array<ModuleManifest> = [
  BASE_CARD_MANIFEST,
  CORP_ERA_CARD_MANIFEST,
  PROMO_CARD_MANIFEST,
  VENUS_CARD_MANIFEST,
  COLONIES_CARD_MANIFEST,
  PRELUDE_CARD_MANIFEST,
  PRELUDE2_CARD_MANIFEST,
  TURMOIL_CARD_MANIFEST,
  COMMUNITY_CARD_MANIFEST,
  ARES_CARD_MANIFEST,
  MOON_CARD_MANIFEST,
  PATHFINDERS_CARD_MANIFEST,
  CEO_CARD_MANIFEST,
  STAR_WARS_CARD_MANIFEST,
  UNDERWORLD_CARD_MANIFEST,
  CHEMICAL_CARD_MANIFEST,
];

================
File: cards/ares/AresCardManifest.ts
================
import {CardName} from '../../../common/cards/CardName';
import {ModuleManifest} from '../ModuleManifest';
import {BioengineeringEnclosure} from './BioengineeringEnclosure';
import {BiofertilizerFacility} from './BiofertilizerFacility';
import {ButterflyEffect} from './ButterflyEffect';
import {CapitalAres} from './CapitalAres';
import {CommercialDistrictAres} from './CommercialDistrictAres';
import {DeimosDownAres} from './DeimosDownAres';
import {DesperateMeasures} from './DesperateMeasures';
import {EcologicalSurvey} from './EcologicalSurvey';
import {EcologicalZoneAres} from './EcologicalZoneAres';
import {GeologicalSurvey} from './GeologicalSurvey';
import {GreatDamAres} from './GreatDamAres';
import {IndustrialCenterAres} from './IndustrialCenterAres';
import {LavaFlowsAres} from './LavaFlowsAres';
import {MagneticFieldGeneratorsAres} from './MagneticFieldGeneratorsAres';
import {MarketingExperts} from './MarketingExperts';
import {MetallicAsteroid} from './MetallicAsteroid';
import {MiningAreaAres} from './MiningAreaAres';
import {MiningRightsAres} from './MiningRightsAres';
import {MoholeAreaAres} from './MoholeAreaAres';
import {NaturalPreserveAres} from './NaturalPreserveAres';
import {NuclearZoneAres} from './NuclearZoneAres';
import {OceanCity} from './OceanCity';
import {OceanFarm} from './OceanFarm';
import {OceanSanctuary} from './OceanSanctuary';
import {RestrictedAreaAres} from './RestrictedAreaAres';
import {SolarFarm} from './SolarFarm';

export const ARES_CARD_MANIFEST = new ModuleManifest({
  module: 'ares',
  projectCards: {
    [CardName.BIOENGINEERING_ENCLOSURE]: {Factory: BioengineeringEnclosure},
    [CardName.BIOFERTILIZER_FACILITY]: {Factory: BiofertilizerFacility},
    [CardName.BUTTERFLY_EFFECT]: {Factory: ButterflyEffect},
    [CardName.CAPITAL_ARES]: {Factory: CapitalAres},
    [CardName.COMMERCIAL_DISTRICT_ARES]: {Factory: CommercialDistrictAres},
    [CardName.DEIMOS_DOWN_ARES]: {Factory: DeimosDownAres},
    [CardName.DESPERATE_MEASURES]: {Factory: DesperateMeasures},
    [CardName.ECOLOGICAL_SURVEY]: {Factory: EcologicalSurvey},
    [CardName.ECOLOGICAL_ZONE_ARES]: {Factory: EcologicalZoneAres},
    [CardName.GEOLOGICAL_SURVEY]: {Factory: GeologicalSurvey},
    [CardName.INDUSTRIAL_CENTER_ARES]: {Factory: IndustrialCenterAres},
    [CardName.GREAT_DAM_ARES]: {Factory: GreatDamAres},
    [CardName.LAVA_FLOWS_ARES]: {Factory: LavaFlowsAres},
    [CardName.MAGNETIC_FIELD_GENERATORS_ARES]: {Factory: MagneticFieldGeneratorsAres},
    [CardName.MARKETING_EXPERTS]: {Factory: MarketingExperts},
    [CardName.METALLIC_ASTEROID]: {Factory: MetallicAsteroid},
    [CardName.MINING_AREA_ARES]: {Factory: MiningAreaAres},
    [CardName.MINING_RIGHTS_ARES]: {Factory: MiningRightsAres},
    [CardName.MOHOLE_AREA_ARES]: {Factory: MoholeAreaAres},
    [CardName.NATURAL_PRESERVE_ARES]: {Factory: NaturalPreserveAres},
    [CardName.NUCLEAR_ZONE_ARES]: {Factory: NuclearZoneAres},
    [CardName.OCEAN_CITY]: {Factory: OceanCity},
    [CardName.OCEAN_FARM]: {Factory: OceanFarm},
    [CardName.OCEAN_SANCTUARY]: {Factory: OceanSanctuary},
    [CardName.RESTRICTED_AREA_ARES]: {Factory: RestrictedAreaAres},
    [CardName.SOLAR_FARM]: {Factory: SolarFarm},
  },
  cardsToRemove: [
    CardName.CAPITAL,
    CardName.COMMERCIAL_DISTRICT,
    CardName.DEIMOS_DOWN,
    CardName.DEIMOS_DOWN_PROMO,
    CardName.ECOLOGICAL_ZONE,
    CardName.GREAT_DAM,
    CardName.GREAT_DAM_PROMO,
    CardName.INDUSTRIAL_CENTER,
    CardName.LAVA_FLOWS,
    CardName.MAGNETIC_FIELD_GENERATORS,
    CardName.MAGNETIC_FIELD_GENERATORS_PROMO,
    CardName.MINING_AREA,
    CardName.MINING_RIGHTS,
    CardName.MOHOLE_AREA,
    CardName.NATURAL_PRESERVE,
    CardName.NUCLEAR_ZONE,
    CardName.RESTRICTED_AREA,
  ],
});

================
File: cards/ares/BioengineeringEnclosure.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {CardType} from '../../../common/cards/CardType';
import {IActionCard} from '../ICard';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {SelectCard} from '../../inputs/SelectCard';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';

export class BioengineeringEnclosure extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.BIOENGINEERING_ENCLOSURE,
      tags: [Tag.ANIMAL],
      cost: 7,
      resourceType: CardResource.ANIMAL,
      protectedResources: true,

      behavior: {
        addResources: 2,
      },

      requirements: {tag: Tag.SCIENCE},
      metadata: {
        description: 'Requires 1 science tag to play. Add 2 animals to this card. OTHERS MAY NOT REMOVE ANIMALS FROM THIS CARD.',
        cardNumber: 'A01',
        renderData: CardRenderer.builder((b) => {
          b.action('Remove 1 animal from THIS card to add 1 animal to ANOTHER card.', (eb) => {
            eb.resource(CardResource.ANIMAL).asterix().startAction.resource(CardResource.ANIMAL).asterix();
          }).br;
          b.resource(CardResource.ANIMAL, 2);
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    // >1 because this player already has bioengineering enclosure.
    return this.resourceCount > 0 && player.getResourceCards(this.resourceType).length > 1;
  }

  public action(player: IPlayer) {
    player.defer(
      () => {
        const resourceCards = player.getResourceCards(this.resourceType).filter((card) => card.name !== CardName.BIOENGINEERING_ENCLOSURE);

        if (resourceCards.length === 0) {
          return undefined;
        }

        if (resourceCards.length === 1) {
          this.resourceCount--;
          player.addResourceTo(resourceCards[0], 1);
          player.game.log('${0} moved 1 animal from Bioengineering Enclosure to ${1}.', (b) => b.player(player).card(resourceCards[0]));
          return undefined;
        }

        return new SelectCard(
          'Select card to add 1 animal',
          'Add animal',
          resourceCards)
          .andThen(
            ([card]) => {
              this.resourceCount--;
              player.addResourceTo(card, 1);
              player.game.log('${0} moved 1 animal from Bioengineering Enclosure to ${1}.', (b) => b.player(player).card(card));
              return undefined;
            },
          );
      },
    );
    return undefined;
  }
}

================
File: cards/ares/BiofertilizerFacility.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {TileType} from '../../../common/TileType';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';

export class BiofertilizerFacility extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BIOFERTILIZER_FACILITY,
      tags: [Tag.MICROBE, Tag.BUILDING],
      cost: 12,

      behavior: {
        production: {plants: 1},
        addResourcesToAnyCard: {count: 2, type: CardResource.MICROBE},
        tile: {
          type: TileType.BIOFERTILIZER_FACILITY,
          on: 'land',
          adjacencyBonus: {bonus: [SpaceBonus.PLANT, SpaceBonus.MICROBE]},
        },
      },

      requirements: {tag: Tag.SCIENCE},
      metadata: {
        description: 'Requires 1 science tag. Increase your plant production 1 step. ' +
                  'Add up to 2 microbes to ANY card. ' +
                  'Place this tile which grants an ADJACENCY BONUS of 1 plant and 1 microbe.',
        cardNumber: 'A02',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1));
          b.resource(CardResource.MICROBE, 2);
          b.br;
          b.tile(TileType.BIOFERTILIZER_FACILITY, false, true);
        }),
      },
    });
  }
}

================
File: cards/ares/ButterflyEffect.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {ShiftAresGlobalParametersDeferred} from '../../deferredActions/ShiftAresGlobalParametersDeferred';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {AresHandler} from '../../ares/AresHandler';
import {HAZARD_CONSTRAINTS} from '../../../common/ares/AresData';

export class ButterflyEffect extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.BUTTERFLY_EFFECT,
      cost: 8,

      behavior: {
        tr: 1,
      },

      metadata: {
        cardNumber: 'A03',
        description: 'Gain 1 TR. Move each hazard marker up to 1 step up or down along its terraforming track.',
        renderData: CardRenderer.builder((b) => {
          b.tr(1).br;
          b.plate('All hazard markers').colon().text('-1 / 0 / +1', Size.SMALL);
        }),
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    AresHandler.ifAres(player.game, (aresData) => {
      const hazardData = aresData.hazardData;
      if (HAZARD_CONSTRAINTS.some((constraint) => hazardData[constraint].available === true)) {
        player.game.defer(new ShiftAresGlobalParametersDeferred(player));
      } else {
        player.game.log('All global parameters are high enough that there is no point in changing any of them.');
      }
    });
    return undefined;
  }
}

================
File: cards/ares/CapitalAres.ts
================
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {CardName} from '../../../common/cards/CardName';
import {TileType} from '../../../common/TileType';
import {Capital} from '../base/Capital';
import {CardRenderer} from '../render/CardRenderer';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';

export class CapitalAres extends Capital {
  constructor() {
    super(
      CardName.CAPITAL_ARES,
      {bonus: [SpaceBonus.MEGACREDITS, SpaceBonus.MEGACREDITS]},
      {
        cardNumber: 'A05',
        description: {
          text: 'Requires 4 ocean tiles. Place tile with ADJACENCY BONUS of 2 M€. Energy prod -2 and M€ prod +5.',
          align: 'left',
        },
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().megacredits(5);
          }).nbsp.tile(TileType.CAPITAL, false, true).br;
          b.vpText('1 additional VP for each ocean tile adjacent to this city tile.');
        }),
        victoryPoints: CardRenderDynamicVictoryPoints.oceans(1, 1),
      },
    );
  }
}

================
File: cards/ares/CommercialDistrictAres.ts
================
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {CardName} from '../../../common/cards/CardName';
import {CommercialDistrict} from '../base/CommercialDistrict';
import {CardRenderer} from '../render/CardRenderer';
import {TileType} from '../../../common/TileType';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';


export class CommercialDistrictAres extends CommercialDistrict {
  constructor() {
    super(
      CardName.COMMERCIAL_DISTRICT_ARES,
      {bonus: [SpaceBonus.MEGACREDITS, SpaceBonus.MEGACREDITS]},
      {
        cardNumber: 'A06',
        description: 'Place this tile which grants an ADJACENCY BONUS of 2 M€. Decrease your energy production 1 step and increase your M€ production 4 steps.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(4).br;
          }).nbsp.nbsp.tile(TileType.COMMERCIAL_DISTRICT, false, true).br;
          b.vpText('1 VP per adjacent city tile.');
        }),
        victoryPoints: CardRenderDynamicVictoryPoints.cities(1, 1, true),
      });
  }
}

================
File: cards/ares/DeimosDownAres.ts
================
import {CardName} from '../../../common/cards/CardName';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';
import {all, digit} from '../Options';
import {DeimosDownPromo} from '../promo/DeimosDownPromo';

export class DeimosDownAres extends DeimosDownPromo {
  constructor() {
    super(
      CardName.DEIMOS_DOWN_ARES,
      {bonus: [SpaceBonus.ASTEROID, SpaceBonus.STEEL]},
      {
        cardNumber: 'A26',
        renderData: CardRenderer.builder((b) => {
          b.temperature(3).br;
          b.tile(TileType.DEIMOS_DOWN, false, true).asterix().br;
          b.steel(4, {digit}).nbsp.minus().plants(-6, {all});
        }),
        description: 'Raise temperature 3 steps and gain 4 steel. Place this tile ADJACENT TO no other city tile. It provides adjacency bonus of 1 asteroid and 1 steel.',
      });
  }
}

================
File: cards/ares/DesperateMeasures.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {IGame} from '../../IGame';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {SelectSpace} from '../../inputs/SelectSpace';
import {TileType} from '../../../common/TileType';
import {AresHandler} from '../../ares/AresHandler';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';

export class DesperateMeasures extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.DESPERATE_MEASURES,
      cost: 1,
      victoryPoints: -2,

      metadata: {
        cardNumber: 'A04',
        description: 'Place a bronze cube on a dust storm tile and raise oxygen 1 step, or place a bronze cube on an erosion tile and raise the temperature 1 step. The hazard tile with the bronze cube cannot be removed.',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.RESOURCE_CUBE).asterix().br;
          b.temperature(1).slash().oxygen(1);
        }),
      },
    });
  }

  private getHazardTiles(game: IGame) {
    return game.board.spaces.filter((space) => AresHandler.hasHazardTile(space));
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    // You can't play desperate measures if there isn't a hazard marker in play.
    return this.getHazardTiles(player.game).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select a hazard space to protect', this.getHazardTiles(player.game))
      .andThen((space) => {
        if (space.tile === undefined) {
          throw new Error(`selected space ${space.id} without tile for DesperateMeasures`);
        }
        space.tile.protectedHazard = true;
        const tileType = space.tile.tileType;
        if (TileType.DUST_STORM_MILD === tileType || TileType.DUST_STORM_SEVERE === tileType) {
          player.game.increaseOxygenLevel(player, 1);
        } else {
        // is an erosion tile when the expression above is false.
          player.game.increaseTemperature(player, 1);
        }
        return undefined;
      });
  }
}

================
File: cards/ares/EcologicalSurvey.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {Resource} from '../../../common/Resource';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {SurveyCard} from './SurveyCard';
import {all} from '../Options';

export class EcologicalSurvey extends SurveyCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ECOLOGICAL_SURVEY,
      tags: [Tag.SCIENCE],
      cost: 9,

      requirements: {greeneries: 3, all},
      metadata: {
        description: 'Requires 3 greeneries on Mars.',
        cardNumber: 'A07',
        renderData: CardRenderer.builder((b) => {
          b.effect('When placing a tile grants you any plants, animals or microbes, you gain one additional of each of those resources that you gain.', (eb) => {
            eb.emptyTile().startEffect;
            eb.plus().plants(1).resource(CardResource.ANIMAL).resource(CardResource.MICROBE);
          });
        }),
      },
    });
  }

  protected checkForBonuses(cardOwner: IPlayer, space: Space) {
    super.maybeRewardStandardResource(cardOwner, space, Resource.PLANTS, SpaceBonus.PLANT);
    super.maybeRewardCardResource(cardOwner, space, CardResource.MICROBE, SpaceBonus.MICROBE);
    super.maybeRewardCardResource(cardOwner, space, CardResource.ANIMAL, SpaceBonus.ANIMAL);
  }
}

================
File: cards/ares/EcologicalZoneAres.ts
================
import {CardName} from '../../../common/cards/CardName';
import {EcologicalZone} from '../base/EcologicalZone';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';

export class EcologicalZoneAres extends EcologicalZone {
  constructor() {
    super(
      CardName.ECOLOGICAL_ZONE_ARES,
      11,
      {bonus: [SpaceBonus.ANIMAL]},
      {
        description: {
          text: 'Requires that YOU have a greenery tile. Place this tile adjacent to ANY greenery.',
          align: 'left',
        },
        cardNumber: 'A08',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an animal or plant tag INCLUDING THESE, add an animal to this card.', (eb) => {
            eb.tag(Tag.ANIMAL).slash().tag(Tag.PLANT).startEffect;
            eb.resource(CardResource.ANIMAL).tile(TileType.ECOLOGICAL_ZONE, false, true);
          }).br;
          b.vpText('The tile grants an ADJACENCY BONUS of 1 animal. 1 VP per 2 animals on this card.');
        }),
      },
    );
  }
}

================
File: cards/ares/GeologicalSurvey.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {SurveyCard} from './SurveyCard';
import {all, max} from '../Options';

export class GeologicalSurvey extends SurveyCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.GEOLOGICAL_SURVEY,
      tags: [Tag.SCIENCE],
      cost: 8,

      requirements: {greeneries: 5, all, max},
      metadata: {
        cardNumber: 'A09',
        renderData: CardRenderer.builder((b) => {
          b.effect('When placing a tile ON MARS grants you any steel, titanium, or heat, you gain one additional of each of those resources that you gain.', (eb) => {
            eb.emptyTile().startEffect;
            eb.plus().steel(1).titanium(1).heat(1);
          });
        }),
        description: 'Requires 5 or fewer greeneries on Mars.',
      },
    });
  }

  protected checkForBonuses(cardOwner: IPlayer, space: Space) {
    super.maybeRewardStandardResource(cardOwner, space, Resource.STEEL, SpaceBonus.STEEL);
    super.maybeRewardStandardResource(cardOwner, space, Resource.TITANIUM, SpaceBonus.TITANIUM);
    super.maybeRewardStandardResource(cardOwner, space, Resource.HEAT, SpaceBonus.HEAT);
  }
}

================
File: cards/ares/GreatDamAres.ts
================
import {CardName} from '../../../common/cards/CardName';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';
import {GreatDamPromo} from '../promo/GreatDamPromo';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';

export class GreatDamAres extends GreatDamPromo {
  constructor() {
    super(
      CardName.GREAT_DAM_ARES,
      {bonus: [SpaceBonus.ENERGY, SpaceBonus.ENERGY]},
      {
        cardNumber: 'A25',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2)).tile(TileType.GREAT_DAM, false, true).asterix();
        }),
        description: 'Requires 4 ocean tiles. Increase your energy production 2 steps. Place this tile ADJACENT TO an ocean tile. The tile grants an ADJACENCY BONUS of 2 Energy.',
      },
    );
  }
}

================
File: cards/ares/IndustrialCenterAres.ts
================
import {CardName} from '../../../common/cards/CardName';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {IndustrialCenter} from '../base/IndustrialCenter';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';

export class IndustrialCenterAres extends IndustrialCenter {
  constructor() {
    super(
      CardName.INDUSTRIAL_CENTER_ARES,
      {bonus: [SpaceBonus.STEEL]},
      {
        cardNumber: 'A10',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 7 M€ to increase your steel production 1 step.', (eb) => {
            eb.megacredits(7).startAction.production((pb) => pb.steel(1));
          }).br;
          b.tile(TileType.INDUSTRIAL_CENTER, false, true).asterix();
        }),
        description: 'Place this tile adjacent to a city tile. This tile grants an ADJACENCY BONUS of 1 steel.',
      });
  }
}

================
File: cards/ares/LavaFlowsAres.ts
================
import {CardName} from '../../../common/cards/CardName';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {LavaFlows} from '../base/LavaFlows';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';

export class LavaFlowsAres extends LavaFlows {
  constructor() {
    super(
      CardName.LAVA_FLOWS_ARES,
      {bonus: [SpaceBonus.HEAT, SpaceBonus.HEAT]},
      {
        cardNumber: 'A11',
        renderData: CardRenderer.builder((b) => {
          b.temperature(2).br;
          b.tile(TileType.LAVA_FLOWS, false, true);
        }),
        description: 'Raise temperature 2 steps and place this tile ON EITHER THARSIS THOLUS, ASCRAEUS MONS, PAVONIS MONS OR ARSIA MONS. This tile grants an ADJACENCY BONUS of 2 heat.',
      });
  }
}

================
File: cards/ares/MagneticFieldGeneratorsAres.ts
================
import {CardName} from '../../../common/cards/CardName';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {MagneticFieldGeneratorsPromo} from '../promo/MagneticFieldGeneratorsPromo';

export class MagneticFieldGeneratorsAres extends MagneticFieldGeneratorsPromo {
  constructor() {
    super(
      CardName.MAGNETIC_FIELD_GENERATORS_ARES,
      {bonus: [SpaceBonus.PLANT, SpaceBonus.MICROBE]},
      {
        cardNumber: 'Axx',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(4, {digit}).br;
            pb.plus().plants(2);
          }).br;
          b.tr(3, {digit});
          b.tile(TileType.MAGNETIC_FIELD_GENERATORS, false, true).asterix().br;
        }),
        description: 'Decrease your energy production 4 steps and increase your plant production 2 steps. Raise your TR 3 steps. Place this tile. It provides adjacency bonus of 1 plant and 1 microbe.',
      });
  }
}

================
File: cards/ares/MarketingExperts.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';

export class MarketingExperts extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MARKETING_EXPERTS,
      tags: [Tag.EARTH],
      cost: 5,

      behavior: {
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'A12',
        renderData: CardRenderer.builder((b) => {
          b.effect('When an ADJACENCY BONUS is collected from a tile you own, you gain 1 M€.', (eb) => {
            eb.emptyTile().emptyTile('golden').startEffect.megacredits(1);
          }).br;
          b.production((pb) => pb.megacredits(1));
        }),
        description: 'Increase your M€ production 1 step.',
      },
    });
  }
}

================
File: cards/ares/MetallicAsteroid.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {TileType} from '../../../common/TileType';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {all, digit} from '../Options';

export class MetallicAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.METALLIC_ASTEROID,
      tags: [Tag.SPACE],
      cost: 13,

      behavior: {
        stock: {titanium: 1},
        global: {temperature: 1},
        removeAnyPlants: 4,
        tile: {
          type: TileType.METALLIC_ASTEROID,
          on: 'land',
          adjacencyBonus: {bonus: [SpaceBonus.TITANIUM]},
        },
      },

      metadata: {
        cardNumber: 'A13',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1).titanium(1).br;
          b.minus().plants(4, {digit, all});
          b.tile(TileType.METALLIC_ASTEROID, false, true);
        }),
        description: 'Raise temperature 1 step and gain 1 titanium. Remove up to 4 plants from any player. Place this tile which grants an ADJACENCY BONUS of 1 titanium.',
      },
    });
  }
}

================
File: cards/ares/MiningAreaAres.ts
================
import {CardName} from '../../../common/cards/CardName';
import {MiningArea} from '../base/MiningArea';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';

export class MiningAreaAres extends MiningArea {
  protected override readonly isAres = true;
  constructor() {
    super(
      CardName.MINING_AREA_ARES,
      {
        cardNumber: 'A14',
        renderData: CardRenderer.builder((b) => {
          b.tile(TileType.MINING_STEEL_BONUS, false, true);
          b.tile(TileType.MINING_TITANIUM_BONUS, false, true).asterix().br;
          b.production((pb) => {
            pb.steel(1).or().titanium(1);
          }).asterix();
        }),
        description: 'Place one of these tiles on an area with a steel or titanium placement bonus, ADJACENT TO ANOTHER OF YOUR TILES. This tile provides an ADJACENCY BONUS of the same resource as the area. Increase your production of that resource 1 step.',
      });
  }
}

================
File: cards/ares/MiningRightsAres.ts
================
import {CardName} from '../../../common/cards/CardName';
import {MiningRights} from '../base/MiningRights';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';

export class MiningRightsAres extends MiningRights {
  protected override readonly isAres = true;

  constructor() {
    super(
      CardName.MINING_RIGHTS_ARES,
      {
        cardNumber: 'A15',
        renderData: CardRenderer.builder((b) => {
          b.tile(TileType.MINING_STEEL_BONUS, false, true);
          b.tile(TileType.MINING_TITANIUM_BONUS, false, true).asterix().br;
          b.production((pb) => {
            pb.steel(1).or().titanium(1);
          }).asterix();
        }),
        description: 'Place one of these tiles on an area with a steel or titanium placement bonus. This tile provides an ADJACENCY BONUS of the same resource as the area. Increase your production of that resource 1 step.',
      });
  }
}

================
File: cards/ares/MoholeAreaAres.ts
================
import {CardName} from '../../../common/cards/CardName';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {MoholeArea} from '../base/MoholeArea';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class MoholeAreaAres extends MoholeArea {
  constructor() {
    super(
      CardName.MOHOLE_AREA_ARES,
      {bonus: [SpaceBonus.HEAT, SpaceBonus.HEAT]},
      {
        cardNumber: 'A16',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(4, {digit})).br;
          b.tile(TileType.MOHOLE_AREA, false, true);
        }),
        description: 'Increase your heat production 4 steps. Place this tile ON AN AREA RESERVED FOR OCEAN. The tile grants an ADJACENCY BONUS of 2 heat.',
      });
  }
}

================
File: cards/ares/NaturalPreserveAres.ts
================
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {TileType} from '../../../common/TileType';
import {CardName} from '../../../common/cards/CardName';
import {NaturalPreserve} from '../base/NaturalPreserve';
import {CardRenderer} from '../render/CardRenderer';

export class NaturalPreserveAres extends NaturalPreserve {
  constructor() {
    super(
      CardName.NATURAL_PRESERVE_ARES,
      {bonus: [SpaceBonus.MEGACREDITS]},
      {
        cardNumber: 'A18',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1)).nbsp.tile(TileType.NATURAL_PRESERVE, false, true).asterix();
        }),
        description: 'Oxygen must be 4% or less. Place this tile NEXT TO NO OTHER TILE. The tile grants an ADJACENCY BONUS of of 1 M€. Increase your M€ production 1 step.',
      });
  }
}

================
File: cards/ares/NuclearZoneAres.ts
================
import {TileType} from '../../../common/TileType';
import {CardName} from '../../../common/cards/CardName';
import {NuclearZone} from '../base/NuclearZone';
import {CardRenderer} from '../render/CardRenderer';

export class NuclearZoneAres extends NuclearZone {
  constructor() {
    super(
      CardName.NUCLEAR_ZONE_ARES,
      11,
      {bonus: [], cost: 2},
      {
        cardNumber: 'A19',
        renderData: CardRenderer.builder((b) => {
          b.tile(TileType.NUCLEAR_ZONE, false, true).temperature(2);
        }),
        description: 'Raise the temperature two steps. Place this tile. Players must pay an additional 2M€ when they place a tile with their player marker on it ADJACENT to the Nuclear Zone.',
      });
  }
}

================
File: cards/ares/OceanCity.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {TileType} from '../../../common/TileType';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';

export class OceanCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.OCEAN_CITY,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 18,

      behavior: {
        production: {energy: -1, megacredits: 3},
        tile: {
          type: TileType.OCEAN_CITY,
          on: 'upgradeable-ocean',
        },
      },

      requirements: {oceans: 6},
      metadata: {
        cardNumber: 'A20',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          }).nbsp.tile(TileType.OCEAN_CITY, false, true);
        }),
        description: 'Requires 6 ocean tiles. Decrease your energy production 1 step and increase your M€ production 3 steps. Place this tile on top of an existing ocean tile, IGNORING NORMAL PLACEMENT RESTRICTIONS FOR CITIES. The tile counts as a city as well as an ocean.',
      },
    });
  }
}

================
File: cards/ares/OceanFarm.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {TileType} from '../../../common/TileType';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';

export class OceanFarm extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.OCEAN_FARM,
      tags: [Tag.PLANT, Tag.BUILDING],
      cost: 15,

      behavior: {
        production: {plants: 1, heat: 1},
        tile: {
          type: TileType.OCEAN_FARM,
          on: 'upgradeable-ocean',
          adjacencyBonus: {bonus: [SpaceBonus.PLANT]},
        },
      },

      requirements: {oceans: 4},
      metadata: {
        cardNumber: 'A21',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.heat(1).br;
            pb.plants(1);
          }).nbsp.tile(TileType.OCEAN_FARM, false, true);
        }),
        description: 'Requires 4 ocean tiles. Increase your heat production 1 step and increase your plant production 1 step. Place this tile on top of an existing ocean tile. The tile grants an ADJACENCY BONUS of 1 plant.',
      },
    });
  }
}

================
File: cards/ares/OceanSanctuary.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {TileType} from '../../../common/TileType';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {IProjectCard} from '../IProjectCard';

export class OceanSanctuary extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.OCEAN_SANCTUARY,
      tags: [Tag.ANIMAL],
      cost: 9,
      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}},
      requirements: {oceans: 5},

      behavior: {
        addResources: 1,
        tile: {
          type: TileType.OCEAN_SANCTUARY,
          on: 'upgradeable-ocean',
          adjacencyBonus: {bonus: [SpaceBonus.ANIMAL]},
        },
      },

      metadata: {
        cardNumber: 'A22',
        renderData: CardRenderer.builder((b) => {
          b.tile(TileType.OCEAN_SANCTUARY, false, true).nbsp.resource(CardResource.ANIMAL).br;
          b.vpText('1 VP per animal on this card.');
        }),
        description: 'Requires 5 ocean tiles. Place this tile on top of an existing ocean tile. The tile grants an ADJACENCY BONUS of 1 animal. Add 1 animal to this card.',
      },
    });
  }
}

================
File: cards/ares/RestrictedAreaAres.ts
================
import {CardName} from '../../../common/cards/CardName';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {RestrictedArea} from '../base/RestrictedArea';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';

export class RestrictedAreaAres extends RestrictedArea {
  constructor() {
    super(
      CardName.RESTRICTED_AREA_ARES,
      {bonus: [SpaceBonus.DRAW_CARD]},
      {
        cardNumber: 'A24',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 M€ to draw a card.', (eb) => {
            eb.megacredits(2).startAction.cards(1);
          }).br;
          b.tile(TileType.RESTRICTED_AREA, false, true);
        }),
        description: 'Place this tile which grants an ADJACENCY BONUS of 1 card.',
      });
  }
}

================
File: cards/ares/SolarFarm.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {SelectSpace} from '../../inputs/SelectSpace';
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {TileType} from '../../../common/TileType';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {message} from '../../logs/MessageBuilder';
import {Units} from '../../../common/Units';

export class SolarFarm extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SOLAR_FARM,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 12,

      metadata: {
        cardNumber: 'A17',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.energy(1).slash().plants(1);
          }).asterix().nbsp.tile(TileType.SOLAR_FARM, false, true).br;
        }),
        description: 'Place this tile which grants an ADJACENCY BONUS of 2 energy. Increase your energy production 1 step for each plant resource on the area where you place the tile.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions): boolean {
    return player.game.board.getAvailableSpacesOnLand(player, canAffordOptions).length > 0;
  }

  public productionBox(player: IPlayer) {
    const space = player.game.board.getSpaceByTileCard(this.name);
    if (space === undefined) {
      throw new Error('Solar Farm space not found');
    }
    const plantsOnSpace = space.bonus.filter((b) => b === SpaceBonus.PLANT).length;
    return Units.of({energy: plantsOnSpace});
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace(message('Select space for ${0} tile', (b) => b.card(this)), player.game.board.getAvailableSpacesOnLand(player))
      .andThen((space) => {
        player.game.addTile(player, space, {
          tileType: TileType.SOLAR_FARM,
          card: this.name,
        });
        player.production.adjust(this.productionBox(player), {log: true});
        space.adjacency = {bonus: [SpaceBonus.ENERGY, SpaceBonus.ENERGY]};
        return undefined;
      });
  }
}

================
File: cards/ares/SurveyCard.ts
================
import {Card, StaticCardProperties} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {Resource} from '../../../common/Resource';
import {CardResource} from '../../../common/CardResource';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {GainResources} from '../../deferredActions/GainResources';
import {Phase} from '../../../common/Phase';
import {IProjectCard} from '../IProjectCard';
import {BoardType} from '../../boards/BoardType';
import {SpaceType} from '../../../common/boards/SpaceType';
import {PartyHooks} from '../../turmoil/parties/PartyHooks';
import {PartyName} from '../../../common/turmoil/PartyName';
import {Board} from '../../boards/Board';
import {AresHandler} from '../../ares/AresHandler';

/**
 * Abstraction for cards that give rewards based on tile placement.  (e.g. Ecological Survey, Geological Survey.)
 */
export abstract class SurveyCard extends Card implements IProjectCard {
  constructor(properties: StaticCardProperties) {
    super(properties);
  }

  /**
   * Returns true if this space yields an adjacency bonus.
   */
  private anyAdjacentSpaceGivesBonus(board: Board, space: Space, bonus: SpaceBonus): boolean {
    return board.getAdjacentSpaces(space).some((adj) => adj.adjacency?.bonus.includes(bonus));
  }

  /**
   * Returns true if the tile just placed gives a bonus of a given type.
   */
  private grantsBonusNow(space: Space, bonus: SpaceBonus) {
    return space.tile?.covers === undefined && space.bonus.includes(bonus);
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space, boardType: BoardType) {
    // Adjacency bonuses are only available on Mars.
    if (boardType !== BoardType.MARS) {
      return;
    }
    if (cardOwner.game.phase === Phase.SOLAR || cardOwner.id !== activePlayer.id) {
      return;
    }

    this.checkForBonuses(cardOwner, space);
  }

  protected abstract checkForBonuses(cardOwner: IPlayer, space: Space): void;

  private log(cardOwner: IPlayer, resource: Resource | CardResource): void {
    cardOwner.game.log(
      '${0} gained a bonus ${1} because of ${2}',
      (b) => b.player(cardOwner).string(resource).cardName(this.name));
  }

  /**
   * Optionally grants a unit of `resource` (which matches `bonus`) based on `cardOwner` having placed a tile on `space`.
   */
  protected maybeRewardStandardResource(cardOwner: IPlayer, space: Space, resource: Resource, bonus: SpaceBonus): void {
    const board = cardOwner.game.board;
    let grant = this.grantsBonusNow(space, bonus) || this.anyAdjacentSpaceGivesBonus(board, space, bonus);
    if (!grant) {
      switch (resource) {
      case Resource.STEEL:
        grant = space.spaceType !== SpaceType.COLONY &&
            PartyHooks.shouldApplyPolicy(cardOwner, PartyName.MARS, 'mfp01');
        break;
      case Resource.PLANTS:
        grant = Board.isUncoveredOceanSpace(space) &&
          cardOwner.cardIsInEffect(CardName.ARCTIC_ALGAE);
      }
    }
    if (grant) {
      cardOwner.game.defer(new GainResources(cardOwner, resource).andThen(() => this.log(cardOwner, resource)));
    }
  }

  /**
   * Optionally grants a unit of `resource` (which matches `bonus`) based on `cardOwner` having placed a tile on `space`.
   */
  protected maybeRewardCardResource(cardOwner: IPlayer, space: Space, resource: CardResource, bonus: SpaceBonus) {
    const board = cardOwner.game.board;
    if (cardOwner.playedCards.some((card) => card.resourceType === resource) &&
        (this.grantsBonusNow(space, bonus) || AresHandler.anyAdjacentSpaceGivesBonus(board, space, bonus))) {
      cardOwner.game.defer(new AddResourcesToCard(
        cardOwner,
        resource,
        {log: false}))
        .andThen(() => this.log(cardOwner, resource));
    }
  }
}

================
File: cards/base/AcquiredCompany.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class AcquiredCompany extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ACQUIRED_COMPANY,
      tags: [Tag.EARTH],
      cost: 10,

      behavior: {
        production: {megacredits: 3},
      },

      metadata: {
        description: 'Increase your M€ production 3 steps.',
        cardNumber: '106',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.megacredits(3))),
      },
    });
  }
}

================
File: cards/base/AdaptationTechnology.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class AdaptationTechnology extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ADAPTATION_TECHNOLOGY,
      tags: [Tag.SCIENCE],
      cost: 12,
      victoryPoints: 1,
      globalParameterRequirementBonus: {steps: 2},

      metadata: {
        cardNumber: '153',
        renderData: CardRenderer.builder((b) => {
          b.effect('Your global requirements are +2 or -2 steps, your choice in each case.', (eb) => {
            eb.plate('Global requirements').startEffect.text('+/- 2');
          });
        }),
      },
    });
  }
}

================
File: cards/base/AdaptedLichen.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class AdaptedLichen extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ADAPTED_LICHEN,
      tags: [Tag.PLANT],
      cost: 9,

      behavior: {
        production: {plants: 1},
      },

      metadata: {
        description: 'Increase your plant production 1 step.',
        cardNumber: '048',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.plants(1))),
      },
    });
  }
}

================
File: cards/base/AdvancedAlloys.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class AdvancedAlloys extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ADVANCED_ALLOYS,
      tags: [Tag.SCIENCE],
      cost: 9,

      behavior: {
        steelValue: 1,
        titanumValue: 1,
      },

      metadata: {
        cardNumber: '071',
        renderData: CardRenderer.builder((b) => {
          b.effect('Each titanium you have is worth 1 M€ extra.', (be) => {
            be.titanium(1).startEffect.plus(Size.SMALL).megacredits(1);
          }).br;
          b.effect('Each steel you have is worth 1 M€ extra.', (be) => {
            be.steel(1).startEffect.plus(Size.SMALL).megacredits(1);
          });
        }),
      },
    });
  }
}

================
File: cards/base/AdvancedEcosystems.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';

export class AdvancedEcosystems extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ADVANCED_ECOSYSTEMS,
      tags: [Tag.PLANT, Tag.MICROBE, Tag.ANIMAL],
      cost: 11,
      victoryPoints: 3,

      requirements: [{tag: Tag.PLANT}, {tag: Tag.ANIMAL}, {tag: Tag.MICROBE}],
      metadata: {
        description: 'Requires a plant tag, a microbe tag, and an animal tag.',
        cardNumber: '135',
      },
    });
  }
}

================
File: cards/base/AerobrakedAmmoniaAsteroid.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class AerobrakedAmmoniaAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.AEROBRAKED_AMMONIA_ASTEROID,
      tags: [Tag.SPACE],
      cost: 26,

      behavior: {
        production: {heat: 3, plants: 1},
        addResourcesToAnyCard: {count: 2, type: CardResource.MICROBE},
      },

      metadata: {
        description: 'Increase your heat production 3 steps and your plant production 1 step. Add 2 microbes to ANOTHER card.',
        cardNumber: '170',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.heat(3).br;
            pb.plants(1);
          }).br;
          b.resource(CardResource.MICROBE, 2).asterix();
        }),
      },
    });
  }
}

================
File: cards/base/AICentral.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class AICentral extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.AI_CENTRAL,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 21,

      behavior: {
        production: {energy: -1},
      },

      action: {
        drawCard: {count: 2},
      },

      victoryPoints: 1,

      requirements: {tag: Tag.SCIENCE, count: 3},
      metadata: {
        description: {
          text: 'Requires 3 science tags to play. Decrease your energy production 1 step.',
          align: 'left',
        },
        cardNumber: '208',
        renderData: CardRenderer.builder((b) => {
          b.action('Draw 2 cards.', (ab) => ab.empty().startAction.cards(2)).br;
          b.production((pb) => pb.minus().energy(1));
        }),
      },
    });
  }
}

================
File: cards/base/Algae.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Algae extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ALGAE,
      tags: [Tag.PLANT],
      cost: 10,

      behavior: {
        production: {plants: 2},
        stock: {plants: 1},
      },

      requirements: {oceans: 5},
      metadata: {
        description: 'Requires 5 ocean tiles. Gain 1 plant and increase your plant production 2 steps.',
        cardNumber: '047',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.plants(2)).plants(1)),
      },
    });
  }
}

================
File: cards/base/AntiGravityTechnology.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class AntiGravityTechnology extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ANTI_GRAVITY_TECHNOLOGY,
      tags: [Tag.SCIENCE],
      cost: 14,
      victoryPoints: 3,

      requirements: {tag: Tag.SCIENCE, count: 7},
      cardDiscount: {amount: 2},
      metadata: {
        description: 'Requires 7 science tags.',
        cardNumber: '150',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a card, you pay 2 M€ less for it.', (be) => be.empty().startEffect.megacredits(-2));
        }),
      },
    });
  }
}

================
File: cards/base/Ants.ts
================
import {IActionCard} from '../ICard';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {RemoveResourcesFromCard} from '../../deferredActions/RemoveResourcesFromCard';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class Ants extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ANTS,
      tags: [Tag.MICROBE],
      cost: 9,

      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {oxygen: 4},

      metadata: {
        cardNumber: '035',
        description: 'Requires 4% oxygen.',
        renderData: CardRenderer.builder((b) => {
          b.action('Remove 1 microbe from any card to add 1 to this card.', (eb) => {
            eb.resource(CardResource.MICROBE, {all}).startAction.resource(CardResource.MICROBE);
          }).br;
          b.vpText('1 VP per 2 microbes on this card.');
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    if (player.game.isSoloMode()) return true;
    return RemoveResourcesFromCard.getAvailableTargetCards(player, CardResource.MICROBE).length > 0;
  }

  public action(player: IPlayer) {
    player.game.defer(new RemoveResourcesFromCard(player, CardResource.MICROBE).andThen((response) => {
      if (response.proceed) {
        player.game.defer(new AddResourcesToCard(player, CardResource.MICROBE, {filter: (c) => c.name === this.name}));
      }
    }));
    return undefined;
  }
}

================
File: cards/base/AquiferPumping.ts
================
import {IActionCard} from '../ICard';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {PlaceOceanTile} from '../../deferredActions/PlaceOceanTile';
import {CardRenderer} from '../render/CardRenderer';
import {TITLES} from '../../inputs/titles';

export const OCEAN_COST = 8;
export class AquiferPumping extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.AQUIFER_PUMPING,
      tags: [Tag.BUILDING],
      cost: 18,

      metadata: {
        cardNumber: '187',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 8 M€ to place 1 ocean tile. STEEL MAY BE USED as if you were playing a building card.',
            (eb) => eb.megacredits(8).super((b) => b.steel(1)).startAction.oceans(1));
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.canAfford({cost: OCEAN_COST, steel: true, tr: {oceans: 1}});
  }
  public action(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 8, {canUseSteel: true, title: TITLES.payForCardAction(this.name)}))
      .andThen(() => player.game.defer(new PlaceOceanTile(player)));
    return undefined;
  }
}

================
File: cards/base/ArchaeBacteria.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {max} from '../Options';

export class ArchaeBacteria extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ARCHAEBACTERIA,
      tags: [Tag.MICROBE],
      cost: 6,

      behavior: {
        production: {plants: 1},
      },

      requirements: {temperature: -18, max},
      metadata: {
        description: 'It must be -18 C or colder. Increase your plant production 1 step.',
        cardNumber: '042',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.plants(1))),
      },
    });
  }
}

================
File: cards/base/ArcticAlgae.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {Priority} from '../../deferredActions/Priority';
import {GainResources} from '../../deferredActions/GainResources';
import {CardRenderer} from '../render/CardRenderer';
import {all, max} from '../Options';
import {Board} from '../../boards/Board';

export class ArcticAlgae extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ARCTIC_ALGAE,
      tags: [Tag.PLANT],
      cost: 12,

      behavior: {
        stock: {plants: 1},
      },

      requirements: {temperature: -12, max},
      metadata: {
        description: 'It must be -12 C or colder to play. Gain 1 plant.',
        cardNumber: '023',
        renderData: CardRenderer.builder((b) => {
          b.effect('When anyone places an ocean tile, gain 2 plants.', (be) => be.oceans(1, {all}).startEffect.plants(2)).br;
          b.plants(1);
        }),
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (Board.isUncoveredOceanSpace(space)) {
      cardOwner.game.defer(
        new GainResources(cardOwner, Resource.PLANTS, {count: 2}).andThen(() => activePlayer.game.log(
          '${0} gained 2 ${1} from ${2}',
          (b) => b.player(cardOwner).string(Resource.PLANTS).cardName(this.name))),
        cardOwner.id !== activePlayer.id ? Priority.OPPONENT_TRIGGER : undefined);
    }
  }
}

================
File: cards/base/ArtificialLake.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class ArtificialLake extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ARTIFICIAL_LAKE,
      tags: [Tag.BUILDING],
      cost: 15,
      victoryPoints: 1,

      behavior: {
        ocean: {on: 'land'},
      },

      requirements: {temperature: -6},
      metadata: {
        description: 'Requires -6 C or warmer. Place 1 ocean tile ON AN AREA NOT RESERVED FOR OCEAN.',
        cardNumber: '116',
        renderData: CardRenderer.builder((b) => b.oceans(1).asterix()),
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions) {
    // This is not covered in executor.
    if (!player.game.canAddOcean()) return true; // Card is playable, it just has no effect.
    return player.game.board.getAvailableSpacesOnLand(player, canAffordOptions).length > 0;
  }
}

================
File: cards/base/ArtificialPhotosynthesis.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class ArtificialPhotosynthesis extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ARTIFICIAL_PHOTOSYNTHESIS,
      tags: [Tag.SCIENCE],
      cost: 12,

      behavior: {
        or: {
          autoSelect: true,
          behaviors: [
            {
              production: {energy: 2},
              title: 'Increase your energy production 2 steps',
            },
            {
              production: {plants: 1},
              title: 'Increase your plant production 1 step',
            },
          ],
        },
      },

      metadata: {
        description: 'Increase your plant production 1 step or your energy production 2 steps.',
        cardNumber: '115',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.plants(1).or(Size.SMALL).energy(2))),
      },
    });
  }
}

================
File: cards/base/Asteroid.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class Asteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ASTEROID,
      tags: [Tag.SPACE],
      cost: 14,

      behavior: {
        stock: {titanium: 2},
        global: {temperature: 1},
        removeAnyPlants: 3,
      },

      metadata: {
        description: 'Raise temperature 1 step and gain 2 titanium. Remove up to 3 plants from any player.',
        cardNumber: '009',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1).br;
          b.titanium(2).br;
          b.minus().plants(-3, {all});
        }),
      },
    });
  }
}

================
File: cards/base/AsteroidMining.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class AsteroidMining extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ASTEROID_MINING,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 30,
      victoryPoints: 2,

      behavior: {
        production: {titanium: 2},
      },

      metadata: {
        description: 'Increase your titanium production 2 steps.',
        cardNumber: '040',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.titanium(2))),
      },
    });
  }
}

================
File: cards/base/AsteroidMiningConsortium.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {DecreaseAnyProduction} from '../../deferredActions/DecreaseAnyProduction';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {GainProduction} from '../../deferredActions/GainProduction';

export class AsteroidMiningConsortium extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ASTEROID_MINING_CONSORTIUM,
      tags: [Tag.JOVIAN],
      cost: 13,
      victoryPoints: 1,

      requirements: {production: Resource.TITANIUM, count: 1},
      metadata: {
        description: 'Requires that you have titanium production. Decrease any titanium production 1 step and increase your own 1 step.',
        cardNumber: '002',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().titanium(-1, {all}).br;
            pb.plus().titanium(1);
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new DecreaseAnyProduction(
      player,
      Resource.TITANIUM,
      {count: 1, stealing: true},
    ));
    player.game.defer(new GainProduction(player, Resource.TITANIUM, {count: 1, log: false}));
    return undefined;
  }
}

================
File: cards/base/BeamFromAThoriumAsteroid.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class BeamFromAThoriumAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BEAM_FROM_A_THORIUM_ASTEROID,
      tags: [Tag.JOVIAN, Tag.SPACE, Tag.POWER],
      cost: 32,
      victoryPoints: 1,

      behavior: {
        production: {heat: 3, energy: 3},
      },

      requirements: {tag: Tag.JOVIAN},
      metadata: {
        cardNumber: '058',
        description: 'Requires a Jovian tag. Increase your heat production and energy production 3 steps each.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.heat(3).br;
            pb.energy(3);
          });
        }),
      },
    });
  }
}

================
File: cards/base/BigAsteroid.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {all} from '../Options';

export class BigAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.BIG_ASTEROID,
      tags: [Tag.SPACE],
      cost: 27,

      behavior: {
        stock: {titanium: 4},
        global: {temperature: 2},
        removeAnyPlants: 4,
      },

      metadata: {
        description: 'Raise temperature 2 steps and gain 4 titanium. Remove up to 4 plants from any player.',
        cardNumber: '011',
        renderData: CardRenderer.builder((b) => {
          b.temperature(2).br;
          b.titanium(4).br;
          b.minus().plants(-4, {all});
        }),
      },
    });
  }
}

================
File: cards/base/BiomassCombustors.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class BiomassCombustors extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BIOMASS_COMBUSTORS,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 4,
      victoryPoints: -1,

      // This might not work for Robotic Workforce yet.
      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 1},
        production: {energy: 2},
      },

      requirements: {oxygen: 6},
      metadata: {
        description: 'Requires 6% oxygen. Decrease any plant production 1 step and increase your energy production 2 steps.',
        cardNumber: '183',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().plants(-1, {all}).br;
            pb.plus().energy(2);
          });
        }),
      },
    });
  }
}

================
File: cards/base/Birds.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {Resource} from '../../../common/Resource';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class Birds extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.BIRDS,
      tags: [Tag.ANIMAL],
      cost: 10,

      resourceType: CardResource.ANIMAL,
      requirements: {oxygen: 13},
      victoryPoints: {resourcesHere: {}},

      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 2},
      },

      action: {
        addResources: 1,
      },

      metadata: {
        cardNumber: '072',
        description: 'Requires 13% oxygen. Decrease any plant production 2 steps. 1 VP per animal on this card.',
        renderData: CardRenderer.builder((b) => {
          b.action('Add an animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.production((pb) => {
            pb.minus().plants(-2, {all});
          });
        }),
      },
    });
  }
}

================
File: cards/base/BlackPolarDust.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class BlackPolarDust extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BLACK_POLAR_DUST,
      cost: 15,

      behavior: {
        ocean: {},
        production: {megacredits: -2, heat: 3},
      },

      metadata: {
        cardNumber: '022',
        description: 'Place an ocean tile. Decrease your M€ production 2 steps and increase your heat production 3 steps.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().megacredits(2).br;
            pb.plus().heat(3);
          }).oceans(1);
        }),
      },
    });
  }
}

================
File: cards/base/BreathingFilters.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';

export class BreathingFilters extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BREATHING_FILTERS,
      tags: [Tag.SCIENCE],
      cost: 11,
      victoryPoints: 2,

      requirements: {oxygen: 7},
      metadata: {
        description: 'Requires 7% oxygen.',
        cardNumber: '114',
      },
    });
  }
}

================
File: cards/base/BribedCommittee.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class BribedCommittee extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.BRIBED_COMMITTEE,
      tags: [Tag.EARTH],
      cost: 7,
      victoryPoints: -2,

      behavior: {
        tr: 2,
      },

      metadata: {
        cardNumber: '112',
        description: 'Raise your TR 2 steps.',
        renderData: CardRenderer.builder((b) => b.tr(2)),
      },
    });
  }
}

================
File: cards/base/BuildingIndustries.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class BuildingIndustries extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BUILDING_INDUSTRIES,
      tags: [Tag.BUILDING],
      cost: 6,

      behavior: {
        production: {energy: -1, steel: 2},
      },

      metadata: {
        cardNumber: '065',
        description: 'Decrease your energy production 1 step and increase your steel production 2 steps.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().steel(2);
          });
        }),
      },
    });
  }
}

================
File: cards/base/Bushes.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Bushes extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BUSHES,
      tags: [Tag.PLANT],
      cost: 10,

      behavior: {
        production: {plants: 2},
        stock: {plants: 2},
      },

      requirements: {temperature: -10},
      metadata: {
        cardNumber: '093',
        description: 'Requires -10 C or warmer. Increase your plant production 2 steps. Gain 2 plants.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.plants(2);
          }).plants(2);
        }),
      },
    });
  }
}

================
File: cards/base/BusinessContacts.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class BusinessContacts extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.BUSINESS_CONTACTS,
      tags: [Tag.EARTH],
      cost: 7,

      behavior: {
        drawCard: {count: 4, keep: 2},
      },

      metadata: {
        cardNumber: '111',
        renderData: CardRenderer.builder((b) => b.text('Look at the top 4 cards from the deck. Take 2 of them into hand and discard the other 2.', Size.SMALL, true)),
      },
    });
  }
}

================
File: cards/base/BusinessNetwork.ts
================
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class BusinessNetwork extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.BUSINESS_NETWORK,
      tags: [Tag.EARTH],
      cost: 4,
      behavior: {
        production: {megacredits: -1},
      },

      action: {
        drawCard: {count: 1, pay: true},
      },

      metadata: {
        cardNumber: '110',
        description: 'Decrease your M€ production 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.action(undefined, (eb) => eb.empty().startAction.empty()).text('Action: Look at the top card and either buy it or discard it', Size.SMALL, true).br;
          b.production((pb) => pb.megacredits(-1));
        }),
      },
    });
  }
}

================
File: cards/base/CallistoPenalMines.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class CallistoPenalMines extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CALLISTO_PENAL_MINES,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 24,
      victoryPoints: 2,

      behavior: {
        production: {megacredits: 3},
      },

      metadata: {
        description: 'Increase your M€ production 3 steps.',
        cardNumber: '082',
        renderData: CardRenderer.builder((b) => b.production((pb) => {
          pb.megacredits(3);
        })),
      },
    });
  }
}

================
File: cards/base/Capital.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {TileType} from '../../../common/TileType';
import {CardName} from '../../../common/cards/CardName';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';
import {Board} from '../../boards/Board';
import {CardMetadata} from '../../../common/cards/CardMetadata';
import {CardRenderer} from '../render/CardRenderer';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';

export class Capital extends Card implements IProjectCard {
  constructor(
    name = CardName.CAPITAL,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata: CardMetadata = {
      cardNumber: '008',
      description: {
        text: 'Requires 4 ocean tiles. Place this tile. Decrease your energy production 2 steps and increase your M€ production 5 steps.',
        align: 'left',
      },
      renderData: CardRenderer.builder((b) => {
        b.production((pb) => {
          pb.minus().energy(2).br;
          pb.plus().megacredits(5);
        }).nbsp.tile(TileType.CAPITAL, false).br;
        b.vpText('1 additional VP for each ocean tile adjacent to this city tile.');
      }),
      victoryPoints: CardRenderDynamicVictoryPoints.oceans(1, 1),
    },
  ) {
    super({
      type: CardType.AUTOMATED,
      name,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 26,

      behavior: {
        production: {energy: -2, megacredits: 5},
        tile: {
          type: TileType.CAPITAL,
          on: 'city',
          title: 'Select space for special city tile',
          adjacencyBonus: adjacencyBonus,
        },
      },

      requirements: {oceans: 4},
      victoryPoints: 'special',
      metadata,
    });
  }
  public override getVictoryPoints(player: IPlayer) {
    const usedSpace = player.game.board.getSpaceByTileCard(this.name);
    if (usedSpace !== undefined) {
      return player.game.board.getAdjacentSpaces(usedSpace)
        .filter((s) => Board.isOceanSpace(s)).length;
    }
    return 0;
  }
}

================
File: cards/base/CarbonateProcessing.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class CarbonateProcessing extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CARBONATE_PROCESSING,
      tags: [Tag.BUILDING],
      cost: 6,

      behavior: {
        production: {energy: -1, heat: 3},
      },

      metadata: {
        cardNumber: '043',
        description: 'Decrease your energy production 1 step and increase your heat production 3 steps.',
        renderData: CardRenderer.builder((b) => b.production((pb) => {
          pb.minus().energy(1).br;
          pb.plus().heat(3);
        })),
      },
    });
  }
}

================
File: cards/base/CaretakerContract.ts
================
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class CaretakerContract extends ActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CARETAKER_CONTRACT,
      cost: 3,
      requirements: {temperature: 0},

      action: {
        spend: {heat: 8},
        tr: 1,
      },

      metadata: {
        cardNumber: '154',
        description: 'Requires 0° C or warmer.',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 8 heat to increase your terraform rating 1 step.', (eb) => {
            eb.heat(8).startAction.tr(1);
          });
        }),
      },
    });
  }
}

================
File: cards/base/Cartel.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Cartel extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CARTEL,
      tags: [Tag.EARTH],
      cost: 8,

      behavior: {
        production: {megacredits: {tag: Tag.EARTH}},
      },

      metadata: {
        cardNumber: '137',
        description: 'Increase your M€ production 1 step for each Earth tag you have, including this.',
        renderData: CardRenderer.builder((b) => b.production((pb) => {
          pb.megacredits(1).slash().tag(Tag.EARTH);
        })),
      },
    });
  }
}

================
File: cards/base/CEOsFavoriteProject.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class CEOsFavoriteProject extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.CEOS_FAVORITE_PROJECT,
      cost: 1,

      behavior: {
        addResourcesToAnyCard: {
          count: 1,
          min: 1,
          mustHaveCard: true,
          robotCards: true,
        },
      },

      metadata: {
        cardNumber: '149',
        renderData: CardRenderer.builder((b) => b.text('Add 1 resource to a card with at least 1 resource on it', Size.SMALL, true)),
      },
    });
  }
}

================
File: cards/base/CloudSeeding.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class CloudSeeding extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CLOUD_SEEDING,
      cost: 11,

      behavior: {
        production: {megacredits: -1, plants: 2},
        decreaseAnyProduction: {type: Resource.HEAT, count: 1},
      },

      requirements: {oceans: 3},
      metadata: {
        cardNumber: '004',
        description: 'Requires 3 ocean tiles. Decrease your M€ production 1 step and any heat production 1 step. Increase your plant production 2 steps.',
        renderData: CardRenderer.builder((b) => b.production((pb) => {
          pb.minus().megacredits(1).heat(1, {all}).br;
          pb.plus().plants(2);
        })),
      },
    });
  }
}

================
File: cards/base/ColonizerTrainingCamp.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {max} from '../Options';

export class ColonizerTrainingCamp extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.COLONIZER_TRAINING_CAMP,
      tags: [Tag.JOVIAN, Tag.BUILDING],
      cost: 8,
      victoryPoints: 2,

      requirements: {oxygen: 5, max},
      metadata: {
        description: 'Oxygen must be 5% or less.',
        cardNumber: '001',
      },
    });
  }
}

================
File: cards/base/Comet.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class Comet extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.COMET,
      tags: [Tag.SPACE],
      cost: 21,

      behavior: {
        global: {temperature: 1},
        ocean: {},
        removeAnyPlants: 3,
      },

      metadata: {
        cardNumber: '010',
        description: 'Raise temperature 1 step and place an ocean tile. Remove up to 3 plants from any player.',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1).oceans(1).br;
          b.minus().plants(-3, {all});
        }),
      },
    });
  }
}

================
File: cards/base/CommercialDistrict.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {TileType} from '../../../common/TileType';
import {CardName} from '../../../common/cards/CardName';
import {Board} from '../../boards/Board';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';
import {CardRenderer} from '../render/CardRenderer';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';

export class CommercialDistrict extends Card implements IProjectCard {
  constructor(
    name = CardName.COMMERCIAL_DISTRICT,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: '085',
      description: 'Place this tile. Decrease your energy production 1 step and increase your M€ production 4 steps.',
      renderData: CardRenderer.builder((b) => {
        b.production((pb) => {
          pb.minus().energy(1).br;
          pb.plus().megacredits(4).br;
        }).nbsp.nbsp.tile(TileType.COMMERCIAL_DISTRICT, true).br;
        b.vpText('1 VP per adjacent city tile.');
      }),
      victoryPoints: CardRenderDynamicVictoryPoints.cities(1, 1, true, true),
    },
  ) {
    super({
      type: CardType.AUTOMATED,
      name,
      tags: [Tag.BUILDING],
      cost: 16,
      adjacencyBonus,

      behavior: {
        production: {energy: -1, megacredits: 4},
        tile: {
          type: TileType.COMMERCIAL_DISTRICT,
          on: 'land',
          adjacencyBonus: adjacencyBonus,
        },
      },

      victoryPoints: 'special',
      metadata,
    });
  }

  public override getVictoryPoints(player: IPlayer) {
    const usedSpace = player.game.board.getSpaceByTileCard(this.name);
    if (usedSpace !== undefined) {
      return player.game.board.getAdjacentSpaces(usedSpace).filter(
        (adjacentSpace) => Board.isCitySpace(adjacentSpace),
      ).length;
    }
    return 0;
  }
}

================
File: cards/base/ConvoyFromEuropa.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class ConvoyFromEuropa extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.CONVOY_FROM_EUROPA,
      tags: [Tag.SPACE],
      cost: 15,

      behavior: {
        ocean: {},
        drawCard: 1,
      },

      metadata: {
        cardNumber: '161',
        description: 'Place 1 ocean tile and draw 1 card.',
        renderData: CardRenderer.builder((b) => b.oceans(1).cards(1)),
      },
    });
  }
}

================
File: cards/base/CorporateStronghold.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class CorporateStronghold extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CORPORATE_STRONGHOLD,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 11,

      behavior: {
        production: {energy: -1, megacredits: 3},
        city: {},
      },
      victoryPoints: -2,

      metadata: {
        cardNumber: '182',
        description: 'Decrease your energy production 1 step and increase your M€ production 3 steps. Place a city tile.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          }).nbsp.nbsp.city();
        }),
      },
    });
  }
}

================
File: cards/base/CupolaCity.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {max} from '../Options';

export class CupolaCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CUPOLA_CITY,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 16,

      behavior: {
        production: {energy: -1, megacredits: 3},
        city: {},
      },

      requirements: {oxygen: 9, max},
      metadata: {
        cardNumber: '029',
        description: 'Oxygen must be 9% or less. Place a city tile. Decrease your energy production 1 step and increase your M€ production 3 steps.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          }).nbsp.nbsp.city();
        }),
      },
    });
  }
}

================
File: cards/base/Decomposers.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Phase} from '../../../common/Phase';

export class Decomposers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.DECOMPOSERS,
      tags: [Tag.MICROBE],
      cost: 5,

      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 3},
      requirements: {oxygen: 3},

      metadata: {
        cardNumber: '131',
        description: 'Requires 3% oxygen.',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an animal, plant, or microbe tag, including this, add a microbe to this card.', (be) => {
            be.tag(Tag.ANIMAL).slash();
            be.tag(Tag.PLANT).slash();
            be.tag(Tag.MICROBE);
            be.startEffect.resource(CardResource.MICROBE);
          }).br;
          b.vpText('1 VP per 3 microbes on this card.');
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const qty = player.tags.cardTagCount(card, [Tag.ANIMAL, Tag.PLANT, Tag.MICROBE]);
    player.addResourceTo(this, {qty, log: true});
  }
  public override bespokePlay(player: IPlayer) {
    // Get two extra microbes from EcoExperts if played during prelude while having just played EcoExperts
    if (player.game.phase === Phase.PRELUDES && player.playedCards.length > 0 && player.playedCards[player.playedCards.length-1].name === CardName.ECOLOGY_EXPERTS) {
      player.addResourceTo(this, {qty: 2, log: true});
    }
    return undefined;
  }
}

================
File: cards/base/DeepWellHeating.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class DeepWellHeating extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DEEP_WELL_HEATING,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 13,

      behavior: {
        production: {energy: 1},
        global: {temperature: 1},
      },

      metadata: {
        cardNumber: '003',
        description: 'Increase your energy production 1 step. Increase temperature 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1)).temperature(1);
        }),
      },
    });
  }
}

================
File: cards/base/DeimosDown.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class DeimosDown extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.DEIMOS_DOWN,
      tags: [Tag.SPACE],
      cost: 31,

      behavior: {
        stock: {steel: 4},
        global: {temperature: 3},
        removeAnyPlants: 8,
      },

      metadata: {
        cardNumber: '039',
        description: 'Raise temperature 3 steps and gain 4 steel. Remove up to 8 plants from any player.',
        renderData: CardRenderer.builder((b) => {
          b.temperature(3).br;
          b.steel(4).br;
          b.minus().plants(-8, {all});
        }),
      },
    });
  }
}

================
File: cards/base/DesignedMicroOrganisms.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {max} from '../Options';

export class DesignedMicroOrganisms extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DESIGNED_MICROORGANISMS,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      cost: 16,

      behavior: {
        production: {plants: 2},
      },

      requirements: {temperature: -14, max},
      metadata: {
        cardNumber: '155',
        description: 'It must be -14 C or colder. Increase your plant production 2 steps.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(2));
        }),
      },
    });
  }
}

================
File: cards/base/DevelopmentCenter.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class DevelopmentCenter extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.DEVELOPMENT_CENTER,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 11,

      action: {
        spend: {energy: 1},
        drawCard: 1,
      },

      metadata: {
        cardNumber: '014',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 energy to draw a card.', (eb) => {
            eb.energy(1).startAction.cards(1);
          });
        }),
      },
    });
  }
}

================
File: cards/base/DomedCrater.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit, max} from '../Options';

export class DomedCrater extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DOMED_CRATER,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 24,
      victoryPoints: 1,

      behavior: {
        production: {energy: -1, megacredits: 3},
        stock: {plants: 3},
        city: {},
      },

      requirements: {oxygen: 7, max},
      metadata: {
        cardNumber: 'T03',
        description: {
          text: 'Oxygen must be 7% or less. Gain 3 plants. Place a city tile. Decrease your energy production 1 step and increase your M€ production 3 steps.',
          align: 'left',
        },
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          }).nbsp.city().plants(3, {digit}).br;
        }),
      },
    });
  }
}

================
File: cards/base/DustSeals.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {max} from '../Options';

export class DustSeals extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DUST_SEALS,
      cost: 2,
      victoryPoints: 1,

      requirements: {oceans: 3, max},
      metadata: {
        description: 'Requires 3 or less ocean tiles.',
        cardNumber: '119',
      },
    });
  }
}

================
File: cards/base/EarthCatapult.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class EarthCatapult extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.EARTH_CATAPULT,
      tags: [Tag.EARTH],
      cost: 23,
      victoryPoints: 2,

      cardDiscount: {amount: 2},
      metadata: {
        cardNumber: '070',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a card, you pay 2 M€ less for it.', (eb) => {
            eb.empty().startEffect.megacredits(-2);
          });
        }),
      },
    });
  }
}

================
File: cards/base/EarthOffice.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class EarthOffice extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.EARTH_OFFICE,
      tags: [Tag.EARTH],
      cost: 1,

      cardDiscount: {tag: Tag.EARTH, amount: 3},
      metadata: {
        cardNumber: '105',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an Earth tag, you pay 3 M€ less for it.', (eb) => {
            eb.tag(Tag.EARTH).startEffect.megacredits(-3);
          });
        }),
      },
    });
  }
}

================
File: cards/base/EcologicalZone.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {TileType} from '../../../common/TileType';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Space} from '../../boards/Space';
import {CardName} from '../../../common/cards/CardName';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';
import {CardMetadata} from '../../../common/cards/CardMetadata';
import {CardRenderer} from '../render/CardRenderer';
import {Phase} from '../../../common/Phase';
import {Board} from '../../boards/Board';

export class EcologicalZone extends Card implements IProjectCard {
  constructor(
    name = CardName.ECOLOGICAL_ZONE,
    cost = 12,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata: CardMetadata = {
      description: {
        text: 'Requires that YOU have a greenery tile. Place this tile adjacent to ANY greenery.',
        align: 'left',
      },
      cardNumber: '128',
      renderData: CardRenderer.builder((b) => {
        b.effect('When you play an animal or plant tag INCLUDING THESE, add an animal to this card.', (eb) => {
          eb.tag(Tag.ANIMAL).slash().tag(Tag.PLANT).startEffect.resource(CardResource.ANIMAL);
        }).br;
        b.vpText('1 VP per 2 animals on this card.').tile(TileType.ECOLOGICAL_ZONE, true).asterix();
      }),
    },
  ) {
    super({
      type: CardType.ACTIVE,
      name,
      tags: [Tag.ANIMAL, Tag.PLANT],
      cost,
      resourceType: CardResource.ANIMAL,
      adjacencyBonus,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {greeneries: 1},
      metadata,
    });
  }


  private getAvailableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): Array<Space> {
    return player.game.board.getAvailableSpacesOnLand(player, canAffordOptions)
      .filter((space) => player.game.board.getAdjacentSpaces(space).filter(Board.isGreenerySpace).length > 0);
  }
  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions): boolean {
    return this.getAvailableSpaces(player, canAffordOptions).length > 0;
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const qty = player.tags.cardTagCount(card, [Tag.ANIMAL, Tag.PLANT]);
    player.addResourceTo(this, {qty, log: true});
  }
  public override bespokePlay(player: IPlayer) {
    // Get one extra animal from EcoExperts if played during prelude while having just played EcoExperts
    if (player.game.phase === Phase.PRELUDES && player.playedCards.length > 0 && player.playedCards[player.playedCards.length-1].name === CardName.ECOLOGY_EXPERTS) {
      player.addResourceTo(this, {qty: 1, log: true});
    }

    return new SelectSpace('Select space next to greenery for special tile', this.getAvailableSpaces(player))
      .andThen((space) => {
        player.game.addTile(player, space, {
          tileType: TileType.ECOLOGICAL_ZONE,
        });
        space.adjacency = this.adjacencyBonus;
        return undefined;
      });
  }
}

================
File: cards/base/ElectroCatapult.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {max} from '../Options';

export class ElectroCatapult extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ELECTRO_CATAPULT,
      tags: [Tag.BUILDING],
      cost: 17,

      behavior: {
        production: {energy: -1},
      },

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 1 plant to gain 7 M€.',
            spend: {plants: 1},
            stock: {megacredits: 7},
          },
          {
            title: 'Spend 1 steel to gain 7 M€.',
            spend: {steel: 1},
            stock: {megacredits: 7},
          }],
        },
      },

      victoryPoints: 1,

      requirements: {oxygen: 8, max},
      metadata: {
        cardNumber: '069',
        description: {
          text: 'Oxygen must be 8% or less. Decrease your energy production 1 step.',
          align: 'left',
        },
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 plant or 1 steel to gain 7 M€.', (eb) => {
            eb.plants(1).slash().steel(1).startAction.megacredits(7);
          }).br;
          b.production((pb) => pb.minus().energy(1));
        }),
      },
    });
  }

  // KEEP THIS
  // private log(player: Player, resource: Resources) {
  //   player.game.log('${0} spent 1 ${1} to gain 7 M€', (b) => b.player(player).string(resource));
  // }
}

================
File: cards/base/EnergySaving.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {Size} from '../../../common/cards/render/Size';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class EnergySaving extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ENERGY_SAVING,
      tags: [Tag.POWER],
      cost: 15,

      behavior: {
        production: {energy: {cities: {}}},
      },

      metadata: {
        cardNumber: '189',
        description: 'Increase your energy production 1 step for each city tile in play.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).slash().city({size: Size.SMALL, all}));
        }),
      },
    });
  }
}

================
File: cards/base/EnergyTapping.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {DecreaseAnyProduction} from '../../deferredActions/DecreaseAnyProduction';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {GainProduction} from '../../deferredActions/GainProduction';

export class EnergyTapping extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ENERGY_TAPPING,
      tags: [Tag.POWER],
      cost: 3,
      victoryPoints: -1,

      metadata: {
        cardNumber: '201',
        description: 'Decrease any energy production 1 step and increase your own 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1, {all}).br;
            pb.plus().energy(1);
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const gainProduction = new GainProduction(player, Resource.ENERGY, {count: 1, log: false});
    const decreaseAnyProduction = new DecreaseAnyProduction(player, Resource.ENERGY, {count: 1, stealing: true});
    // If no player has energy production, then This Player must gain their energy production in order to lose it.
    if (player.game.getPlayers().filter((player) => player.production.energy > 0).length === 0) {
      player.game.defer(gainProduction).andThen(() => player.game.defer(decreaseAnyProduction));
    } else {
      player.game.defer(decreaseAnyProduction).andThen(() => player.game.defer(gainProduction));
    }
    return undefined;
  }
}

================
File: cards/base/EOSChasmaNationalPark.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';

export class EosChasmaNationalPark extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.EOS_CHASMA_NATIONAL_PARK,
      tags: [Tag.PLANT, Tag.BUILDING],
      cost: 16,
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 2},
        stock: {plants: 3},
        addResourcesToAnyCard: {count: 1, type: CardResource.ANIMAL},
      },

      requirements: {temperature: -12},
      metadata: {
        cardNumber: '026',
        description: 'Requires -12 C or warmer. Add 1 animal TO ANY ANIMAL CARD. Gain 3 plants. Increase your M€ production 2 steps.',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.ANIMAL).asterix().plants(3).br;
          b.production((pb) => pb.megacredits(2));
        }),
      },
    });
  }
}

================
File: cards/base/EquatorialMagnetizer.ts
================
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class EquatorialMagnetizer extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.EQUATORIAL_MAGNETIZER,
      tags: [Tag.BUILDING],
      cost: 11,

      action: {
        production: {energy: -1},
        tr: 1,
      },

      metadata: {
        cardNumber: '015',
        renderData: CardRenderer.builder((b) => {
          b.action('Decrease your energy production 1 step to increase your terraform rating 1 step.', (eb) => {
            eb.production((pb) => pb.energy(1)).startAction.tr(1);
          });
        }),
      },
    });
  }
}

================
File: cards/base/ExtremeColdFungus.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectCard} from '../../inputs/SelectCard';
import {IProjectCard} from '../IProjectCard';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {max} from '../Options';
import {message} from '../../logs/MessageBuilder';

export class ExtremeColdFungus extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.EXTREME_COLD_FUNGUS,
      tags: [Tag.MICROBE],
      cost: 13,

      requirements: {temperature: -10, max},
      metadata: {
        cardNumber: '134',
        description: 'It must be -10 C or colder.',
        renderData: CardRenderer.builder((b) => {
          b.action('Gain 1 plant.', (eb) => {
            eb.empty().startAction.plants(1);
          }).br;
          b.or().br;
          b.action('Add 2 microbes to ANOTHER card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE, 2).asterix();
          });
        }),
      },
    });
  }
  public canAct(): boolean {
    return true;
  }
  public action(player: IPlayer) {
    const otherMicrobeCards = player.getResourceCards(CardResource.MICROBE);

    if (otherMicrobeCards.length === 0) {
      player.stock.add(Resource.PLANTS, 1, {log: true});
      return undefined;
    }

    const gainPlantOption = new SelectOption('Gain 1 plant', 'Gain plant').andThen(() => {
      player.stock.add(Resource.PLANTS, 1, {log: true});
      return undefined;
    });

    if (otherMicrobeCards.length === 1) {
      const targetCard = otherMicrobeCards[0];

      return new OrOptions(
        new SelectOption(message('Add ${0} microbes to ${1}', (b) => b.number(2).card(targetCard)), 'Add microbes').andThen(() => {
          player.addResourceTo(targetCard, {qty: 2, log: true});
          return undefined;
        }),
        gainPlantOption,
      );
    }

    return new OrOptions(
      new SelectCard(
        'Select card to add 2 microbes',
        'Add microbes',
        otherMicrobeCards)
        .andThen(([card]) => {
          player.addResourceTo(card, {qty: 2, log: true});
          return undefined;
        }),
      gainPlantOption,
    );
  }
}

================
File: cards/base/Farming.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Farming extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FARMING,
      tags: [Tag.PLANT],
      cost: 16,
      victoryPoints: 2,

      behavior: {
        production: {megacredits: 2, plants: 2},
        stock: {plants: 2},
      },

      requirements: {temperature: 4},
      metadata: {
        cardNumber: '118',
        description: 'Requires +4° C or warmer. Increase your M€ production 2 steps and your plant production 2 steps. Gain 2 plants.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(2).br;
            pb.plants(2);
          }).nbsp.plants(2);
        }),
      },
    });
  }
}

================
File: cards/base/Fish.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class Fish extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.FISH,
      tags: [Tag.ANIMAL],
      cost: 9,

      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 1},
      },

      action: {
        addResources: 1,
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}},
      requirements: {temperature: 2},

      metadata: {
        cardNumber: '052',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.production((pb) => pb.minus().plants(1, {all})).br;
          b.vpText('1 VP for each animal on this card.');
        }),
        description: {
          text: 'Requires +2 C° or warmer. Decrease any plant production 1 step.',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/base/Flooding.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {SelectPlayer} from '../../inputs/SelectPlayer';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {PlaceOceanTile} from '../../deferredActions/PlaceOceanTile';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class Flooding extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.FLOODING,
      cost: 7,
      tr: {oceans: 1},
      victoryPoints: -1,

      metadata: {
        cardNumber: '188',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).nbsp.minus().megacredits(4, {all}).asterix();
        }),
        description: 'Place an ocean tile. IF THERE ARE TILES ADJACENT TO THIS OCEAN TILE, YOU MAY REMOVE 4 M€ FROM THE OWNER OF ONE OF THOSE TILES.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    if (player.game.isSoloMode()) {
      game.defer(new PlaceOceanTile(player));
      return undefined;
    }

    game.defer(new PlaceOceanTile(player)).andThen((space) => {
      const adjacentPlayers: Set<IPlayer> = new Set();
      game.board.getAdjacentSpaces(space).forEach((space) => {
        if (space.player && space.player !== player && space.tile) {
          adjacentPlayers.add(space.player);
        }
      });

      // TODO(kberg) This has got to be a common thing, right? Reuse this, right?
      if (adjacentPlayers.size > 0) {
        return new OrOptions(
          new SelectPlayer(
            Array.from(adjacentPlayers),
            'Select adjacent player to remove 4 M€ from',
            'Remove credits',
          ).andThen((target) => {
            target.maybeBlockAttack(player, (proceed) => {
              if (proceed) {
                target.stock.deduct(Resource.MEGACREDITS, 4, {log: true, from: player});
              }
              return undefined;
            });
            return undefined;
          }),
          new SelectOption('Don\'t remove M€ from adjacent player'));
      }
      return undefined;
    });
    return undefined;
  }
}

================
File: cards/base/FoodFactory.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class FoodFactory extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FOOD_FACTORY,
      tags: [Tag.BUILDING],
      cost: 12,

      behavior: {
        production: {megacredits: 4, plants: -1},
      },
      victoryPoints: 1,

      metadata: {
        cardNumber: '041',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().plants(1).br;
            pb.plus().megacredits(4);
          });
        }),
        description: 'Decrease your plant production 1 step and increase your M€ production 4 steps.',
      },
    });
  }
}

================
File: cards/base/FueledGenerators.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class FueledGenerators extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FUELED_GENERATORS,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 1,

      behavior: {
        production: {energy: 1, megacredits: -1},
      },

      metadata: {
        cardNumber: '100',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().megacredits(1).br;
            pb.plus().energy(1);
          });
        }),
        description: 'Decrease your M€ production 1 step and increase your energy production 1 steps.',
      },
    });
  }
}

================
File: cards/base/FuelFactory.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class FuelFactory extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FUEL_FACTORY,
      tags: [Tag.BUILDING],
      cost: 6,

      behavior: {
        production: {energy: -1, megacredits: 1, titanium: 1},
      },

      metadata: {
        cardNumber: '180',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().titanium(1).megacredits(1);
          });
        }),
        description: 'Decrease your energy production 1 step and increase your titanium and your M€ production 1 step each.',
      },
    });
  }
}

================
File: cards/base/FusionPower.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class FusionPower extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FUSION_POWER,
      tags: [Tag.SCIENCE, Tag.POWER, Tag.BUILDING],
      cost: 14,

      behavior: {
        production: {energy: 3},
      },

      requirements: {tag: Tag.POWER, count: 2},
      metadata: {
        cardNumber: '132',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(3));
        }),
        description: 'Requires 2 power tags. Increase your energy production 3 steps.',
      },
    });
  }
}

================
File: cards/base/GanymedeColony.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {SpaceName} from '../../SpaceName';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class GanymedeColony extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GANYMEDE_COLONY,
      tags: [Tag.JOVIAN, Tag.SPACE, Tag.CITY],
      cost: 20,

      victoryPoints: {tag: Tag.JOVIAN},
      behavior: {
        city: {space: SpaceName.GANYMEDE_COLONY},
      },

      metadata: {
        description: 'Place a city tile ON THE RESERVED AREA.',
        cardNumber: '081',
        renderData: CardRenderer.builder((b) => {
          b.city().asterix().br;
          b.vpText('1 VP per Jovian tag you have.');
        }),
      },
    });
  }
}

================
File: cards/base/GeneRepair.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class GeneRepair extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GENE_REPAIR,
      tags: [Tag.SCIENCE],
      cost: 12,
      victoryPoints: 2,

      behavior: {
        production: {megacredits: 2},
      },

      requirements: {tag: Tag.SCIENCE, count: 3},
      metadata: {
        cardNumber: '091',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.megacredits(2))),
        description: 'Requires 3 science tags. Increase your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/base/GeothermalPower.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class GeothermalPower extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GEOTHERMAL_POWER,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 11,

      behavior: {
        production: {energy: 2},
      },

      metadata: {
        cardNumber: '117',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.energy(2))),
        description: 'Increase your energy production 2 steps.',
      },
    });
  }
}

================
File: cards/base/GHGFactories.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class GHGFactories extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GHG_FACTORIES,
      tags: [Tag.BUILDING],
      cost: 11,

      behavior: {
        production: {energy: -1, heat: 4},
      },

      metadata: {
        cardNumber: '126',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().heat(4, {digit});
          });
        }),
        description: 'Decrease your energy production 1 step and increase your heat production 4 steps.',
      },
    });
  }
}

================
File: cards/base/GHGProducingBacteria.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class GHGProducingBacteria extends ActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.GHG_PRODUCING_BACTERIA,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      cost: 8,
      resourceType: CardResource.MICROBE,

      requirements: {oxygen: 4},

      action: {
        or: {
          autoSelect: true,
          behaviors: [
            {
              spend: {resourcesHere: 2},
              global: {temperature: 1},
              title: 'Remove 2 microbes to raise temperature 1 step',
              // LogHelper.logRemoveResource(player, this, 2, 'raise temperature 1 step');
            },
            {
              addResources: 1,
              title: 'Add 1 microbe to this card',
            },
          ],
        },
      },

      metadata: {
        description: 'Requires 4% oxygen.',
        cardNumber: '034',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.or().br;
          b.action('Remove 2 microbes to raise temperature 1 step.', (eb) => {
            eb.resource(CardResource.MICROBE, 2).startAction.temperature(1);
          });
        }),
      },
    });
  }
}

================
File: cards/base/GiantIceAsteroid.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class GiantIceAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.GIANT_ICE_ASTEROID,
      tags: [Tag.SPACE],
      cost: 36,

      behavior: {
        global: {temperature: 2},
        removeAnyPlants: 6,
        ocean: {count: 2},
      },

      metadata: {
        description: 'Raise temperature 2 steps and place 2 ocean tiles. Remove up to 6 plants from any player.',
        cardNumber: '080',
        renderData: CardRenderer.builder((b) => {
          b.temperature(2).br;
          b.oceans(2).br;
          b.minus().plants(-6, {all});
        }),
      },
    });
  }
}

================
File: cards/base/GiantSpaceMirror.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class GiantSpaceMirror extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GIANT_SPACE_MIRROR,
      tags: [Tag.POWER, Tag.SPACE],
      cost: 17,

      behavior: {
        production: {energy: 3},
      },

      metadata: {
        cardNumber: '083',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.energy(3))),
        description: 'Increase your energy production 3 steps.',
      },
    });
  }
}

================
File: cards/base/Grass.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Grass extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GRASS,
      tags: [Tag.PLANT],
      cost: 11,

      behavior: {
        production: {plants: 1},
        stock: {plants: 3},
      },

      requirements: {temperature: -16},
      metadata: {
        cardNumber: '087',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).plants(3);
        }),
        description: 'Requires -16° C or warmer. Increase your plant production 1 step. Gain 3 plants.',
      },
    });
  }
}

================
File: cards/base/GreatDam.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class GreatDam extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GREAT_DAM,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 12,

      behavior: {
        production: {energy: 2},
      },
      victoryPoints: 1,

      requirements: {oceans: 4},
      metadata: {
        cardNumber: '136',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2));
        }),
        description: 'Requires 4 ocean tiles. Increase your energy production 2 steps.',
      },
    });
  }
}

================
File: cards/base/GreatEscarpmentConsortium.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {DecreaseAnyProduction} from '../../deferredActions/DecreaseAnyProduction';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {GainProduction} from '../../deferredActions/GainProduction';

export class GreatEscarpmentConsortium extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GREAT_ESCARPMENT_CONSORTIUM,
      cost: 6,

      requirements: {production: Resource.STEEL, count: 1},
      metadata: {
        cardNumber: '061',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().steel(-1, {all}).br;
            pb.plus().steel(1);
          });
        }),
        description: 'Requires that you have steel production. Decrease any steel production 1 step and increase your own 1 step.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(
      new DecreaseAnyProduction(player, Resource.STEEL, {count: 1, stealing: true}));
    player.game.defer(new GainProduction(player, Resource.STEEL, {count: 1, log: true}));
    return undefined;
  }
}

================
File: cards/base/Greenhouses.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class Greenhouses extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GREENHOUSES,
      tags: [Tag.PLANT, Tag.BUILDING],
      cost: 6,

      behavior: {
        stock: {plants: {cities: {}}},
      },

      metadata: {
        cardNumber: '096',
        renderData: CardRenderer.builder((b) => {
          b.plants(1).slash().city({size: Size.SMALL, all});
        }),
        description: 'Gain 1 plant for each city tile in play.',
      },
    });
  }
}

================
File: cards/base/Hackers.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {DecreaseAnyProduction} from '../../deferredActions/DecreaseAnyProduction';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class Hackers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HACKERS,
      cost: 3,
      victoryPoints: -1,

      behavior: {
        production: {energy: -1, megacredits: 2},
      },

      metadata: {
        cardNumber: '125',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).megacredits(2, {all}).br;
            pb.plus().megacredits(2);
          });
        }),
        description: 'Decrease your energy production 1 step and any M€ production 2 steps. Increase your M€ production 2 steps.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(
      new DecreaseAnyProduction(player, Resource.MEGACREDITS, {count: 2, stealing: true}));
    return undefined;
  }
}

================
File: cards/base/Heather.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Heather extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HEATHER,
      tags: [Tag.PLANT],
      cost: 6,

      behavior: {
        production: {plants: 1},
        stock: {plants: 1},
      },

      requirements: {temperature: -14},
      metadata: {
        cardNumber: '178',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).plants(1);
        }),
        description: 'Requires -14 C° or warmer. Increase your plant production 1 step. Gain 1 plant.',
      },
    });
  }
}

================
File: cards/base/HeatTrappers.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class HeatTrappers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HEAT_TRAPPERS,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 6,
      victoryPoints: -1,

      behavior: {
        decreaseAnyProduction: {type: Resource.HEAT, count: 2},
        production: {energy: 1},
      },

      metadata: {
        cardNumber: '178',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().heat(2, {all}).br;
            pb.plus().energy(1);
          });
        }),
        description: 'Decrease any heat production 2 steps and increase your energy production 1 step.',
      },
    });
  }
}

================
File: cards/base/Herbivores.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {Resource} from '../../../common/Resource';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {Board} from '../../boards/Board';

export class Herbivores extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.HERBIVORES,
      tags: [Tag.ANIMAL],
      cost: 12,

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {oxygen: 8},

      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 1},
        addResources: 1,
      },

      metadata: {
        cardNumber: '147',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you place a greenery tile, add an animal to this card.', (eb) => {
            eb.greenery({withO2: false}).startEffect.resource(CardResource.ANIMAL);
          }).br;
          b.vpText('1 VP per 2 animals on this card.');
          b.resource(CardResource.ANIMAL).production((pb) => pb.minus().plants(1, {all}));
        }),
        description: {
        // TODO (chosta): revert the original description once a solution for description space is found
          text: 'Requires 8% oxygen. +1 animal to this card. -1 any plant production',
          align: 'left',
        },
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (cardOwner.id === activePlayer.id && Board.isGreenerySpace(space)) {
      cardOwner.game.defer(new AddResourcesToCard(cardOwner, CardResource.ANIMAL, {filter: (c) => c.name === this.name}));
    }
  }
}

================
File: cards/base/HiredRaiders.ts
================
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';
import {message} from '../../logs/MessageBuilder';

export class HiredRaiders extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.HIRED_RAIDERS,
      cost: 1,

      metadata: {
        cardNumber: '124',
        renderData: CardRenderer.builder((b) => {
          b.text('steal', Size.MEDIUM, true).steel(2, {all}).br;
          b.or().br;
          b.text('steal', Size.MEDIUM, true).megacredits(3, {all});
        }),
        description: 'Steal up to 2 steel, or 3 M€ from any player.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    if (player.game.isSoloMode()) {
      return new OrOptions(
        new SelectOption('Steal 2 steel', 'Steal steel').andThen(() => {
          player.steel += 2;
          return undefined;
        }),
        new SelectOption('Steal 3 M€', 'Steal M€').andThen(() => {
          player.megaCredits += 3;
          return undefined;
        }),
      );
    }

    const availableActions = new OrOptions();

    player.getOpponents().forEach((target) => {
      if (target.steel > 0 && !target.alloysAreProtected()) {
        const amountStolen = Math.min(2, target.steel);
        const optionTitle = message('Steal ${0} steel from ${1}', (b) => b.number(amountStolen).player(target).getMessage());

        availableActions.options.push(new SelectOption(optionTitle).andThen(() => {
          target.maybeBlockAttack(player, (proceed) => {
            if (proceed) {
              target.stock.deduct(Resource.STEEL, 2, {log: true, from: player, stealing: true});
              player.steel += amountStolen;
            }
            return undefined;
          });
          return undefined;
        }));
      }

      if (target.megaCredits > 0) {
        const amountStolen = Math.min(3, target.megaCredits);
        const optionTitle = message('Steal ${0} M€ from ${1}', (b) => b.number(amountStolen).player(target));

        availableActions.options.push(new SelectOption(optionTitle).andThen(() => {
          target.maybeBlockAttack(player, (proceed) => {
            if (proceed) {
              player.megaCredits += amountStolen;
              target.stock.deduct(Resource.MEGACREDITS, 3, {log: true, from: player, stealing: true});
            }
            return undefined;
          });
          return undefined;
        }));
      }
    });

    if (availableActions.options.length > 0) {
      availableActions.options.push(new SelectOption('Do not steal').andThen(() => {
        return undefined;
      }));
      return availableActions;
    }
    return undefined;
  }
}

================
File: cards/base/IceAsteroid.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class IceAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ICE_ASTEROID,
      tags: [Tag.SPACE],
      cost: 23,

      behavior: {
        ocean: {count: 2},
      },

      metadata: {
        cardNumber: '078',
        renderData: CardRenderer.builder((b) => b.oceans(2)),
        description: 'Place 2 ocean tiles.',
      },
    });
  }
}

================
File: cards/base/IceCapMelting.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class IceCapMelting extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ICE_CAP_MELTING,
      cost: 5,

      behavior: {
        ocean: {},
      },

      requirements: {temperature: 2},
      metadata: {
        cardNumber: '181',
        renderData: CardRenderer.builder((b) => b.oceans(1)),
        description: 'Requires +2 C or warmer. Place 1 ocean tile.',
      },
    });
  }
}

================
File: cards/base/ImmigrantCity.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {Priority} from '../../deferredActions/Priority';
import {GainProduction} from '../../deferredActions/GainProduction';
import {LoseProduction} from '../../deferredActions/LoseProduction';
import {Board} from '../../boards/Board';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class ImmigrantCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.IMMIGRANT_CITY,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 13,

      metadata: {
        cardNumber: '200',
        renderData: CardRenderer.builder((b) => {
          b.effect('When a city tile is placed, including this, increase your M€ production 1 step.', (eb) => {
            eb.city({all}).startEffect.production((pb) => pb.megacredits(1));
          }).br;
          b.production((pb) => pb.minus().energy(1).megacredits(-2)).city();
        }),
        description: 'Decrease your energy production 1 step and decrease your M€ production 2 steps. Place a city tile.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    const hasEnergyProduction = player.production.energy >= 1;
    const canPlaceCityOnMars = player.game.board.getAvailableSpacesForCity(player).length > 0;
    const canDecreaseMcProduction = player.production.megacredits >= -4 || player.isCorporation(CardName.THARSIS_REPUBLIC);

    return hasEnergyProduction && canDecreaseMcProduction && canPlaceCityOnMars;
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (Board.isCitySpace(space)) {
      cardOwner.game.defer(
        new GainProduction(cardOwner, Resource.MEGACREDITS),
        cardOwner.id !== activePlayer.id ? Priority.OPPONENT_TRIGGER : undefined,
      );
    }
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select space for city tile', player.game.board.getAvailableSpacesForCity(player))
      .andThen((space) => {
        player.game.addCity(player, space);
        player.game.defer(new LoseProduction(player, Resource.ENERGY, {count: 1}));
        player.game.defer(new LoseProduction(player, Resource.MEGACREDITS, {count: 2}));
        return undefined;
      });
  }
}

================
File: cards/base/ImmigrationShuttles.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class ImmigrationShuttles extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.IMMIGRATION_SHUTTLES,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 31,
      victoryPoints: {cities: {}, all: true, per: 3},

      behavior: {
        production: {megacredits: 5},
      },

      metadata: {
        cardNumber: '198',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(5)).br;
          b.vpText('1 VP for every 3rd City in play.');
        }),
        description: 'Increase your M€ production 5 steps.',
      },
    });
  }
}

================
File: cards/base/ImportedGHG.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class ImportedGHG extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.IMPORTED_GHG,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 7,

      behavior: {
        production: {heat: 1},
        stock: {heat: 3},
      },

      metadata: {
        cardNumber: '162',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(1)).heat(3);
        }),
        description: 'Increase your heat production 1 step and gain 3 heat.',
      },
    });
  }
}

================
File: cards/base/ImportedHydrogen.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectCard} from '../../inputs/SelectCard';
import {PlayerInput} from '../../PlayerInput';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {message} from '../../logs/MessageBuilder';

export class ImportedHydrogen extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.IMPORTED_HYDROGEN,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 16,

      behavior: {
        ocean: {},
      },

      metadata: {
        cardNumber: '019',
        renderData: CardRenderer.builder((b) => {
          b.plants(3, {digit});
          b.or();
          b.resource(CardResource.MICROBE, {amount: 3, digit}).asterix().or();
          b.resource(CardResource.ANIMAL, {amount: 2, digit}).asterix().br;
          b.oceans(1);
        }),
        description: 'Gain 3 plants, or add 3 microbes or 2 animals to ANOTHER card. Place an ocean tile.',
      },
    });
  }

  public override bespokePlay(player: IPlayer): undefined | PlayerInput {
    const availableMicrobeCards = player.getResourceCards(CardResource.MICROBE);
    const availableAnimalCards = player.getResourceCards(CardResource.ANIMAL);

    const gainPlants = function() {
      player.stock.add(Resource.PLANTS, 3, {log: true});
      return undefined;
    };

    if (availableMicrobeCards.length === 0 && availableAnimalCards.length === 0) {
      return gainPlants();
    }

    const availableActions = [];

    const gainPlantsOption = new SelectOption('Gain 3 plants', 'Gain plants').andThen(gainPlants);
    availableActions.push(gainPlantsOption);

    if (availableMicrobeCards.length === 1) {
      const targetMicrobeCard = availableMicrobeCards[0];
      availableActions.push(new SelectOption(message('Add ${0} microbes to ${1}', (b) => b.number(3).card(targetMicrobeCard)), 'Add microbes').andThen(() => {
        player.addResourceTo(targetMicrobeCard, {qty: 3, log: true});
        return undefined;
      }));
    } else if (availableMicrobeCards.length > 1) {
      availableActions.push(new SelectCard('Add 3 microbes to a card',
        'Add microbes',
        availableMicrobeCards)
        .andThen(([card]) => {
          player.addResourceTo(card, {qty: 3, log: true});
          return undefined;
        }));
    }

    if (availableAnimalCards.length === 1) {
      const targetAnimalCard = availableAnimalCards[0];
      availableActions.push(new SelectOption(message('Add ${0} animals to ${1}', (b) => b.number(2).card(targetAnimalCard)), 'Add animals').andThen(() => {
        player.addResourceTo(targetAnimalCard, {qty: 2, log: true});
        return undefined;
      }));
    } else if (availableAnimalCards.length > 1) {
      availableActions.push(new SelectCard('Add 2 animals to a card', 'Add animals', availableAnimalCards)
        .andThen(([card]) => {
          player.addResourceTo(card, {qty: 2, log: true});
          return undefined;
        }));
    }

    return new OrOptions(...availableActions);
  }
}

================
File: cards/base/ImportedNitrogen.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class ImportedNitrogen extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.IMPORTED_NITROGEN,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 23,

      behavior: {
        stock: {plants: 4},
        tr: 1,
        addResourcesToAnyCard: [
          {type: CardResource.MICROBE, count: 3},
          {type: CardResource.ANIMAL, count: 2},
        ],
      },

      metadata: {
        cardNumber: '163',
        renderData: CardRenderer.builder((b) => {
          b.tr(1).br;
          b.plants(4, {digit});
          b.resource(CardResource.MICROBE, {amount: 3, digit}).asterix().nbsp;
          b.resource(CardResource.ANIMAL, {amount: 2, digit}).asterix();
        }),
        description: 'Raise your TR 1 step and gain 4 plants. Add 3 microbes to ANOTHER card and 2 animals to ANOTHER card.',
      },
    });
  }
}

================
File: cards/base/ImportOfAdvancedGHG.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class ImportOfAdvancedGHG extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.IMPORT_OF_ADVANCED_GHG,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 9,

      behavior: {
        production: {heat: 2},
      },

      metadata: {
        cardNumber: '167',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.heat(2))),
        description: 'Increase your heat production 2 steps.',
      },
    });
  }
}

================
File: cards/base/IndenturedWorkers.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class IndenturedWorkers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.INDENTURED_WORKERS,
      cost: 0,
      victoryPoints: -1,

      metadata: {
        cardNumber: '195',
        renderData: CardRenderer.builder((b) => {
          b.text('next card', Size.SMALL, true).colon().megacredits(-8);
        }),
        description: 'The next card you play this generation costs 8 M€ less.',
      },
    });
  }

  public override getCardDiscount(player: IPlayer) {
    if (player.lastCardPlayed === this.name) {
      return 8;
    }
    return 0;
  }
}

================
File: cards/base/IndustrialCenter.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {TileType} from '../../../common/TileType';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Space} from '../../boards/Space';
import {CardName} from '../../../common/cards/CardName';
import {Board} from '../../boards/Board';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';
import {CardRenderer} from '../render/CardRenderer';

export class IndustrialCenter extends ActionCard implements IProjectCard {
  constructor(
    name = CardName.INDUSTRIAL_CENTER,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: '123',
      renderData: CardRenderer.builder((b) => {
        b.action('Spend 7 M€ to increase your steel production 1 step.', (eb) => {
          eb.megacredits(7).startAction.production((pb) => pb.steel(1));
        }).br;
        b.tile(TileType.INDUSTRIAL_CENTER, true, false).asterix();
      }),
      description: 'Place this tile adjacent to a city tile.',
    }) {
    super({
      type: CardType.ACTIVE,
      name,
      tags: [Tag.BUILDING],
      cost: 4,
      adjacencyBonus,

      action: {
        spend: {megacredits: 7},
        production: {steel: 1},
      },
      metadata,
    });
  }

  private getAvailableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): Array<Space> {
    return player.game.board.getAvailableSpacesOnLand(player, canAffordOptions)
      .filter((space) => player.game.board.getAdjacentSpaces(space).some((adjacentSpace) => Board.isCitySpace(adjacentSpace)));
  }
  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions): boolean {
    return this.getAvailableSpaces(player, canAffordOptions).length > 0;
  }
  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select space adjacent to a city tile', this.getAvailableSpaces(player))
      .andThen((space) => {
        player.game.addTile(player, space, {tileType: TileType.INDUSTRIAL_CENTER});
        space.adjacency = this.adjacencyBonus;
        return undefined;
      });
  }
}

================
File: cards/base/IndustrialMicrobes.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class IndustrialMicrobes extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INDUSTRIAL_MICROBES,
      tags: [Tag.MICROBE, Tag.BUILDING],
      cost: 12,

      behavior: {
        production: {energy: 1, steel: 1},
      },

      metadata: {
        cardNumber: '158',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).steel(1));
        }),
        description: 'Increase your energy production and your steel production 1 step each.',
      },
    });
  }
}

================
File: cards/base/Insects.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Insects extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INSECTS,
      tags: [Tag.MICROBE],
      cost: 9,

      behavior: {
        production: {plants: {tag: Tag.PLANT}},
      },

      requirements: {oxygen: 6},
      metadata: {
        cardNumber: '148',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1).slash().tag(Tag.PLANT));
        }),
        description: 'Requires 6% oxygen. Increase your plant production 1 step for each plant tag you have.',
      },
    });
  }
}

================
File: cards/base/Insulation.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {SelectAmount} from '../../inputs/SelectAmount';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Insulation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INSULATION,
      cost: 2,

      metadata: {
        cardNumber: '152',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.text('-X').heat(1).nbsp.text('+').megacredits(1, {text: 'x'});
          });
        }),
        description: 'Decrease your heat production any number of steps and increase your M€ production the same number of steps.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    return player.production.heat >= 1;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectAmount('Select amount of heat production to decrease', 'Decrease', 1, player.production.heat)
      .andThen((amount) => {
        player.production.add(Resource.HEAT, -amount, {log: true});
        player.production.add(Resource.MEGACREDITS, amount, {log: true});
        return undefined;
      });
  }
}

================
File: cards/base/InterstellarColonyShip.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';

export class InterstellarColonyShip extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.INTERSTELLAR_COLONY_SHIP,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 24,
      victoryPoints: 4,

      requirements: {tag: Tag.SCIENCE, count: 5},
      metadata: {
        description: 'Requires that you have 5 science tags.',
        cardNumber: '027',
      },
    });
  }
}

================
File: cards/base/InventionContest.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class InventionContest extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.INVENTION_CONTEST,
      tags: [Tag.SCIENCE],
      cost: 2,

      behavior: {
        drawCard: {count: 3, keep: 1},
      },

      metadata: {
        cardNumber: '192',
        renderData: CardRenderer.builder((b) => {
          b.text('Look at the top 3 cards from the deck. Take 1 of them into hand and discard the other two', Size.SMALL, true);
        }),
      },
    });
  }
}

================
File: cards/base/InventorsGuild.ts
================
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class InventorsGuild extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.INVENTORS_GUILD,
      tags: [Tag.SCIENCE],
      cost: 9,

      action: {
        drawCard: {count: 1, pay: true},
      },

      metadata: {
        cardNumber: '006',
        renderData: CardRenderer.builder((b) => {
          b.action(undefined, (eb) => eb.empty().startAction.empty()).text('Action: Look at the top card and either buy it or discard it', Size.SMALL, true);
        }),
      },
    });
  }
}

================
File: cards/base/InvestmentLoan.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class InvestmentLoan extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.INVESTMENT_LOAN,
      tags: [Tag.EARTH],
      cost: 3,

      behavior: {
        production: {megacredits: -1},
        stock: {megacredits: 10},
      },

      metadata: {
        cardNumber: '151',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(-1)).nbsp.megacredits(10);
        }),
        description: 'Decrease your M€ production 1 step. Gain 10 M€.',
      },
    });
  }
}

================
File: cards/base/IoMiningIndustries.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class IoMiningIndustries extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.IO_MINING_INDUSTRIES,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 41,
      victoryPoints: {tag: Tag.JOVIAN},

      behavior: {
        production: {titanium: 2, megacredits: 2},
      },

      metadata: {
        cardNumber: '092',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(2).megacredits(2)).br;
          b.vpText('1 VP per Jovian tag you have.');
        }),
        description: 'Increase your titanium production 2 steps and your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/base/Ironworks.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class Ironworks extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.IRONWORKS,
      tags: [Tag.BUILDING],
      cost: 11,

      action: {
        spend: {energy: 4},
        stock: {steel: 1},
        global: {oxygen: 1},
      },

      metadata: {
        cardNumber: '101',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 4 energy to gain 1 steel and raise oxygen 1 step.', (eb) => {
            eb.energy(4, {digit}).startAction.steel(1).oxygen(1);
          });
        }),
      },
    });
  }
}

================
File: cards/base/KelpFarming.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class KelpFarming extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.KELP_FARMING,
      tags: [Tag.PLANT],
      cost: 17,
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 2, plants: 3},
        stock: {plants: 2},
      },

      requirements: {oceans: 6},
      metadata: {
        cardNumber: '055',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(2).br;
            pb.plants(3);
          }).nbsp.plants(2);
        }),
        description: 'Requires 6 ocean tiles. Increase your M€ production 2 steps and your plant production 3 steps. Gain 2 plants.',
      },
    });
  }
}

================
File: cards/base/LagrangeObservatory.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class LagrangeObservatory extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LAGRANGE_OBSERVATORY,
      tags: [Tag.SCIENCE, Tag.SPACE],
      cost: 9,
      victoryPoints: 1,

      behavior: {
        drawCard: 1,
      },

      metadata: {
        cardNumber: '196',
        renderData: CardRenderer.builder((b) => b.cards(1)),
        description: 'Draw 1 card.',
      },
    });
  }
}

================
File: cards/base/LakeMarineris.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class LakeMarineris extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LAKE_MARINERIS,
      cost: 18,
      requirements: {temperature: 0},
      victoryPoints: 2,

      behavior: {
        ocean: {count: 2},
      },

      metadata: {
        cardNumber: '053',
        renderData: CardRenderer.builder((b) => b.oceans(2)),
        description: 'Requires 0° C or warmer. Place 2 ocean tiles.',
      },
    });
  }
}

================
File: cards/base/LandClaim.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {SelectSpace} from '../../inputs/SelectSpace';
import {CardName} from '../../../common/cards/CardName';
import {LogHelper} from '../../LogHelper';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class LandClaim extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.LAND_CLAIM,
      cost: 1,

      metadata: {
        cardNumber: '066',
        renderData: CardRenderer.builder((b) => {
          b.text('Place your marker on a non-reserved area. Only you may place a tile there.', Size.SMALL, true);
        }),
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.game.board.getNonReservedLandSpaces().length > 0;
  }
  public override bespokePlay(player: IPlayer) {
    return new SelectSpace(
      'Select space for claim',
      player.game.board.getNonReservedLandSpaces())
      .andThen((space) => {
        space.player = player;
        LogHelper.logBoardTileAction(player, space, 'land claim');
        return undefined;
      });
  }
}

================
File: cards/base/LargeConvoy.ts
================
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectCard} from '../../inputs/SelectCard';
import {SelectOption} from '../../inputs/SelectOption';
import {PlayerInput} from '../../PlayerInput';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {digit} from '../Options';
import {message} from '../../logs/MessageBuilder';

export class LargeConvoy extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.LARGE_CONVOY,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 36,
      victoryPoints: 2,

      behavior: {
        drawCard: 2,
        ocean: {},
      },

      metadata: {
        cardNumber: '143',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).cards(2).br;
          b.plants(5, {digit}).or(Size.MEDIUM).resource(CardResource.ANIMAL, {amount: 4, digit}).asterix();
        }),
        description: 'Place an ocean tile and draw 2 cards. Gain 5 plants or add 4 animals to ANOTHER card.',
      },
    });
  }

  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const animalCards = player.getResourceCards(CardResource.ANIMAL);

    const gainPlants = function() {
      player.stock.add(Resource.PLANTS, 5, {log: true});
      return undefined;
    };

    if (animalCards.length === 0 ) return gainPlants();

    const availableActions = [];

    const gainPlantsOption = new SelectOption('Gain 5 plants', 'Gain plants').andThen(gainPlants);
    availableActions.push(gainPlantsOption);

    if (animalCards.length === 1) {
      const targetAnimalCard = animalCards[0];
      availableActions.push(new SelectOption(message('Add ${0} animals to ${1}', (b) => b.number(4).card(targetAnimalCard)), 'Add animals').andThen(() => {
        player.addResourceTo(targetAnimalCard, {qty: 4, log: true});
        return undefined;
      }));
    } else {
      availableActions.push(
        new SelectCard(
          'Select card to add 4 animals',
          'Add animals',
          animalCards)
          .andThen(([card]) => {
            player.addResourceTo(card, {qty: 4, log: true});
            return undefined;
          }),
      );
    }

    return new OrOptions(...availableActions);
  }
}

================
File: cards/base/LavaFlows.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {TileType} from '../../../common/TileType';
import {CardName} from '../../../common/cards/CardName';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';
import {CardRenderer} from '../render/CardRenderer';

export class LavaFlows extends Card implements IProjectCard {
  constructor(
    name = CardName.LAVA_FLOWS,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: '140',
      renderData: CardRenderer.builder((b) => {
        b.temperature(2).br;
        b.tile(TileType.LAVA_FLOWS, true, false).asterix();
      }),
      description: 'Raise temperature 2 steps and place this tile ON EITHER THARSIS THOLUS, ASCRAEUS MONS, PAVONIS MONS OR ARSIA MONS.',
    }) {
    super({
      type: CardType.EVENT,
      name,
      cost: 18,
      adjacencyBonus,

      behavior: {
        global: {temperature: 2},
        tile: {
          type: TileType.LAVA_FLOWS,
          on: 'volcanic',
          title: 'Select either Tharsis Tholus, Ascraeus Mons, Pavonis Mons or Arsia Mons',
          adjacencyBonus: adjacencyBonus,
        },
      },
      metadata,
    });
  }
}

================
File: cards/base/Lichen.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Lichen extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LICHEN,
      tags: [Tag.PLANT],
      cost: 7,

      behavior: {
        production: {plants: 1},
      },

      requirements: {temperature: -24},
      metadata: {
        cardNumber: '159',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1));
        }),
        description: 'Requires -24 C or warmer. Increase your plant production 1 step.',
      },
    });
  }
}

================
File: cards/base/LightningHarvest.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class LightningHarvest extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LIGHTNING_HARVEST,
      cost: 8,
      tags: [Tag.POWER],
      victoryPoints: 1,

      behavior: {
        production: {energy: 1, megacredits: 1},
      },

      requirements: {tag: Tag.SCIENCE, count: 3},
      metadata: {
        cardNumber: '046',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).megacredits(1));
        }),
        description: 'Requires 3 science tags. Increase your energy production and your M€ production one step each.',
      },
    });
  }
}

================
File: cards/base/Livestock.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Livestock extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.LIVESTOCK,
      tags: [Tag.ANIMAL],
      cost: 13,

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}},
      requirements: {oxygen: 9},

      behavior: {
        production: {plants: -1, megacredits: 2},
      },

      action: {
        addResources: 1,
      },

      metadata: {
        cardNumber: '184',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.production((pb) => {
            pb.minus().plants(1).nbsp.plus().megacredits(2);
          }).br;
          b.vpText('1 VP for each animal on this card.');
        }),
        description: {
          text: 'Requires 9% oxygen. Decrease your plant production 1 step and increase your M€ production 2 steps',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/base/LocalHeatTrapping.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectCard} from '../../inputs/SelectCard';
import {CardResource} from '../../../common/CardResource';
import {ICard} from '../ICard';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {message} from '../../logs/MessageBuilder';

export class LocalHeatTrapping extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.LOCAL_HEAT_TRAPPING,
      cost: 1,

      // Normally reserveUnits is managed by the rest of the game engine. But in this case
      // the only purpose of reserveUnits is to prevent the player from spending that heat
      // as Helion. Managing reserveUnits in this case will be handled by overriding canPlay
      // and play, which is not a rare behavior.
      //
      // This is made that much more complicated thanks to Merger and Stormcraft Incorporated.
      reserveUnits: {heat: 5},

      metadata: {
        cardNumber: '190',
        renderData: CardRenderer.builder((b) => {
          b.minus().heat(5, {digit});
          b.plus().plants(4, {digit});
          b.or().resource(CardResource.ANIMAL, {amount: 2, digit}).asterix();
        }),
        description: 'Spend 5 heat to gain either 4 plants, or to add 2 animals to ANOTHER card.',
      },
    });
  }

  public override canPlay(player: IPlayer) {
    // This card can cost 0 or 1.
    const cardCost = player.getCardCost(this); // Would be nice to use precalculated value.

    let heat = player.heat;
    let floaters = player.resourcesOnCard(CardName.STORMCRAFT_INCORPORATED);

    // If the card costs anything, determine where that 1MC can come from. Assume it can come from MC first.
    if (cardCost === 1 && player.megaCredits === 0) {
      if (heat > 0) {
        heat--;
      } else if (floaters > 0) {
        floaters--;
      } else {
        return false;
      }
    }

    // At this point, the card cost has been assumed handled, and it's just a question of whether there's 5 heat
    // left.

    const availableHeat = heat + (floaters * 2);
    return availableHeat >= 5;
  }

  // By overriding play, the heat is not deducted automatically.
  public override play(player: IPlayer) {
    const availableActions = new OrOptions();

    const animalCards: Array<ICard> = player.getResourceCards(CardResource.ANIMAL);
    const gainPlantsOption = new SelectOption('Gain 4 plants', 'Gain plants').andThen(() => {
      player.stock.add(Resource.PLANTS, 4, {log: true});
      return undefined;
    });

    if (animalCards.length === 0) {
      availableActions.options.push(gainPlantsOption);
    } else if (animalCards.length === 1) {
      const targetCard = animalCards[0];
      availableActions.options.push(
        gainPlantsOption,
        new SelectOption(message('Add ${0} animals to ${1}', (b) => b.number(2).card(targetCard)), 'Add animals').andThen(() => {
          player.addResourceTo(targetCard, {qty: 2, log: true});
          return undefined;
        }));
    } else {
      availableActions.options.push(
        gainPlantsOption,
        new SelectCard('Select card to add 2 animals', 'Add animals', animalCards)
          .andThen(([card]) => {
            player.addResourceTo(card, {qty: 2, log: true});
            return undefined;
          }));
    }

    return player.spendHeat(5, () => {
      if (availableActions.options.length === 1) return availableActions.options[0].cb();
      return availableActions;
    });
  }
}

================
File: cards/base/LunarBeam.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class LunarBeam extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LUNAR_BEAM,
      tags: [Tag.EARTH, Tag.POWER],
      cost: 13,

      behavior: {
        production: {megacredits: -2, heat: 2, energy: 2},
      },

      metadata: {
        cardNumber: '030',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().megacredits(2).br;
            pb.plus().heat(2).br;
            pb.plus().energy(2);
          });
        }),
        description: 'Decrease your M€ production 2 steps and increase your heat production and energy production 2 steps each.',
      },
    });
  }
}

================
File: cards/base/MagneticFieldDome.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class MagneticFieldDome extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MAGNETIC_FIELD_DOME,
      tags: [Tag.BUILDING],
      cost: 5,

      behavior: {
        production: {energy: -2, plants: 1},
        tr: 1,
      },

      metadata: {
        cardNumber: '171',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().plants(1);
          });
          b.tr(1);
        }),
        description: 'Decrease your energy production 2 steps and increase your plant production 1 step. Raise your TR 1 step.',
      },
    });
  }
}

================
File: cards/base/MagneticFieldGenerators.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class MagneticFieldGenerators extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MAGNETIC_FIELD_GENERATORS,
      tags: [Tag.BUILDING],
      cost: 20,

      behavior: {
        production: {energy: -4, plants: 2},
        tr: 3,
      },

      metadata: {
        cardNumber: '165',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(4, {digit}).br;
            pb.plus().plants(2);
          }).br;
          b.tr(3);
        }),
        description: 'Decrease your energy production 4 steps and increase your plant production 2 steps. Raise your TR 3 steps.',
      },
    });
  }
}

================
File: cards/base/Mangrove.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Mangrove extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MANGROVE,
      tags: [Tag.PLANT],
      cost: 12,
      victoryPoints: 1,

      behavior: {
        greenery: {on: 'ocean'},
      },

      requirements: {temperature: 4},
      metadata: {
        cardNumber: '059',
        renderData: CardRenderer.builder((b) => b.greenery().asterix()),
        description: 'Requires +4 C or warmer. Place a greenery tile ON AN AREA RESERVED FOR OCEAN and raise oxygen 1 step. Disregard normal placement restrictions for this.',
      },
    });
  }
}

================
File: cards/base/MarsUniversity.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectCard} from '../../inputs/SelectCard';
import {SelectOption} from '../../inputs/SelectOption';
import {CardName} from '../../../common/cards/CardName';
import {Priority} from '../../deferredActions/Priority';
import {CardRenderer} from '../render/CardRenderer';

export class MarsUniversity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MARS_UNIVERSITY,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 8,
      victoryPoints: 1,

      metadata: {
        cardNumber: '073',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a science tag, including this, you may discard a card from hand to draw a card.', (eb) => {
            eb.tag(Tag.SCIENCE).startEffect.minus().cards(1).nbsp.plus().cards(1);
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    const scienceTags = player.tags.cardTagCount(card, Tag.SCIENCE);
    this.onScienceTagAdded(player, scienceTags);
  }
  public onColonyAddedToLeavitt(player: IPlayer) {
    this.onScienceTagAdded(player, 1);
  }
  public onScienceTagAdded(player: IPlayer, count: number) {
    for (let i = 0; i < count; i++) {
      player.defer(() => {
        // No card to discard
        if (player.cardsInHand.length === 0) {
          return undefined;
        }
        return new OrOptions(
          new SelectCard('Select a card to discard', 'Discard', player.cardsInHand)
            .andThen(([card]) => {
              player.game.log('${0} is using their ${1} effect to draw a card by discarding a card.', (b) => b.player(player).card(this));
              player.discardCardFromHand(card, {log: true});
              player.drawCard();
              return undefined;
            }),
          new SelectOption('Do nothing'),
        );
      },
      Priority.DISCARD_AND_DRAW);
    }
    return undefined;
  }
}

================
File: cards/base/MartianRails.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class MartianRails extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MARTIAN_RAILS,
      tags: [Tag.BUILDING],
      cost: 13,

      action: {
        spend: {energy: 1},
        stock: {megacredits: {cities: {where: 'onmars'}}},
      },

      metadata: {
        cardNumber: '007',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 energy to gain 1 M€ for each city tile ON MARS.', (eb) => {
            eb.energy(1).startAction.megacredits(1).slash();
            eb.city({all, size: Size.SMALL}).asterix();
          }).br;
        }),
      },
    });
  }
}

================
File: cards/base/MassConverter.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class MassConverter extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MASS_CONVERTER,
      tags: [Tag.SCIENCE, Tag.POWER],
      cost: 8,

      behavior: {
        production: {energy: 6},
      },

      requirements: {tag: Tag.SCIENCE, count: 5},
      cardDiscount: {tag: Tag.SPACE, amount: 2, per: 'card'},
      metadata: {
        cardNumber: '094',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => pb.energy(6));
        }),
        description: 'Requires 5 science tags. Increase your energy production 6 steps.',
      },
    });
  }
}

================
File: cards/base/MediaArchives.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {sum} from '../../../common/utils/utils';

export class MediaArchives extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MEDIA_ARCHIVES,
      tags: [Tag.EARTH],
      cost: 8,

      metadata: {
        cardNumber: '107',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(1).slash().tag(Tag.EVENT, {all});
        }),
        description: 'Gain 1 M€ for each event EVER PLAYED by all players.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const allPlayedEvents = sum(player.game.getPlayers().map((player) => player.getPlayedEventsCount()));
    player.stock.add(Resource.MEGACREDITS, allPlayedEvents, {log: true});
    return undefined;
  }
}

================
File: cards/base/MediaGroup.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {GainResources} from '../../deferredActions/GainResources';
import {Resource} from '../../../common/Resource';

export class MediaGroup extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MEDIA_GROUP,
      tags: [Tag.EARTH],
      cost: 6,

      metadata: {
        cardNumber: '109',
        renderData: CardRenderer.builder((b) => {
          b.effect('After you play an event card, you gain 3 M€.', (eb) => {
            eb.tag(Tag.EVENT).startEffect.megacredits(3);
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.type === CardType.EVENT) {
      player.game.defer(new GainResources(player, Resource.MEGACREDITS, {count: 3, log: true}));
    }
  }
}

================
File: cards/base/MedicalLab.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class MedicalLab extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MEDICAL_LAB,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 13,
      victoryPoints: 1,

      behavior: {
        production: {megacredits: {tag: Tag.BUILDING, per: 2}},
      },

      metadata: {
        cardNumber: '207',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).slash().tag(Tag.BUILDING, 2);
          });
        }),
        description: 'Increase your M€ production 1 step for every 2 building tags you have, including this.',
      },
    });
  }
}

================
File: cards/base/MethaneFromTitan.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class MethaneFromTitan extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.METHANE_FROM_TITAN,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 28,
      victoryPoints: 2,

      behavior: {
        production: {heat: 2, plants: 2},
      },

      requirements: {oxygen: 2},
      metadata: {
        description: 'Requires 2% oxygen. Increase your heat production 2 steps and your plant production 2 steps.',
        cardNumber: '018',
        renderData: CardRenderer.builder((b) => b.production((pb) => {
          pb.heat(2).br;
          pb.plants(2);
        })),
      },
    });
  }
}

================
File: cards/base/MicroMills.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class MicroMills extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MICRO_MILLS,
      cost: 3,

      behavior: {
        production: {heat: 1},
      },

      metadata: {
        cardNumber: '164',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(1));
        }),
        description: 'Increase your heat production 1 step.',
      },
    });
  }
}

================
File: cards/base/Mine.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Mine extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MINE,
      tags: [Tag.BUILDING],
      cost: 4,

      behavior: {
        production: {steel: 1},
      },

      metadata: {
        description: 'Increase your steel production 1 step.',
        cardNumber: '056',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.steel(1))),
      },
    });
  }
}

================
File: cards/base/MineralDeposit.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class MineralDeposit extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.MINERAL_DEPOSIT,
      cost: 5,

      behavior: {
        stock: {steel: 5},
      },

      metadata: {
        cardNumber: '062',
        renderData: CardRenderer.builder((b) => b.steel(5, {digit})),
        description: 'Gain 5 steel.',
      },
    });
  }
}

================
File: cards/base/MiningArea.ts
================
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {TileType} from '../../../common/TileType';
import {CardName} from '../../../common/cards/CardName';
import {MiningCard} from './MiningCard';
import {CardRenderer} from '../render/CardRenderer';

export class MiningArea extends MiningCard {
  protected readonly title = 'Select a space with a steel or titanium bonus adjacent to one of your tiles';

  constructor(
    name = CardName.MINING_AREA,
    metadata = {
      cardNumber: '064',
      renderData: CardRenderer.builder((b) => {
        b.tile(TileType.MINING_AREA, true).asterix().br;
        b.production((pb) => {
          pb.steel(1).or().titanium(1);
        }).asterix();
      }),
      description: 'Place this tile on an area with a steel or titanium placement bonus, adjacent to another of your tiles. Increase your production of that resource 1 step.',
    }) {
    super(
      name,
      4,
      metadata,
    );
  }

  protected override getAvailableSpaces(player: IPlayer, canAffordOptions: CanAffordOptions) {
    return super.getAvailableSpaces(player, canAffordOptions)
      .filter((space) => player.game.board.getAdjacentSpaces(space).some((adjacentSpace) => adjacentSpace.tile !== undefined && adjacentSpace.tile.tileType !== TileType.OCEAN && adjacentSpace.player === player));
  }
}

================
File: cards/base/MiningCard.ts
================
import {Card} from '../Card';
import {CardMetadata} from '../../../common/cards/CardMetadata';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';
import {IProjectCard} from '../../cards/IProjectCard';
import {Space} from '../../boards/Space';
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Tag} from '../../../common/cards/Tag';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {TileType} from '../../../common/TileType';
import {SelectResourceTypeDeferred} from '../../deferredActions/SelectResourceTypeDeferred';
import {Units} from '../../../common/Units';

export abstract class MiningCard extends Card implements IProjectCard {
  public bonusResource?: Array<Resource>;
  protected abstract readonly title: string;
  protected readonly isAres: boolean = false;
  protected readonly placeTile: boolean = true;

  constructor(
    name: CardName,
    cost: number,
    metadata: CardMetadata) {
    super({
      type: CardType.AUTOMATED,
      name,
      tags: [Tag.BUILDING],
      cost,
      metadata,
    });
  }
  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions): boolean {
    return this.getAvailableSpaces(player, canAffordOptions).length > 0;
  }

  private getAdjacencyBonus(bonusType: SpaceBonus): AdjacencyBonus | undefined {
    if (this.isAres) {
      return {bonus: [bonusType]};
    }
    return undefined;
  }
  protected getAvailableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): ReadonlyArray<Space> {
    return player.game.board.getAvailableSpacesOnLand(player, canAffordOptions)
      // Ares-only: exclude spaces already covered (which is only returned if the tile is a hazard tile.)
      .filter((space) => space.tile === undefined)
      .filter((space) => space.bonus.includes(SpaceBonus.STEEL) || space.bonus.includes(SpaceBonus.TITANIUM));
  }

  private getTileType(bonus: SpaceBonus.STEEL | SpaceBonus.TITANIUM): TileType {
    if (this.isAres) {
      return bonus === SpaceBonus.STEEL ? TileType.MINING_STEEL_BONUS : TileType.MINING_TITANIUM_BONUS;
    }
    if (this.name === CardName.MINING_RIGHTS) {
      return TileType.MINING_RIGHTS;
    }
    return TileType.MINING_AREA;
  }

  public productionBox() {
    // TODO(kberg): Matches Specialzied Settlement
    const units = {...Units.EMPTY};
    if (this.bonusResource && this.bonusResource.length === 1) {
      units[this.bonusResource[0]] += 1;
    }
    return units;
  }

  public override bespokePlay(player: IPlayer): SelectSpace {
    return new SelectSpace(this.title, this.getAvailableSpaces(player))
      .andThen((space) => {
        this.spaceSelected(player, space);
        return undefined;
      });
  }

  protected spaceSelected(player: IPlayer, space: Space): void {
    const bonusResources = [];
    if (space.bonus.includes(SpaceBonus.STEEL)) {
      bonusResources.push(Resource.STEEL);
    }
    if (space.bonus.includes(SpaceBonus.TITANIUM)) {
      bonusResources.push(Resource.TITANIUM);
    }

    player.game.defer(
      new SelectResourceTypeDeferred(
        player,
        bonusResources,
        'Select a resource to gain 1 unit of production'))
      .andThen((resource) => {
        player.production.add(resource, 1, {log: true});
        this.bonusResource = [resource];
        if (this.placeTile) {
          const spaceBonus = resource === Resource.TITANIUM ? SpaceBonus.TITANIUM : SpaceBonus.STEEL;
          player.game.addTile(player, space, {tileType: this.getTileType(spaceBonus)});
          space.adjacency = this.getAdjacencyBonus(spaceBonus);
        }
      });
  }
}

================
File: cards/base/MiningExpedition.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class MiningExpedition extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.MINING_EXPEDITION,
      cost: 12,

      behavior: {
        stock: {steel: 2},
        global: {oxygen: 1},
        removeAnyPlants: 2,
      },

      metadata: {
        cardNumber: '063',
        renderData: CardRenderer.builder((b) => {
          b.oxygen(1).br;
          b.minus().plants(-2, {all});
          b.steel(2);
        }),
        description: 'Raise oxygen 1 step. Remove 2 plants from any player. Gain 2 steel.',
      },
    });
  }
}

================
File: cards/base/MiningRights.ts
================
import {CardName} from '../../../common/cards/CardName';
import {MiningCard} from './MiningCard';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';

export class MiningRights extends MiningCard {
  protected readonly title: string = 'Select a space with a steel or titanium bonus';

  constructor(
    name = CardName.MINING_RIGHTS,
    metadata = {
      cardNumber: '067',
      renderData: CardRenderer.builder((b) => {
        b.tile(TileType.MINING_RIGHTS, true).asterix().br;
        b.production((pb) => {
          pb.steel(1).or().titanium(1);
        }).asterix();
      }),
      description: 'Place this tile on an area with a steel or titanium placement bonus. Increase that production 1 step.',
    },
  ) {
    super(
      name,
      9,
      metadata);
  }
}

================
File: cards/base/MirandaResort.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class MirandaResort extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MIRANDA_RESORT,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 12,
      victoryPoints: 1,

      behavior: {
        production: {megacredits: {tag: Tag.EARTH}},
      },

      metadata: {
        cardNumber: '051',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).slash().tag(Tag.EARTH);
          });
        }),
        description: 'Increase your M€ production 1 step for each Earth tag you have.',
      },
    });
  }
}

================
File: cards/base/MoholeArea.ts
================
import {TileType} from '../../../common/TileType';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class MoholeArea extends Card implements IProjectCard {
  constructor(
    name = CardName.MOHOLE_AREA,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: '142',
      renderData: CardRenderer.builder((b) => {
        b.production((pb) => pb.heat(4, {digit})).br;
        b.tile(TileType.MOHOLE_AREA, true);
      }),
      description: 'Increase your heat production 4 steps. Place this tile ON AN AREA RESERVED FOR OCEAN.',
    }) {
    super({
      type: CardType.AUTOMATED,
      name,
      tags: [Tag.BUILDING],
      cost: 20,
      metadata,

      behavior: {
        production: {heat: 4},
        tile: {
          type: TileType.MOHOLE_AREA,
          on: 'ocean',
          adjacencyBonus: adjacencyBonus,
        },
      },
    });
  }
}

================
File: cards/base/Moss.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Moss extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MOSS,
      tags: [Tag.PLANT],
      cost: 4,

      behavior: {
        production: {plants: 1},
      },

      requirements: {oceans: 3},
      metadata: {
        cardNumber: '122',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).nbsp.minus().plants(1);
        }),
        description: 'Requires 3 ocean tiles and that you lose 1 plant. Increase your plant production 1 step.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    const hasViralEnhancers = player.playedCards.find((card) => card.name === CardName.VIRAL_ENHANCERS);
    const hasEnoughPlants = player.plants >= 1 || hasViralEnhancers !== undefined || player.isCorporation(CardName.MANUTECH);

    return hasEnoughPlants;
  }
  public override bespokePlay(player: IPlayer) {
    player.plants--;
    return undefined;
  }
}

================
File: cards/base/NaturalPreserve.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {TileType} from '../../../common/TileType';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';
import {CardRenderer} from '../render/CardRenderer';
import {max} from '../Options';

export class NaturalPreserve extends Card implements IProjectCard {
  constructor(
    name = CardName.NATURAL_PRESERVE,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: '044',
      renderData: CardRenderer.builder((b) => {
        b.production((pb) => pb.megacredits(1)).nbsp.tile(TileType.NATURAL_PRESERVE, true).asterix();
      }),
      description: 'Oxygen must be 4% or less. Place this tile NEXT TO NO OTHER TILE. Increase your M€ production 1 step.',
    }) {
    super({
      type: CardType.AUTOMATED,
      name,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 9,

      behavior: {
        production: {megacredits: 1},
        tile: {
          type: TileType.NATURAL_PRESERVE,
          on: 'isolated',
          adjacencyBonus: adjacencyBonus,
        },
      },

      adjacencyBonus,
      requirements: {oxygen: 4, max},
      victoryPoints: 1,
      metadata,
    });
  }
}

================
File: cards/base/NitriteReducingBacteria.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class NitriteReducingBacteria extends ActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.NITRITE_REDUCING_BACTERIA,
      tags: [Tag.MICROBE],
      cost: 11,
      resourceType: CardResource.MICROBE,

      behavior: {
        addResources: 3,
      },

      action: {
        or: {
          autoSelect: true,
          behaviors: [
            {
              spend: {resourcesHere: 3},
              tr: 1,
              title: 'Remove 3 microbes to increase your terraform rating 1 step',
              // LogHelper.logRemoveResource(player, this, 3, 'gain 1 TR');
            },
            {
              addResources: 1,
              title: 'Add 1 microbe to this card',
            },
          ],
        },
      },

      metadata: {
        cardNumber: '157',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.or().br;
          b.action('Remove 3 microbes to increase your TR 1 step.', (eb) => {
            eb.resource(CardResource.MICROBE, 3).startAction.tr(1);
          }).br;
          b.resource(CardResource.MICROBE, 3);
        }),
        description: 'Add 3 microbes to this card.',
      },
    });
  }
}

================
File: cards/base/NitrogenRichAsteroid.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class NitrogenRichAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.NITROGEN_RICH_ASTEROID,
      tags: [Tag.SPACE],
      cost: 31,

      behavior: {
        global: {temperature: 1},
        tr: 2,
      },

      metadata: {
        cardNumber: '037',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.plants(1).nbsp.or().br;
            pb.tag(Tag.PLANT, {amount: 3, digit}).colon().nbsp.plants(4, {digit});
          }).br;
          b.tr(2).temperature(1);
        }),
        description: 'Raise your terraforming rating 2 steps and temperature 1 step. Increase your plant production 1 step, or 4 steps if you have 3 plant tags.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    if (player.tags.count(Tag.PLANT) < 3) {
      player.production.add(Resource.PLANTS, 1, {log: true});
    } else {
      player.production.add(Resource.PLANTS, 4, {log: true});
    }
    return undefined;
  }
}

================
File: cards/base/NitrophilicMoss.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class NitrophilicMoss extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.NITROPHILIC_MOSS,
      tags: [Tag.PLANT],
      cost: 8,

      behavior: {
        production: {plants: 2},
      },

      requirements: {oceans: 3},
      metadata: {
        cardNumber: '146',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.plants(2);
          }).nbsp.minus().plants(2);
        }),
        description: 'Requires 3 ocean tiles and that you lose 2 plants. Increase your plant production 2 steps.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    const viralEnhancers = player.playedCards.find((card) => card.name === CardName.VIRAL_ENHANCERS);
    const hasEnoughPlants = player.plants >= 2 || player.isCorporation(CardName.MANUTECH) || player.plants >= 1 && viralEnhancers !== undefined;

    return hasEnoughPlants;
  }
  public override bespokePlay(player: IPlayer) {
    player.plants -= 2;
    return undefined;
  }
}

================
File: cards/base/NoctisCity.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {SelectSpace} from '../../inputs/SelectSpace';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {message} from '../../logs/MessageBuilder';

export class NoctisCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.NOCTIS_CITY,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 18,

      behavior: {
        production: {energy: -1, megacredits: 3},
      },

      metadata: {
        cardNumber: '017',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          }).nbsp.city().asterix();
        }),
        description: 'Decrease your energy production 1 step and increase your M€ production 3 steps. Place a city tile ON THE RESERVED AREA, disregarding normal placement restrictions.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    if (player.game.board.noctisCitySpaceId !== undefined) {
      return true;
    } else {
      return player.game.board.getAvailableSpacesForCity(player).length > 0;
    }
  }
  public override bespokePlay(player: IPlayer) {
    const noctisCitySpaceId = player.game.board.noctisCitySpaceId;
    if (noctisCitySpaceId !== undefined) {
      const space = player.game.board.getSpaceOrThrow(noctisCitySpaceId);
      player.game.addCity(player, space);
      return undefined;
    }
    return new SelectSpace(message('Select space for ${0}', (b) => b.card(this)), player.game.board.getAvailableSpacesForCity(player))
      .andThen((space) => {
        player.game.addCity(player, space);
        return undefined;
      });
  }
}

================
File: cards/base/NoctisFarming.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class NoctisFarming extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.NOCTIS_FARMING,
      tags: [Tag.PLANT, Tag.BUILDING],
      cost: 10,
      requirements: {temperature: -20},
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 1},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: '176',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1);
          }).nbsp.plants(2);
        }),
        description: 'Requires -20 C or warmer. Increase your M€ production 1 step and gain 2 plants.',
      },
    });
  }
}

================
File: cards/base/NuclearPower.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class NuclearPower extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.NUCLEAR_POWER,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 10,

      behavior: {
        production: {energy: 3, megacredits: -2},
      },

      metadata: {
        cardNumber: '045',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().megacredits(2).br;
            pb.plus().energy(3);
          });
        }),
        description: 'Decrease your M€ production 2 steps and increase your energy production 3 steps.',
      },
    });
  }
}

================
File: cards/base/NuclearZone.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {TileType} from '../../../common/TileType';
import {CardName} from '../../../common/cards/CardName';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';
import {CardRenderer} from '../render/CardRenderer';

export class NuclearZone extends Card implements IProjectCard {
  constructor(
    name = CardName.NUCLEAR_ZONE,
    cost = 10,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: '097',
      renderData: CardRenderer.builder((b) => {
        b.tile(TileType.NUCLEAR_ZONE, true).br;
        b.temperature(2);
      }),
      description: 'Place this tile and raise temperature 2 steps.',
    }) {
    super({
      type: CardType.AUTOMATED,
      name,
      tags: [Tag.EARTH],
      cost,
      behavior: {
        global: {temperature: 2},
        tile: {
          type: TileType.NUCLEAR_ZONE,
          on: 'land',
          adjacencyBonus: adjacencyBonus,
        },
      },
      metadata,
      victoryPoints: -2,
    });
  }
}

================
File: cards/base/OlympusConference.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {Priority} from '../../deferredActions/Priority';
import {CardRenderer} from '../render/CardRenderer';

export class OlympusConference extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.OLYMPUS_CONFERENCE,
      tags: [Tag.SCIENCE, Tag.EARTH, Tag.BUILDING],
      cost: 10,
      resourceType: CardResource.SCIENCE,
      victoryPoints: 1,

      metadata: {
        cardNumber: '185',
        renderData: CardRenderer.builder((b) => {
          b.tag(Tag.SCIENCE).colon().resource(CardResource.SCIENCE).br;
          b.or().br;
          b.minus().resource(CardResource.SCIENCE).plus().cards(1);
        }),
        description: 'When you play a science tag, including this, either add a science resource to this card, or remove a science resource from this card to draw a card.',
      },
    });
  }


  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    const scienceTags = player.tags.cardTagCount(card, Tag.SCIENCE);
    this.onScienceTagAdded(player, scienceTags);
  }
  public onColonyAddedToLeavitt(player: IPlayer) {
    this.onScienceTagAdded(player, 1);
  }
  public onScienceTagAdded(player: IPlayer, count: number) {
    for (let i = 0; i < count; i++) {
      player.defer(() => {
        // Can't remove a resource
        if (this.resourceCount === 0) {
          player.addResourceTo(this, 1);
          return undefined;
        }
        const options = new OrOptions(
          new SelectOption('Remove a science resource from this card to draw a card', 'Remove resource').andThen(() => {
            player.removeResourceFrom(this);
            player.drawCard();
            return undefined;
          }),
          new SelectOption('Add a science resource to this card', 'Add resource').andThen(() => {
            player.addResourceTo(this, 1);
            return undefined;
          }),
        );
        options.title = 'Select an option for Olympus Conference';
        return options;
      },
      Priority.SUPERPOWER); // Unshift that deferred action
    }
    return undefined;
  }
}

================
File: cards/base/OpenCity.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class OpenCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.OPEN_CITY,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 23,
      requirements: {oxygen: 12},
      victoryPoints: 1,

      behavior: {
        production: {energy: -1, megacredits: 4},
        stock: {plants: 2},
        city: {},
      },

      metadata: {
        cardNumber: '108',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(4);
          }).city().plants(2);
        }),
        description: {
          text: 'Requires 12% oxygen. Gain 2 plants. Place a city tile. Decrease your energy production 1 step and increase your M€ production 4 steps.',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/base/OptimalAerobraking.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';

export class OptimalAerobraking extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.OPTIMAL_AEROBRAKING,
      tags: [Tag.SPACE],
      cost: 7,

      metadata: {
        cardNumber: '031',
        renderData: CardRenderer.builder((b) => b.effect('When you play a space event, you gain 3 M€ and 3 heat.', (be) => {
          be.tag(Tag.SPACE).tag(Tag.EVENT).startEffect.megacredits(3).heat(3);
        })),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.type === CardType.EVENT && card.tags.includes(Tag.SPACE)) {
      player.stock.add(Resource.MEGACREDITS, 3, {log: true, from: this});
      player.stock.add(Resource.HEAT, 3, {log: true, from: this});
    }
  }
}

================
File: cards/base/OreProcessor.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class OreProcessor extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ORE_PROCESSOR,
      tags: [Tag.BUILDING],
      cost: 13,

      action: {
        spend: {energy: 4},
        stock: {titanium: 1},
        global: {oxygen: 1},
      },

      metadata: {
        cardNumber: '104',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 4 energy to gain 1 titanium and increase oxygen 1 step.', (eb) => {
            eb.energy(4, {digit}).startAction.titanium(1).oxygen(1);
          });
        }),
      },
    });
  }
}

================
File: cards/base/PermafrostExtraction.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class PermafrostExtraction extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.PERMAFROST_EXTRACTION,
      cost: 8,

      behavior: {
        ocean: {},
      },

      requirements: {temperature: -8},
      metadata: {
        cardNumber: '191',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1);
        }),
        description: 'Requires -8 C or warmer. Place 1 ocean tile.',
      },
    });
  }
}

================
File: cards/base/PeroxidePower.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class PeroxidePower extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PEROXIDE_POWER,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 7,

      behavior: {
        production: {energy: 2, megacredits: -1},
      },

      metadata: {
        cardNumber: '089',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().megacredits(1).br;
            pb.plus().energy(2);
          });
        }),
        description: 'Decrease your M€ production 1 step and increase your energy production 2 steps.',
      },
    });
  }
}

================
File: cards/base/Pets.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {Priority} from '../../deferredActions/Priority';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {Board} from '../../boards/Board';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class Pets extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PETS,
      tags: [Tag.EARTH, Tag.ANIMAL],
      cost: 10,
      resourceType: CardResource.ANIMAL,
      protectedResources: true,

      victoryPoints: {resourcesHere: {}, per: 2},

      behavior: {
        addResources: 1,
      },

      metadata: {
        cardNumber: '172',
        renderData: CardRenderer.builder((b) => {
          b.effect('When any city tile is placed, add an animal to this card.', (eb) => {
            eb.city({size: Size.SMALL, all}).startEffect.resource(CardResource.ANIMAL);
          }).br;
          b.resource(CardResource.ANIMAL).br;
          b.text('Animals may not be removed from this card', Size.SMALL, true).br;
          b.vpText('1 VP per 2 animals here.');
        }),
        description: {text: 'Add 1 animal to this card.', align: 'left'},
      },
    });
  }


  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (Board.isCitySpace(space)) {
      cardOwner.game.defer(
        new AddResourcesToCard(cardOwner, CardResource.ANIMAL, {filter: (c) => c.name === this.name}),
        cardOwner.id !== activePlayer.id ? Priority.OPPONENT_TRIGGER : undefined,
      );
    }
  }
}

================
File: cards/base/PhobosSpaceHaven.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {SpaceName} from '../../SpaceName';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class PhobosSpaceHaven extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PHOBOS_SPACE_HAVEN,
      tags: [Tag.SPACE, Tag.CITY],
      cost: 25,
      victoryPoints: 3,

      behavior: {
        production: {titanium: 1},
        city: {space: SpaceName.PHOBOS_SPACE_HAVEN},
      },

      metadata: {
        cardNumber: '021',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).nbsp.city().asterix();
        }),
        description: 'Increase your titanium production 1 step and place a city tile ON THE RESERVED AREA.',
      },
    });
  }
}

================
File: cards/base/PhysicsComplex.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class PhysicsComplex extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PHYSICS_COMPLEX,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 12,

      resourceType: CardResource.SCIENCE,
      victoryPoints: {resourcesHere: {}, each: 2},

      action: {
        spend: {energy: 6},
        addResources: 1,
      },

      metadata: {
        cardNumber: '095',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 6 energy to add a science resource to this card.', (eb) => {
            eb.energy(6, {digit}).startAction.resource(CardResource.SCIENCE);
          }).br;
          b.vpText('2 VP for each science resource on this card.');
        }),
      },
    });
  }
}

================
File: cards/base/Plantation.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Plantation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PLANTATION,
      tags: [Tag.PLANT],
      cost: 15,

      behavior: {
        greenery: {},
      },

      requirements: {tag: Tag.SCIENCE, count: 2},
      metadata: {
        cardNumber: '193',
        renderData: CardRenderer.builder((b) => {
          b.greenery();
        }),
        description: 'Requires 2 science tags. Place a greenery tile and raise oxygen 1 step.',
      },
    });
  }
}

================
File: cards/base/PowerGrid.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class PowerGrid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.POWER_GRID,
      tags: [Tag.POWER],
      cost: 18,

      behavior: {
        production: {energy: {tag: Tag.POWER}},
      },

      metadata: {
        cardNumber: '102',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).slash().tag(Tag.POWER));
        }),
        description: 'Increase your energy production step for each power tag you have, including this.',
      },
    });
  }
}

================
File: cards/base/PowerInfrastructure.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IActionCard} from '../ICard';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {SelectAmount} from '../../inputs/SelectAmount';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';

export class PowerInfrastructure extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.POWER_INFRASTRUCTURE,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 4,

      metadata: {
        cardNumber: '194',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend any amount of energy and gain that amount of M€.', (eb) => {
            eb.text('x').energy(1).startAction.megacredits(1, {text: 'x'});
          });
        }),
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.energy > 0;
  }
  public action(player: IPlayer) {
    return new SelectAmount('Select amount of energy to spend', 'Spend energy', 1, player.energy)
      .andThen((amount) => {
        player.stock.deduct(Resource.ENERGY, amount);
        player.stock.add(Resource.MEGACREDITS, amount, {log: true});
        return undefined;
      });
  }
}

================
File: cards/base/PowerPlant.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class PowerPlant extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.POWER_PLANT,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 4,

      behavior: {
        production: {energy: 1},
      },

      metadata: {
        cardNumber: '141',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1));
        }),
        description: 'Increase your energy production 1 step.',
      },
    });
  }
}

================
File: cards/base/PowerSupplyConsortium.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {DecreaseAnyProduction} from '../../deferredActions/DecreaseAnyProduction';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {GainProduction} from '../../deferredActions/GainProduction';

export class PowerSupplyConsortium extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.POWER_SUPPLY_CONSORTIUM,
      tags: [Tag.POWER],
      cost: 5,

      requirements: {tag: Tag.POWER, count: 2},
      metadata: {
        cardNumber: '160',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1, {all}).br;
            pb.plus().energy(1);
          });
        }),
        description: 'Requires 2 power tags. Decrease any energy production 1 step and increase your own 1 step.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const gainProduction = new GainProduction(player, Resource.ENERGY, {count: 1, log: false});
    const decreaseAnyProduction = new DecreaseAnyProduction(player, Resource.ENERGY, {count: 1, stealing: true});
    // If no player has energy production, then This Player must gain their energy production in order to lose it.
    if (player.game.getPlayers().filter((player) => player.production.energy > 0).length === 0) {
      player.game.defer(gainProduction).andThen(() => player.game.defer(decreaseAnyProduction));
    } else {
      player.game.defer(decreaseAnyProduction).andThen(() => player.game.defer(gainProduction));
    }
    return undefined;
  }
}

================
File: cards/base/Predators.ts
================
import {IActionCard} from '../ICard';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {RemoveResourcesFromCard} from '../../deferredActions/RemoveResourcesFromCard';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class Predators extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PREDATORS,
      tags: [Tag.ANIMAL],
      cost: 14,

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}},
      requirements: {oxygen: 11},

      metadata: {
        cardNumber: '024',
        renderData: CardRenderer.builder((b) => {
          b.action('Remove 1 animal from any card and add it to this card.', (eb) => {
            eb.resource(CardResource.ANIMAL, {all}).startAction.resource(CardResource.ANIMAL);
          }).br;
          b.vpText('1 VP per animal on this card.');
        }),
        description: 'Requires 11% oxygen.',
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    if (player.game.isSoloMode()) return true;
    return RemoveResourcesFromCard.getAvailableTargetCards(player, CardResource.ANIMAL).length > 0;
  }

  public action(player: IPlayer) {
    player.game.defer(
      new RemoveResourcesFromCard(player, CardResource.ANIMAL)
        .andThen((response) => {
          if (response.proceed) {
            player.game.defer(new AddResourcesToCard(player, CardResource.ANIMAL, {filter: (c) => c.name === this.name}));
          }
        }));
    return undefined;
  }
}

================
File: cards/base/ProtectedHabitats.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {CardResource} from '../../../common/CardResource';

export class ProtectedHabitats extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PROTECTED_HABITATS,
      cost: 5,

      metadata: {
        cardNumber: '173',
        renderData: CardRenderer.builder((b) => {
          b.text('Opponents may not remove your', Size.SMALL, true).br;
          b.plants(1).resource(CardResource.ANIMAL).resource(CardResource.MICROBE);
        }),
      },
    });
  }
}

================
File: cards/base/ProtectedValley.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class ProtectedValley extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PROTECTED_VALLEY,
      tags: [Tag.PLANT, Tag.BUILDING],
      cost: 23,

      behavior: {
        production: {megacredits: 2},
        greenery: {on: 'ocean'},
      },

      metadata: {
        cardNumber: '174',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).nbsp;
          b.greenery().asterix();
        }),
        description: 'Increase your M€ production 2 steps. Place a greenery tile ON AN AREA RESERVED FOR OCEAN, disregarding normal placement restrictions, and increase oxygen 1 step.',
      },
    });
  }
}

================
File: cards/base/QuantumExtractor.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class QuantumExtractor extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.QUANTUM_EXTRACTOR,
      tags: [Tag.SCIENCE, Tag.POWER],
      cost: 13,

      behavior: {
        production: {energy: 4},
      },

      requirements: {tag: Tag.SCIENCE, count: 4},
      cardDiscount: {tag: Tag.SPACE, amount: 2},
      metadata: {
        cardNumber: '079',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => pb.energy(4, {digit}));
        }),
        description: 'Requires 4 science tags. Increase your energy production 4 steps.',
      },
    });
  }
}

================
File: cards/base/RadChemFactory.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class RadChemFactory extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.RAD_CHEM_FACTORY,
      tags: [Tag.BUILDING],
      cost: 8,

      behavior: {
        production: {energy: -1},
        tr: 2,
      },

      metadata: {
        cardNumber: '205',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().energy(1)).br;
          b.tr(2);
        }),
        description: 'Decrease your energy production 1 step. Raise your TR 2 steps.',
      },
    });
  }
}

================
File: cards/base/RadSuits.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class RadSuits extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.RAD_SUITS,
      cost: 6,
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 1},
      },

      requirements: {cities: 2, all},
      metadata: {
        cardNumber: '186',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1));
        }),
        description: 'Requires two cities in play. Increase your M€ production 1 step.',
      },
    });
  }
}

================
File: cards/base/RegolithEaters.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class RegolithEaters extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.REGOLITH_EATERS,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      cost: 13,
      resourceType: CardResource.MICROBE,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Remove 2 microbes to raise oxygen level 1 step',
            spend: {resourcesHere: 2},
            global: {oxygen: 1},
            // LogHelper.logRemoveResource(player, this, 2, 'raise oxygen 1 step');
          },
          {
            title: 'Add 1 microbe to this card',
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: '033',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.or().br;
          b.action('Remove 2 microbes from this card to raise oxygen level 1 step.', (eb) => {
            eb.resource(CardResource.MICROBE, 2).startAction.oxygen(1);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/base/ReleaseOfInertGases.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class ReleaseOfInertGases extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.RELEASE_OF_INERT_GASES,
      cost: 14,

      behavior: {
        tr: 2,
      },

      metadata: {
        cardNumber: '036',
        renderData: CardRenderer.builder((b) => {
          b.tr(2);
        }),
        description: 'Raise your terraforming rating 2 steps.',
      },
    });
  }
}

================
File: cards/base/Research.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Research extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.RESEARCH,
      tags: [Tag.SCIENCE, Tag.SCIENCE],
      cost: 11,
      victoryPoints: 1,

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: '090',
        renderData: CardRenderer.builder((b) => {
          b.cards(2);
        }),
        description: 'Counts as playing 2 science cards. Draw 2 cards.',
      },
    });
  }
}

================
File: cards/base/ResearchOutpost.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class ResearchOutpost extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.RESEARCH_OUTPOST,
      tags: [Tag.SCIENCE, Tag.CITY, Tag.BUILDING],
      cost: 18,

      behavior: {
        city: {on: 'isolated'},
      },

      cardDiscount: {amount: 1},
      metadata: {
        cardNumber: '020',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a card, you pay 1 M€ less for it.', (eb) => {
            eb.empty().startEffect.megacredits(-1);
          }).br;
          b.city();
        }),
        description: 'Place a city tile NEXT TO NO OTHER TILE.',
      },
    });
  }
}

================
File: cards/base/RestrictedArea.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {TileType} from '../../../common/TileType';
import {CardName} from '../../../common/cards/CardName';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';
import {CardRenderer} from '../render/CardRenderer';

export class RestrictedArea extends ActionCard implements IProjectCard {
  constructor(
    name = CardName.RESTRICTED_AREA,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: '199',
      renderData: CardRenderer.builder((b) => {
        b.action('Spend 2 M€ to draw a card.', (eb) => {
          eb.megacredits(2).startAction.cards(1);
        }).br;
        b.tile(TileType.RESTRICTED_AREA, true);
      }),
      description: 'Place this tile.',
    }) {
    super({
      type: CardType.ACTIVE,
      name,
      tags: [Tag.SCIENCE],
      //Andy updated this. Hacky way to rebalance around Ares.
      cost: 13,

      behavior: {
        tile: {
          type: TileType.RESTRICTED_AREA,
          on: 'land',
          adjacencyBonus: adjacencyBonus,
        },
      },

      action: {
        spend: {megacredits: 2},
        drawCard: 1,
      },

      metadata,
    });
  }
}

================
File: cards/base/RoboticWorkforce.ts
================
import {Tag} from '../../../common/cards/Tag';
import {RoboticWorkforceBase} from './RoboticWorkforceBase';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {IPlayer} from '../../IPlayer';
import {Priority} from '../../deferredActions/Priority';

export class RoboticWorkforce extends RoboticWorkforceBase {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ROBOTIC_WORKFORCE,
      tags: [Tag.SCIENCE],
      cost: 9,
      metadata: {
        cardNumber: '086',
        hasExternalHelp: true,
        renderData: CardRenderer.builder((b) => {
          b.text('Copy A', Size.SMALL, true).nbsp;
          b.production((pb) => pb.tag(Tag.BUILDING));
        }),
        description: 'Duplicate only the production box of one of your building cards.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.defer(
      this.selectBuildingCard(
        player,
        this.getPlayableBuildingCards(player),
        'Select builder card to copy',
      ),
      Priority.ROBOTIC_WORKFORCE,
    );
    return undefined;
  }
}

================
File: cards/base/RoboticWorkforceBase.ts
================
import {Tag} from '../../../common/cards/Tag';
import {Card, StaticCardProperties} from '../Card';
import {IPlayer} from '../../IPlayer';
import {SelectCard} from '../../inputs/SelectCard';
import {ICard} from '../ICard';
import {Behavior} from '../../behavior/Behavior';
import {getBehaviorExecutor} from '../../behavior/BehaviorExecutor';
import {PlayerInput} from '../../PlayerInput';
import {CardName} from '../../../common/cards/CardName';

export abstract class RoboticWorkforceBase extends Card {
  constructor(properties: StaticCardProperties) {
    super(properties);
  }

  /**
   * Returns a copy of behavior with just `production` and `decreaseAnyProduction` fields.
   */
  protected productionBehavior(behavior: Behavior): Behavior {
    const filtered: Behavior = {};
    if (behavior.production !== undefined) {
      filtered.production = behavior.production;
    }
    if (behavior.decreaseAnyProduction !== undefined) {
      filtered.decreaseAnyProduction = behavior.decreaseAnyProduction;
    }
    return filtered;
  }

  protected isCardApplicable(card: ICard, player: IPlayer): boolean {
    if (!card.tags.includes(Tag.BUILDING) && !card.tags.includes(Tag.WILD)) {
      return false;
    }

    // Small Open Pit Mine allows a player to choose between two options. Both are
    // positive production so accept it rather than dig deep.
    if (card.name === CardName.SMALL_OPEN_PIT_MINE) {
      return true;
    }

    if (card.productionBox !== undefined) {
      return player.production.canAdjust(card.productionBox(player));
    }

    if (card.behavior !== undefined) {
      const productionBehavior = this.productionBehavior(card.behavior);
      if (Object.keys(productionBehavior).length > 0) {
        return getBehaviorExecutor().canExecute(productionBehavior, player, card);
      }
    }

    // Card has no production box.
    return false;
  }

  protected getPlayableBuildingCards(player: IPlayer): ReadonlyArray<ICard> {
    return player.tableau.filter((card) => this.isCardApplicable(card, player));
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return this.getPlayableBuildingCards(player).length > 0;
  }

  protected selectBuildingCard(player: IPlayer, cards: ReadonlyArray<ICard>, title: string, cb: (card: ICard) => PlayerInput | undefined = () => undefined) {
    if (cards.length === 0) {
      return undefined;
    }
    return new SelectCard(title, 'Copy', cards)
      .andThen(([card]) => {
        player.game.log('${0} copied ${1} production with ${2}', (b) =>
          b.player(player).card(card).card(this));

        if (card.produce) {
          card.produce(player);
        } else if (card.productionBox) {
          player.production.adjust(card.productionBox(player), {log: true});
        } else if (card.behavior !== undefined) {
          getBehaviorExecutor().execute(this.productionBehavior(card.behavior), player, card);
        }
        return cb(card);
      });
  }
}

================
File: cards/base/RoverConstruction.ts
================
import {IProjectCard} from '../IProjectCard';
import {Space} from '../../boards/Space';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {Priority} from '../../deferredActions/Priority';
import {GainResources} from '../../deferredActions/GainResources';
import {Board} from '../../boards/Board';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class RoverConstruction extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ROVER_CONSTRUCTION,
      tags: [Tag.BUILDING],
      cost: 8,
      victoryPoints: 1,

      metadata: {
        cardNumber: '038',
        renderData: CardRenderer.builder((b) => {
          b.effect('When any city tile is placed, gain 2 M€.', (eb) => {
            eb.city({size: Size.SMALL, all}).startEffect.megacredits(2);
          });
        }),
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (Board.isCitySpace(space)) {
      cardOwner.game.defer(
        new GainResources(cardOwner, Resource.MEGACREDITS, {count: 2, log: true}),
        cardOwner.id !== activePlayer.id ? Priority.OPPONENT_TRIGGER : undefined,
      );
    }
  }
}

================
File: cards/base/Sabotage.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {OrOptions} from '../../inputs/OrOptions';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {SelectOption} from '../../inputs/SelectOption';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {all, digit} from '../Options';
import {message} from '../../logs/MessageBuilder';

export class Sabotage extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SABOTAGE,
      cost: 1,

      metadata: {
        cardNumber: '121',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(3, {all, digit}).nbsp.or(Size.SMALL).nbsp;
          b.minus().steel(4, {all, digit}).br.or(Size.SMALL).nbsp;
          b.minus().megacredits(7, {all});
        }),
        description: 'Remove up to 3 titanium from any player, or 4 steel, or 7 M€.',
      },
    });
  }

  private title(amount: number, type: string, target: IPlayer) {
    return message('Remove ${0} ${1} from ${2}', (b) => b.number(amount).string(type).player(target));
  }

  public override bespokePlay(player: IPlayer) {
    if (player.game.isSoloMode()) return undefined;

    const availableActions = new OrOptions();

    player.getOpponents().forEach((target) => {
      if (target.titanium > 0 && !target.alloysAreProtected()) {
        const amountRemoved = Math.min(3, target.titanium);
        const optionTitle = this.title(amountRemoved, 'titanium', target);
        availableActions.options.push(new SelectOption(optionTitle).andThen(() => {
          target.stock.deduct(Resource.TITANIUM, 3, {log: true, from: player});
          return undefined;
        }));
      }

      if (target.steel > 0 && !target.alloysAreProtected()) {
        const amountRemoved = Math.min(4, target.steel);
        const optionTitle = this.title(amountRemoved, 'steel', target);
        availableActions.options.push(new SelectOption(optionTitle).andThen(() => {
          target.stock.deduct(Resource.STEEL, 4, {log: true, from: player});
          return undefined;
        }));
      }

      if (target.megaCredits > 0) {
        const amountRemoved = Math.min(7, target.megaCredits);
        const optionTitle = this.title(amountRemoved, 'M€', target);
        availableActions.options.push(new SelectOption(optionTitle).andThen(() => {
          target.stock.deduct(Resource.MEGACREDITS, 7, {log: true, from: player});
          return undefined;
        }));
      }
    });

    if (availableActions.options.length > 0) {
      availableActions.options.push(new SelectOption('Do not remove resource').andThen(() => {
        return undefined;
      }));
      return availableActions;
    }
    return undefined;
  }
}

================
File: cards/base/Satellites.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Satellites extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SATELLITES,
      tags: [Tag.SPACE],
      cost: 10,

      behavior: {
        production: {megacredits: {tag: Tag.SPACE}},
      },

      metadata: {
        cardNumber: '175',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).slash().tag(Tag.SPACE);
          });
        }),
        description: 'Increase your M€ production 1 step for each space tag you have, including this one.',
      },
    });
  }
}

================
File: cards/base/SearchForLife.ts
================
import {IActionCard} from '../ICard';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../render/CardRenderer';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';
import {max} from '../Options';
import {TITLES} from '../../inputs/titles';

export class SearchForLife extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SEARCH_FOR_LIFE,
      tags: [Tag.SCIENCE],
      cost: 3,

      resourceType: CardResource.SCIENCE,
      victoryPoints: 'special',

      requirements: {oxygen: 6, max},
      metadata: {
        cardNumber: '005',
        description: 'Oxygen must be 6% or less.',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 M€ to reveal the top card of the draw deck. If that card has a microbe tag, add a science resource here.', (eb) => {
            eb.megacredits(1).startAction.tag(Tag.MICROBE).asterix().nbsp.colon().nbsp.resource(CardResource.SCIENCE);
          }).br;
          b.vpText('3 VPs if you have one or more science resources here.');
        }),
        victoryPoints: CardRenderDynamicVictoryPoints.searchForLife(),
      },
    });
  }

  public override getVictoryPoints() {
    if (this.resourceCount > 0) {
      return 3;
    }
    return 0;
  }
  public canAct(player: IPlayer): boolean {
    if (!player.game.projectDeck.canDraw(1)) {
      this.warnings.add('deckTooSmall');
    }
    return player.canAfford(1);
  }
  public action(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 1, {title: TITLES.payForCardAction(this.name)}))
      .andThen(() => {
        const card = player.game.projectDeck.draw(player.game);
        if (card === undefined) {
          return;
        }
        player.game.log('${0} revealed and discarded ${1}', (b) => b.player(player).card(card, {tags: true}));
        if (card.tags.includes(Tag.MICROBE)) {
          player.addResourceTo(this, 1);
          player.game.log('${0} found life!', (b) => b.player(player));
        }

        player.game.projectDeck.discard(card);
      });

    return undefined;
  }
}

================
File: cards/base/SecurityFleet.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SecurityFleet extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SECURITY_FLEET,
      tags: [Tag.SPACE],
      cost: 12,
      resourceType: CardResource.FIGHTER,

      victoryPoints: {resourcesHere: {}},

      action: {
        spend: {titanium: 1},
        addResources: 1,
      },

      metadata: {
        cardNumber: '028',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add 1 fighter resource to this card.', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.FIGHTER);
          }).br;
          b.vpText('1 VP for each fighter resource on this card.');
        }),
      },
    });
  }
}

================
File: cards/base/Shuttles.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Shuttles extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SHUTTLES,
      tags: [Tag.SPACE],
      cost: 10,
      victoryPoints: 1,

      behavior: {
        production: {energy: -1, megacredits: 2},
      },

      requirements: {oxygen: 5},
      cardDiscount: {tag: Tag.SPACE, amount: 2},
      metadata: {
        cardNumber: '166',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => {
            pb.minus().energy(1).nbsp;
            pb.plus().megacredits(2);
          });
        }),
        description: {
          text: 'Requires 5% oxygen. Decrease your energy production 1 step and increase your M€ production 2 steps.',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/base/SmallAnimals.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {Resource} from '../../../common/Resource';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class SmallAnimals extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SMALL_ANIMALS,
      tags: [Tag.ANIMAL],
      cost: 6,

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {oxygen: 6},

      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 1},
      },

      action: {
        addResources: 1,
      },

      metadata: {
        cardNumber: '054',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.production((pb) => pb.minus().plants(1, {all})).br;
          b.vpText('1 VP per 2 animals on this card.');
        }),
        description: {
          text: 'Requires 6% oxygen. Decrease any plant production 1 step.',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/base/SoilFactory.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SoilFactory extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SOIL_FACTORY,
      tags: [Tag.BUILDING],
      cost: 9,

      behavior: {
        production: {energy: -1, plants: 1},
      },
      victoryPoints: 1,

      metadata: {
        cardNumber: '179',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().plants(1);
          });
        }),
        description: 'Decrease your energy production 1 step and increase your plant production 1 step.',
      },
    });
  }
}

================
File: cards/base/SolarPower.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SolarPower extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SOLAR_POWER,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 11,

      behavior: {
        production: {energy: 1},
      },
      victoryPoints: 1,

      metadata: {
        cardNumber: '113',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1));
        }),
        description: 'Increase your energy production 1 step.',
      },
    });
  }
}

================
File: cards/base/SolarWindPower.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SolarWindPower extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SOLAR_WIND_POWER,
      tags: [Tag.SCIENCE, Tag.SPACE, Tag.POWER],
      cost: 11,

      behavior: {
        production: {energy: 1},
        stock: {titanium: 2},
      },

      metadata: {
        cardNumber: '077',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1)).br.titanium(2);
        }),
        description: 'Increase your energy production 1 step and gain 2 titanium.',
      },
    });
  }
}

================
File: cards/base/Soletta.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Soletta extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SOLETTA,
      tags: [Tag.SPACE],
      cost: 35,

      behavior: {
        production: {heat: 7},
      },

      metadata: {
        cardNumber: '203',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(7));
        }),
        description: 'Increase your heat production 7 steps.',
      },
    });
  }
}

================
File: cards/base/SpaceElevator.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SpaceElevator extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SPACE_ELEVATOR,
      tags: [Tag.SPACE, Tag.BUILDING],
      cost: 27,

      behavior: {
        production: {titanium: 1},
      },
      action: {
        spend: {steel: 1},
        stock: {megacredits: 5},
      },

      victoryPoints: 2,

      metadata: {
        cardNumber: '203',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 steel to gain 5 M€.', (eb) => {
            eb.steel(1).startAction.megacredits(5);
          }).br;
          b.production((pb) => pb.titanium(1));
        }),
        description: 'Increase your titanium production 1 step.',
      },
    });
  }
}

================
File: cards/base/SpaceMirrors.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SpaceMirrors extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SPACE_MIRRORS,
      tags: [Tag.POWER, Tag.SPACE],
      cost: 3,

      action: {
        spend: {megacredits: 7},
        production: {energy: 1},
      },

      metadata: {
        cardNumber: '076',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 7 M€ to increase your energy production 1 step.', (eb) => {
            eb.megacredits(7).startAction.production((pb) => pb.energy(1));
          });
        }),
      },
    });
  }
}

================
File: cards/base/SpaceStation.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SpaceStation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SPACE_STATION,
      tags: [Tag.SPACE],
      cost: 10,
      victoryPoints: 1,

      cardDiscount: {tag: Tag.SPACE, amount: 2},
      metadata: {
        cardNumber: '025',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-2);
          });
        }),
      },
    });
  }
}

================
File: cards/base/SpecialDesign.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SpecialDesign extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SPECIAL_DESIGN,
      tags: [Tag.SCIENCE],
      cost: 4,
      globalParameterRequirementBonus: {steps: 2, nextCardOnly: true},

      metadata: {
        cardNumber: '206',
        renderData: CardRenderer.builder((b) => {
          b.plate('Global requirements').colon().text('+/- 2');
        }),
        description: 'The next card you play this generation is +2 or -2 steps in global requirements, your choice.',
      },
    });
  }
}

================
File: cards/base/Sponsors.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Sponsors extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SPONSORS,
      tags: [Tag.EARTH],
      cost: 6,

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: '068',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2));
        }),
        description: 'Increase your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/base/standardActions/ConvertHeat.ts
================
import {StandardActionCard} from '../../StandardActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {MAX_TEMPERATURE} from '../../../../common/constants';
import {Units} from '../../../../common/Units';
import {message} from '../../../logs/MessageBuilder';
import {SelectOption} from '../../../inputs/SelectOption';


export class ConvertHeat extends StandardActionCard {
  constructor() {
    super({
      name: CardName.CONVERT_HEAT,
      metadata: {
        cardNumber: 'SA2',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 8 heat to raise temperature 1 step.', (eb) => {
            eb.heat(8).startAction.temperature(1);
          }),
        ),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    
    if (player.game.getTemperature() === MAX_TEMPERATURE) {
      this.warnings.add('maxtemp');
    }

    // Strictly speaking, this conditional is not necessary, because canAfford manages reserveUnits.
    if (player.availableHeat() < player.heatNeededForTemperature) {
      return false;
    }

    return player.canAfford({
      cost: 0,
      tr: {temperature: 1},
      reserveUnits: Units.of({heat: player.heatNeededForTemperature}),
    });
  }

  public action(player: IPlayer) {    
    return new SelectOption(
      message('Spend ${0} heat to raise temperature', (b) => b.number(player.heatNeededForTemperature)),
      'Confirm'
    ).andThen(() => {
      return player.spendHeat(player.heatNeededForTemperature, () => {
        this.actionUsed(player);
        player.game.increaseTemperature(player, 1);
        return undefined;
      });
    });
  }
}

================
File: cards/base/standardActions/ConvertPlants.ts
================
import {StandardActionCard} from '../../StandardActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {MAX_OXYGEN_LEVEL} from '../../../../common/constants';
import {SelectSpace} from '../../../inputs/SelectSpace';
import {Units} from '../../../../common/Units';
import {message} from '../../../logs/MessageBuilder';


export class ConvertPlants extends StandardActionCard {
  constructor() {
    super({
      name: CardName.CONVERT_PLANTS,
      metadata: {
        cardNumber: 'SA2',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 8 plants to place a greenery tile and raise oxygen 1 step.', (eb) => {
            eb.plants(8).startAction.greenery();
          }),
        ),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    if (player.plants < player.plantsNeededForGreenery) {
      return false;
    }
    if (player.game.board.getAvailableSpacesForGreenery(player).length === 0) {
      return false;
    }
    if (player.game.getOxygenLevel() === MAX_OXYGEN_LEVEL) {
      // The level is maximized, and that means you don't have to try to figure out if the
      // player can afford the reds tax when increasing the oxygen level.
      return true;
    }
    return player.canAfford({
      cost: 0,
      tr: {oxygen: 1},
      reserveUnits: Units.of({plants: player.plantsNeededForGreenery}),
    });
  }

  public action(player: IPlayer) {
    return new SelectSpace(
      message('Convert ${0} plants into greenery', (b) => b.number(player.plantsNeededForGreenery)),
      player.game.board.getAvailableSpacesForGreenery(player))
      .andThen((space) => {
        this.actionUsed(player);
        player.game.addGreenery(player, space);
        player.plants -= player.plantsNeededForGreenery;
        return undefined;
      });
  }
}

================
File: cards/base/standardActions/standardProjects/AquiferStandardProject.ts
================
import {IPlayer} from '../../../../IPlayer';
import {CardName} from '../../../../../common/cards/CardName';
import {CardRenderer} from '../../../render/CardRenderer';
import {PlaceOceanTile} from '../../../../deferredActions/PlaceOceanTile';
import {StandardProjectCard} from '../../../StandardProjectCard';

export class AquiferStandardProject extends StandardProjectCard {
  constructor() {
    super({
      name: CardName.AQUIFER_STANDARD_PROJECT,
      cost: 18,
      tr: {oceans: 1},
      metadata: {
        cardNumber: 'SP2',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 18 M€ to place an ocean tile.', (eb) => {
            eb.megacredits(18).startAction.oceans(1);
          })),
      },
    });
  }

  public override canPayWith(player: IPlayer) {
    if (player.isCorporation(CardName.KUIPER_COOPERATIVE)) {
      return {kuiperAsteroids: true};
    } else {
      return {};
    }
  }

  public override canAct(player: IPlayer): boolean {
    if (!player.game.canAddOcean()) {
      this.warnings.add('maxoceans');
    }
    return super.canAct(player);
  }

  actionEssence(player: IPlayer): void {
    player.game.defer(new PlaceOceanTile(player));
  }
}

================
File: cards/base/standardActions/standardProjects/AsteroidStandardProject.ts
================
import * as constants from '../../../../../common/constants';
import {IPlayer} from '../../../../IPlayer';
import {CardName} from '../../../../../common/cards/CardName';
import {CardRenderer} from '../../../render/CardRenderer';
import {StandardProjectCard} from '../../../StandardProjectCard';

export class AsteroidStandardProject extends StandardProjectCard {
  constructor() {
    super({
      name: CardName.ASTEROID_STANDARD_PROJECT,
      cost: 14,
      tr: {temperature: 1},
      metadata: {
        cardNumber: 'SP9',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 14 M€ to raise the temperature 1 step.', (eb) => {
            eb.megacredits(14).startAction.temperature(1);
          }),
        ),
      },
    });
  }

  public override canPayWith(player: IPlayer) {
    if (player.isCorporation(CardName.KUIPER_COOPERATIVE)) {
      return {kuiperAsteroids: true};
    } else {
      return {};
    }
  }

  public override canAct(player: IPlayer): boolean {
    if (player.game.getTemperature() >= constants.MAX_TEMPERATURE) {
      this.warnings.add('maxtemp');
    }
    return super.canAct(player);
  }

  actionEssence(player: IPlayer): void {
    player.game.increaseTemperature(player, 1);
  }
}

================
File: cards/base/standardActions/standardProjects/CityStandardProject.ts
================
import {IPlayer} from '../../../../IPlayer';
import {CardName} from '../../../../../common/cards/CardName';
import {CardRenderer} from '../../../render/CardRenderer';
import {StandardProjectCard} from '../../../StandardProjectCard';
import {PlaceCityTile} from '../../../../deferredActions/PlaceCityTile';
import {Resource} from '../../../../../common/Resource';

export class CityStandardProject extends StandardProjectCard {
  constructor() {
    super({
      name: CardName.CITY_STANDARD_PROJECT,
      cost: 25,
      metadata: {
        cardNumber: 'SP4',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 25 M€ to place a city tile and increase your M€ production 1 step.', (eb) => {
            eb.megacredits(25).startAction.city().production((pb) => {
              pb.megacredits(1);
            });
          }),
        ),
      },
    });
  }

  protected override discount(player: IPlayer): number {
    if (player.playedCards.find((card) => card.name === CardName.PREFABRICATION_OF_HUMAN_HABITATS)) {
      return 2 + super.discount(player);
    }
    return super.discount(player);
  }

  public override canPayWith(player: IPlayer) {
    if (player.playedCards.find((card) => card.name === CardName.PREFABRICATION_OF_HUMAN_HABITATS)) {
      return {steel: true};
    } else {
      return {};
    }
  }

  public override canAct(player: IPlayer): boolean {
    // This is pricey because it forces calling canPlayOptions twice.
    if (player.game.board.getAvailableSpacesForCity(player, this.canPlayOptions(player)).length === 0) {
      return false;
    }
    return super.canAct(player);
  }

  actionEssence(player: IPlayer): void {
    player.game.defer(new PlaceCityTile(player));
    player.production.add(Resource.MEGACREDITS, 1);
  }
}

================
File: cards/base/standardActions/standardProjects/GreeneryStandardProject.ts
================
import {IPlayer} from '../../../../IPlayer';
import {CardName} from '../../../../../common/cards/CardName';
import {CardRenderer} from '../../../render/CardRenderer';
import {StandardProjectCard} from '../../../StandardProjectCard';
import {PlaceGreeneryTile} from '../../../../deferredActions/PlaceGreeneryTile';

export class GreeneryStandardProject extends StandardProjectCard {
  constructor() {
    super({
      name: CardName.GREENERY_STANDARD_PROJECT,
      cost: 23,
      tr: {oxygen: 1},
      metadata: {
        cardNumber: 'SP6',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 23 M€ to place a greenery tile and raise oxygen 1 step.', (eb) => {
            eb.megacredits(23).startAction.greenery();
          }),
        ),
      },
    });
  }
  protected override discount(player: IPlayer): number {
    let discount = 0;
    if (player.cardIsInEffect(CardName.ECO_CENTRAL)) {
      discount += 3;
    }
    return discount;
  }

  public override canPayWith(player: IPlayer) {
    if (player.isCorporation(CardName.SOYLENT_SEEDLING_SYSTEMS)) {
      return {seeds: true};
    } else {
      return {};
    }
  }

  public override canAct(player: IPlayer): boolean {
    // This is pricey because it forces calling canPlayOptions twice.
    if (player.game.board.getAvailableSpacesForGreenery(player, this.canPlayOptions(player)).length === 0) {
      return false;
    }
    return super.canAct(player);
  }

  actionEssence(player: IPlayer): void {
    player.game.defer(new PlaceGreeneryTile(player));
  }
}

================
File: cards/base/standardActions/standardProjects/PowerPlantStandardProject.ts
================
import {IPlayer} from '../../../../IPlayer';
import {CardName} from '../../../../../common/cards/CardName';
import {CardRenderer} from '../../../render/CardRenderer';
import {StandardProjectCard} from '../../../StandardProjectCard';
import {Resource} from '../../../../../common/Resource';

export class PowerPlantStandardProject extends StandardProjectCard {
  constructor() {
    super({
      name: CardName.POWER_PLANT_STANDARD_PROJECT,
      cost: 11,
      metadata: {
        cardNumber: 'SP7',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 11 M€ to increase your energy production 1 step.', (eb) => {
            eb.megacredits(11).startAction.production((pb) => {
              pb.energy(1);
            });
          }),
        ),
      },
    });
  }

  protected override discount(player: IPlayer): number {
    let discount = 0;
    if (player.isCorporation(CardName.THORGATE)) {
      discount += 3;
    }
    if (player.cardIsInEffect(CardName.HIGH_TEMP_SUPERCONDUCTORS)) {
      discount += 3;
    }
    return discount;
  }

  actionEssence(player: IPlayer): void {
    player.production.add(Resource.ENERGY, 1);
  }
}

================
File: cards/base/standardActions/standardProjects/SellPatentsStandardProject.ts
================
import {IPlayer} from '../../../../IPlayer';
import {CardName} from '../../../../../common/cards/CardName';
import {CardRenderer} from '../../../render/CardRenderer';
import {StandardProjectCard} from '../../../StandardProjectCard';
import {SelectCard} from '../../../../inputs/SelectCard';
import {IProjectCard} from '../../../IProjectCard';

export class SellPatentsStandardProject extends StandardProjectCard {
  constructor() {
    super({
      name: CardName.SELL_PATENTS_STANDARD_PROJECT,
      cost: 0,
      metadata: {
        cardNumber: 'SP8',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Discard any number of cards to gain that amount of M€.', (eb) => {
            eb.text('X').cards(1).startAction.megacredits(1, {text: 'x'});
          }),
        ),
      },
    });
  }

  public override canAct(player: IPlayer): boolean {
    return player.cardsInHand.length > 0;
  }

  actionEssence(): void {
    // no-op
  }

  public override action(player: IPlayer): SelectCard<IProjectCard> {
    return new SelectCard(
      'Sell patents',
      'Sell',
      player.cardsInHand,
      {max: player.cardsInHand.length, played: false})
      .andThen((cards) => {
        player.megaCredits += cards.length;
        cards.forEach((card) => player.discardCardFromHand(card));
        this.projectPlayed(player);
        player.game.log('${0} sold ${1} patents', (b) => b.player(player).number(cards.length));
        return undefined;
      });
  }
}

================
File: cards/base/StandardTechnology.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IStandardProjectCard} from '../IStandardProjectCard';
import {Resource} from '../../../common/Resource';

export class StandardTechnology extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.STANDARD_TECHNOLOGY,
      tags: [Tag.SCIENCE],
      cost: 6,

      metadata: {
        cardNumber: '156',
        renderData: CardRenderer.builder((b) => {
          b.effect('After you pay for a standard project, except selling patents, you gain 3 M€.', (eb) => {
            eb.plate('Standard projects').startEffect.megacredits(3);
          });
        }),
      },
    });
  }
  public onStandardProject(player: IPlayer, projectType: IStandardProjectCard) {
    if (projectType.name !== CardName.SELL_PATENTS_STANDARD_PROJECT) {
      player.stock.add(Resource.MEGACREDITS, 3, {log: true});
    }
  }
}

================
File: cards/base/Steelworks.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class Steelworks extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.STEELWORKS,
      tags: [Tag.BUILDING],
      cost: 15,

      action: {
        spend: {energy: 4},
        stock: {steel: 2},
        global: {oxygen: 1},
      },

      metadata: {
        cardNumber: '103',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 4 energy to gain 2 steel and increase oxygen 1 step.', (eb) => {
            eb.energy(4, {digit}).startAction.steel(2).oxygen(1);
          });
        }),
      },
    });
  }
}

================
File: cards/base/StripMine.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class StripMine extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.STRIP_MINE,
      tags: [Tag.BUILDING],
      cost: 25,

      behavior: {
        production: {energy: -2, steel: 2, titanium: 1},
        global: {oxygen: 2},
      },

      metadata: {
        cardNumber: '138',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().steel(2).titanium(1);
          }).br;
          b.oxygen(2);
        }),
        description: 'Decrease your energy production 2 steps. Increase your steel production 2 steps and your titanium production 1 step. Raise oxygen 2 steps.',
      },
    });
  }
}

================
File: cards/base/SubterraneanReservoir.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SubterraneanReservoir extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SUBTERRANEAN_RESERVOIR,
      cost: 11,

      behavior: {
        ocean: {},
      },

      metadata: {
        cardNumber: '127',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1);
        }),
        description: 'Place 1 ocean tile.',
      },
    });
  }
}

================
File: cards/base/SymbioticFungus.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SymbioticFungus extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SYMBIOTIC_FUNGUS,
      tags: [Tag.MICROBE],
      cost: 4,

      action: {
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 1, autoSelect: true},
        // return new SelectCard('Select card to add microbe', 'Add microbe', availableCards, ([card]) => {
      },

      requirements: {temperature: -14},
      metadata: {
        cardNumber: '133',
        renderData: CardRenderer.builder((b) => {
          b.action('Add a microbe to ANOTHER card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE).asterix();
          });
        }),
        description: 'Requires -14 C° or warmer.',
      },
    });
  }
}

================
File: cards/base/Tardigrades.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Tardigrades extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TARDIGRADES,
      tags: [Tag.MICROBE],
      cost: 4,

      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 4},

      action: {
        addResources: 1,
      },

      metadata: {
        cardNumber: '049',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.vpText('1 VP per 4 Microbes on this card.');
        }),
      },
    });
  }
}

================
File: cards/base/TechnologyDemonstration.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class TechnologyDemonstration extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.TECHNOLOGY_DEMONSTRATION,
      tags: [Tag.SCIENCE, Tag.SPACE],
      cost: 5,

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: '204',
        renderData: CardRenderer.builder((b) => {
          b.cards(2);
        }),
        description: 'Draw two cards.',
      },
    });
  }
}

================
File: cards/base/TectonicStressPower.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class TectonicStressPower extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TECTONIC_STRESS_POWER,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 18,

      behavior: {
        production: {energy: 3},
      },
      victoryPoints: 1,

      requirements: {tag: Tag.SCIENCE, count: 2},
      metadata: {
        cardNumber: '145',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(3));
        }),
        description: 'Requires 2 science tags. Increase your energy production 3 steps.',
      },
    });
  }
}

================
File: cards/base/TerraformingGanymede.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class TerraformingGanymede extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TERRAFORMING_GANYMEDE,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 33,
      victoryPoints: 2,

      metadata: {
        cardNumber: '197',
        renderData: CardRenderer.builder((b) => {
          b.tr(1).slash().tag(Tag.JOVIAN);
        }),
        description: 'Raise your TR 1 step for each Jovian tag you have, including this.',
      },
    });
  }

  public computeTr(player: IPlayer) {
    return {tr: 1 + player.tags.count(Tag.JOVIAN)};
  }

  public override bespokePlay(player: IPlayer) {
    const steps = 1 + player.tags.count(Tag.JOVIAN);
    player.increaseTerraformRating(steps, {log: true});

    return undefined;
  }
}

================
File: cards/base/TitaniumMine.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class TitaniumMine extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TITANIUM_MINE,
      tags: [Tag.BUILDING],
      cost: 7,

      behavior: {
        production: {titanium: 1},
      },

      metadata: {
        cardNumber: '144',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1));
        }),
        description: 'Increase your titanium production 1 step.',
      },
    });
  }
}

================
File: cards/base/TollStation.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class TollStation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TOLL_STATION,
      tags: [Tag.SPACE],
      cost: 12,

      behavior: {
        production: {megacredits: {tag: Tag.SPACE, others: true}},
      },

      metadata: {
        cardNumber: '099',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).slash().tag(Tag.SPACE, {all}).asterix();
          });
        }),
        description: 'Increase your M€ production 1 step for each space tag your OPPONENTS have.',
      },
    });
  }
}

================
File: cards/base/TowingAComet.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class TowingAComet extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.TOWING_A_COMET,
      tags: [Tag.SPACE],
      cost: 23,

      behavior: {
        stock: {plants: 2},
        global: {oxygen: 1},
        ocean: {},
      },

      metadata: {
        cardNumber: '075',
        renderData: CardRenderer.builder((b) => {
          b.oxygen(1).oceans(1).br;
          b.plants(2);
        }),
        description: 'Gain 2 plants. Raise oxygen level 1 step and place an ocean tile.',
      },
    });
  }
}

================
File: cards/base/TransNeptuneProbe.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';

export class TransNeptuneProbe extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TRANS_NEPTUNE_PROBE,
      tags: [Tag.SCIENCE, Tag.SPACE],
      cost: 6,
      victoryPoints: 1,

      metadata: {
        cardNumber: '084',
      },
    });
  }
}

================
File: cards/base/Trees.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Trees extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TREES,
      tags: [Tag.PLANT],
      cost: 13,
      victoryPoints: 1,

      behavior: {
        production: {plants: 3},
        stock: {plants: 1},
      },

      requirements: {temperature: -4},
      metadata: {
        cardNumber: '060',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(3)).plants(1);
        }),
        description: 'Requires -4 C or warmer. Increase your plant production 3 steps. Gain 1 plant.',
      },
    });
  }
}

================
File: cards/base/TropicalResort.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class TropicalResort extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TROPICAL_RESORT,
      tags: [Tag.BUILDING],
      cost: 13,

      behavior: {
        production: {megacredits: 3, heat: -2},
      },
      victoryPoints: 2,

      metadata: {
        cardNumber: '098',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) =>{
            pb.minus().heat(2).br;
            pb.plus().megacredits(3);
          });
        }),
        description: 'Reduce your heat production 2 steps and increase your M€ production 3 steps.',
      },
    });
  }
}

================
File: cards/base/TundraFarming.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class TundraFarming extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TUNDRA_FARMING,
      tags: [Tag.PLANT],
      cost: 16,
      victoryPoints: 2,

      behavior: {
        production: {plants: 1, megacredits: 2},
        stock: {plants: 1},
      },

      requirements: {temperature: -6},
      metadata: {
        cardNumber: '169',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) =>{
            pb.plants(1).megacredits(2);
          }).plants(1);
        }),
        description: 'Requires -6° C or warmer. Increase your plant production 1 step and your M€ production 2 steps. Gain 1 plant.',
      },
    });
  }
}

================
File: cards/base/UndergroundCity.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class UndergroundCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.UNDERGROUND_CITY,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 18,

      behavior: {
        production: {energy: -2, steel: 2},
        city: {},
      },

      metadata: {
        cardNumber: '032',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().steel(2);
          }).nbsp.city();
        }),
        description: 'Place a city tile. Decrease your energy production 2 steps and increase your steel production 2 steps.',
      },
    });
  }
}

================
File: cards/base/UndergroundDetonations.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class UndergroundDetonations extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.UNDERGROUND_DETONATIONS,
      tags: [Tag.BUILDING],
      cost: 6,

      action: {
        spend: {megacredits: 10},
        production: {heat: 2},
      },

      metadata: {
        cardNumber: '202',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 10M€ to increase your heat production 2 steps.', (eb) => {
            eb.megacredits(10).startAction.production((pb)=>pb.heat(2));
          });
        }),
      },
    });
  }
}

================
File: cards/base/UrbanizedArea.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {SelectSpace} from '../../inputs/SelectSpace';
import {CardName} from '../../../common/cards/CardName';
import {Board} from '../../boards/Board';
import {CardRenderer} from '../render/CardRenderer';

export class UrbanizedArea extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.URBANIZED_AREA,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 10,

      behavior: {
        production: {energy: -1, megacredits: 2},
      },

      metadata: {
        cardNumber: '120',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(2);
          }).city().asterix();
        }),
        description: 'Decrease your energy production 1 step and increase your M€ production 2 steps. Place a city tile ADJACENT TO AT LEAST 2 OTHER CITY TILES.',
      },
    });
  }
  private getAvailableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): Array<Space> {
    return player.game.board.getAvailableSpacesOnLand(player, canAffordOptions)
      .filter((space) => player.game.board.getAdjacentSpaces(space).filter((adjacentSpace) => Board.isCitySpace(adjacentSpace)).length >= 2);
  }
  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions): boolean {
    return this.getAvailableSpaces(player, canAffordOptions).length > 0;
  }
  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select space next to at least 2 other city tiles', this.getAvailableSpaces(player))
      .andThen((space) => {
        player.game.addCity(player, space);
        return undefined;
      });
  }
}

================
File: cards/base/VestaShipyard.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class VestaShipyard extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.VESTA_SHIPYARD,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 15,
      victoryPoints: 1,

      behavior: {
        production: {titanium: 1},
      },

      metadata: {
        cardNumber: '057',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1));
        }),
        description: 'Increase your titanium production 1 step.',
      },
    });
  }
}

================
File: cards/base/ViralEnhancers.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';

import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';
import {message} from '../../logs/MessageBuilder';

export class ViralEnhancers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.VIRAL_ENHANCERS,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      cost: 9,

      metadata: {
        cardNumber: '074',
        renderData: CardRenderer.builder((b) => {
          b.tag(Tag.PLANT).slash().tag(Tag.MICROBE).slash().tag(Tag.ANIMAL).br;
          b.effect('When you play a plant, microbe, or an animal tag, including this, gain 1 plant or add 1 resource to THAT CARD.', (eb) => {
            eb.empty().startEffect;
            eb.plants(1).slash().resource(CardResource.MICROBE).asterix().slash().resource(CardResource.ANIMAL).asterix();
          });
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    const resourceCount = player.tags.cardTagCount(card, [Tag.ANIMAL, Tag.PLANT, Tag.MICROBE]);
    if (resourceCount === 0) {
      return undefined;
    }

    if (card.resourceType !== CardResource.ANIMAL && card.resourceType !== CardResource.MICROBE) {
      player.plants += resourceCount;
      return undefined;
    }

    for (let i = 0; i < resourceCount; i++) {
      player.defer(
        () => new OrOptions(
          new SelectOption(message('Add resource to card ${0}', (b) => b.card(card)), 'Add resource').andThen(() => {
            player.addResourceTo(card);
            return undefined;
          }),
          new SelectOption('Gain plant').andThen(() => {
            player.plants++;
            return undefined;
          }),
        ),
      );
    }
    return undefined;
  }
}

================
File: cards/base/Virus.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {OrOptions} from '../../inputs/OrOptions';
import {PlayerInput} from '../../PlayerInput';
import {CardName} from '../../../common/cards/CardName';
import {SelectOption} from '../../inputs/SelectOption';
import {CardResource} from '../../../common/CardResource';
import {RemoveAnyPlants} from '../../deferredActions/RemoveAnyPlants';
import {RemoveResourcesFromCard} from '../../deferredActions/RemoveResourcesFromCard';
import {CardRenderer} from '../render/CardRenderer';
import {all, digit} from '../Options';

export class Virus extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.VIRUS,
      tags: [Tag.MICROBE],
      cost: 1,

      metadata: {
        cardNumber: '050',
        renderData: CardRenderer.builder((b) => {
          b.minus().resource(CardResource.ANIMAL, {amount: 2, all, digit}).nbsp;
          b.or().nbsp.minus().plants(5, {all, digit});
        }),
        description: 'Remove up to 2 animals or 5 plants from any player.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    if (player.game.isSoloMode()) {
      player.game.someoneHasRemovedOtherPlayersPlants = true;
      return undefined;
    }

    const orOptionsAnimals = new RemoveResourcesFromCard(player, CardResource.ANIMAL, 2, {mandatory: false}).execute() as OrOptions;
    const removeAnimals = orOptionsAnimals !== undefined ?
      orOptionsAnimals.options[0] :
      undefined;

    const orOptionsPlants = new RemoveAnyPlants(player, 5).execute();
    const removePlants = orOptionsPlants !== undefined ?
      orOptionsPlants.options.slice(0, -1) :
      undefined;

    // If no other player has resources to remove
    // assume player will remove nothing from themselves
    if (removeAnimals === undefined && removePlants === undefined) {
      player.game.log('There was nobody to steal plants or animals from.');
      return undefined;
    }

    const orOptions = new OrOptions();
    if (removeAnimals !== undefined) {
      orOptions.options.push(removeAnimals);
    }
    if (removePlants !== undefined) {
      orOptions.options.push(...removePlants);
    }
    orOptions.options.push(new SelectOption('Skip removal'));

    return orOptions;
  }
}

================
File: cards/base/WaterImportFromEuropa.ts
================
import {IActionCard} from '../ICard';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {PlaceOceanTile} from '../../deferredActions/PlaceOceanTile';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../render/CardRenderer';
import {TITLES} from '../../inputs/titles';

const ACTION_COST = 12;
export class WaterImportFromEuropa extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.WATER_IMPORT_FROM_EUROPA,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 25,

      victoryPoints: {tag: Tag.JOVIAN},

      metadata: {
        cardNumber: '012',
        renderData: CardRenderer.builder((b) => {
          b.action('Pay 12 M€ to place an ocean tile. TITANIUM MAY BE USED as if playing a space card.', (eb) => {
            eb.megacredits(12).super((b) => b.titanium(1)).startAction.oceans(1);
          }).br;
          b.vpText('1 VP for each Jovian tag you have.');
        }),
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.canAfford({cost: ACTION_COST, titanium: true, tr: {oceans: 1}});
  }
  public action(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, ACTION_COST, {canUseTitanium: true, title: TITLES.action}))
      .andThen(() => player.game.defer(new PlaceOceanTile(player)));
    return undefined;
  }
}

================
File: cards/base/WaterSplittingPlant.ts
================
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';

export class WaterSplittingPlant extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.WATER_SPLITTING_PLANT,
      tags: [Tag.BUILDING],
      cost: 12,

      action: {
        spend: {energy: 3},
        global: {oxygen: 1},
      },

      requirements: {oceans: 2},
      metadata: {
        cardNumber: '177',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 3 energy to raise oxygen 1 step.', (eb) => {
            eb.energy(3).startAction.oxygen(1);
          });
        }),
        description: 'Requires 2 ocean tiles.',
      },
    });
  }

  public override bespokeCanAct(player: IPlayer) {
    // This tests for Reds costs that would ideally be dealt with somewhere
    // between ActionCard and the Executor.
    return player.canAfford({cost: 0, tr: {oxygen: 1}});
  }
}

================
File: cards/base/WavePower.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class WavePower extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.WAVE_POWER,
      tags: [Tag.POWER],
      cost: 8,
      victoryPoints: 1,

      behavior: {
        production: {energy: 1},
      },

      requirements: {oceans: 3},
      metadata: {
        cardNumber: '139',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1));
        }),
        description: 'Requires 3 ocean tiles. Increase your energy production 1 step.',
      },
    });
  }
}

================
File: cards/base/Windmills.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Windmills extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.WINDMILLS,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 6,

      behavior: {
        production: {energy: 1},
      },
      victoryPoints: 1,

      requirements: {oxygen: 7},
      metadata: {
        cardNumber: '168',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1));
        }),
        description: 'Requires 7% oxygen. Increase your energy production 1 step.',
      },
    });
  }
}

================
File: cards/base/Worms.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Worms extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.WORMS,
      tags: [Tag.MICROBE],
      cost: 8,

      behavior: {
        production: {plants: {tag: Tag.MICROBE, per: 2}},
      },

      requirements: {oxygen: 4},
      metadata: {
        cardNumber: '129',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1).slash().tag(Tag.MICROBE, 2));
        }),
        description: 'Requires 4% oxygen. Increase your plant production 1 step for every 2 microbe tags you have, including this.',
      },
    });
  }
}

================
File: cards/base/Zeppelins.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class Zeppelins extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ZEPPELINS,
      cost: 13,
      victoryPoints: 1,

      behavior: {
        production: {megacredits: {cities: {where: 'onmars'}}},
      },

      requirements: {oxygen: 5},
      metadata: {
        cardNumber: '129',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).slash();
            pb.city({size: Size.SMALL, all}).asterix();
          });
        }),
        description: 'Requires 5% oxygen. Increase your M€ production 1 step for each city tile ON MARS.',
      },
    });
  }
}

================
File: cards/Card.ts
================
import {CardMetadata} from '../../common/cards/CardMetadata';
import {CardName} from '../../common/cards/CardName';
import {CardType} from '../../common/cards/CardType';
import {CardDiscount, GlobalParameterRequirementBonus} from '../../common/cards/Types';
import {AdjacencyBonus} from '../ares/AdjacencyBonus';
import {CardResource} from '../../common/CardResource';
import {Tag} from '../../common/cards/Tag';
import {CanAffordOptions, IPlayer} from '../IPlayer';
import {TRSource} from '../../common/cards/TRSource';
import {Units} from '../../common/Units';
import {ICard} from './ICard';
import {CardRenderDynamicVictoryPoints} from './render/CardRenderDynamicVictoryPoints';
import {CardRenderItemType} from '../../common/cards/render/CardRenderItemType';
import {IVictoryPoints} from '../../common/cards/IVictoryPoints';
import {IProjectCard} from './IProjectCard';
import {MoonExpansion} from '../moon/MoonExpansion';
import {PlayerInput} from '../PlayerInput';
import {OneOrArray} from '../../common/utils/types';
import {TileType} from '../../common/TileType';
import {Behavior} from '../behavior/Behavior';
import {getBehaviorExecutor} from '../behavior/BehaviorExecutor';
import {Counter} from '../behavior/Counter';
import {CardRequirementsDescriptor} from './CardRequirementDescriptor';
import {CardRequirements} from './requirements/CardRequirements';
import {CardRequirementDescriptor} from '../../common/cards/CardRequirementDescriptor';
import {asArray} from '../../common/utils/utils';
import {YesAnd} from './requirements/CardRequirement';
import {GlobalParameter} from '../../common/GlobalParameter';
import {Warning} from '../../common/cards/Warning';

/**
 * Cards that do not need a cost attribute.
 */
const CARD_TYPES_WITHOUT_COST: ReadonlyArray<CardType> = [
  CardType.CORPORATION,
  CardType.PRELUDE,
  CardType.CEO,
  CardType.STANDARD_ACTION,
] as const;

/* Properties that are the same internally and externally */
type SharedProperties = {
  /** @deprecated use behavior */
  adjacencyBonus?: AdjacencyBonus;
  action?: Behavior | undefined;
  behavior?: Behavior | undefined;
  cardCost?: number;
  cardDiscount?: OneOrArray<CardDiscount>;
  type: CardType;
  cost?: number;
  initialActionText?: string;
  firstAction?: Behavior & {text: string};
  globalParameterRequirementBonus?: GlobalParameterRequirementBonus;
  metadata: CardMetadata;
  requirements?: CardRequirementsDescriptor;
  name: CardName;
  resourceType?: CardResource;
  protectedResources?: boolean;
  startingMegaCredits?: number;
  tags?: Array<Tag>;
  /** Describes where the card's TR comes from. */
  tr?: TRSource,
  victoryPoints?: number | 'special' | IVictoryPoints,
  optionalEnergyConversion?: boolean,
}

/* Internal representation of card properties. */
type InternalProperties = SharedProperties & {
  reserveUnits?: Units,
  requirements: Array<CardRequirementsDescriptor>
  compiledRequirements: CardRequirements;
  tilesBuilt: ReadonlyArray<TileType>,
}

/* External representation of card properties. */
export type StaticCardProperties = SharedProperties & {
  reserveUnits?: Partial<Units>,
  requirements?: OneOrArray<CardRequirementDescriptor>,
  tilesBuilt?: ReadonlyArray<TileType>,
}

const cardProperties = new Map<CardName, InternalProperties>();

/**
 * Card is an implementation for most cards in the game, which provides one key features:
 *
 * 1. It stores key card properties into a static cache, which means that each instance of a card
 *    consumes very little memory.
 *
 * 2. It's key behavior is to provide a lot of the `canPlay` and `play` behavior currently
 *    in player.canPlay and player.play. These will eventually be removed and
 *    put right in here.
 *
 * In order to implement this default behavior, Card subclasses should ideally not
 * override `play` and `canPlay`. Instead, they should override `bespokeCanPlay` and
 * `bespokePlay`, which provide bespoke, or custom hand-crafted play and canPlay
 * behavior.
 *
 * If this seems counterintuitive, think about it this way: very little behavior should
 * be custom-written for each card, _no_ common behavior should be custom-written for
 * each card, either.
 */
export abstract class Card implements ICard {
  protected readonly properties: InternalProperties;
  public resourceCount = 0;
  public warnings = new Set<Warning>();

  private internalize(external: StaticCardProperties): InternalProperties {
    const name = external.name;
    if (external.type === CardType.CORPORATION && external.startingMegaCredits === undefined) {
      throw new Error(`${name}: corp cards must define startingMegaCredits`);
    }
    if (external.cost === undefined) {
      if (CARD_TYPES_WITHOUT_COST.includes(external.type) === false) {
        throw new Error(`${name} must have a cost property`);
      }
    }
    let step = 0;
    try {
      // TODO(kberg): apply these changes in CardVictoryPoints.vue and remove this conditional altogether.
      Card.autopopulateMetadataVictoryPoints(external);

      step = 1;
      validateBehavior(external.behavior, name);
      step = 2;
      validateBehavior(external.firstAction, name);
      step = 3;
      validateBehavior(external.action, name);
      step = 4;
      Card.validateTilesBuilt(external);
      step = 5;
    } catch (e) {
      throw new Error(`Cannot validate ${name} (${step}): ${e}`);
    }

    const translatedRequirements = asArray(external.requirements ?? []).map((req) => populateCount(req));
    const compiledRequirements = CardRequirements.compile(translatedRequirements);
    const tilesBuilt = [...external.tilesBuilt ?? []];
    if (external.behavior?.tile?.type !== undefined) {
      tilesBuilt.push(external.behavior?.tile.type);
    }
    if (external.behavior?.moon?.tile?.type !== undefined) {
      tilesBuilt.push(external.behavior.moon.tile.type);
    }
    if (external.behavior?.moon?.habitatTile !== undefined) {
      tilesBuilt.push(TileType.MOON_HABITAT);
    }
    if (external.behavior?.moon?.mineTile !== undefined) {
      tilesBuilt.push(TileType.MOON_MINE);
    }
    if (external.behavior?.moon?.roadTile !== undefined) {
      tilesBuilt.push(TileType.MOON_ROAD);
    }

    const internal: InternalProperties = {
      ...external,
      reserveUnits: external.reserveUnits === undefined ? undefined : Units.of(external.reserveUnits),
      requirements: translatedRequirements,
      compiledRequirements: compiledRequirements,
      tilesBuilt: tilesBuilt,
    };
    return internal;
  }

  constructor(external: StaticCardProperties) {
    const name = external.name;
    let internal = cardProperties.get(name);
    if (internal === undefined) {
      internal = this.internalize(external);
      cardProperties.set(name, internal);
    }
    this.properties = internal;
  }

  public get adjacencyBonus() {
    return this.properties.adjacencyBonus;
  }
  public get behavior() {
    return this.properties.behavior;
  }
  public get cardCost() {
    return this.properties.cardCost;
  }
  public get type() {
    return this.properties.type;
  }
  public get cost() {
    return this.properties.cost === undefined ? 0 : this.properties.cost;
  }
  public get initialActionText() {
    return this.properties.initialActionText || this.properties.firstAction?.text;
  }
  public get firstAction() {
    return this.properties.firstAction;
  }
  public get metadata() {
    return this.properties.metadata;
  }
  public get requirements() {
    return this.properties.requirements;
  }
  public get name() {
    return this.properties.name;
  }
  public get resourceType() {
    return this.properties.resourceType;
  }
  public get protectedResources() {
    return this.properties.protectedResources;
  }
  public get startingMegaCredits() {
    return this.properties.startingMegaCredits === undefined ? 0 : this.properties.startingMegaCredits;
  }
  public get tags() {
    return this.properties.tags === undefined ? [] : this.properties.tags;
  }
  public get cardDiscount() {
    return this.properties.cardDiscount;
  }
  public get reserveUnits(): Units {
    return this.properties.reserveUnits || Units.EMPTY;
  }
  public get tr(): TRSource | undefined {
    return this.properties.tr;
  }
  public get victoryPoints(): number | 'special' | IVictoryPoints | undefined {
    return this.properties.victoryPoints;
  }
  public get tilesBuilt(): ReadonlyArray<TileType> {
    return this.properties.tilesBuilt;
  }
  public canPlay(player: IPlayer, canAffordOptions?: CanAffordOptions): boolean | YesAnd {
    let yesAnd: YesAnd | undefined = undefined;
    const satisfied = this.properties.compiledRequirements.satisfies(player);
    if (satisfied === false) {
      return false;
    }
    if (satisfied !== true) {
      yesAnd = satisfied;
    }

    if (this.behavior !== undefined) {
      if (getBehaviorExecutor().canExecute(this.behavior, player, this, canAffordOptions) === false) {
        return false;
      }
    }
    const bespokeCanPlay = this.bespokeCanPlay(player, canAffordOptions ?? {cost: 0});
    if (bespokeCanPlay === false) {
      return false;
    }

    if (yesAnd !== undefined) {
      return yesAnd;
    }
    return true;
  }

  public bespokeCanPlay(_player: IPlayer, _canAffordOptions: CanAffordOptions): boolean {
    return true;
  }

  public play(player: IPlayer): PlayerInput | undefined {
    player.stock.deductUnits(MoonExpansion.adjustedReserveCosts(player, this));
    if (this.behavior !== undefined) {
      getBehaviorExecutor().execute(this.behavior, player, this);
    }
    return this.bespokePlay(player);
  }

  public bespokePlay(_player: IPlayer): PlayerInput | undefined {
    return undefined;
  }

  public onDiscard(player: IPlayer): void {
    if (this.behavior !== undefined) {
      getBehaviorExecutor().onDiscard(this.behavior, player, this);
    }
    this.bespokeOnDiscard(player);
  }

  public bespokeOnDiscard(_player: IPlayer): void {
  }

  public getVictoryPoints(player: IPlayer): number {
    const vp = this.properties.victoryPoints;
    if (typeof(vp) === 'number') {
      return vp;
    }
    if (typeof(vp) === 'object') {
      return new Counter(player, this).count(vp, 'vps');
    }
    if (vp === 'special') {
      throw new Error('When victoryPoints is \'special\', override getVictoryPoints');
    }

    const vps = this.properties.metadata.victoryPoints;
    if (vps === undefined) {
      return 0;
    }

    if (typeof(vps) === 'number') return vps;

    if (vps.targetOneOrMore === true || vps.anyPlayer === true) {
      throw new Error('Not yet handled');
    }

    let units: number | undefined = 0;

    switch (vps.item?.type) {
    case CardRenderItemType.RESOURCE:
      units = this.resourceCount;
      break;
    case CardRenderItemType.TAG:
      if (vps.item.tag === undefined) {
        throw new Error('tag attribute missing');
      }
      units = player.tags.count(vps.item.tag, 'raw');
      break;
    }

    if (units === undefined) {
      throw new Error('Not yet handled');
    }
    return vps.points * Math.floor(units / vps.target);
  }

  private static autopopulateMetadataVictoryPoints(properties: StaticCardProperties) {
    const vps = properties.victoryPoints;
    if (vps === undefined) {
      return;
    }

    if (vps === 'special') {
      if (properties.metadata.victoryPoints === undefined) {
        throw new Error('When card.victoryPoints is \'special\', metadata.vp and getVictoryPoints must be supplied');
      }
      return;
    } else {
      if (properties.metadata.victoryPoints !== undefined) {
        throw new Error('card.victoryPoints and metadata.victoryPoints cannot be on the same card');
      }
    }

    if (typeof(vps) === 'number') {
      properties.metadata.victoryPoints = vps;
      return;
    }
    const each = vps.each ?? 1;
    const per = vps.per ?? 1;
    if (vps.resourcesHere !== undefined) {
      if (properties.resourceType === undefined) {
        throw new Error('When defining a card-resource based VP, resourceType must be defined.');
      }
      properties.metadata.victoryPoints = CardRenderDynamicVictoryPoints.resource(properties.resourceType, each, per);
      return;
    } else if (vps.tag !== undefined) {
      properties.metadata.victoryPoints = CardRenderDynamicVictoryPoints.tag(vps.tag, each, per);
    } else if (vps.cities !== undefined) {
      properties.metadata.victoryPoints = CardRenderDynamicVictoryPoints.cities(each, per, vps.all);
    } else if (vps.colonies !== undefined) {
      properties.metadata.victoryPoints = CardRenderDynamicVictoryPoints.colonies(each, per, vps.all);
    } else if (vps.moon !== undefined) {
      if (vps.moon.road !== undefined) {
        // vps.per is ignored
        properties.metadata.victoryPoints = CardRenderDynamicVictoryPoints.moonRoadTile(each, vps.all);
      } else {
        throw new Error('moon defined, but no valid sub-object defined');
      }
    } else {
      throw new Error('Unknown VPs defined');
    }
  }

  private static validateTilesBuilt(properties: StaticCardProperties) {
    if (properties.tilesBuilt !== undefined) {
      if (properties.behavior?.tile?.type !== undefined) {
        throw new Error('tilesBuilt and behavior.tile.tileType both defined: ' + properties.name);
      }
      if (properties.behavior?.moon?.tile?.type !== undefined) {
        throw new Error('tilesBuilt and behavior.moon.tile.tileType both defined: ' + properties.name);
      }
      if (properties.behavior?.moon?.habitatTile !== undefined) {
        throw new Error('tilesBuilt and behavior.moon.habitatTile both defined: ' + properties.name);
      }
      if (properties.behavior?.moon?.mineTile !== undefined) {
        throw new Error('tilesBuilt and behavior.moon.mineTile both defined: ' + properties.name);
      }
      if (properties.behavior?.moon?.roadTile !== undefined) {
        throw new Error('tilesBuilt and behavior.moon.roadTile both defined: ' + properties.name);
      }
    }
  }

  public getCardDiscount(_player?: IPlayer, card?: IProjectCard): number {
    if (this.cardDiscount === undefined) {
      return 0;
    }
    let sum = 0;
    const discounts = asArray(this.cardDiscount);
    for (const discount of discounts) {
      if (discount.tag === undefined) {
        sum += discount.amount;
      } else {
        const tags = card?.tags.filter((tag) => tag === discount.tag).length ?? 0;
        if (discount.per !== 'card') {
          sum += discount.amount * tags;
        } else if (tags > 0) {
          sum += discount.amount;
        }
      }
    }
    return sum;
  }

  public getGlobalParameterRequirementBonus(player: IPlayer, parameter: GlobalParameter): number {
    if (this.properties.globalParameterRequirementBonus !== undefined) {
      const globalParameterRequirementBonus = this.properties.globalParameterRequirementBonus;
      if (globalParameterRequirementBonus.nextCardOnly === true) {
        if (player.lastCardPlayed !== this.name) {
          return 0;
        }
      }
      if (globalParameterRequirementBonus.parameter !== undefined) {
        if (globalParameterRequirementBonus.parameter !== parameter) {
          return 0;
        }
      }
      return globalParameterRequirementBonus.steps;
    }
    return 0;
  }
}

function populateCount(requirement: CardRequirementDescriptor): CardRequirementDescriptor {
  requirement.count =
    requirement.count ??
    requirement.oceans ??
    requirement.oxygen ??
    requirement.temperature ??
    requirement.venus ??
    requirement.tr ??
    requirement.resourceTypes ??
    requirement.greeneries ??
    requirement.cities ??
    requirement.colonies ??
    requirement.floaters ??
    requirement.partyLeader ??
    requirement.habitatRate ??
    requirement.miningRate ??
    requirement.logisticRate ??
    requirement.habitatTiles ??
    requirement.miningTiles ??
    requirement.roadTiles ??
    requirement.corruption ??
    requirement.excavation;

  return requirement;
}

export function validateBehavior(behavior: Behavior | undefined, name: CardName) : void {
  function validate(condition: boolean, error: string) {
    if (condition === false) {
      throw new Error(`for ${name}: ${error}`);
    }
  }
  if (behavior === undefined) {
    return;
  }
  if (behavior.spend) {
    const spend = behavior.spend;
    if (spend.megacredits) {
      validate(behavior.tr === undefined, 'spend.megacredits is not yet compatible with tr');
      validate(behavior.global === undefined, 'spend.megacredits is not yet compatible with global');
      validate(behavior.moon?.habitatRate === undefined, 'spend.megacredits is not yet compatible with moon.habitatRate');
      validate(behavior.moon?.logisticsRate === undefined, 'spend.megacredits is not yet compatible with moon.logisticsRate');
      validate(behavior.moon?.miningRate === undefined, 'spend.megacredits is not yet compatible with moon.miningRate');
    }
    // Don't spend heat with other types yet. It's probably not compatible. Check carefully.
    if (spend.heat) {
      validate(Object.keys(spend).length === 1, 'spend.heat cannot be used with another spend');
    }
  }
}

================
File: cards/CardRequirementDescriptor.ts
================
const COUNTABLE_REQUIREMENTS = [
  'oxygen',
  'temperature',
  'oceans',
  'habitatRate',
  'miningRate',
  'logisticRate',
] as const;
type CountableRequirement = typeof COUNTABLE_REQUIREMENTS[number];
type BaseDescriptor = {[v in CountableRequirement]?: number};
export type CardRequirementsDescriptor = BaseDescriptor & {max?: boolean}

================
File: cards/cardSerialization.ts
================
import {newProjectCard} from '../createCard';
import {SerializedCard} from '../SerializedCard';
import {isCeoCard} from './ceos/ICeoCard';
import {IProjectCard} from './IProjectCard';
import {isICloneTagCard} from './pathfinders/ICloneTagCard';
import {SelfReplicatingRobots} from './promo/SelfReplicatingRobots';
import {CardType} from '../../common/cards/CardType';
import {asArray} from '../../common/utils/utils';

export function serializeProjectCard(card: IProjectCard): SerializedCard {
  const serialized: SerializedCard = {
    name: card.name,
  };
  if (card.type === CardType.PROXY) {
    return serialized;
  }
  if (card.bonusResource !== undefined) {
    serialized.bonusResource = card.bonusResource;
  }
  if (card.resourceCount !== undefined) {
    serialized.resourceCount = card.resourceCount;
  }
  if (card.generationUsed !== undefined) {
    serialized.generationUsed = card.generationUsed;
  }
  if (card instanceof SelfReplicatingRobots) {
    serialized.targetCards = card.targetCards.map((t) => {
      return {
        card: {name: t.name},
        resourceCount: t.resourceCount,
      };
    });
  }
  if (isICloneTagCard(card)) {
    serialized.cloneTag = card.cloneTag;
  }
  if (isCeoCard(card)) {
    serialized.isDisabled = card.isDisabled;
    if (card.opgActionIsActive !== undefined) {
      serialized.opgActionIsActive = card.opgActionIsActive;
    }
  }
  if (card.data !== undefined) {
    serialized.data = card.data;
  }
  return serialized;
}

export function deserializeProjectCard(element: SerializedCard): IProjectCard {
  const card = newProjectCard(element.name);
  if (card === undefined) {
    throw new Error(`Card ${element.name} not found`);
  }
  if (element.resourceCount !== undefined) {
    card.resourceCount = element.resourceCount;
  }
  if (card.hasOwnProperty('data')) {
    card.data = element.data;
  }
  if (element.generationUsed !== undefined) {
    card.generationUsed = element.generationUsed;
  }
  if (isICloneTagCard(card) && element.cloneTag !== undefined) {
    card.cloneTag = element.cloneTag;
  }
  if (card instanceof SelfReplicatingRobots && element.targetCards !== undefined) {
    card.targetCards = [];
    element.targetCards.forEach((targetCard) => {
      const foundTargetCard = newProjectCard(targetCard.card.name);
      if (foundTargetCard !== undefined) {
        foundTargetCard.resourceCount = targetCard.resourceCount;
        card.targetCards.push(foundTargetCard);
      } else {
        console.warn('did not find card for SelfReplicatingRobots', targetCard);
      }
    });
  }
  if (!(card instanceof SelfReplicatingRobots)) {
    if (element.bonusResource !== undefined) {
      card.bonusResource = asArray(element.bonusResource);
    }
  }
  if (isCeoCard(card)) {
    card.isDisabled = element.isDisabled;
    if (element.opgActionIsActive !== undefined) {
      card.opgActionIsActive = element.opgActionIsActive;
    }
  }
  return card;
}

================
File: cards/ceos/Apollo.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';

import {MoonExpansion} from '../../moon/MoonExpansion';
import {Resource} from '../../../common/Resource';
import {all} from '../Options';


export class Apollo extends CeoCard {
  constructor() {
    super({
      name: CardName.APOLLO,
      metadata: {
        cardNumber: 'L35',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('ACTIVATE THE BELOW ABILITY');
          b.br.br;
          b.moonHabitat({all}).moonMine({all}).moonRoad({all}).nbsp.colon().megacredits(3);
          b.br.br;
        }),
        description: 'Once per game, gain 3 M€ for each tile on The Moon.',
      },
    });
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const moonSpacesCount = MoonExpansion.spaces(player.game, undefined, {surfaceOnly: true}).length;
    player.stock.add(Resource.MEGACREDITS, moonSpacesCount * 3, {log: true});
    return undefined;
  }
}

================
File: cards/ceos/Asimov.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {inplaceShuffle} from '../../utils/shuffle';
import {UnseededRandom} from '../../../common/utils/Random';
import {ASIMOV_AWARD_BONUS} from '../../../common/constants';

import {IAward} from '../../awards/IAward';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {Size} from '../../../common/cards/render/Size';

import {ALL_AWARDS} from '../../awards/Awards';
import {AwardScorer} from '../../awards/AwardScorer';
import {message} from '../../logs/MessageBuilder';

export class Asimov extends CeoCard {
  constructor() {
    super({
      name: CardName.ASIMOV,
      metadata: {
        cardNumber: 'L01',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.award().nbsp.colon().text('+' + ASIMOV_AWARD_BONUS, Size.LARGE);
          b.br.br.br;
          b.opgArrow().text('10-X').award().asterix();
        }),
        description: 'You have +' + ASIMOV_AWARD_BONUS + ' score for all awards. Once per game, draw 10-X awards (min. 1), where X is the current generation number. You may put one into the game and fund it for free.',
      },
    });
  }

  public override canAct(player: IPlayer): boolean {
    if (!super.canAct(player)) {
      return false;
    }
    if (player.game.isSoloMode()) return false; // Awards are disabled in solo mode
    return !player.game.allAwardsFunded();
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const game = player.game;
    const awardCount = Math.max(1, 10 - game.generation);
    const validAwards = this.getValidAwards(player);
    inplaceShuffle(validAwards, UnseededRandom.INSTANCE);

    const freeAward = new OrOptions();
    freeAward.title = 'Select award to put into play and fund';
    freeAward.buttonLabel = 'Confirm';

    freeAward.options = validAwards.slice(0, awardCount).map((award) => this.selectAwardToFund(player, award));
    freeAward.options.push(
      new SelectOption('Do nothing').andThen(() => {
        game.log('${0} chose not to fund any award', (b) => b.player(player));
        return undefined;
      }),
    );

    return freeAward;
  }

  private selectAwardToFund(player: IPlayer, award: IAward): SelectOption {
    const game = player.game;
    const scorer = new AwardScorer(game, award);
    // Sort the players by score:
    const players: Array<IPlayer> = game.getPlayers().slice();
    players.sort((p1, p2) => scorer.get(p2) - scorer.get(p1));
    const title = message('Fund ${0} award [${1}]', (b) => b.award(award).string(
      players.map((player) => player.name + ': ' + scorer.get(player)).join(' / ')));

    return new SelectOption(title).andThen(() => {
      player.game.awards.push(award);
      player.game.fundAward(player, award);
      return undefined;
    });
  }

  private getValidAwards(player: IPlayer): Array<IAward> {
    // NB: This makes no effort to maintain Award synergy.
    const gameOptions = player.game.gameOptions;
    const validAwards = ALL_AWARDS.filter((award) => {
      // TODO(kberg): Centralize this so this card doesn't have to be updated.

      // Remove awards already in the game
      if (player.game.awards.includes(award)) return false;
      // Remove awards that require unused variants/expansions
      if (!gameOptions.venusNextExtension && award.name === 'Venuphile') return false;
      if (!gameOptions.turmoilExtension && award.name === 'Politician') return false;
      if (!gameOptions.aresExtension && award.name === 'Entrepreneur') return false;
      if (!gameOptions.moonExpansion && award.name === 'Full Moon') return false;
      if (!gameOptions.moonExpansion && award.name === 'Lunar Magnate') return false;
      if (!gameOptions.underworldExpansion && award.name === 'Kingpin') return false;
      if (!gameOptions.underworldExpansion && award.name === 'EdgeLord') return false;
      return true;
    });
    if (validAwards.length === 0) throw new Error('getValidAwards award list is empty.');
    return validAwards;
  }
}

================
File: cards/ceos/Bjorn.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {Resource} from '../../../common/Resource';

export class Bjorn extends CeoCard {
  constructor() {
    super({
      name: CardName.BJORN,
      metadata: {
        cardNumber: 'L02',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('STEAL').megacredits(1, {text: 'x+2'}).asterix();
          b.br;
        }),
        description: 'Once per game, steal X+2 M€ from each player that has more M€ than you, where X is the current generation number.',
      },
    });
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const game = player.game;
    const targets = player.getOpponents().filter((p) => p.megaCredits > player.megaCredits);

    targets.forEach((target) => {
      target.maybeBlockAttack(player, (proceed) => {
        if (proceed) {
          target.stock.steal(Resource.MEGACREDITS, game.generation + 2, player);
        }
        return undefined;
      });
    });

    return undefined;
  }
}

================
File: cards/ceos/Caesar.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';

import {SelectProductionToLoseDeferred} from '../../deferredActions/SelectProductionToLoseDeferred';
import {PlaceHazardTile} from '../../deferredActions/PlaceHazardTile';
import {TileType} from '../../../common/TileType';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class Caesar extends CeoCard {
  constructor() {
    super({
      name: CardName.CAESAR,
      metadata: {
        cardNumber: 'L33',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('X').hazardTile(1, {size: Size.LARGE}).br;
          b.minus().production((pb) => pb.wild(1, {all})).asterix();
          b.br;
        }),
        description: 'Once per game, place X hazard tiles where X is the current generation number. Each opponent loses 1 unit of production of their choice, or 2 units if there are 6 or more hazard tiles.',
      },
    });
  }

  public override canAct(player: IPlayer): boolean {
    if (!super.canAct(player)) {
      return false;
    }
    return player.game.board.getAvailableSpacesOnLand(player).length >= player.game.generation;
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const game = player.game;
    for (let i = 0; i < game.generation; i++) {
      game.defer(new PlaceHazardTile(player, TileType.EROSION_MILD));
    }

    player.defer(() => {
      const units = game.board.getHazards().length < 6 ? 1 : 2;
      player.getOpponents().forEach((opponent) => {
        game.defer(new SelectProductionToLoseDeferred(opponent, units));
      });
      return undefined;
    });

    return undefined;
  }
}

================
File: cards/ceos/CeoCard.ts
================
import {Card, StaticCardProperties} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {ICeoCard} from './ICeoCard';
import {IPlayer} from '../../IPlayer';

type StaticCeoProperties = Pick<StaticCardProperties, 'name' | 'tags' | 'victoryPoints' | 'metadata'>;

export abstract class CeoCard extends Card implements ICeoCard {
  public isDisabled = false;

  constructor(properties: StaticCeoProperties) {
    super({
      type: CardType.CEO,
      ...properties,
    });
  }

  public canAct(_player: IPlayer): boolean {
    return this.isDisabled === false;
  }

  public override play(_player: IPlayer) {
    return undefined;
  }

  public override get type(): CardType.CEO {
    return CardType.CEO;
  }
}

================
File: cards/ceos/CeoCardManifest.ts
================
import {CardName} from '../../../common/cards/CardName';
import {ModuleManifest} from '../ModuleManifest';

import {Apollo} from './Apollo';
import {Asimov} from './Asimov';
import {Bjorn} from './Bjorn';
import {Caesar} from './Caesar';
import {Clarke} from './Clarke';
import {Duncan} from './Duncan';
import {Ender} from './Ender';
import {Faraday} from './Faraday';
import {Floyd} from './Floyd';
import {Gaia} from './Gaia';
import {Gordon} from './Gordon';
import {Greta} from './Greta';
import {HAL9000} from './HAL9000';
// import {Huan} from './Huan';
import {Ingrid} from './Ingrid';
import {Jansson} from './Jansson';
import {Karen} from './Karen';
import {Lowell} from './Lowell';
import {Maria} from './Maria';
import {Musk} from './Musk';
import {Naomi} from './Naomi';
import {Neil} from './Neil';
import {Oscar} from './Oscar';
import {Petra} from './Petra';
import {Quill} from './Quill';
import {Rogers} from './Rogers';
import {Ryu} from './Ryu';
import {Shara} from './Shara';
import {Stefan} from './Stefan';
import {Tate} from './Tate';
import {Ulrich} from './Ulrich';
import {VanAllen} from './VanAllen';
import {Will} from './Will';
import {Xavier} from './Xavier';
import {Xu} from './Xu';
import {Yvonne} from './Yvonne';
import {Zan} from './Zan';


import {CoLeadership} from './CoLeadership';

export const CEO_CARD_MANIFEST = new ModuleManifest({
  module: 'ceo',
  ceoCards: {
    [CardName.APOLLO]: {Factory: Apollo, compatibility: 'moon'},
    [CardName.ASIMOV]: {Factory: Asimov},
    [CardName.BJORN]: {Factory: Bjorn},
    [CardName.CAESAR]: {Factory: Caesar, compatibility: 'ares'},
    [CardName.CLARKE]: {Factory: Clarke},
    [CardName.DUNCAN]: {Factory: Duncan},
    [CardName.ENDER]: {Factory: Ender},
    [CardName.FARADAY]: {Factory: Faraday},
    [CardName.FLOYD]: {Factory: Floyd},
    [CardName.GAIA]: {Factory: Gaia, compatibility: 'ares'},
    [CardName.GORDON]: {Factory: Gordon},
    [CardName.GRETA]: {Factory: Greta},
    [CardName.HAL9000]: {Factory: HAL9000},
    // [CardName.HUAN]: {Factory: Huan, compatibility: 'colonies'},
    [CardName.INGRID]: {Factory: Ingrid},
    [CardName.JANSSON]: {Factory: Jansson},
    [CardName.KAREN]: {Factory: Karen, compatibility: 'prelude'},
    [CardName.LOWELL]: {Factory: Lowell},
    [CardName.MARIA]: {Factory: Maria, compatibility: 'colonies'},
    [CardName.MUSK]: {Factory: Musk},
    [CardName.NAOMI]: {Factory: Naomi, compatibility: 'colonies'},
    [CardName.NEIL]: {Factory: Neil, compatibility: 'moon'},
    [CardName.OSCAR]: {Factory: Oscar, compatibility: 'turmoil'},
    [CardName.PETRA]: {Factory: Petra, compatibility: 'turmoil'},
    [CardName.QUILL]: {Factory: Quill, compatibility: 'venus'},
    [CardName.ROGERS]: {Factory: Rogers, compatibility: 'venus'},
    [CardName.RYU]: {Factory: Ryu},
    [CardName.SHARA]: {Factory: Shara, compatibility: 'pathfinders'},
    [CardName.STEFAN]: {Factory: Stefan},
    [CardName.TATE]: {Factory: Tate},
    [CardName.ULRICH]: {Factory: Ulrich},
    [CardName.VANALLEN]: {Factory: VanAllen},
    [CardName.WILL]: {Factory: Will, compatibility: 'venus'},
    [CardName.XAVIER]: {Factory: Xavier, compatibility: 'prelude'},
    [CardName.XU]: {Factory: Xu, compatibility: 'venus'},
    [CardName.YVONNE]: {Factory: Yvonne, compatibility: 'colonies'},
    [CardName.ZAN]: {Factory: Zan, compatibility: 'turmoil'},
  },
  preludeCards: {
    [CardName.CO_LEADERSHIP]: {Factory: CoLeadership},
  },
});

================
File: cards/ceos/Clarke.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';

import {Resource} from '../../../common/Resource';

export class Clarke extends CeoCard {
  constructor() {
    super({
      name: CardName.CLARKE,
      metadata: {
        cardNumber: 'L03',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('ACTIVATE THE BELOW ABILITY').br;
          b.production((pb) => pb.plants(1).heat(1));
          b.text('X+4').plants(1).heat(1).asterix();
        }),
        description: 'Once per game, increase your plant and heat production 1 step each. Gain plants and heat equal to your production +4.',
      },
    });
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    player.production.add(Resource.PLANTS, 1, {log: true});
    player.production.add(Resource.HEAT, 1, {log: true});
    player.stock.add(Resource.PLANTS, player.production.plants + 4, {log: true});
    player.stock.add(Resource.HEAT, player.production.heat + 4, {log: true});
    return undefined;
  }
}

================
File: cards/ceos/CoLeadership.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardRenderer} from '../render/CardRenderer';
import {PreludeCard} from '../prelude/PreludeCard';
import {Size} from '../../../common/cards/render/Size';
import {DrawCeoCardFromDeck} from '../../deferredActions/DrawCeoCardFromDeck';

export class CoLeadership extends PreludeCard {
  constructor() {
    super({
      name: CardName.CO_LEADERSHIP,
      metadata: {
        cardNumber: 'xxx',
        renderData: CardRenderer.builder((b) => {
          b.text('Draw 3 CEO cards and take one to your hand, it will be played on your first turn. Discard the other 2.', Size.SMALL, true);
        }),
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    if (!player.game.ceoDeck.canDraw(3)) {
      this.warnings.add('deckTooSmall');
    }
    return true;
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new DrawCeoCardFromDeck(player, 3)).andThen((card) => {
      if (card !== undefined) {
        player.ceoCardsInHand.push(card);
      }
    });
    return undefined;
  }
}

================
File: cards/ceos/Duncan.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {Resource} from '../../../common/Resource';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';


export class Duncan extends CeoCard {
  constructor() {
    super({
      name: CardName.DUNCAN,

      victoryPoints: 'special',

      metadata: {
        cardNumber: 'L04',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().vpIcon().asterix().megacredits(1, {text: '4x'});
          b.br;
        }),
        victoryPoints: CardRenderDynamicVictoryPoints.questionmark(),
        description: 'Once per game, gain 7-X VP and 4X M€, where X is the current generation number.',
      },
    });
  }

  public generationUsed = -1;

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    player.stock.add(Resource.MEGACREDITS, 4 * player.game.generation, {log: true});
    this.generationUsed = player.game.generation;
    return undefined;
  }

  public override getVictoryPoints(): number {
    if (this.isDisabled === true && this.generationUsed !== undefined) {
      return 7 - this.generationUsed;
    }
    return 0;
  }
}

================
File: cards/ceos/Ender.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {DrawCards} from '../../deferredActions/DrawCards';
import {Priority} from '../../deferredActions/Priority';
import {DiscardCards} from '../../deferredActions/DiscardCards';

export class Ender extends CeoCard {
  constructor() {
    super({
      name: CardName.ENDER,
      metadata: {
        cardNumber: 'L05',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().minus().text('2X').cards(1).plus().text('2X').cards(1);
        }),
        description: 'Once per game, discard any number of cards up to twice the current generation number to draw that many cards.',
      },
    });
  }

  public override canAct(player: IPlayer): boolean {
    if (!super.canAct(player)) {
      return false;
    }
    return player.cardsInHand.length > 0;
  }

  public action(player: IPlayer): undefined {
    this.isDisabled = true;
    const max = Math.min(player.cardsInHand.length, player.game.generation * 2);
    player.game.defer(new DiscardCards(player, 0, max), Priority.DISCARD_AND_DRAW)
      .andThen((cards) => player.game.defer(DrawCards.keepAll(player, cards.length)));
    return undefined;
  }
}

================
File: cards/ceos/Faraday.ts
================
import {MultiSet} from 'mnemonist';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {IProjectCard} from '../IProjectCard';
import {Size} from '../../../common/cards/render/Size';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {Tag} from '../../../common/cards/Tag';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {message} from '../../logs/MessageBuilder';
import {TITLES} from '../../inputs/titles';

const INVALID_TAGS = [
  Tag.EVENT,
  Tag.WILD,
];

export class Faraday extends CeoCard {
  constructor() {
    super({
      name: CardName.FARADAY,
      metadata: {
        cardNumber: 'L27',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.text('5', Size.LARGE).diverseTag(1).colon().megacredits(-3).cards(1, {secondaryTag: AltSecondaryTag.DIVERSE}).asterix();
          b.br.br;
        }),
        description: 'When you gain a multiple of 5 for any tag type IN PLAY, you may pay 3 M€ to draw a card with that tag. Wild tags do not count for this effect.',
      },
    });
  }

  public override canAct(): boolean {
    return false;
  }

  // This _could_ save CPU cycles instead of running multiple finds?
  private countTags(player: IPlayer): Record<Tag, number> {
    const record: Partial<Record<Tag, number>> = {};
    for (const entry of player.tags.countAllTags()) {
      record[entry.tag] = entry.count;
    }
    // This is safe because countAllTags returns all tags. I wish it were easy to initialize a Record type.
    // Actually it doesn't return Clone tags.
    return record as Record<Tag, number>;
  }

  private gainedMultiple(tagsOnCard: number, total: number): boolean {
    const priorTagCount = total - tagsOnCard;
    // Modulo 5 what the tag count was before the card was played.
    // Sum that pre-played count with the new cards tags.  If this sum is >=5, offer a card draw.
    // this wont work if someone makes a card with > 5 tags of one type, but...
    return priorTagCount % 5 + tagsOnCard >= 5;
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.tags.length === 0 || card.type === CardType.EVENT || !player.canAfford(2)) {
      return;
    }

    this.processTags(player, card.tags);
  }

  public onColonyAddedToLeavitt(player: IPlayer) {
    this.processTags(player, [Tag.SCIENCE]);
  }

  private processTags(player: IPlayer, tags: ReadonlyArray<Tag>) {
    const counts = this.countTags(player);

    const tagsOnCard = MultiSet.from(tags);
    tagsOnCard.forEachMultiplicity((countOnCard, tagOnCard) => {
      if (INVALID_TAGS.includes(tagOnCard)) return;
      if (this.gainedMultiple(countOnCard, counts[tagOnCard])) {
        player.defer(this.effectOptions(player, tagOnCard));
      }
    });
  }

  public effectOptions(player: IPlayer, tag: Tag) {
    if (!player.canAfford(3)) return;
    return new OrOptions(
      new SelectOption(message('Pay 3 M€ to draw a ${1} card', (b) => b.string(tag))).andThen(() => {
        player.game.defer(new SelectPaymentDeferred(player, 3, {title: TITLES.payForCardAction(this.name)}))
          .andThen(() => player.drawCard(1, {tag: tag}));
        return undefined;
      }),
      new SelectOption('Do nothing'),
    );
  }
}

================
File: cards/ceos/Floyd.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {PlayProjectCard} from '../../deferredActions/PlayProjectCard';

export class Floyd extends CeoCard {
  constructor() {
    super({
      name: CardName.FLOYD,
      metadata: {
        cardNumber: 'L06',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('ACTIVATE THE BELOW ABILITY');
          b.br.br;
          b.text('PLAY').cards(1).colon().megacredits(-13).megacredits(1, {text: '-2x'}).asterix();
          b.br.br;
        }),
        description: 'Once per game, play a card from hand for 13 + 2X M€ less, where X is the current generation number.',
      },
    });
  }

  public opgActionIsActive = false;

  public override canAct(player: IPlayer): boolean {
    if (!super.canAct(player)) {
      return false;
    }
    return player.cardsInHand.length > 0;
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    this.opgActionIsActive = true;
    player.game.defer(new PlayProjectCard(player))
      .andThen(() => this.opgActionIsActive = false);
    return undefined;
  }

  public override getCardDiscount(player: IPlayer) {
    if (this.opgActionIsActive === true) {
      return 13 + (2 * player.game.generation);
    }
    return 0;
  }
}

================
File: cards/ceos/Gaia.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {SpaceType} from '../../../common/boards/SpaceType';

import {AresHandler} from '../../ares/AresHandler';
import {isHazardTileType} from '../../../common/AresTileType';

export class Gaia extends CeoCard {
  constructor() {
    super({
      name: CardName.GAIA,
      metadata: {
        cardNumber: 'L32',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().colon().adjacencyBonus().asterix();
          b.br;
        }),
        description: 'Once per game, gain the Ares adjacency bonuses of all player-owned tiles on Mars.',
      },
    });
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const board = player.game.board;
    // For every tile placed on the board, grant all the adjacency bonuses for that tile.
    // We do not exclude Ocean tiles because of things like Ocean Cities.
    // We exclude all tiles that _do not_ have owners
    // We exlcude all hazard tiles. (Spaces with Hazard tiles can have players in weird edge cases, like with Land Claim)
    const tilesOnMars = board.spaces.filter((space) =>
      space.tile?.tileType !== undefined && space.player !== undefined && !isHazardTileType(space.tile.tileType) && space.spaceType !== SpaceType.COLONY,
    );
    tilesOnMars.forEach((space) => {
      AresHandler.ifAres(player.game, () => {
        AresHandler.earnAdjacencyBonuses(player, space, {giveAresTileOwnerBonus: false});
      });
    });
    return undefined;
  }
}

================
File: cards/ceos/Gordon.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {Board} from '../../boards/Board';
import {Space} from '../../boards/Space';
import {GainResources} from '../../deferredActions/GainResources';
import {Resource} from '../../../common/Resource';
import {SpaceType} from '../../../common/boards/SpaceType';
import {BoardType} from '../../boards/BoardType';
import {Phase} from '../../../common/Phase';

export class Gordon extends CeoCard {
  constructor() {
    super({
      name: CardName.GORDON,
      metadata: {
        cardNumber: 'L07',
        renderData: CardRenderer.builder((b) => {
          b.greenery().city().colon().megacredits(2).asterix();
          b.br.br;
        }),
        description: 'Ignore placement restrictions for greenery and city tiles on Mars. Gain 2 M€ when you place a greenery or city tile on Mars.',
      },
    });
  }

  public override canAct(): boolean {
    return false;
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space, boardType: BoardType) {
    if (cardOwner.id !== activePlayer.id) return;
    if (boardType !== BoardType.MARS || space.spaceType !== SpaceType.LAND) return;
    if (cardOwner.game.phase === Phase.SOLAR) return;

    if (Board.isCitySpace(space) || Board.isGreenerySpace(space)) {
      cardOwner.game.defer(new GainResources(cardOwner, Resource.MEGACREDITS, {count: 2, log: true}));
    }
    return;
  }
}

================
File: cards/ceos/Greta.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {Resource} from '../../../common/Resource';
import {Phase} from '../../../common/Phase';

export class Greta extends CeoCard {
  constructor() {
    super({
      name: CardName.GRETA,
      metadata: {
        cardNumber: 'L31',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('ACTIVATE THE BELOW ABILITY');
          b.br.br;
          b.tr(1).colon().megacredits(4).asterix();
          b.br;
        }),
        description: 'When you take an action or play a card that increases your TR THIS GENERATION (max 10 times), gain 4 M€.',
      },
    });
  }

  public opgActionIsActive = false;
  public effectTriggerCount = 0;

  public action(): PlayerInput | undefined {
    this.opgActionIsActive = true;
    this.isDisabled = true;
    return undefined;
  }

  public onIncreaseTerraformRating(player: IPlayer, cardOwner: IPlayer) {
    const game = player.game;
    if (this.opgActionIsActive === true && this.effectTriggerCount < 10) {
      if (player === cardOwner && game.phase === Phase.ACTION) {
        player.stock.add(Resource.MEGACREDITS, 4, {log: true});
        this.effectTriggerCount++;
      }
    }
    return undefined;
  }
}

================
File: cards/ceos/HAL9000.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {digit} from '../Options';
import {Units} from '../../../common/Units';

export class HAL9000 extends CeoCard {
  constructor() {
    super({
      name: CardName.HAL9000,
      metadata: {
        cardNumber: 'L08',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('ACTIVATE THE BELOW ABILITY');
          b.br.br;
          b.minus().text('EACH').production((pb) => pb.wild(1)).nbsp.colon().wild(4, {digit}).asterix();
          b.br;
        }),
        description: 'Once per game, decrease each of your productions 1 step to gain 4 of that resource.',
      },
    });
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    // For every Unit type, if it can be reduced one unit, do so, and give the player
    // 4 of that resource.
    for (const type of Units.keys) {
      const adjustment = Units.of({});
      adjustment[type] = -1;
      if (player.production.canAdjust(adjustment)) {
        player.production.adjust(adjustment, {log: true});
        adjustment[type] = 4;
        player.stock.addUnits(adjustment, {log: true});
      }
    }
    return undefined;
  }
}

================
File: cards/ceos/ICeoCard.ts
================
import {IActionCard, ICard} from '../ICard';
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';

export interface ICeoCard extends IProjectCard, Partial<IActionCard> {
  /** If this card is active this generation. */
  opgActionIsActive?: boolean;

  canAct(player: IPlayer): boolean;
}

export function isCeoCard(card: ICard): card is ICeoCard {
  return card.type === CardType.CEO;
}

================
File: cards/ceos/Ingrid.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {Space} from '../../boards/Space';
import {Phase} from '../../../common/Phase';
import {SpaceType} from '../../../common/boards/SpaceType';
import {BoardType} from '../../boards/BoardType';

export class Ingrid extends CeoCard {
  constructor() {
    super({
      name: CardName.INGRID,
      metadata: {
        cardNumber: 'L09',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('ACTIVATE THE BELOW ABILITY');
          b.br.br;
          b.emptyTile('normal').asterix().nbsp.colon().nbsp.plus().cards(1);
          b.br;
        }),
        description: 'When you take an action that places a tile on Mars THIS GENERATION, draw a card.',
      },
    });
  }

  public opgActionIsActive = false;

  public action(): PlayerInput | undefined {
    this.isDisabled = true;
    this.opgActionIsActive = true;
    return undefined;
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space, boardType: BoardType) {
    if (this.opgActionIsActive === false) return;
    // This filters for tiles only on mars (not moon), and includes Land+Oceans+'Coves'(landoceans)
    if (boardType !== BoardType.MARS || space.spaceType === SpaceType.COLONY) return;
    if (cardOwner.id !== activePlayer.id) return;
    if (cardOwner.game.phase === Phase.SOLAR) return;

    cardOwner.drawCard();
  }
}

================
File: cards/ceos/Jansson.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
// import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';

export class Jansson extends CeoCard {
  constructor() {
    super({
      name: CardName.JANSSON,
      metadata: {
        cardNumber: 'L10',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().emptyTile().wild(1).asterix();
        }),
        description: 'Once per game, gain all placement bonuses under your tiles on Mars.',
      },
    });
  }

  public action(player: IPlayer): undefined {
    this.isDisabled = true;
    const spaces = player.game.board.spaces.filter((space) => space.tile !== undefined && space.player === player);
    spaces.forEach((space) => {
      player.game.grantSpaceBonuses(player, space);
    });
    return undefined;
  }
}

================
File: cards/ceos/Karen.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {PreludesExpansion} from '../../preludes/PreludesExpansion';

export class Karen extends CeoCard {
  constructor() {
    super({
      name: CardName.KAREN,
      metadata: {
        cardNumber: 'L11',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('X').prelude().asterix();
        }),
        description: 'Once per game, draw Prelude cards equal to the current generation number and choose one to play, and discard the rest.',
      },
    });
  }

  public override canAct(player: IPlayer) {
    if (!player.game.preludeDeck.canDraw(player.game.generation)) {
      this.warnings.add('deckTooSmall');
    }
    return super.canAct(player);
  }
  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const game = player.game;
    const cards = game.preludeDeck.drawN(game, game.generation);
    return PreludesExpansion.playPrelude(player, cards);
  }
}

================
File: cards/ceos/Lowell.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {Tag} from '../../../common/cards/Tag';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {TITLES} from '../../inputs/titles';
import {DrawCeoCardFromDeck} from '../../deferredActions/DrawCeoCardFromDeck';
import {inplaceRemove} from '../../../common/utils/utils';

export class Lowell extends CeoCard {
  constructor() {
    super({
      name: CardName.LOWELL,
      tags: [Tag.WILD],
      metadata: {
        cardNumber: 'L12',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().megacredits(8).colon().text('CHANGE LEADER').asterix();
          b.br.br;
        }),
        description: 'Once per game, pay 8 M€ to draw 3 CEO cards and choose one to play. Discard this card.',
      },
    });
  }

  public override canAct(player: IPlayer): boolean {
    if (!player.game.ceoDeck.canDraw(3)) {
      this.warnings.add('deckTooSmall');
    }
    if (!super.canAct(player)) {
      return false;
    }
    return player.canAfford(8);
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const game = player.game;

    game.defer(new SelectPaymentDeferred(player, 8, {title: TITLES.payForCardAction(this.name)}))
      .andThen(() => {
        player.game.defer(new DrawCeoCardFromDeck(player, 3)).andThen((newCeo) => {
          if (newCeo !== undefined) {
            // Move Lowell to the discard pile
            inplaceRemove(player.playedCards, this);
            game.ceoDeck.discard(this);
            // Play the new CEO
            player.playCard(newCeo);
          }
        });
      });
    return undefined;
  }
}

================
File: cards/ceos/Maria.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {ColoniesHandler} from '../../colonies/ColoniesHandler';

export class Maria extends CeoCard {
  constructor() {
    super({
      name: CardName.MARIA,
      metadata: {
        cardNumber: 'L13',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('X ').colonyTile().colonies(1);
        }),
        description: 'Once per game, draw colony tiles equal to the current generation number. Put one into play and build a colony on it for free if possible.',
      },
    });
  }

  public override canAct(player: IPlayer): boolean {
    const game = player.game;
    if (game.discardedColonies === undefined || !game.gameOptions.coloniesExtension) return false;
    return game.discardedColonies.length > 0 && this.isDisabled === false;
  }

  public action(player: IPlayer): undefined {
    const game = player.game;
    const count = Math.min(game.discardedColonies.length, player.game.generation);
    const availableColonies = game.discardedColonies.slice(0, count);

    this.isDisabled = true;
    ColoniesHandler.addColonyTile(player, {
      colonies: availableColonies, cb: (colony) => {
        if (colony.isActive) {
          colony.addColony(player);
        }
      }});
    return undefined;
  }
}

================
File: cards/ceos/Musk.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';

import {DrawCards} from '../../deferredActions/DrawCards';

import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {SelectCard} from '../../inputs/SelectCard';


export class Musk extends CeoCard {
  constructor() {
    super({
      name: CardName.MUSK,
      metadata: {
        cardNumber: 'L28',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().minus().cards(1, {secondaryTag: Tag.EARTH}).colon().cards(1, {secondaryTag: Tag.SPACE}).titanium(1).asterix();
          b.br;
          b.titanium(6);
          b.br.br;
        }),
        description: 'Once per game, discard any number of Earth cards to draw that many space cards, and gain that many units of titanium, plus 6.',
      },
    });
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const game = player.game;
    const eligibleCards = player.cardsInHand.filter((card) => card.tags.includes(Tag.EARTH));

    if (eligibleCards.length === 0) {
      game.log('${0} has no Earth cards', (b) => b.player(player), {reservedFor: player});
      player.stock.add(Resource.TITANIUM, 6, {log: true});
      return undefined;
    }

    return new SelectCard(
      'Select Earth card(s) to discard',
      'Discard',
      eligibleCards,
      {min: 0, max: eligibleCards.length})
      .andThen(
        (cards) => {
          player.stock.add(Resource.TITANIUM, cards.length + 6, {log: true});
          for (const card of cards) {
            player.discardCardFromHand(card);
          }
          player.game.defer(DrawCards.keepAll(player, cards.length, {tag: Tag.SPACE}));
          return undefined;
        },
      );
  }
}

================
File: cards/ceos/Naomi.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {MAX_COLONY_TRACK_POSITION} from '../../../common/constants';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {ColoniesHandler} from '../../colonies/ColoniesHandler';
import {Resource} from '../../../common/Resource';

export class Naomi extends CeoCard {
  constructor() {
    super({
      name: CardName.NAOMI,
      metadata: {
        cardNumber: 'L14',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.colonies(1).colon().energy(2).megacredits(3);
          b.br.br.br;
          b.opgArrow().text('SET ALL').colonies(1).asterix();
        }),
        description: 'When you build a colony, gain 2 energy and 3 M€. Once per game, move each colony tile track marker to its highest or lowest value.',
      },
    });
  }

  public override canAct(player: IPlayer): boolean {
    return super.canAct(player) && ColoniesHandler.tradeableColonies(player.game).length > 0;
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const game = player.game;
    const activeColonies = game.colonies.filter((colony) => colony.isActive);

    activeColonies.forEach((colony) => {
      player.defer(() => new OrOptions(
        new SelectOption('Move the ' + colony.name + ' tile track marker to its HIGHEST value').andThen(() => {
          colony.trackPosition = MAX_COLONY_TRACK_POSITION;
          return undefined;
        }),
        new SelectOption('Move the ' + colony.name + ' tile track marker to its LOWEST value').andThen(() => {
          colony.trackPosition = colony.colonies.length;
          return undefined;
        }),
      ));
    });
    return undefined;
  }

  public onColonyAdded(player: IPlayer, cardOwner: IPlayer) {
    if (player === cardOwner) {
      player.stock.add(Resource.ENERGY, 2, {log: true});
      player.stock.add(Resource.MEGACREDITS, 3, {log: true});
    }
  }
}

================
File: cards/ceos/Neil.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {all} from '../Options';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {Resource} from '../../../common/Resource';

export class Neil extends CeoCard {
  constructor() {
    super({
      name: CardName.NEIL,
      metadata: {
        cardNumber: 'L34',
        renderData: CardRenderer.builder((b) => {
          b.tag(Tag.MOON, {all}).colon().megacredits(1);
          b.br.br;
          b.opgArrow().production((pb) => pb.megacredits(1, {text: '?'})).asterix();
        }),
        description: 'Gain 1 M€ when any player plays a Moon tag. Once per game, increase your M€ production by the value of the LOWEST Moon rate.',
      },
    });
  }

  public onCardPlayedFromAnyPlayer(thisCardOwner: IPlayer, _playedCardOwner: IPlayer, card: IProjectCard) {
    for (const tag of card.tags) {
      if (tag === Tag.MOON) {
        thisCardOwner.game.getCardPlayerOrThrow(this.name).stock.add(Resource.MEGACREDITS, 1, {log: true});
      }
    }
    return undefined;
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const game = player.game;
    MoonExpansion.ifMoon(game, (moonData) => {
      const lowestRate = Math.min(moonData.habitatRate, moonData.logisticRate, moonData.miningRate);

      if (lowestRate > 0) {
        player.production.add(Resource.MEGACREDITS, lowestRate, {log: true});
      }
    });

    return undefined;
  }
}

================
File: cards/ceos/Oscar.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';

import {Turmoil} from '../../turmoil/Turmoil';

export class Oscar extends CeoCard {
  constructor() {
    super({
      name: CardName.OSCAR,
      metadata: {
        cardNumber: 'L15',
        renderData: CardRenderer.builder((b) => {
          b.plus().influence();
          b.br.br;
          b.opgArrow().chairman();
        }),
        description: 'You have +1 influence. Once per game, replace the Chairman with one of your delegates.',
      },
    });
  }

  public override play(player: IPlayer) {
    const turmoil = player.game.turmoil;
    if (turmoil) turmoil.addInfluenceBonus(player);
    return undefined;
  }

  public override canAct(player: IPlayer): boolean {
    if (!super.canAct(player)) {
      return false;
    }
    const turmoil = Turmoil.getTurmoil(player.game);
    return turmoil.hasDelegatesInReserve(player) && turmoil.chairman !== player;
  }

  public action(player: IPlayer): PlayerInput | undefined {
    const turmoil = Turmoil.getTurmoil(player.game);
    turmoil.setNewChairman(player, player.game, /* setAgenda*/false, /* gainTR*/false);
    turmoil.delegateReserve.remove(player);
    // Increase totalDelegatesPlaced manually since we're not using SendDeletageToArea()
    // If we dont do this player will not get the bonus for POLITICAN Awards
    player.totalDelegatesPlaced += 1;
    this.isDisabled = true;
    return undefined;
  }
}

================
File: cards/ceos/Petra.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {DELEGATES_FOR_NEUTRAL_PLAYER} from '../../../common/constants';
import {Turmoil} from '../../turmoil/Turmoil';
import {SelectParty} from '../../inputs/SelectParty';
import {Resource} from '../../../common/Resource';
import {Size} from '../../../common/cards/render/Size';

export class Petra extends CeoCard {
  constructor() {
    super({
      name: CardName.PETRA,
      metadata: {
        cardNumber: 'L16',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('ACTIVATE THE BELOW ABILITY');
          b.br;
          b.text('REPLACE ALL NEUTRAL', Size.TINY).delegates(1).colon().megacredits(3).asterix();
          b.br.br;
          b.plus().delegates(3).asterix;
        }),
        description: 'Once per game, replace all Neutral delegates with your delegates. Gain 3 M€ for each delegate replaced this way. Place 3 Neutral delegates.',
      },
    });
  }

  public override canAct(player: IPlayer): boolean {
    if (!super.canAct(player)) {
      return false;
    }
    // We need to make sure that the player has enough delegates available to replace ALL neuts.
    //  including Chairman!
    const turmoil = player.game.turmoil;
    if (turmoil === undefined || this.isDisabled === true) return false;
    const numNeutralDelegates = DELEGATES_FOR_NEUTRAL_PLAYER - turmoil.getAvailableDelegateCount('NEUTRAL');
    const playerTotalDelegateCount = turmoil.getAvailableDelegateCount(player);
    return playerTotalDelegateCount >= numNeutralDelegates;
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;

    const turmoil = player.game.turmoil as Turmoil;

    let count = 0; // How many delegates were swapped out

    // Replace all neutral delegates in all parties
    for (const party of turmoil.parties) {
      const neutralDelegates = party.delegates.count('NEUTRAL');
      for (let i = 0; i < neutralDelegates; i++) {
        // Add the delegate _before_ removing the Neutral, otherwise we get errors when it
        // attempts to find the new party leader if there are no remaining members in the party.
        turmoil.sendDelegateToParty(player, party.name, player.game);
        turmoil.removeDelegateFromParty('NEUTRAL', party.name, player.game);
        // This would be nice to use:
        // turmoil.replaceDelegateFromParty('NEUTRAL', player.id, party.name, player.game);
        // but it generates errors if the party only has the single Neutral member

        // Check dominance after every replacement
        turmoil.checkDominantParty();
      }
      count += neutralDelegates;
    }

    // Replace chairman if it is neutral
    if (turmoil.chairman === 'NEUTRAL') {
      turmoil.setNewChairman(player, player.game, /* setAgenda */ false);
      turmoil.delegateReserve.remove(player);
      count += 1;
    }
    // If we dont do this player will not get the bonus for POLITICAN Awards
    player.totalDelegatesPlaced += count;
    player.stock.add(Resource.MEGACREDITS, count * 3, {log: true});

    // Place 3 Neutral delegates
    const availableParties = turmoil.parties.map((party) => party.name);
    const title = 'Select where to send a Neutral delegate';
    const previousDominantParty = turmoil.dominantParty.name;

    for (let i = 0; i < 3; i++) {
      player.defer(() => {
        return new SelectParty(title, 'Send delegate', availableParties)
          .andThen((partyName) => {
            turmoil.sendDelegateToParty('NEUTRAL', partyName, player.game);
            player.game.log('${0} sent ${1} Neutral delegate in ${2} area', (b) => b.player(player).number(1).party(turmoil.getPartyByName(partyName)));
            return undefined;
          });
      });
    }

    if (turmoil.dominantParty.name !== previousDominantParty) {
      player.game.log('${0} is the new dominant party', (b) => b.string(turmoil.dominantParty.name));
    }
    return undefined;
  }
}

================
File: cards/ceos/Quill.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {CardResource} from '../../../common/CardResource';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {Resource} from '../../../common/Resource';
import {GainResources} from '../../deferredActions/GainResources';


export class Quill extends CeoCard {
  constructor() {
    super({
      name: CardName.QUILL,
      metadata: {
        cardNumber: 'L17',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('ACTIVATE THE BELOW ABILITY').br;
          b.cards(1, {secondaryTag: AltSecondaryTag.FLOATER}).colon().resource(CardResource.FLOATER, 2).megacredits(1).asterix();
        }),
        description: 'Once per game, add 2 floaters to each of your cards that collect floaters, then add 2 floaters to ANY card. Gain 1 M€ for every 2 floaters added this way.',
      },
    });
  }

  public override canAct(player: IPlayer): boolean {
    if (!super.canAct(player)) {
      return false;
    }
    return player.getResourceCards(CardResource.FLOATER).length > 0;
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const resourceCards = player.getResourceCards(CardResource.FLOATER);
    resourceCards.forEach((card) => player.addResourceTo(card, {qty: 2, log: true}));
    player.game.defer(new AddResourcesToCard(player, CardResource.FLOATER, {count: 2}));
    player.game.defer(new GainResources(player, Resource.MEGACREDITS, {count: resourceCards.length + 1, log: true}));
    return undefined;
  }
}

================
File: cards/ceos/Rogers.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';

import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {GlobalParameter} from '../../../common/GlobalParameter';

export class Rogers extends CeoCard {
  constructor() {
    super({
      name: CardName.ROGERS,
      metadata: {
        cardNumber: 'L18',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('ACTIVATE THE BELOW ABILITY');
          b.br;
          b.tag(Tag.VENUS).colon().projectRequirements();
          b.br;
          b.tag(Tag.VENUS).colon().megacredits(-3);
        }),
        description: 'Ignore global requirements for your Venus cards THIS GENERATION. When you play a Venus tag THIS GENERATION, you pay 3 M€ less for it.',
      },
    });
  }

  public opgActionIsActive = false;

  public action(): PlayerInput | undefined {
    this.isDisabled = true;
    this.opgActionIsActive = true;
    return undefined;
  }

  public override getGlobalParameterRequirementBonus(_player: IPlayer, parameter: GlobalParameter): number {
    if (this.opgActionIsActive === false || parameter !== GlobalParameter.VENUS) return 0;
    // Magic number high enough to always ignore requirements.
    return 50;
  }

  public override getCardDiscount(_player: IPlayer, card: IProjectCard) {
    if (this.opgActionIsActive === false) return 0;
    return card.tags.filter((tag) => tag === Tag.VENUS).length * 3;
  }
}

================
File: cards/ceos/Ryu.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';

import {OrOptions} from '../../inputs/OrOptions';
import {ALL_RESOURCES, Resource} from '../../../common/Resource';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectAmount} from '../../inputs/SelectAmount';
import {message} from '../../logs/MessageBuilder';

export class Ryu extends CeoCard {
  constructor() {
    super({
      name: CardName.RYU,
      metadata: {
        cardNumber: 'L30',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('ACTIVATE THE BELOW ABILITY');
          b.br;
          b.text('SWAP X+2').production((pb) => pb.wild(1));
          b.br.br;
        }),
        description: 'Once per game, swap up to X+2 units of production between two resources, where X is the current generation number.',
      },
    });
  }

  public override canAct(player: IPlayer): boolean {
    if (!super.canAct(player)) {
      return false;
    }
    return player.production.megacredits +
              player.production.steel +
              player.production.titanium +
              player.production.plants +
              player.production.energy +
              player.production.heat > -5;
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const choices = new OrOptions();

    ALL_RESOURCES.filter((r) => this.productionIsDecreasable(player, r)).forEach((resourceToDecrease) => {
      const selectOption = new SelectOption(message('Decrease ${0} production', (b) => b.string(resourceToDecrease))).andThen(() => {
        // M€ production can go down to -5
        let decreasable = player.production.get(resourceToDecrease);
        if (resourceToDecrease === Resource.MEGACREDITS) decreasable += 5;
        const maxDecreasableAmt = Math.min(player.game.generation + 2, decreasable);

        return new SelectAmount(
          `Select amount of ${resourceToDecrease} production to decrease`,
          'Decrease',
          1,
          maxDecreasableAmt,
          true,
        ).andThen((amount) => {
          const productionToIncrease =
            ALL_RESOURCES.filter((res) => res !== resourceToDecrease)
              .map((res) => new SelectOption(message('Increase ${0} production', (b) => b.string(res))).andThen(() => {
                player.production.add(resourceToDecrease, -amount, {log: true});
                // player.production.adjust()
                player.production.add(res, amount, {log: true});
                return undefined;
              }));

          return new OrOptions(...productionToIncrease);
        });
      });

      choices.options.push(selectOption);
    });

    return choices;
  }

  private productionIsDecreasable(player: IPlayer, resource: Resource): boolean {
    let minProduction = 0;
    if (resource === Resource.MEGACREDITS) minProduction -= 5;
    return player.production.get(resource) > minProduction;
  }
}

================
File: cards/ceos/Shara.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {Tag} from '../../../common/cards/Tag';
import {DeclareCloneTag} from '../../pathfinders/DeclareCloneTag';
import {Resource} from '../../../common/Resource';
import {clone} from '../Options';

export class Shara extends CeoCard {
  constructor() {
    super({
      name: CardName.SHARA,
      metadata: {
        cardNumber: 'LXXX',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('ACTIVATE THE BELOW ABILITY').br;
          b.planetaryTrack().text('2').nbsp.megacredits(0, {clone}).asterix();
          // TODO(d-little): Confirm Balance
          // There is an option here to balance Shara by subtracting money equal to the current generation.
          // However, this might put Shara on the too-weak side of the equation due to the limits on the Pathfinder influence track.
          // For now, do not subtract the MC, but if users complain that Shara is OP we should revisit this balance.
          // b.planetaryTrack().text('2').nbsp.megacredits(0, {clone}).asterix().minus().megacredits(0, {multiplier}).asterix();
        }),
        // description: 'Once per game, choose a planet tag. This card counts as having immediately played 2 of that tag. Then gain M€ equal to that tags planety influence track minus the current generation.',
        description: 'Once per game, choose a planet tag. This card counts as having immediately played 2 of that tag. Then gain M€ equal to that tags planety influence track.',
      },
    });
  }

  public cloneTag: Tag = Tag.CLONE;

  public override get tags(): Array<Tag> {
    return [this.cloneTag, this.cloneTag];
  }


  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const data = player.game.pathfindersData;
    if (data === undefined) {
      return undefined;
    }
    player.game.defer(new DeclareCloneTag(player, this))
      .andThen((tag) => {
        // const value = data[tag] - player.game.generation;
        const value = data[tag];
        player.stock.add(Resource.MEGACREDITS, value, {log: true});
      });
    return undefined;
  }
}

================
File: cards/ceos/Stefan.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {SelectCard} from '../../inputs/SelectCard';

export class Stefan extends CeoCard {
  constructor() {
    super({
      name: CardName.STEFAN,
      metadata: {
        cardNumber: 'L19',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('SELL').cards(1).colon().megacredits(3);
        }),
        description: 'Once per game, sell any number of cards from your hand for 3 M€ each.',
      },
    });
  }

  public override canAct(player: IPlayer): boolean {
    if (!super.canAct(player)) {
      return false;
    }
    return player.cardsInHand.length > 0;
  }


  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    return new SelectCard(
      'Sell patents',
      'Sell',
      player.cardsInHand,
      {min: 0, max: player.cardsInHand.length})
      .andThen((cards) => {
        player.megaCredits += cards.length * 3;

        cards.forEach((card) => {
          player.discardCardFromHand(card);
        });

        player.game.log('${0} sold ${1} patents', (b) => b.player(player).number(cards.length));
        return undefined;
      });
  }
}

================
File: cards/ceos/Tate.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';

import {Tag} from '../../../common/cards/Tag';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {Size} from '../../../common/cards/render/Size';
import {inplaceRemove} from '../../../common/utils/utils';
import {message} from '../../logs/MessageBuilder';

export class Tate extends CeoCard {
  constructor() {
    super({
      name: CardName.TATE,
      metadata: {
        cardNumber: 'L20',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('5', Size.LARGE).cards(1, {secondaryTag: Tag.WILD}).asterix();
          b.br.br;
        }),
        description: 'Once per game, name a tag. Reveal cards from the deck until you find 5 cards with that tag. BUY up to 2 cards and discard the rest.',
      },
    });
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const game = player.game;
    const tags = [...game.tags];
    inplaceRemove(tags, Tag.WILD);
    inplaceRemove(tags, Tag.EVENT);
    inplaceRemove(tags, Tag.CLONE);

    const options = tags.map((tag) => {
      return new SelectOption(message('Search for ${0} tags', (b) => b.string(tag)), 'Search').andThen(() => {
        game.log('${0} searched for ${1} tags', (b) => b.player(player).string(tag));
        player.drawCardKeepSome(5, {keepMax: 2, tag: tag, paying: true, logDrawnCard: true});
        return undefined;
      });
    });

    return new OrOptions(...options);
  }
}

================
File: cards/ceos/Ulrich.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {Resource} from '../../../common/Resource';
import {MAX_OCEAN_TILES} from '../../../common/constants';

export class Ulrich extends CeoCard {
  constructor() {
    super({
      name: CardName.ULRICH,
      metadata: {
        cardNumber: 'L21',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().oceans(1).colon().megacredits(1, {text: '4x'}).slash().megacredits(15).asterix();
        }),
        description: 'Once per game, gain 4 M€ for each ocean placed. If all oceans are aleady placed, gain only 15 M€.',
      },
    });
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const game = player.game;
    const oceansPlaced = game.board.getOceanSpaces().length;
    const bonusCredits = oceansPlaced < MAX_OCEAN_TILES ? (oceansPlaced * 4) : 15;
    player.stock.add(Resource.MEGACREDITS, bonusCredits, {log: true});
    return undefined;
  }
}

================
File: cards/ceos/VanAllen.ts
================
import {CardName} from '../../../common/cards/CardName';
import {all, digit} from '../Options';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';

export class VanAllen extends CeoCard {
  constructor() {
    super({
      name: CardName.VANALLEN,
      metadata: {
        cardNumber: 'L22',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.milestone().colon().text('=').megacredits(0, {digit});
          b.br;
          b.milestone({all}).colon().megacredits(3);
          b.br.br;
        }),
        description: 'You may claim milestones for free (you must still meet the requirements). When any milestone is claimed, gain 3 M€.',
      },
    });
  }

  // All of the Van Allen hook is done in src/server/Player.ts : claimMilestone()

  public override canAct(): boolean {
    return false;
  }
}

================
File: cards/ceos/Will.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';

import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {CardResource} from '../../../common/CardResource';

export class Will extends CeoCard {
  constructor() {
    super({
      name: CardName.WILL,
      metadata: {
        cardNumber: 'L23',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('GAIN THESE RESOURCES').br;
          b.resource(CardResource.ANIMAL).resource(CardResource.ANIMAL).resource(CardResource.MICROBE).resource(CardResource.MICROBE).br;
          b.resource(CardResource.FLOATER).resource(CardResource.FLOATER).wild(1).wild(1);
          b.br;
        }),
        description: 'Once per game, add the following resources to your cards: 2 animals, 2 microbes, 2 floaters, 2 wild.',
      },
    });
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    player.game.defer(new AddResourcesToCard(player, CardResource.ANIMAL, {count: 2}));
    player.game.defer(new AddResourcesToCard(player, CardResource.MICROBE, {count: 2}));
    player.game.defer(new AddResourcesToCard(player, CardResource.FLOATER, {count: 2}));
    player.game.defer(new AddResourcesToCard(player, undefined, {count: 2}));

    return undefined;
  }
}

================
File: cards/ceos/Xavier.ts
================
import {CardName} from '../../../common/cards/CardName';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';

export class Xavier extends CeoCard {
  constructor() {
    super({
      name: CardName.XAVIER,
      metadata: {
        cardNumber: 'L24',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('GAIN').tag(Tag.WILD, 2).asterix();
          b.br;
          b.plainText('Once per game, gain 2 wild tags for THIS GENERATION.');
          b.br.br;
          b.effect('AFTER this action has been used, when playing a card with a requirement, you pay 1 M€ less for it.',
            (eb) => eb.asterix().startEffect.cards(1, {secondaryTag: AltSecondaryTag.REQ}).colon().megacredits(-1));
        }),
      },
    });
  }

  public opgActionIsActive = false;

  public override get tags(): Array<Tag> {
    return this.opgActionIsActive ? [Tag.WILD, Tag.WILD] : [];
  }

  public action(): PlayerInput | undefined {
    this.isDisabled = true;
    this.opgActionIsActive = true;
    return undefined;
  }

  public override getCardDiscount(_player: IPlayer, card: IProjectCard) {
    if (this.isDisabled && card.requirements.length > 0) return 1;
    return 0;
  }
}

================
File: cards/ceos/Xu.ts
================
import {CardName} from '../../../common/cards/CardName';
import {PlayerInput} from '../../PlayerInput';
import {IPlayer} from '../../IPlayer';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {all} from '../Options';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {sum} from '../../../common/utils/utils';

export class Xu extends CeoCard {
  constructor() {
    super({
      name: CardName.XU,
      tags: [Tag.VENUS],

      metadata: {
        cardNumber: 'L37',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().tag(Tag.VENUS, {all}).colon().megacredits(2).megacredits(8).asterix();
          b.br.br;
        }),
        description: 'Once per game, gain 2 M€ for each Venus tag in play. Gain an additional 8 M€ if you Have the most Venus tags in play.',
      },
    });
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const players = player.game.getPlayers();

    // If the player being counted is Me, include Wild tags. Dont include opponent wild tags
    const counts = players.map((p) => p.tags.count(Tag.VENUS, player.id === p.id ? 'default' : 'raw'));

    const total = sum(counts);
    player.stock.add(Resource.MEGACREDITS, total * 2, {log: true});

    const maxPlayerVenusTagCount = Math.max(...counts);
    if (maxPlayerVenusTagCount === player.tags.count(Tag.VENUS)) {
      player.stock.add(Resource.MEGACREDITS, 8, {log: true});
    }

    return undefined;
  }
}

================
File: cards/ceos/Yvonne.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {Size} from '../../../common/cards/render/Size';

export class Yvonne extends CeoCard {
  constructor() {
    super({
      name: CardName.YVONNE,
      metadata: {
        cardNumber: 'L25',
        renderData: CardRenderer.builder((b) => {
          b.opgArrow().text('GAIN ALL YOUR COLONY BONUSES TWICE', Size.SMALL);
        }),
        description: 'Once per game, gain all your colony bonuses twice.',
      },
    });
  }


  public override canAct(player: IPlayer): boolean {
    if (!super.canAct(player)) {
      return false;
    }
    return player.game.gameOptions.coloniesExtension === true;
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    player.game.colonies.forEach((colony) => {
      colony.colonies.filter((owner) => owner === player.id).forEach((owner) => {
        player.defer(() => colony.giveColonyBonus(player.game.getPlayerById(owner)));
        player.defer(() => colony.giveColonyBonus(player.game.getPlayerById(owner)));
      });
    });
    return undefined;
  }
}

================
File: cards/ceos/Zan.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardRenderer} from '../render/CardRenderer';
import {CeoCard} from './CeoCard';
import {PartyName} from '../../../common/turmoil/PartyName';
import {Turmoil} from '../../turmoil/Turmoil';
import {Size} from '../../../common/cards/render/Size';
import {Resource} from '../../../common/Resource';

export class Zan extends CeoCard {
  constructor() {
    super({
      name: CardName.ZAN,
      metadata: {
        cardNumber: 'L26',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.redsInactive().asterix();
          b.br.br;
          b.opgArrow().text('ALL', Size.SMALL).delegates(1).colon().zanReds().megacredits(1);
        }),
        description: 'You are immune to Reds\' ruling policy. Once per game, place all of your available delegates in Reds. Gain 1 M€ for each delegate placed this way.',
      },
    });
  }

  public action(player: IPlayer): PlayerInput | undefined {
    this.isDisabled = true;
    const game = player.game;
    const turmoil = Turmoil.getTurmoil(game);
    const totalAvailableDelegates = turmoil.getAvailableDelegateCount(player);
    while (turmoil.getAvailableDelegateCount(player) > 0) {
      turmoil.sendDelegateToParty(player, PartyName.REDS, game);
    }
    // If we dont do this player will not get the bonus for POLITICAN Awards
    player.totalDelegatesPlaced += totalAvailableDelegates;
    player.stock.add(Resource.MEGACREDITS, totalAvailableDelegates, {log: true});
    return undefined;
  }
}

================
File: cards/chemical/AlchemicReactions.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';

export class AlchemicReactions extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ALCHEMIC_REACTIONS,
      tags: [Tag.SCIENCE],
      cost: 10,
      requirements: {tag: Tag.SCIENCE, count: 5},

      metadata: {
        cardNumber: 'x193',
        renderData: CardRenderer.builder((b) => {
          b.action('Convert ALL your energy resources into titanium.', (eb) => {
            eb.text('X').energy(1).asterix().startAction.text('X').titanium(1);
          }).br;
        }),
        description: 'Requires 5 science tags.',
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.energy > 0;
  }
  public action(player: IPlayer) {
    player.stock.add(Resource.TITANIUM, player.stock.energy);
    player.stock.energy = 0;
    return undefined;
  }
}

================
File: cards/chemical/base/1_SubcrustVaporTrapping.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class SubcrustVaporTrapping extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SUBCRUST_VAPOR_TRAPPING,
      cost: 12,
      requirements: {tag: Tag.SCIENCE, count: 2},
      behavior: {
        ocean: {},
      },
      victoryPoints: 1,

      metadata: {
        cardNumber: 'xB1',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1);
        }),
        description: 'Requires 2 science tags. Place an ocean tile.',
      },
    });
  }
}

================
File: cards/chemical/base/10_ArtificialAsteroid.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ArtificialAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ARTIFICIAL_ASTEROID,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 3,

      behavior: {
        global: {temperature: 1},
      },

      metadata: {
        cardNumber: 'xB10',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1).nbsp.minus().energy(2);
        }),
        description: 'Raise the temperature 1 step. Lose 2 energy resources.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.energy >= 2;
  }
  public override bespokePlay(player: IPlayer) {
    player.energy -= 2;
    return undefined;
  }
}

================
File: cards/chemical/base/100_ExplosivesTestSite.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class ExplosivesTestSite extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.EXPLOSIVES_TEST_SITE,
      cost: 17,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      victoryPoints: -1,

      behavior: {
        production: {energy: -1, megacredits: 2},
        global: {temperature: 2},
      },

      metadata: {
        cardNumber: 'xB100',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(2);
          });
          b.temperature(2);
        }),
        description: 'Decrease your energy production 1 step and increase your M€ production 2 steps. Raise the temperature 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/101_GrandStadium.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class GrandStadium extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GRAND_STADIUM,
      tags: [Tag.BUILDING],
      cost: 5,
      victoryPoints: 1,
      requirements: {cities: 3},

      behavior: {
        production: {energy: -1, megacredits: 3},
      },

      metadata: {
        cardNumber: 'xB101',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          }).nbsp;
        }),
        description: 'Decrease your energy production 1 step and increase your M€ production 4 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/102_PolarOutpost.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class PolarOutpost extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.POLAR_OUTPOST,
      cost: 12,
      tags: [Tag.BUILDING],
      requirements: {temperature: -16, max: true},
      victoryPoints: 2,

      behavior: {
        production: {megacredits: 1},
        stock: {heat: 2},
      },

      metadata: {
        cardNumber: 'xB102',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1)).nbsp.heat(2);
        }),
        description: 'Requires -16°C or colder. Increase your M€ production 1 step and gain 2 heat.',
      },
    });
  }
}

================
File: cards/chemical/base/103_RuralHousing.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class RuralHousing extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.RURAL_HOUSING,
      cost: 9,
      tags: [Tag.BUILDING],
      requirements: {oxygen: 12},
      victoryPoints: 1,

      behavior: {
        stock: {megacredits: {greeneries: {}, all: false}},
      },

      metadata: {
        cardNumber: 'xB103',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(1).slash().greenery({withO2: false});
        }),
        description: 'Requires 12% oxygen. Gain 1 M€ for each greenery tile you own.',
      },
    });
  }
}

================
File: cards/chemical/base/104_TunnelBoring.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class TunnelBoring extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TUNNEL_BORING,
      cost: 16,
      tags: [Tag.BUILDING],
      victoryPoints: 1,

      behavior: {
        production: {steel: 2},
      },

      metadata: {
        cardNumber: 'xB104',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(2));
        }),
        description: 'Increase your steel production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/105_LithiumMine.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class LithiumMine extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LITHIUM_MINE,
      cost: 20,
      tags: [Tag.POWER, Tag.BUILDING],

      behavior: {
        production: {steel: 1, energy: 1},
        global: {oxygen: 1},
      },

      metadata: {
        cardNumber: 'xB105',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(1).energy(1)).nbsp.oxygen(1);
        }),
        description: 'Increase your steel production 1 step and your energy production 1 step. Raise the oxygen 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/106_ChasmaExcavation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class ChasmaExcavation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CHASMA_EXCAVATION,
      cost: 12,
      tags: [Tag.BUILDING],
      victoryPoints: 1,
      requirements: {oceans: 3, max: true},

      behavior: {
        production: {steel: 1},
        stock: {steel: 2},
      },

      metadata: {
        cardNumber: 'xB106',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(1)).nbsp.steel(2);
        }),
        description: 'Requires 3 or less ocean tiles. Increase your steel production 1 step and gain 2 steel.',
      },
    });
  }
}

================
File: cards/chemical/base/107_DeepPolarExtraction.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class DeepPolarExtraction extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DEEP_POLAR_EXTRACTION,
      cost: 12,
      tags: [Tag.BUILDING],
      requirements: {temperature: -10},

      behavior: {
        production: {steel: 1, heat: 1},
        ocean: {},
      },

      metadata: {
        cardNumber: 'xB107',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(1).heat(1)).nbsp.oceans(1);
        }),
        description: 'Requires -10°C or warmer. Increase your steel production 1 step and your heat production 1 step. Place an ocean tile.',
      },
    });
  }
}

================
File: cards/chemical/base/108_CallistoOperations.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class CallistoOperations extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CALLISTO_OPERATIONS,
      cost: 22,
      tags: [Tag.JOVIAN, Tag.SPACE],

      behavior: {
        production: {titanium: 1},
        ocean: {},
      },

      metadata: {
        cardNumber: 'xB108',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).nbsp.oceans(1);
        }),
        description: 'Increase your titanium production 1 step and place an ocean tile.',
      },
    });
  }
}

================
File: cards/chemical/base/109_SaturnGasMine.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class SaturnGasMine extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SATURN_GAS_MINE,
      cost: 26,
      tags: [Tag.JOVIAN, Tag.POWER, Tag.SPACE],
      victoryPoints: 2,

      behavior: {
        production: {titanium: 1, energy: 1},
      },

      metadata: {
        cardNumber: 'xB109',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1).energy(1));
        }),
        description: 'Increase your titanium production 1 step and your energy production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/11_InstantiatedSolarFlare.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {OrOptions} from '../../../inputs/OrOptions';
import {PlayerInput} from '../../../PlayerInput';
import {CardName} from '../../../../common/cards/CardName';
import {SelectOption} from '../../../inputs/SelectOption';
import {CardResource} from '../../../../common/CardResource';
import {RemoveResourcesFromCard} from '../../../deferredActions/RemoveResourcesFromCard';
import {CardRenderer} from '../../render/CardRenderer';
import {all, digit} from '../../Options';
import {Tag} from '../../../../common/cards/Tag';

export class InstantiatedSolarFlare extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.INSTANTIATED_SOLAR_FLARE,
      tags: [Tag.SPACE],
      cost: 11,
      requirements: {tag: Tag.SCIENCE, count: 3},
      behavior: {
        global: {temperature: 2},
        removeAnyPlants: 4,
      },
      victoryPoints: -1,

      metadata: {
        cardNumber: 'xB11',
        renderData: CardRenderer.builder((b) => {
          b.temperature(2).nbsp;
          b.minus().plants(4, {all, digit}).nbsp;
          b.minus().resource(CardResource.ANIMAL, {all});
        }),
        description: 'Requires 3 science tags. Raise the temperature 2 steps. Remove up to 4 plants from any player and remove up to 1 animal from any player.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    if (player.game.isSoloMode()) {
      return undefined;
    }
    const orOptionsAnimals = new RemoveResourcesFromCard(player, CardResource.ANIMAL, 1).execute() as OrOptions;

    const orOptions = new OrOptions();
    if (orOptionsAnimals !== undefined) {
      orOptions.options.push(orOptionsAnimals);
    } else {
      player.game.log('There was nobody to remove animals from.');
      return undefined;
    }
    orOptions.options.push(new SelectOption('Skip removal', 'Confirm').andThen(() => {
      return undefined;
    }));

    return orOptionsAnimals;
  }
}

================
File: cards/chemical/base/110_LaserDrillMining.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class LaserDrillMining extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LASER_DRILL_MINING,
      cost: 12,
      tags: [Tag.BUILDING],

      behavior: {
        production: {energy: -1, titanium: 1, heat: 2},
      },

      metadata: {
        cardNumber: 'xB110',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().titanium(1).heat(2);
          });
        }),
        description: 'Decrease your energy production 1 step. Increase your titanium production 1 step and your heat production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/111_HydrualicMining.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class HydrualicMining extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HYDRUALIC_MINING,
      cost: 8,
      tags: [Tag.BUILDING],
      requirements: {oceans: 3},

      behavior: {
        production: {titanium: 1},
        stock: {steel: 2},
      },

      metadata: {
        cardNumber: 'xB111',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).nbsp.steel(2);
        }),
        description: 'Requires 3 ocean tiles. Increase your titanium production 1 step and gain 2 steel.',
      },
    });
  }
}

================
File: cards/chemical/base/112_EnzymaticTreatment.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class EnzymaticTreatment extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ENZYMATIC_TREATMENT,
      cost: 7,

      metadata: {
        cardNumber: 'xB112',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.plants(1).nbsp.or().br;
            pb.tag(Tag.PLANT, {amount: 2, digit}).colon().nbsp.plants(2, {digit});
          });
        }),
        description: 'Increase your plant production 1 step, or 2 steps if you have 2 plant tags.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    if (player.tags.count(Tag.PLANT) < 2) {
      player.production.add(Resource.PLANTS, 1, {log: true});
    } else {
      player.production.add(Resource.PLANTS, 2, {log: true});
    }
    return undefined;
  }
}

================
File: cards/chemical/base/113_RegolithAeration.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class RegolithAeration extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.REGOLITH_AERATION,
      cost: 13,
      tags: [Tag.BUILDING],

      behavior: {
        production: {energy: -2, plants: 2},
        tr: 1,
      },

      metadata: {
        cardNumber: 'xB113',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().plants(2);
          });
          b.tr(1);
        }),
        description: 'Decrease your energy production 2 steps, increase your plant production 2 steps, and raise your TR 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/114_Mixotrophs.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class Mixotrophs extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MIXOTROPHS,
      cost: 6,
      tags: [Tag.MICROBE],
      requirements: {tag: Tag.MICROBE, count: 1},

      behavior: {
        production: {plants: 1},
      },

      metadata: {
        cardNumber: 'x114',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1));
        }),
        description: 'Requires 1 microbe tag. Increase your plant production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/115_BotanicalLab.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class BotanicalLab extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BOTANICAL_LAB,
      cost: 8,
      tags: [Tag.PLANT, Tag.BUILDING],
      requirements: {tag: Tag.SCIENCE, count: 2},
      victoryPoints: 1,

      behavior: {
        production: {plants: 1},
      },

      metadata: {
        cardNumber: 'xB115',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1));
        }),
        description: 'Requires 2 science tags. Increase your plant production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/116_IndustrialComposting.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

export class IndustrialComposting extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INDUSTRIAL_COMPOSTING,
      cost: 4,
      tags: [Tag.MICROBE, Tag.BUILDING],
      requirements: [{tag: Tag.PLANT}, {tag: Tag.ANIMAL}, {tag: Tag.MICROBE}],

      behavior: {
        production: {plants: 1},
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 2},
      },

      metadata: {
        cardNumber: 'xB116',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).resource(CardResource.MICROBE, 2).asterix();
        }),
        description: 'Requires a plant tag, an animal tag, and a microbe tag. Increase your plant production 1 step and add 2 microbes to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/base/117_ExtremeNitrophiles.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class ExtremeNitrophiles extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.EXTREME_NITROPHILES,
      cost: 13,
      tags: [Tag.PLANT],
      requirements: {temperature: -24},

      behavior: {
        production: {plants: 1},
        stock: {plants: 3},
      },

      metadata: {
        cardNumber: 'xB117',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).plants(3);
        }),
        description: 'Requires -24°C or warmer. Increase your plant production 1 step and gain 3 plants.',
      },
    });
  }
}

================
File: cards/chemical/base/118_VascularTundraPlants.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class VascularTundraPlants extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.VASCULAR_TUNDRA_PLANTS,
      cost: 10,
      tags: [Tag.PLANT],
      requirements: {temperature: -18},

      behavior: {
        production: {plants: 1},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'xB118',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).plants(2);
        }),
        description: 'Requires -18°C or warmer. Increase your plant production 1 step and gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/base/119_Bamboo.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class Bamboo extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BAMBOO,
      cost: 14,
      tags: [Tag.PLANT],
      requirements: {temperature: -16},

      behavior: {
        production: {plants: 2},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'xB119',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(2)).plants(2);
        }),
        description: 'Requires -16°C or warmer. Increase your plant production 2 steps and gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/base/12_AcceleratedImpactor.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all, digit} from '../../Options';
import {Tag} from '../../../../common/cards/Tag';

export class AcceleratedImpactor extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ACCELERATED_IMPACTOR,
      tags: [Tag.SPACE],
      cost: 22,
      behavior: {
        global: {temperature: 2},
        stock: {
          titanium: 2
        },
        removeAnyPlants: 6,
      },

      metadata: {
        cardNumber: 'xB12',
        renderData: CardRenderer.builder((b) => {
          b.temperature(2).nbsp.titanium(2).nbsp;
          b.minus().plants(6, {all, digit});
        }),
        description: 'Raise the temperature 2 steps and gain 2 titanium. Remove up to 6 plants from any player.',
      },
    });
  }
}

================
File: cards/chemical/base/120_ErosionReducingGreenery.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class ErosionReducingGreenery extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.EROSION_REDUCING_GREENERY,
      cost: 12,
      tags: [Tag.PLANT],
      requirements: {temperature: -16},

      behavior: {
        production: {plants: 1},
        stock: {plants: 1},
        tr: 1,
      },

      metadata: {
        cardNumber: 'xB120',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).nbsp.plants(1).nbsp.tr(1);
        }),
        description: 'Requires -16°C or warmer. Increase your plant production 1 step, gain 1 plant, and raise your TR 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/121_ParasiticPlants.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {all} from '../../Options';

export class ParasiticPlants extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PARASITIC_PLANTS,
      cost: 4,
      tags: [Tag.PLANT],
      requirements: {temperature: -14},

      behavior: {
        production: {plants: 1},
        removeAnyPlants: 2,
      },

      metadata: {
        cardNumber: 'x159',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).nbsp.minus().plants(2, {all});
        }),
        description: 'Increase your plant production 1 step and remove up to 2 plants from any player.',
      },
    });
  }
}

================
File: cards/chemical/base/122_Wildberries.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

export class Wildberries extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.WILDBERRIES,
      cost: 9,
      tags: [Tag.PLANT],
      requirements: {temperature: -12},

      behavior: {
        production: {plants: 1},
        stock: {plants: 2},
        addResourcesToAnyCard: {type: CardResource.ANIMAL, count: 1},
      },

      metadata: {
        cardNumber: 'xB122',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).plants(2).resource(CardResource.ANIMAL).asterix();
        }),
        description: 'Requires -12°C or warmer. Increase your plant production 1 step, gain 2 plants, and add an animal to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/base/123_AnaerobicEnergyCropping.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class AnaerobicEnergyCropping extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ANAEROBIC_ENERGY_CROPPING,
      cost: 12,
      tags: [Tag.POWER, Tag.PLANT],
      requirements: {temperature: -10},

      behavior: {
        production: {plants: 1, energy: 2},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'xB123',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1).energy(2)).plants(2);
        }),
        description: 'Requires -10°C or warmer. Increase your plant production 1 step and your energy production 2 steps. Gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/base/124_AdaptedHardwood.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class AdaptedHardwood extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ADAPTED_HARDWOOD,
      cost: 20,
      tags: [Tag.PLANT],
      requirements: {temperature: -10},

      behavior: {
        production: {plants: 3, megacredits: 3},
      },

      metadata: {
        cardNumber: 'xB124',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(3).br.plants(3));
        }),
        description: 'Requires -10°C or higher. Increase your M€ production 3 steps and your plant production 3 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/125_AquaticBiodomes.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

export class AquaticBiodomes extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.AQUATIC_BIODOMES,
      cost: 23,
      tags: [Tag.ANIMAL, Tag.PLANT, Tag.BUILDING],
      requirements: {temperature: -10},

      behavior: {
        production: {plants: 2},
        ocean: {},
        addResourcesToAnyCard: {type: CardResource.ANIMAL, count: 2},
      },

      metadata: {
        cardNumber: 'xB125',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(2)).oceans(1).resource(CardResource.ANIMAL, 2).asterix();
        }),
        description: 'Requires -10°C or warmer. Increase your plant production 2 steps, place an ocean tile, and add 2 animals to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/base/126_Conifers.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class Conifers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CONIFERS,
      cost: 14,
      tags: [Tag.PLANT],
      requirements: {temperature: -8},
      victoryPoints: 1,

      behavior: {
        production: {plants: 2},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'xB126',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(2)).plants(2);
        }),
        description: 'Requires -8°C or warmer. Increase your plant production 2 steps and gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/base/127_WildBarley.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class WildBarley extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.WILD_BARLEY,
      cost: 7,
      tags: [Tag.PLANT],
      requirements: {temperature: -8},

      behavior: {
        production: {plants: 1, megacredits: 1},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'xB127',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).plants(1)).plants(2);
        }),
        description: 'Requires -8°C or warmer. Increase your M€ production 1 step and your plant production 1 step. Gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/base/128_WetlandsChemical.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';
import {TileType} from '../../../../common/TileType';

export class WetlandsChemical extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.WETLANDS_CHEMICAL,
      cost: 14,
      tags: [Tag.PLANT],
      requirements: {temperature: -6},
      victoryPoints: 1,

      behavior: {
        stock: {plants: 3},
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 2},
        tile: {
          type: TileType.WETLANDS_CHEMICAL,
          on: 'land',
          title: 'Select space for special tile',
        },
      },

      metadata: {
        cardNumber: 'xB128',
        renderData: CardRenderer.builder((b) => {
          b.tile(TileType.WETLANDS_CHEMICAL, false).nbsp.plants(3).br.resource(CardResource.MICROBE, 2).asterix();
        }),
        description: 'Requires -6°C or warmer. Place this tile, gain 3 plants, and add 2 microbes to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/base/129_Cacti.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class Cacti extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CACTI,
      cost: 2,
      tags: [Tag.PLANT],
      requirements: {temperature: 2},

      behavior: {
        production: {plants: 1},
        stock: {plants: 1},
      },

      metadata: {
        cardNumber: 'xB129',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).plants(1);
        }),
        description: 'Requires +2°C or warmer. Increase your plant production 1 step and gain 1 plant.',
      },
    });
  }
}

================
File: cards/chemical/base/13_IronRichAsteroid.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {Tag} from '../../../../common/cards/Tag';

export class IronRichAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.IRON_RICH_ASTEROID,
      tags: [Tag.SPACE],
      cost: 13,
      behavior: {
        global: {temperature: 1},
        stock: {steel: 3},
        removeAnyPlants: 2,
      },

      metadata: {
        cardNumber: 'xB13',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1).nbsp;
          b.steel(3).br;
          b.minus().plants(2, {all});
        }),
        description: 'Raise the temperature 1 step and gain 3 steel. Remove up to 2 plants from any player.',
      },
    });
  }
}

================
File: cards/chemical/base/130_AdaptedFruitFarming.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class AdaptedFruitFarming extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ADAPTED_FRUIT_FARMING,
      cost: 17,
      tags: [Tag.PLANT],
      requirements: {temperature: 4},
      victoryPoints: 2,

      behavior: {
        production: {plants: 3, megacredits: 2},
        stock: {plants: 1},
      },

      metadata: {
        cardNumber: 'xB130',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2).br.plants(3)).plants(1);
        }),
        description: 'Requires +4°C or higher. Increase your M€ production 2 steps and your plant production 3 steps. Gain 1 plant.',
      },
    });
  }
}

================
File: cards/chemical/base/131_RiceFields.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class RiceFields extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.RICE_FIELDS,
      cost: 18,
      tags: [Tag.PLANT],
      requirements: {temperature: 4},

      behavior: {
        production: {plants: 1, megacredits: 2},
        greenery: {},
      },

      metadata: {
        cardNumber: 'xB131',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2).plants(1)).nbsp.greenery();
        }),
        description: 'Requires +4°C or higher. increase your M€ production 2 steps, your plant production 1 step, and place a greenery tile.',
      },
    });
  }
}

================
File: cards/chemical/base/132_CoralReef.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

export class CoralReef extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CORAL_REEF,
      cost: 24,
      tags: [Tag.PLANT],
      requirements: {temperature: 6},
      victoryPoints: 2,

      behavior: {
        ocean: {},
        stock: {plants: 3},
        addResourcesToAnyCard: {type: CardResource.ANIMAL, count: 1},
      },

      metadata: {
        cardNumber: 'xB132',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).plants(3).resource(CardResource.ANIMAL).asterix();
        }),
        description: 'Requires +6°C or warmer. Place an ocean tile, gain 3 plants, and add an animal to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/base/133_CyanobacteriaChemical.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

export class CyanobacteriaChemical extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CYANOBACTERIA_CHEMICAL,
      cost: 7,
      tags: [Tag.MICROBE],
      requirements: {oceans: 2},

      behavior: {
        production: {plants: 1},
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 1},
      },

      metadata: {
        cardNumber: 'xB133',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).resource(CardResource.MICROBE).asterix();
        }),
        description: 'Requires 2 ocean tiles. Raise your plant production 1 step and add 1 microbe to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/base/134_HydroponicsFacility.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class HydroponicsFacility extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HYDROPONICS_FACILITY,
      cost: 9,
      tags: [Tag.PLANT, Tag.BUILDING],
      requirements: {oceans: 3},

      behavior: {
        production: {plants: 1, megacredits: 1},
      },

      metadata: {
        cardNumber: 'xB134',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).plants(1));
        }),
        description: 'Requires 3 ocean tiles. Increase your M€ production 1 step and your plant production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/135_RedAlgae.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class RedAlgae extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.RED_ALGAE,
      cost: 10,
      tags: [Tag.PLANT],
      requirements: {oceans: 4},

      behavior: {
        production: {plants: 2},
      },

      metadata: {
        cardNumber: 'xB135',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(2));
        }),
        description: 'Requires 4 ocean tiles. Increase your plant production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/136_Irrigation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {SelectSpace} from '../../../inputs/SelectSpace';
import {IPlayer} from '../../../IPlayer';
import {CanAffordOptions} from '../../../IPlayer';
import {Board} from '../../../boards/Board';
import {Space} from '../../../boards/Space';

export class Irrigation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.IRRIGATION,
      cost: 18,
      tags: [Tag.PLANT, Tag.BUILDING],
      requirements: {oceans: 6},

      behavior: {
        production: {plants: 1},
      },

      metadata: {
        cardNumber: 'xB136',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).nbsp.greenery().asterix();
        }),
        description: 'Requires 6 ocean tiles. Increase your plant production 1 step. Place a greenery tile ADJACENT TO AN OCEAN',
      },
    });
  }
  private getAvailableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): Array<Space> {
    return player.game.board.getAvailableSpacesOnLand(player, canAffordOptions)
      .filter((space) => player.game.board.getAdjacentSpaces(space).filter(Board.isOceanSpace).length > 0);
  }
  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions): boolean {
    return this.getAvailableSpaces(player, canAffordOptions).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select space next to ocean for greenery tile', this.getAvailableSpaces(player))
      .andThen((requestedSpace: Space) => {
        player.game.addGreenery(player, requestedSpace);
        return undefined;
      });
  }
}

================
File: cards/chemical/base/137_Monsoons.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all, digit} from '../../Options';
import {Resource} from '../../../../common/Resource';

export class Monsoons extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MONSOONS,
      cost: 12,
      requirements: {oceans: 8},
      victoryPoints: 1,

      behavior: {
        decreaseAnyProduction: {type: Resource.HEAT, count: 2},
        production: {plants: 4},
      },

      metadata: {
        cardNumber: 'xB137',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().heat(2, {all}).br;
            pb.plus().plants(4, {digit});
          });
        }),
        description: 'Requires 8 ocean tiles. Decrease any player\'s heat production 2 steps and increase your plant production 4 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/138_HeavyRespirators.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class HeavyRespirators extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HEAVY_RESPIRATORS,
      cost: 10,
      tags: [Tag.PLANT],
      requirements: {oxygen: 7},

      behavior: {
        greenery: {},
        global: {oxygen: -1},
      },

      metadata: {
        cardNumber: 'xB138',
        renderData: CardRenderer.builder((b) => {
          b.greenery({withO2: false}).asterix();
        }),
        description: 'Requires 7% oxygen. Place a greenery tile BUT DO NOT RAISE THE OXYGEN.',
      },
    });
  }
}

================
File: cards/chemical/base/139_BeeFarming.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class BeeFarming extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BEE_FARMING,
      cost: 15,
      tags: [Tag.MICROBE],
      requirements: {oxygen: 9},
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 1, plants: {tag: Tag.PLANT}},
      },

      metadata: {
        cardNumber: 'xB139',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).br;
            pb.plants(1).slash().tag(Tag.PLANT);
          });
        }),
        description: 'Requires 9% oxygen. Increase your M€ production 1 step and your plant production 1 step for each plant tag you have.',
      },
    });
  }
}

================
File: cards/chemical/base/14_Overgrowth.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CanAffordOptions, IPlayer} from '../../../IPlayer';
import {TileType} from '../../../../common/TileType';
import {SelectSpace} from '../../../inputs/SelectSpace';
import {Space} from '../../../boards/Space';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Board} from '../../../boards/Board';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectPlayer} from '../../../inputs/SelectPlayer';
import {SelectOption} from '../../../inputs/SelectOption';
import {all} from '../../Options';
import {Resource} from '../../../../common/Resource';

export class Overgrowth extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.OVERGROWTH,
      tags: [Tag.PLANT],
      cost: 7,
      requirements: {greeneries: 1},
      victoryPoints: -1,
      behavior: {
        global: {oxygen: 1},
      },
      metadata: {
        description: 'Requires that YOU have a greenery tile. Raise the oxygen 1 step. Place this tile adjacent to ANY greenery. IF THERE ARE TILES ADJACENT TO THIS TILE, YOU MAY REMOVE 4 M€ FROM THE OWNER OF ONE OF THOSE TILES.',
        cardNumber: 'xB14',
        renderData: CardRenderer.builder((b) => {
          b.tile(TileType.OVERGROWTH, false).asterix().nbsp.minus().megacredits(4, {all}).asterix();
          b.oxygen(1).br;
        }),
      },
    });
  }


  private getAvailableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): Array<Space> {
    return player.game.board.getAvailableSpacesOnLand(player, canAffordOptions)
      .filter((space) => player.game.board.getAdjacentSpaces(space).filter(Board.isGreenerySpace).length > 0);
  }
  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions): boolean {
    return this.getAvailableSpaces(player, canAffordOptions).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select space next to greenery for special tile', this.getAvailableSpaces(player))
      .andThen((requestedSpace: Space) => {
        player.game.addTile(player, requestedSpace, {
          tileType: TileType.OVERGROWTH,
        });
        requestedSpace.adjacency = this.adjacencyBonus;

        const adjacentPlayers: Set<IPlayer> = new Set();
        player.game.board.getAdjacentSpaces(requestedSpace).forEach((space) => {
          if (space.player && space.player !== player && space.tile) {
            adjacentPlayers.add(space.player);
          }
        });

        if (adjacentPlayers.size > 0) {
          return new OrOptions(
            new SelectPlayer(Array.from(adjacentPlayers), 'Select adjacent player to remove 4 M€ from', 'Remove credits')
              .andThen((selectedPlayer: IPlayer) => {
                selectedPlayer.stock.deduct(Resource.MEGACREDITS, 4, {log: true, from: player});
                return undefined;
              }),
            new SelectOption('Don\'t remove M€ from adjacent player', 'Confirm')
              .andThen(() => {
                return undefined;
              }),
          );
        }
        return undefined;
      },
      );
  }
}

================
File: cards/chemical/base/140_SyntheticGrowthHormones.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class SyntheticGrowthHormones extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SYNTHETIC_GROWTH_HORMONES,
      tags: [Tag.SCIENCE],
      cost: 10,

      behavior: {
        stock: {plants: {tag: Tag.PLANT, each: 2}},
      },

      metadata: {
        cardNumber: 'xB140',
        renderData: CardRenderer.builder((b) => {
          b.plants(2).slash().tag(Tag.PLANT);
        }),
        description: 'Gain 2 plants for each plant tag you have.',
      },
    });
  }
}

================
File: cards/chemical/base/141_SpaceBasedSolarPower.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class SpaceBasedSolarPower extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SPACE_BASED_SOLAR_POWER,
      cost: 18,
      tags: [Tag.POWER, Tag.SPACE],
      victoryPoints: 1,

      behavior: {
        production: {energy: 2},
      },

      metadata: {
        cardNumber: 'xB141',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2));
        }),
        description: 'Increase your energy production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/142_EfficientBatteries.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class EfficientBatteries extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.EFFICIENT_BATTERIES,
      tags: [Tag.POWER],
      cost: 5,

      behavior: {
        production: {energy: {tag: Tag.POWER, per: 2}},
      },

      metadata: {
        cardNumber: 'xB142',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).slash().tag(Tag.POWER));
        }),
        description: 'Increase your energy production 1 step for every 2 power tags you have, including this.',
      },
    });
  }
}

================
File: cards/chemical/base/143_LargePowerPlant.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class LargePowerPlant extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LARGE_POWER_PLANT,
      cost: 14,
      tags: [Tag.POWER, Tag.BUILDING],

      behavior: {
        production: {energy: 2},
        stock: {energy: 2},
      },

      metadata: {
        cardNumber: 'xB143',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2)).energy(2);
        }),
        description: 'Increase your energy production 2 steps and gain 2 energy.',
      },
    });
  }
}

================
File: cards/chemical/base/144_HydrocarbonSynthesis.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class HydrocarbonSynthesis extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HYDROCARBON_SYNTHESIS,
      cost: 18,
      tags: [Tag.POWER, Tag.BUILDING],
      victoryPoints: 1,

      behavior: {
        production: {energy: 2},
        stock: {energy: 2},
      },

      metadata: {
        cardNumber: 'xB144',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2)).energy(2);
        }),
        description: 'Increase your energy production 2 steps and gain 2 energy.',
      },
    });
  }
}

================
File: cards/chemical/base/145_AtmosphericProcessing.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class AtmosphericProcessing extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ATMOSPHERIC_PROCESSING,
      cost: 9,
      tags: [Tag.POWER, Tag.BUILDING],

      behavior: {
        production: {megacredits: 1, energy: 1},
      },

      metadata: {
        cardNumber: 'xB145',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).energy(1));
        }),
        description: 'Increase your M€ production 1 step and your energy production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/146_UraniumDeposit.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class UraniumDeposit extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.URANIUM_DEPOSIT,
      cost: 8,
      tags: [Tag.POWER, Tag.BUILDING],

      behavior: {
        production: {energy: 1},
        stock: {steel: 2},
      },

      metadata: {
        cardNumber: 'xB146',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1)).steel(2);
        }),
        description: 'Increase your energy production 1 step and gain 2 steel.',
      },
    });
  }
}

================
File: cards/chemical/base/147_AlgaeBioreactors.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class AlgaeBioreactorsChemical extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ALGAE_BIOREACTORS_CHEMICAL,
      cost: 15,
      tags: [Tag.POWER, Tag.MICROBE],

      behavior: {
        production: {energy: 2},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'xB147',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2)).plants(2);
        }),
        description: 'Increase your energy production 2 steps and gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/base/148_MassiveSolarFarm.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {TileType} from '../../../../common/TileType';

export class MassiveSolarFarm extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MASSIVE_SOLAR_FARM,
      cost: 28,
      tags: [Tag.POWER, Tag.BUILDING],
      victoryPoints: 1,
      behavior: {
        production: {energy: 3},
        tile: {
          type: TileType.MASSIVE_SOLAR_FARM,
          on: 'land',
          title: 'Select space for special tile',
        },
      },
      metadata: {
        cardNumber: 'xB148',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(3)).nbsp.tile(TileType.MASSIVE_SOLAR_FARM, false);
        }),
        description: 'Increase your energy production 3 steps and place this tile.',
      },
    });
  }
}

================
File: cards/chemical/base/149_AdvancedHydropower.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {PlaceOceanTile} from '../../../deferredActions/PlaceOceanTile';
import {Resource} from '../../../../common/Resource';

export class AdvancedHydropower extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ADVANCED_HYDROPOWER,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 18,

      metadata: {
        cardNumber: 'xB149',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).production((pb) => pb.energy(1).slash().oceans(2, {size: Size.SMALL}));
        }),
        description: 'Place an ocean tile, then increase your energy production 1 step for every 2 ocean tiles in play.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    player.game.defer(new PlaceOceanTile(player).andThen(() => {
      const energyProduction = Math.floor(player.game.board.getOceanSpaces().length / 2);
      player.production.add(Resource.ENERGY, energyProduction, {log: true});
    }));
    return undefined;
  }
}

================
File: cards/chemical/base/15_CondensedGasConvoy.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class CondensedGasConvoy extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.CONDENSED_GAS_CONVOY,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 17,

      behavior: {
        production: {heat: 2},
        global: {oxygen: 1},
      },

      metadata: {
        cardNumber: 'xB15',
        renderData: CardRenderer.builder((b) => {
          b.oxygen(1).production((pb) => pb.heat(2));
        }),
        description: 'Raise the oxygen 1 step and increase your heat production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/150_EnrichmentPlant.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class EnrichmentPlant extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ENRICHMENT_PLANT,
      cost: 11,
      tags: [Tag.SCIENCE, Tag.POWER, Tag.BUILDING],

      behavior: {
        production: {megacredits: -1, energy: 2},
      },

      metadata: {
        cardNumber: 'xB150',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().megacredits(1).br;
            pb.plus().energy(2);
          });
        }),
        description: 'Decrease your M€ production 1 step and increase your energy production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/151_FuelCellProduction.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class FuelCellProduction extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FUEL_CELL_PRODUCTION,
      cost: 4,
      tags: [Tag.POWER, Tag.BUILDING],

      behavior: {
        production: {megacredits: -2, energy: 2},
      },

      metadata: {
        cardNumber: 'xB151',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().megacredits(2).br;
            pb.plus().energy(2);
          });
        }),
        description: 'Decrease your M€ production 2 steps and increase your energy production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/152_EnergyMohole.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class EnergyMohole extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ENERGY_MOHOLE,
      cost: 14,
      tags: [Tag.POWER, Tag.BUILDING],

      behavior: {
        production: {energy: 1, heat: 2},
      },

      metadata: {
        cardNumber: 'xB152',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.energy(1).br;
            pb.heat(2);
          });
        }),
        description: 'Increase your energy production 1 step and your heat production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/153_HighPowerBetavoltaics.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class HighPowerBetavoltaics extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HIGH_POWER_BETAVOLTAICS,
      cost: 5,
      tags: [Tag.POWER],
      requirements: {tag: Tag.SCIENCE, count: 2},
      victoryPoints: 1,

      behavior: {
        production: {energy: 1},
      },

      metadata: {
        cardNumber: 'xB153',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1));
        }),
        description: 'Requires 2 sciecne tags. Increase your energy production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/154_CentralPowerPlant.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class CentralPowerPlant extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CENTRAL_POWER_PLANT,
      cost: 9,
      tags: [Tag.POWER, Tag.BUILDING],
      requirements: {tag: Tag.POWER, count: 2},

      behavior: {
        production: {energy: 2},
        stock: {energy: 3},
      },

      metadata: {
        cardNumber: 'xB154',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2)).energy(3);
        }),
        description: 'Requires 2 power tags. Increase your energy production 2 steps and gain 3 energy.',
      },
    });
  }
}

================
File: cards/chemical/base/155_IsotopeEnrichingBacteria.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class IsotopeEnrichingBacteria extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ISOTOPE_ENRICHING_BACTERIA,
      cost: 7,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      requirements: {tag: Tag.MICROBE, count: 2},

      behavior: {
        production: {energy: 1},
        stock: {energy: 3},
      },

      metadata: {
        cardNumber: 'xB155',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1)).energy(3);
        }),
        description: 'Requires 2 microbe tags. Increase your energy production 1 step and gain 3 energy.',
      },
    });
  }
}

================
File: cards/chemical/base/156_AnaerobicBacteria.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {digit} from '../../Options';

export class AnaerobicBacteria extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ANAEROBIC_BACTERIA,
      tags: [Tag.MICROBE],
      cost: 12,
      requirements: {oxygen: 4, max: true},

      behavior: {
        or: {
          autoSelect: true,
          behaviors: [
            {
              production: {energy: 2},
              title: 'Increase your energy production 2 steps',
            },
            {
              production: {heat: 3},
              title: 'Increase your heat production 3 steps',
            },
          ],
        },
      },

      metadata: {
        description: 'Oxygen must be 4% or lower. Increase your energy production 2 steps or your heat production 3 steps.',
        cardNumber: 'xB156',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.energy(2).nbsp.or(Size.SMALL).nbsp.heat(3, {digit}))),
      },
    });
  }
}

================
File: cards/chemical/base/157_SolidStateWildEnergy.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class SolidStateWildEnergy extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SOLID_STATE_WIND_ENERGY,
      cost: 7,
      tags: [Tag.POWER, Tag.BUILDING],
      requirements: {oxygen: 5},
      victoryPoints: 1,

      behavior: {
        production: {energy: 1},
      },

      metadata: {
        cardNumber: 'xB157',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1));
        }),
        description: 'Requires 5% oxygen. Increase your energy production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/158_AtmosphericPressureEngine.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class AtmosphericPressureEngine extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ATMOSPHERIC_PRESSURE_ENGINE,
      cost: 9,
      tags: [Tag.POWER, Tag.BUILDING],
      requirements: {oxygen: 9},
      victoryPoints: 1,

      behavior: {
        production: {energy: 2},
      },

      metadata: {
        cardNumber: 'xB158',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2));
        }),
        description: 'Requires 9% oxygen. Increase your energy production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/159_LaserCannon.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {all} from '../../Options';

export class LaserCannon extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LASER_CANNON,
      cost: 13,
      tags: [Tag.SPACE],

      behavior: {
        production: {heat: 3},
        removeAnyPlants: 2,
      },

      metadata: {
        cardNumber: 'xB159',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(3)).br.minus().plants(2, {all});
        }),
        description: 'Increase your heat production 3 steps and remove up to 2 plants from any player.',
      },
    });
  }
}

================
File: cards/chemical/base/16_TemporarySmeltingPlant.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {Size} from '../../../../common/cards/render/Size';

export class TemporarySmeltingPlant extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.TEMPORARY_SMELTING_PLANT,
      tags: [Tag.BUILDING],
      cost: 6,

      behavior: {
        stock: {steel: 2},
        global: {oxygen: 1},
      },

      metadata: {
        cardNumber: 'xB16',
        renderData: CardRenderer.builder((b) => {
          b.minus().energy(3, {digit}).nbsp.or(Size.SMALL).nbsp.minus().heat(5, {digit}).br;
          b.oxygen(1).steel(2);
        }),
        description: 'Lose 3 energy or 5 heat. Raise the oxygen 1 step and gain 2 steel.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.energy >= 3 || player.heat >= 5;
  }
  public override bespokePlay(player: IPlayer) {
    if (player.energy < 3) {
      player.heat -= 5;
      return undefined;
    }
    if (player.heat < 5) {
      player.energy -= 3;
      return undefined;
    }
    const orOptions = new OrOptions();
    orOptions.options.push(new SelectOption('Lose 3 energy', 'Confirm').andThen( () => {
      player.energy -= 3;
      return undefined;
    }));
    orOptions.options.push(new SelectOption('Lose 5 heat', 'Confirm').andThen( () => {
      player.heat -= 5;
      return undefined;
    }));
    return orOptions;
  }
}

================
File: cards/chemical/base/160_PerfluorocarbonProduction.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {digit} from '../../Options';

export class PerfluorocarbonProduction extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PERFLUOROCARBON_PRODUCTION,
      cost: 12,
      tags: [Tag.BUILDING],
      victoryPoints: -1,

      behavior: {
        production: {energy: -1, heat: 5},
      },

      metadata: {
        cardNumber: 'xB160',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().heat(5, {digit});
          });
        }),
        description: 'Decrease your energy production 1 step and increase your heat production 5 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/161_GHGFactoryDistrict.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {TileType} from '../../../../common/TileType';
import {digit} from '../../Options';

export class GHGFactoryDistrict extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GHG_FACTORY_DISTRICT,
      cost: 24,
      tags: [Tag.BUILDING],
      behavior: {
        production: {energy: -2, heat: 7},
        tile: {
          type: TileType.GHG_FACTORY_DISTRICT,
          on: 'land',
          title: 'Select space for special tile',
        },
      },
      metadata: {
        cardNumber: 'xB161',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().heat(7, {digit});
          });
          b.nbsp.tile(TileType.GHG_FACTORY_DISTRICT, false);
        }),
        description: 'Decrease your energy production 2 steps, increase your heat production 7 steps, and place this tile.',
      },
    });
  }
}

================
File: cards/chemical/base/162_NaturalGasExtraction.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {digit} from '../../Options';

export class NaturalGasExtraction extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.NATURAL_GAS_EXTRACTION,
      cost: 13,
      tags: [Tag.BUILDING],
      requirements: {temperature: -20},

      behavior: {
        production: {heat: 4},
      },

      metadata: {
        cardNumber: 'xB162',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(4, {digit}));
        }),
        description: 'Requires -20°C or warmer. Increase your heat production 4 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/163_HydrothermalVents.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {CardResource} from '../../../../common/CardResource';

export class HydrothermalVents extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HYDROTHERMAL_VENTS,
      cost: 10,
      requirements: {oceans: 3},

      behavior: {
        production: {heat: 3},
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 2},
      },

      metadata: {
        cardNumber: 'xB163',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(3)).resource(CardResource.MICROBE, 2).asterix();
        }),
        description: 'Requires 3 ocean tiles. Increase your heat production 3 steps and add 2 microbes to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/base/164_OzoneFactories.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class OzoneFactories extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.OZONE_FACTORIES,
      cost: 16,
      tags: [Tag.BUILDING],
      requirements: {oxygen: 6},

      behavior: {
        production: {heat: 1},
        tr: 2,
      },

      metadata: {
        cardNumber: 'xB164',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(1)).tr(2);
        }),
        description: 'Requires 6% oxygen. Increase your heat production 1 step and raise your TR 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/165_ProbioticTreatment.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {CardResource} from '../../../../common/CardResource';

export class ProbioticTreatment extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PROBIOTIC_TREATMENT,
      cost: 3,

      behavior: {
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 3},
      },

      metadata: {
        cardNumber: 'xB165',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.MICROBE, 3).asterix();
        }),
        description: 'Add 3 microbes to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/base/166_MirandaLabs.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {CardResource} from '../../../../common/CardResource';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';
import {IPlayer} from '../../../IPlayer';
import {ICard} from '../../ICard';
import {SelectCard} from '../../../inputs/SelectCard';

export class MirandaLabs extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MIRANDA_LABS,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 15,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'xB166',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.ANIMAL, 2).asterix().nbsp.or(Size.SMALL).nbsp.resource(CardResource.ASTEROID, 2).asterix();
        }),
        description: 'Add 2 animals or 2 asteroids to ANOTHER card.',
      },
    });
  }
  public getResCards(player: IPlayer): ICard[] {
    let resourceCards = player.getResourceCards(CardResource.ANIMAL);
    resourceCards = resourceCards.concat(player.getResourceCards(CardResource.ASTEROID));
    return resourceCards;
  }

  public override bespokePlay(player: IPlayer) {
    const cards = this.getResCards(player);

    if (cards.length > 1) {
      return new SelectCard(
        'Select card to add 2 resources',
        'Add resources',
        cards)
        .andThen(([card]) => {
          player.addResourceTo(card, {qty: 2, log: true});
          return undefined;
        });
    }

    if (cards.length === 1) {
      player.addResourceTo(cards[0], {qty: 2, log: true});
    }
    return undefined;
  }
}

================
File: cards/chemical/base/167_MarsLifeScienceInstitute.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class MarsLifeScienceInstitute extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MARS_LIFE_SCIENCE_INSTITUTE,
      cost: 13,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      requirements: [{tag: Tag.PLANT}, {tag: Tag.ANIMAL}, {tag: Tag.MICROBE}],
      victoryPoints: 2,

      behavior: {
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'x167',
        renderData: CardRenderer.builder((b) => {
          b.cards(1);
        }),
        description: 'Requires a plant tag, an animal tag, and a microbe tag. Draw a card.',
      },
    });
  }
}

================
File: cards/chemical/base/168_SpeciesCryopreservation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {Tag} from '../../../../common/cards/Tag';

export class SpeciesCryopreservation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SPECIES_CRYOPRESERVATION,
      cost: 5,
      tags: [Tag.SCIENCE, Tag.ANIMAL],
      requirements: {tag: Tag.ANIMAL, count: 2},
      victoryPoints: 1,

      metadata: {
        cardNumber: 'x166',
        description: 'Requires 2 animal tags.',
      },
    });
  }
}

================
File: cards/chemical/base/17_CyanobacteriaBloom.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class CyanobacteriaBloom extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.CYANOBACTERIA_BLOOM,
      tags: [Tag.MICROBE],
      cost: 12,

      behavior: {
        global: {oxygen: 1},
        stock: {plants: {tag: Tag.MICROBE}},
      },

      metadata: {
        cardNumber: 'xB17',
        renderData: CardRenderer.builder((b) => {
          b.oxygen(1).nbsp;
          b.plants(1).slash().tag(Tag.MICROBE);
        }),
        description: 'Raise the oxygen 1 step and gain 1 plant for each microbe tag you have, including this.',
      },
    });
  }
}

================
File: cards/chemical/base/18_OxygenShipment.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {SelectCard} from '../../../inputs/SelectCard';
import {PlayerInput} from '../../../PlayerInput';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class OxygenShipment extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.OXYGEN_SHIPMENT,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 22,

      behavior: {
        global: {oxygen: 2},
      },

      metadata: {
        cardNumber: 'xB18',
        renderData: CardRenderer.builder((b) => {
          b.oxygen(2).br;
          b.resource(CardResource.MICROBE, {amount: 3, digit}).asterix().or();
          b.resource(CardResource.ANIMAL, {amount: 2, digit}).asterix();
        }),
        description: 'Raise the oxygen 2 steps and add 3 microbes or 2 animals to ANOTHER card.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): undefined | PlayerInput {
    const availableMicrobeCards = player.getResourceCards(CardResource.MICROBE);
    const availableAnimalCards = player.getResourceCards(CardResource.ANIMAL);

    const availableActions: Array<PlayerInput> = [];

    if (availableMicrobeCards.length === 1) {
      const targetMicrobeCard = availableMicrobeCards[0];
      availableActions.push(new SelectOption('Add 3 microbes to ' + targetMicrobeCard.name, 'Add microbes').andThen( () => {
        player.addResourceTo(targetMicrobeCard, {qty: 3, log: true});
        return undefined;
      }));
    } else if (availableMicrobeCards.length > 1) {
      availableActions.push(new SelectCard('Add 3 microbes to a card',
        'Add microbes',
        availableMicrobeCards).andThen( ([card]) => {
        player.addResourceTo(card, {qty: 3, log: true});
        return undefined;
      }));
    }

    if (availableAnimalCards.length === 1) {
      const targetAnimalCard = availableAnimalCards[0];
      availableActions.push(new SelectOption('Add 2 animals to ' + targetAnimalCard.name, 'Add animals').andThen( () => {
        player.addResourceTo(targetAnimalCard, {qty: 2, log: true});
        return undefined;
      }));
    } else if (availableAnimalCards.length > 1) {
      availableActions.push(new SelectCard('Add 2 animals to a card', 'Add animals', availableAnimalCards).andThen( ([card]) => {
        player.addResourceTo(card, {qty: 2, log: true});
        return undefined;
      }));
    }
    if (availableActions.length === 0) {
      return undefined;
    }

    return new OrOptions(...availableActions);
  }
}

================
File: cards/chemical/base/19_SpecialAerosols.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class SpecialAerosols extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SPECIAL_AEROSOLS,
      cost: 22,
      requirements: {oxygen: 4},
      behavior: {
        tr: 2,
        production: {plants: 2},
      },

      metadata: {
        cardNumber: 'xB19',
        renderData: CardRenderer.builder((b) => {
          b.tr(2);
          b.production((pb) => pb.plants(2));
        }),
        description: 'Raise your TR 2 steps and increase your plant production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/2_ConvoyFromTitan.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ConvoyFromTitan extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.CONVOY_FROM_TITAN,
      tags: [Tag.SPACE],
      cost: 24,

      behavior: {
        production: {heat: 2},
        ocean: {},
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'xB2',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1);
          b.production((pb) => pb.heat(2));
          b.cards(1);
        }),
        description: 'Place an ocean tile, increase your heat production 2 steps, and draw a card.',
      },
    });
  }
}

================
File: cards/chemical/base/20_ImportedFuel.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ImportedFuel extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.IMPORTED_FUEL,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 11,

      behavior: {
        production: {energy: 1, heat: 1},
        stock: {heat: 2},
      },

      metadata: {
        cardNumber: 'xB20',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).heat(1));
          b.nbsp.heat(2);
        }),
        description: 'Increase your energy production 1 step and your heat production 1 step. Gain 2 heat resources.',
      },
    });
  }
}

================
File: cards/chemical/base/21_AsteroidMiningExpedition.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class AsteroidMiningExpedition extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ASTEROID_MINING_EXPEDITION,
      tags: [Tag.SPACE],
      cost: 12,

      behavior: {
        stock: {steel: 3, titanium: 5},
      },

      metadata: {
        cardNumber: 'xB21',
        renderData: CardRenderer.builder((b) => {
          b.steel(3, {digit}).nbsp.titanium(5, {digit}).nbsp.minus().energy(2, {digit});
        }),
        description: 'Gain 3 steel and 5 titanium. Lose 2 energy.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.energy >= 2;
  }
  public override bespokePlay(player: IPlayer) {
    player.energy -= 2;
    return undefined;
  }
}

================
File: cards/chemical/base/22_LowlandExpedition.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {max} from '../../Options';

export class LowlandExpedition extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.LOWLAND_EXPEDITION,
      cost: 6,
      behavior: {
        stock: {plants: 2},
      },
      victoryPoints: 1,
      requirements: {oceans: 3, max},

      metadata: {
        cardNumber: 'xB22',
        renderData: CardRenderer.builder((b) => {
          b.plants(2);
        }),
        description: 'Requires 3 oceans or fewer. Gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/base/23_PowerSurge.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {digit} from '../../Options';

export class PowerSurge extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.POWER_SURGE,
      tags: [Tag.POWER],
      cost: 3,
      requirements: {tag: Tag.POWER, count: 2},
      behavior: {
        stock: {energy: 8},
      },

      metadata: {
        cardNumber: 'xB23',
        renderData: CardRenderer.builder((b) => {
          b.energy(8, {digit});
        }),
        description: 'Requires 2 power tags. Gain 8 energy.',
      },
    });
  }
}

================
File: cards/chemical/base/24_MinorImpactor.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all, digit} from '../../Options';
import {Tag} from '../../../../common/cards/Tag';

export class MinorImpactor extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.MINOR_IMPACTOR,
      tags: [Tag.SPACE],
      cost: 3,
      behavior: {
        stock: {heat: 4},
        removeAnyPlants: 2,
      },

      metadata: {
        cardNumber: 'xB24',
        renderData: CardRenderer.builder((b) => {
          b.heat(4, {digit}).nbsp;
          b.minus().plants(2, {all});
        }),
        description: 'Gain 4 heat. Remove up to 2 plants from any player.',
      },
    });
  }
}

================
File: cards/chemical/base/25_ControlledBurn.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all, digit} from '../../Options';

export class ControlledBurn extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.CONTROLLED_BURN,
      cost: 1,
      requirements: {oxygen: 6},
      behavior: {
        stock: {heat: 3},
        removeAnyPlants: 3,
      },

      metadata: {
        cardNumber: 'xB25',
        renderData: CardRenderer.builder((b) => {
          b.heat(3, {digit}).nbsp;
          b.minus().plants(3, {all});
        }),
        description: 'Gain 3 heat. Remove up to 3 plants from any player.',
      },
    });
  }
}

================
File: cards/chemical/base/26_EcologicalShipment.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class EcologicalShipment extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ECOLOGICAL_SHIPMENT,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 25,

      behavior: {
        stock: {plants: 5},
        addResourcesToAnyCard: [
          {type: CardResource.MICROBE, count: 3},
          {type: CardResource.ANIMAL, count: 3},
        ],
      },

      metadata: {
        cardNumber: 'xB26',
        renderData: CardRenderer.builder((b) => {
          b.plants(5, {digit}).nbsp;
          b.resource(CardResource.MICROBE, {amount: 3, digit}).asterix().nbsp;
          b.resource(CardResource.ANIMAL, {amount: 3, digit}).asterix();
        }),
        description: 'Gain 5 plants. Add 3 microbes to ANOTHER card and 3 animals to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/base/27_PanspermiaSurvey.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class PanspermiaSurvey extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.PANSPERMIA_SURVEY,
      tags: [Tag.SPACE],
      cost: 25,
      victoryPoints: 3,

      behavior: {
        addResourcesToAnyCard: [
          {type: CardResource.MICROBE, count: 2},
          {type: CardResource.ASTEROID, count: 1},
        ],
      },

      metadata: {
        cardNumber: 'xB27',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.ASTEROID).asterix().nbsp;
          b.resource(CardResource.MICROBE, 2).asterix();
        }),
        description: 'Add 1 asteorid to ANOTHER card and 3 microbes to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/base/28_HabitatConservation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';

export class HabitatConservation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.HABITAT_CONSERVATION,
      tags: [Tag.ANIMAL],
      cost: 6,

      metadata: {
        cardNumber: 'xB28',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.ANIMAL).slash().tag(Tag.ANIMAL).asterix();
        }),
        description: 'Add an animal to every card you have that can contain animals.',
      },
    });
  }

  public override bespokePlay(player: IPlayer): undefined {
    for (const card of player.getResourceCards(CardResource.ANIMAL)) {
      player.addResourceTo(card, {qty: 1, log: false});
    }
    return undefined;
  }
}

================
File: cards/chemical/base/29_AsteroidStudy.ts
================
import {IProjectCard} from '../../IProjectCard';
import {ActionCard} from '../../ActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';

export class AsteroidStudy extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ASTEROID_STUDY,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 12,
      resourceType: CardResource.ASTEROID,
      behavior: {
        addResourcesToAnyCard: {type: CardResource.ASTEROID, count: 2},
      },

      action: {
        spend: {energy: 1},
        addResourcesToAnyCard: {type: CardResource.ASTEROID, count: 1},
      },

      victoryPoints: {resourcesHere: {}, per: 2},

      metadata: {
        cardNumber: 'xB29',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 energy to add 1 asteroid to ANY card.', (eb) => {
            eb.energy(1).startAction.resource(CardResource.ASTEROID).asterix();
          }).br;
          b.resource(CardResource.ASTEROID, 2).asterix().br;
          b.vpText('1VP for each 2 asteroids on this card.');
        }),
        description: 'Add 2 asteroids to ANY card.',
      },
    });
  }
}

================
File: cards/chemical/base/3_HighSpeedComet.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all, digit} from '../../Options';
import {Tag} from '../../../../common/cards/Tag';

export class HighSpeedComet extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.HIGH_SPEED_COMET,
      tags: [Tag.SPACE],
      cost: 27,
      behavior: {
        global: {temperature: 2},
        ocean: {},
        removeAnyPlants: 5,
      },

      metadata: {
        cardNumber: 'xB3',
        renderData: CardRenderer.builder((b) => {
          b.temperature(2);
          b.oceans(1).nbsp;
          b.minus().plants(5, {all, digit});
        }),
        description: 'Raise the temperature 2 steps and place an ocean tile. Remove up to 5 plants from any player.',
      },
    });
  }
}

================
File: cards/chemical/base/30_NitrogenAsteroids.ts
================
import {IActionCard} from '../../ICard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {CardName} from '../../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {TITLES} from '../../../inputs/titles';
import {ICard} from '../../ICard';
import {SelectCard} from '../../../inputs/SelectCard';

export class NitrogenAsteroids extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.NITROGEN_ASTEROIDS,
      type: CardType.ACTIVE,
      tags: [Tag.SPACE],
      cost: 6,
      resourceType: CardResource.ASTEROID,

      metadata: {
        cardNumber: 'xB30',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 6 M€ to add an asteroid resource to this card [TITANIUM MAY BE USED].', (eb) => {
            eb.megacredits(6).super((b) => b.titanium(1)).startAction.resource(CardResource.ASTEROID).asterix();
          }).br;
          b.action('Remove 1 asteroid from this card to increase your TR 1 step.', (eb) => {
            eb.or().resource(CardResource.ASTEROID).startAction.tr(1);
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.canAfford({cost: 6, titanium: true}) || (this.resourceCount > 0 && player.canAfford({cost: 0, tr: {tr: 1}}));
  }

  public action(player: IPlayer) {
    const asteroidCards = player.getResourceCards(CardResource.ASTEROID);
    const opts: Array<SelectOption> = [];

    const addResource = new SelectOption('Pay 6 M€ to add 1 asteroid to any card', 'Pay').andThen( () => this.addResource(player, asteroidCards) );
    const spendResource = new SelectOption('Remove 1 asteroid to raise your TR 1 step', 'Remove asteroid').andThen( () => this.spendResource(player) );

    if (this.resourceCount > 0) {
      opts.push(spendResource);
    } else {
      return this.addResource(player, asteroidCards);
    }

    if (player.canAfford({cost: 6, titanium: true})) {
      opts.push(addResource);
    } else {
      return this.spendResource(player);
    }

    return new OrOptions(...opts);
  }

  private addResource(player: IPlayer, asteroidCards: ICard[]) {
    player.game.defer(new SelectPaymentDeferred(player, 6, {canUseTitanium: true, title: TITLES.payForCardAction(this.name)}));

    if (asteroidCards.length === 1) {
      player.addResourceTo(this, {log: true});
      return undefined;
    }

    return new SelectCard(
      'Select card to add 1 asteroid',
      'Add asteroid',
      asteroidCards).andThen( ([card]) => {
      player.addResourceTo(card, {log: true});
      return undefined;
    },
    );
  }

  private spendResource(player: IPlayer) {
    player.removeResourceFrom(this);
    player.increaseTerraformRating(1);
    player.game.log('${0} removed an asteroid resource to increase their TR 1 step', (b) => b.player(player));
    return undefined;
  }
}

================
File: cards/chemical/base/31_OxygenatedComets.ts
================
import {IActionCard} from '../../ICard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {CardName} from '../../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {TITLES} from '../../../inputs/titles';
import {ICard} from '../../ICard';
import {SelectCard} from '../../../inputs/SelectCard';

export class OxygenatedComets extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.OXYGENATED_COMETS,
      type: CardType.ACTIVE,
      tags: [Tag.SPACE],
      cost: 5,
      resourceType: CardResource.ASTEROID,

      metadata: {
        cardNumber: 'xB31',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 6 M€ to add an asteroid resource to this card [TITANIUM MAY BE USED].', (eb) => {
            eb.megacredits(6).super((b) => b.titanium(1)).startAction.resource(CardResource.ASTEROID).asterix();
          }).br;
          b.action('Remove 1 asteroid from this card to increase the oxygen 1 step.', (eb) => {
            eb.or().resource(CardResource.ASTEROID).startAction.oxygen(1);
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.canAfford({cost: 6, titanium: true}) || (this.resourceCount > 0 && player.canAfford({cost: 0, tr: {oxygen: 1}}));
  }

  public action(player: IPlayer) {
    const asteroidCards = player.getResourceCards(CardResource.ASTEROID);
    const opts: Array<SelectOption> = [];

    const addResource = new SelectOption('Pay 6 M€ to add 1 asteroid to any card', 'Pay').andThen( () => this.addResource(player, asteroidCards) );
    const spendResource = new SelectOption('Remove 1 asteroid to raise the oxygen step', 'Remove asteroid').andThen( () => this.spendResource(player) );

    if (this.resourceCount > 0) {
      opts.push(spendResource);
    } else {
      return this.addResource(player, asteroidCards);
    }

    if (player.canAfford({cost: 6, titanium: true})) {
      opts.push(addResource);
    } else {
      return this.spendResource(player);
    }

    return new OrOptions(...opts);
  }

  private addResource(player: IPlayer, asteroidCards: ICard[]) {
    player.game.defer(new SelectPaymentDeferred(player, 6, {canUseTitanium: true, title: TITLES.payForCardAction(this.name)}));

    if (asteroidCards.length === 1) {
      player.addResourceTo(this, {log: true});
      return undefined;
    }

    return new SelectCard(
      'Select card to add 1 asteroid',
      'Add asteroid',
      asteroidCards).andThen( ([card]) => {
      player.addResourceTo(card, {log: true});
      return undefined;
    },
    );
  }

  private spendResource(player: IPlayer) {
    player.removeResourceFrom(this);
    player.game.increaseOxygenLevel(player, 1);
    player.game.log('${0} removed an asteroid resource to increase the oxygen 1 step', (b) => b.player(player));
    return undefined;
  }
}

================
File: cards/chemical/base/32_KuiperBeltIceAsteroids.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class KuiperBeltIceAsteroids extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.KUIPER_BELT_ICE_ASTEROIDS,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 18,
      resourceType: CardResource.ASTEROID,
      victoryPoints: 1,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 asteroids to place an ocean tile',
            spend: {resourcesHere: 2},
            ocean: {},
          },
          {
            title: 'Add 1 asteroid to this card',
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: 'xB32',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 asteroid to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ASTEROID);
          }).br;
          b.or().br;
          b.action('Remove 2 asteroids from this card to place an ocean tile.', (eb) => {
            eb.resource(CardResource.ASTEROID, 2).startAction.oceans(1);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/base/33_CeresMiningOperations.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class CeresMiningOperations extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CERES_MINING_OPERATIONS,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 31,
      resourceType: CardResource.ASTEROID,
      victoryPoints: {tag: Tag.JOVIAN},

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 1 asteroids to increase your steel production 1 step.',
            spend: {resourcesHere: 1},
            production: {steel: 1},
          },
          {
            title: 'Add 1 asteroid to this card',
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: 'xB33',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 asteroid to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ASTEROID);
          }).br;
          b.or().br;
          b.action('Remove 1 asteroid from this card to increase your steel production 1 step.', (eb) => {
            eb.resource(CardResource.ASTEROID).startAction.production((pb) => pb.steel(1));
          }).br;
          b.vpText('1 VP per Jovian tag you have.');
        }),
      },
    });
  }
}

================
File: cards/chemical/base/34_AmmoniaHeavyAsteroids.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class AmmoniaHeavyAsteroids extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.AMMONIA_HEAVY_ASTEROIDS,
      tags: [Tag.SPACE],
      cost: 5,
      resourceType: CardResource.ASTEROID,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 1 asteroid to increase your heat production 2 steps.',
            spend: {resourcesHere: 1},
            production: {heat: 2},
          },
          {
            title: 'Spend 1 titanium to add 1 asteroid to ANY card',
            spend: {titanium: 1},
            addResourcesToAnyCard: {type: CardResource.ASTEROID, count: 1},
          }],
        },
      },

      metadata: {
        cardNumber: 'xB34',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add 1 asteroid to ANY card.', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.ASTEROID).asterix();
          }).br;
          b.or().br;
          b.action('Remove 1 asteroid from this card to increase your heat production 2 steps.', (eb) => {
            eb.resource(CardResource.ASTEROID).startAction.production((pb) => pb.heat(2));
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/base/35_MTypeAsteroidMining.ts
================
import {IActionCard} from '../../ICard';
import {PlayerInput} from '../../../PlayerInput';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {SelectAmount} from '../../../inputs/SelectAmount';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {digit} from '../../Options';

export class MTypeAsteroidMining extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.M_TYPE_ASTEROID_MINING,
      type: CardType.ACTIVE,
      tags: [Tag.SPACE],
      cost: 27,
      resourceType: CardResource.ASTEROID,

      metadata: {
        cardNumber: 'xB35',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 asteroid to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ASTEROID);
          }).br;
          b.or().br;
          b.action('Spend any number of asteroids here to gain triple amount of steel.', (eb) => {
            eb.text('X').resource(CardResource.ASTEROID).startAction.text('X').steel(3, {digit});
          });
        }),
      },
    });
  }
  public canAct(): boolean {
    return true;
  }
  public action(player: IPlayer) {
    const opts: Array<PlayerInput> = [];

    const addResource = new SelectOption('Add 1 asteroid to this card', 'Add asteroid').andThen( () => {
      player.addResourceTo(this, {log: true});
      return undefined;
    });
    const spendResource = new SelectAmount('Remove any number of asteroids to gain 3 steel per asteroid removed', 'Remove asteroids', 1, this.resourceCount, true)
      .andThen((amount) => this.spendResource(player, amount));

    opts.push(addResource);

    if (this.resourceCount > 0) {
      opts.push(spendResource);
    } else {
      player.addResourceTo(this, {log: true});
      return undefined;
    }

    return new OrOptions(...opts);
  }

  private spendResource(player: IPlayer, amount: number) {
    player.removeResourceFrom(this, amount, {log: false});

    const steelGained = 3 * amount;
    player.steel += steelGained;

    player.game.log('${0} removed ${1} asteroids from ${2} to gain ${3} steel', (b) =>
      b.player(player).number(amount).card(this).number(steelGained));

    return undefined;
  }
}

================
File: cards/chemical/base/36_FloatingWeatherProbes.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class FloatingWeatherProbes extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.FLOATING_WEATHER_PROBES,
      tags: [Tag.SCIENCE],
      cost: 10,
      resourceType: CardResource.FLOATER,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 floaters to increase the oxygen 1 step',
            spend: {resourcesHere: 2},
            global: {oxygen: 1},
          },
          {
            title: 'Spend 2 energy to add 2 floaters to this card',
            spend: {energy: 2},
            addResources: 2,
          }],
        },
      },

      metadata: {
        cardNumber: 'xB36',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 energy to add 2 floaters to this card.', (eb) => {
            eb.energy(2).startAction.resource(CardResource.FLOATER, 2);
          }).br;
          b.or().br;
          b.action('Remove 2 floaters from this card to raise the oxygen 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.oxygen(1);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/base/37_ProductionDrones.ts
================
import {IActionCard} from '../../ICard';
import {IPlayer} from '../../../IPlayer';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {SelectOption} from '../../../inputs/SelectOption';
import {ALL_RESOURCES} from '../../../../common/Resource';
import {OrOptions} from '../../../inputs/OrOptions';

export class ProductionDrones extends Card implements IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PRODUCTION_DRONES,
      cost: 12,
      resourceType: CardResource.FLOATER,

      metadata: {
        cardNumber: 'xB37',
        renderData: CardRenderer.builder((b) => {
          b.action('Add a floater to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER);
          }).br;
          b.or().br;
          b.action('Remove 1 floater from this card to increase (one of) your LOWEST PRODUCTION 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER).startAction.production((pb) => pb.wild(1)).asterix();
          }).br;
        }),
      },
    });
  }
  public canAct(): boolean {
    return true;
  }

  public action(player: IPlayer) {
    const opts: Array<SelectOption> = [];

    const addResource = new SelectOption('Add 1 floater to this card', 'Add floater').andThen( () => {
      player.addResourceTo(this, {log: true});
      return undefined;
    });
    const spendResource = new SelectOption('Remove a floater from this card to increase your lowest production 1 step', 'Remove floater').andThen( () => this.spendResource(player));

    opts.push(addResource);

    if (this.resourceCount > 0) {
      opts.push(spendResource);
    } else {
      player.addResourceTo(this, {log: true});
      return undefined;
    }

    return new OrOptions(...opts);
  }
  private spendResource(player: IPlayer) {
    player.removeResourceFrom(this, 1, {log: false});

    let minimum = player.production.megacredits;
    let lowest: Array<SelectOption> = [];

    ALL_RESOURCES.forEach((resource) => {
      const option = new SelectOption('Increase ' + resource + ' production 1 step', 'Select').andThen( () => {
        player.production.add(resource, 1, {log: true});
        return undefined;
      });

      if (player.production[resource] < minimum) {
        lowest = [];
        minimum = player.production[resource];
      }
      if (player.production[resource] === minimum) lowest.push(option);
    });

    const result = new OrOptions();
    result.options = lowest;
    return result;
  }
}

================
File: cards/chemical/base/38_EuropanBacteria.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class EuropanBacteria extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.EUROPAN_BACTERIA,
      tags: [Tag.JOVIAN, Tag.MICROBE],
      cost: 20,
      requirements: {tag: Tag.JOVIAN, count: 1},
      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 2},

      behavior: {
        tr: 1,
      },

      action: {
        addResources: 1,
      },

      metadata: {
        cardNumber: 'xB38',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.vpText('1 VP per 2 Microbes on this card.').br;
          b.tr(1);
        }),
        description: 'Requires 1 Jovian tag. Raise your TR one step.',
      },
    });
  }
}

================
File: cards/chemical/base/39_Termites.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class Termites extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TERMITES,
      tags: [Tag.MICROBE],
      cost: 10,
      requirements: {oxygen: 4},
      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 2},

      behavior: {
        production: {heat: 1},
      },

      action: {
        addResources: 1,
      },

      metadata: {
        cardNumber: 'xB39',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.vpText('1 VP per 2 Microbes on this card.').br;
          b.production((pb) => pb.heat(1));
        }),
        description: 'Requires 4% oxygen. Increase your heat production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/4_TitaniumComet.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all, digit} from '../../Options';
import {Tag} from '../../../../common/cards/Tag';

export class TitaniumComet extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.TITANIUM_COMET,
      tags: [Tag.SPACE],
      cost: 28,
      behavior: {
        global: {temperature: 1},
        ocean: {},
        stock: {titanium: 3},
        removeAnyPlants: 3,
      },

      metadata: {
        cardNumber: 'xB4',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1);
          b.oceans(1);
          b.titanium(3, {digit}).nbsp;
          b.minus().plants(3, {all, digit});
        }),
        description: 'Raise the temperature 1 step, place an ocean tile, and gain 3 titanium. Remove up to 3 plants from any player.',
      },
    });
  }
}

================
File: cards/chemical/base/40_MartianThermophiles.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class MartianThermophiles extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MARTIAN_THERMOPHILES,
      tags: [Tag.MICROBE],
      cost: 4,
      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 3},

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 1 heat to add 1 microbe to this card',
            spend: {heat: 1},
            addResources: 1,
          },
          {
            title: 'Spend 4 heat to add 2 microbes to this card',
            spend: {heat: 4},
            addResources: 2,
          }],
        },
      },

      metadata: {
        cardNumber: 'xB40',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 heat to add 1 microbe to this card.', (eb) => {
            eb.heat(1).startAction.resource(CardResource.MICROBE);
          }).br;
          b.or().br;
          b.action('Spend 4 heat to add 2 microbes to this card.', (eb) => {
            eb.heat(4, {digit}).startAction.resource(CardResource.MICROBE, 2);
          }).br;
          b.vpText('1 VP per 3 Microbes on this card.').br;
        }),
      },
    });
  }
}

================
File: cards/chemical/base/41_MimicryArchaea.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardResource} from '../../../../common/CardResource';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {CardRenderer} from '../../render/CardRenderer';
import {SelectCard} from '../../../inputs/SelectCard';

export class MimicryArchaea extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MIMICRY_ARCHAEA,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      cost: 13,
      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 3},

      behavior: {
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'xB41',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a plant, microbe, or an animal tag, including this, add a microbe to ANY card.', (eb) => {
            eb.tag(Tag.PLANT).slash().tag(Tag.ANIMAL).slash().tag(Tag.MICROBE).startEffect.resource(CardResource.MICROBE).asterix();
          }).br;
          b.vpText('1 VP per 3 Microbes on this card.').br;
          b.plants(2);
        }),
        description: 'Gain 2 plants.',
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    const resourceCount = player.tags.cardTagCount(card, [Tag.ANIMAL, Tag.PLANT, Tag.MICROBE]);
    const microbeCards = player.getResourceCards(CardResource.MICROBE);

    if (resourceCount === 0) {
      return undefined;
    }
    if (microbeCards.length === 1) {
      player.addResourceTo(this, resourceCount);
      return undefined;
    }
    for (let i = 0; i < resourceCount; i++) {
      player.game.defer(new SimpleDeferredAction(player, () => new SelectCard(
        'Select card to add 1 microbe from Mimicry Archea (' + String(i + 1) + '/' + String(resourceCount) + ')',
        'Add microbe',
        microbeCards).andThen(
        ([card]) => {
          player.addResourceTo(card, {log: true});
          return undefined;
        },
      )));
    }
    return undefined;
  }
}

================
File: cards/chemical/base/42_Macroplankton.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class Macroplankton extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MACROPLANKTON,
      tags: [Tag.MICROBE],
      cost: 8,
      requirements: {temperature: -14},
      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 4},

      behavior: {
        stock: {plants: 2},
      },

      action: {
        addResources: 2,
      },

      metadata: {
        cardNumber: 'xB42',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 2 microbes to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE, 2);
          }).br;
          b.vpText('1 VP per 4 Microbes on this card.').br;
          b.plants(2);
        }),
        description: 'Requires -14°C or warmer. Gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/base/43_WaterSplittingMicrobes.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class WaterSplittingMicrobes extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.WATER_SPLITTING_MICROBES,
      tags: [Tag.MICROBE],
      cost: 5,
      requirements: {oceans: 2},
      resourceType: CardResource.MICROBE,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 microbes to increase the oxygen 1 step',
            spend: {resourcesHere: 2},
            global: {oxygen: 1},
          },
          {
            title: 'Spend 1 M€ to add 1 microbe to this card',
            spend: {megacredits: 1},
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: 'xB43',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 M€ to add 1 microbe to this card.', (eb) => {
            eb.megacredits(1).startAction.resource(CardResource.MICROBE);
          }).br;
          b.or().br;
          b.action('Remove 2 microbes from this card to raise the oxygen 1 step.', (eb) => {
            eb.resource(CardResource.MICROBE, 2).startAction.oxygen(1);
          }).br;
        }),
        description: 'Requires 2 ocean tiles.',
      },
    });
  }
}

================
File: cards/chemical/base/44_HalogenReconstructors.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class HalogenReconstructors extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.HALOGEN_RECONSTRUCTORS,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      cost: 7,
      resourceType: CardResource.MICROBE,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 microbes to increase the temperature 1 step',
            spend: {resourcesHere: 2},
            global: {temperature: 1},
          },
          {
            title: 'Spend 1 M€ to add 1 microbe to this card',
            spend: {megacredits: 1},
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: 'xB44',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 M€ to add 1 microbe to this card.', (eb) => {
            eb.megacredits(1).startAction.resource(CardResource.MICROBE);
          }).br;
          b.or().br;
          b.action('Remove 2 microbes from this card to raise the temperature 1 step.', (eb) => {
            eb.resource(CardResource.MICROBE, 2).startAction.temperature(1);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/base/45_AntiOxidationBacteria.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardResource} from '../../../../common/CardResource';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {Size} from '../../../../common/cards/render/Size';

export class AntiOxidationBacteria extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ANTI_OXIDATION_BACTERIA,
      tags: [Tag.MICROBE],
      cost: 8,
      requirements: {oxygen: 2},
      resourceType: CardResource.MICROBE,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'xB45',
        renderData: CardRenderer.builder((b) => {
          b.tag(Tag.BUILDING).colon().resource(CardResource.MICROBE).or(Size.SMALL).minus().resource(CardResource.MICROBE).plus().production((pb) => pb.megacredits(1)).br;
          b.description('When you play a building tag, either add a microbe to this card or remove a microbe from this card to increase your M€ production 1 step.').br;
        }),
        description: 'Requires 2% oxygen.',
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.tags.includes(Tag.BUILDING) === false) {
      return undefined;
    }
    if (this.resourceCount === 0) {
      player.addResourceTo(this);
      return undefined;
    }

    const addResource = new SelectOption('Add a microbe resource to Anti-Oxidation Bacteria', 'Add microbe').andThen( () => {
      player.addResourceTo(this);
      return undefined;
    });

    const spendResource = new SelectOption('Remove 1 microbe from Anti-Oxidation Bacteria and increase M€ production 1 step', 'Remove microbe').andThen( () => {
      player.removeResourceFrom(this, 1);
      player.production.add(Resource.MEGACREDITS, 1);
      return undefined;
    });

    player.game.defer(new SimpleDeferredAction(player, () => new OrOptions(spendResource, addResource)));
    return undefined;
  }
}

================
File: cards/chemical/base/46_ThallophyteProtists.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ThallophyteProtists extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.THALLOPHYTE_PROTISTS,
      tags: [Tag.MICROBE],
      cost: 12,
      requirements: {temperature: -24},
      resourceType: CardResource.MICROBE,

      behavior: {
        addResources: 2,
      },

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 microbes to raise your plant production 1 step',
            spend: {resourcesHere: 2},
            production: {plants: 1},
          },
          {
            title: 'Add a microbe to this card',
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: 'xB46',
        renderData: CardRenderer.builder((b) => {
          b.action('Add a microbe to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.or().br;
          b.action('Remove 2 microbes from this card to raise your plant production one step.', (eb) => {
            eb.resource(CardResource.MICROBE, 2).startAction.production((pb) => pb.plants(1));
          }).br;
          b.resource(CardResource.MICROBE, 2);
        }),
        description: 'Requires -24°C or warmer. Add 2 microbes to this card.',
      },
    });
  }
}

================
File: cards/chemical/base/47_CarbonLatticeMicrobes.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class CarbonLatticeMicrobes extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CARBON_LATTICE_MICROBES,
      tags: [Tag.MICROBE],
      cost: 5,
      requirements: {tag: Tag.MICROBE, count: 1},
      resourceType: CardResource.MICROBE,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 1 microbe to gain 1 steel and 1 titanium',
            spend: {resourcesHere: 1},
            stock: {steel: 1, titanium: 1},
          },
          {
            title: 'Add a microbe to this card',
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: 'xB47',
        renderData: CardRenderer.builder((b) => {
          b.action('Add a microbe to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.or().br;
          b.action('Remove 1 microbe from this card to gain 1 steel and 1 titanium.', (eb) => {
            eb.resource(CardResource.MICROBE).startAction.steel(1).titanium(1);
          }).br;
        }),
        description: 'Requires 1 microbe tag.',
      },
    });
  }
}

================
File: cards/chemical/base/48_ElectroplaqueMicrobes.ts
================
import {IActionCard} from '../../ICard';
import {PlayerInput} from '../../../PlayerInput';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {SelectAmount} from '../../../inputs/SelectAmount';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';

export class ElectroplaqueMicrobes extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.ELECTROPLAQUE_MICROBES,
      type: CardType.ACTIVE,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      cost: 9,
      resourceType: CardResource.MICROBE,

      metadata: {
        cardNumber: 'xB48',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 2 microbes to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE, 2);
          }).br;
          b.or().br;
          b.action('Spend any number of microbes here to gain that amount of energy.', (eb) => {
            eb.text('x').resource(CardResource.MICROBE).startAction.text('x').energy(1);
          });
        }),
      },
    });
  }
  public canAct(): boolean {
    return true;
  }
  public action(player: IPlayer) {
    const opts: Array<PlayerInput> = [];

    const addResource = new SelectOption('Add 2 microbes to this card', 'Add microbes').andThen( () => {
      player.addResourceTo(this, 2);
      return undefined;
    });
    const spendResource = new SelectAmount('Remove any number of microbes to gain 1 energy per microbe removed', 'Remove microbes', 1, this.resourceCount, true)
      .andThen( (amount: number) => this.spendResource(player, amount) );

    opts.push(addResource);

    if (this.resourceCount > 0) {
      opts.push(spendResource);
    } else {
      player.addResourceTo(this, 2);
      return undefined;
    }

    return new OrOptions(...opts);
  }

  private spendResource(player: IPlayer, amount: number) {
    player.removeResourceFrom(this, amount, {log: false});

    player.energy += amount;

    player.game.log('${0} removed ${1} microbes from ${2} to gain ${3} energy', (b) =>
      b.player(player).number(amount).card(this).number(amount));

    return undefined;
  }
}

================
File: cards/chemical/base/49_LargeAquaticMammals.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {Size} from '../../../../common/cards/render/Size';
import {IPlayer} from '../../../IPlayer';
import {ICard} from '../../ICard';

export class LargeAquaticMammals extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.LARGE_AQUATIC_MAMMALS,
      tags: [Tag.ANIMAL],
      cost: 26,

      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 2},
      },

      action: {
        addResources: 1,
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, each: 2},
      requirements: {temperature: 6},

      metadata: {
        cardNumber: 'xB49',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card. THIS CARD MAY NOT CONTAIN MORE THAN 4 ANIMALS.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL).asterix().nbsp.text('(max 4)', Size.SMALL, true);
          }).br;
          b.production((pb) => pb.minus().plants(2, {all})).br;
          b.vpText('2 VP for each animal on this card.');
        }),
        description: {
          text: 'Requires +6°C or warmer. Decrease any plant production 2 steps.',
          align: 'left',
        },
      },
    });
  }
  public onResourceAdded(_player: IPlayer, card: ICard, _count: number) {
    if (card === this) {
      this.resourceCount = Math.min(this.resourceCount, 4);
    }
  }
}

================
File: cards/chemical/base/5_ExpeditionToDione.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class ExpeditionToDione extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.EXPEDITION_TO_DIONE,
      tags: [Tag.SPACE],
      cost: 19,
      behavior: {
        ocean: {},
        stock: {steel: 2},
      },
      victoryPoints: 1,

      metadata: {
        cardNumber: 'xB5',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).nbsp;
          b.steel(2);
        }),
        description: 'Place an ocean tile and gain 2 steel.',
      },
    });
  }
}

================
File: cards/chemical/base/50_TundraWildlife.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';

export class TundraWildlife extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TUNDRA_WILDLIFE,
      tags: [Tag.ANIMAL],
      cost: 12,

      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 1},
      },

      action: {
        addResources: 1,
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}},
      requirements: {oxygen: 9},

      metadata: {
        cardNumber: 'xB50',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.production((pb) => pb.minus().plants(1, {all})).br;
          b.vpText('1 VP for each animal on this card.');
        }),
        description: {
          text: 'Requires 9% oxygen. Decrease any plant production 1 step.',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/chemical/base/51_Raptors.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {IPlayer} from '../../../IPlayer';
import {CanAffordOptions} from '../../../IPlayer';
import {RemoveResourcesFromCard} from '../../../deferredActions/RemoveResourcesFromCard';

export class Raptors extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.RAPTORS,
      tags: [Tag.ANIMAL],
      cost: 12,

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}},
      requirements: {oxygen: 13},

      action: {
        addResources: 1,
      },

      metadata: {
        cardNumber: 'xB51',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.vpText('1 VP for each animal on this card.').br;
          b.minus().resource(CardResource.ANIMAL, {amount: 2, all});
        }),
        description: {
          text: 'Requires 13% oxygen. Remove 2 animals from any player.',
          align: 'left',
        },
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer, _canAffordOptions?: CanAffordOptions | undefined): boolean {
    if (player.game.isSoloMode()) {
      return true;
    }
    return RemoveResourcesFromCard.getAvailableTargetCards(player, CardResource.ANIMAL).filter( (card) => card.resourceCount >= 2).length >= 1;
  }
  public override bespokePlay(player: IPlayer) {
    if (player.game.isSoloMode()) {
      return undefined;
    }
    player.game.defer(new RemoveResourcesFromCard(player, CardResource.ANIMAL, 2, {mandatory: true}));
    return undefined;
  }
}

================
File: cards/chemical/base/52_FishFarmingLake.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class FishFarmingLake extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.FISH_FARMING_LAKE,
      tags: [Tag.ANIMAL, Tag.BUILDING],
      cost: 16,

      behavior: {
        ocean: {},
      },

      action: {
        addResources: 1,
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}},
      requirements: {temperature: 4},

      metadata: {
        cardNumber: 'xB52',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.oceans(1).br;
          b.vpText('1 VP for each animal on this card.');
        }),
        description: {
          text: 'Requires 4°C or warmer. Place an ocean tile.',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/chemical/base/53_Cephalopods.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {ActionCard} from '../../ActionCard';

export class Cephalopods extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CEPHALOPODS,
      tags: [Tag.ANIMAL],
      cost: 11,

      action: {
        addResources: 1,
      },

      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 1},
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: 1},
      requirements: {oceans: 6},

      metadata: {
        cardNumber: 'xB53',
        renderData: CardRenderer.builder((b) => {
          b.action('Add an animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.production((pb) => pb.minus().plants(1, {all})).br;
          b.vpText('1 VP for every animal on this card.');
        }),
        description: {
          text: 'Requires 6 ocean tiles. Decrease any plant production 1 step.',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/chemical/base/54_EndangeredSpeciesRefuge.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';

export class EndangeredSpeciesRefuge extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ENDANGERED_SPECIES_REFUGE,
      tags: [Tag.EARTH, Tag.ANIMAL, Tag.BUILDING],
      cost: 19,

      behavior: {
        tr: 1,
        addResources: 2,
      },

      action: {
        spend: {megacredits: 4},
        addResources: 1,
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}},
      requirements: {tag: Tag.ANIMAL, count: 2},

      metadata: {
        cardNumber: 'xB54',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 4 M€ to add 1 animal to this card.', (eb) => {
            eb.megacredits(4).startAction.resource(CardResource.ANIMAL);
          }).br;
          b.text('Animals may not be removed from this card', Size.SMALL, true).br;
          b.vpText('1 VP for each animal on this card.').br;
          b.tr(1).resource(CardResource.ANIMAL, 2);
        }),
        description: {
          text: 'Requires 2 animal tags. Raise your TR 1 step and add 2 animals to this card.',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/chemical/base/55_NonHypoxicSmallAnimals.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {IPlayer, CanAffordOptions} from '../../../IPlayer';
import {MessageBuilder} from '../../../logs/MessageBuilder';
import {SelectOption} from '../../../inputs/SelectOption';
import {OrOptions} from '../../../inputs/OrOptions';

export class NonHypoxicSmallAnimals extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.NON_HYPOXIC_SMALL_ANIMALS,
      tags: [Tag.SCIENCE, Tag.ANIMAL],
      cost: 10,

      action: {
        addResources: 1,
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {oxygen: 3},

      metadata: {
        cardNumber: 'xB55',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.minus().plants(2, {all}).br;
          b.vpText('1 VP for every 2 animals on this card.');
        }),
        description: {
          text: 'Requires 3% oxygen. Remove 2 plants from any player.',
          align: 'left',
        },
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer, _canAffordOptions?: CanAffordOptions | undefined): boolean {
    if (player.game.isSoloMode()) {
      return true;
    }
    return player.game.getPlayers().filter((p) => p.plants >= 2 && ( p.id !== player.id && !p.plantsAreProtected() ) ).length >= 1;
  }
  public override bespokePlay(player: IPlayer) {
    if (player.game.isSoloMode()) {
      player.game.someoneHasRemovedOtherPlayersPlants = true;
      return undefined;
    }
    const candidates = player.game.getPlayers().filter((p) => ( p.id !== player.id && !p.plantsAreProtected() ) && p.plants >= 2);

    const removalOptions = candidates.map((candidate) => {
      let qtyToRemove = 2;

      // Botanical Experience hook.
      if (candidate.cardIsInEffect(CardName.BOTANICAL_EXPERIENCE)) {
        qtyToRemove /= 2;
      }

      const message =
        new MessageBuilder('Remove ${0} plants from ${1}')
          .number(qtyToRemove)
          .rawString(candidate.name)
          .getMessage();

      return new SelectOption(message, 'Remove plants').andThen(() => {
        candidate.stock.deduct(Resource.PLANTS, qtyToRemove, {log: true, from: player});
        return undefined;
      });
    });

    return new OrOptions(...removalOptions);
  }
}

================
File: cards/chemical/base/56_SubterranianCreatures.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {IPlayer, CanAffordOptions} from '../../../IPlayer';
import {MessageBuilder} from '../../../logs/MessageBuilder';
import {SelectOption} from '../../../inputs/SelectOption';
import {OrOptions} from '../../../inputs/OrOptions';

export class SubterranianCreatures extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SUBTERRANEAN_CREATURES,
      tags: [Tag.ANIMAL],
      cost: 7,

      action: {
        addResources: 1,
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {oxygen: 4},

      metadata: {
        cardNumber: 'xB56',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.minus().plants(2, {all}).br;
          b.vpText('1 VP for every 2 animals on this card.');
        }),
        description: 'Requires 4% oxygen. Remove 2 plants from any player.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer, _canAffordOptions?: CanAffordOptions | undefined): boolean {
    if (player.game.isSoloMode()) {
      return true;
    }
    return player.game.getPlayers().filter((p) => p.plants >= 2 && ( p.id !== player.id && !p.plantsAreProtected() ) ).length >= 1;
  }
  public override bespokePlay(player: IPlayer) {
    if (player.game.isSoloMode()) {
      player.game.someoneHasRemovedOtherPlayersPlants = true;
      return undefined;
    }
    const candidates = player.game.getPlayers().filter((p) => ( p.id !== player.id && !p.plantsAreProtected() ) && p.plants >= 2);

    const removalOptions = candidates.map((candidate) => {
      let qtyToRemove = 2;

      // Botanical Experience hook.
      if (candidate.cardIsInEffect(CardName.BOTANICAL_EXPERIENCE)) {
        qtyToRemove /= 2;
      }

      const message =
        new MessageBuilder('Remove ${0} plants from ${1}')
          .number(qtyToRemove)
          .rawString(candidate.name)
          .getMessage();

      return new SelectOption(message, 'Remove plants').andThen(() => {
        candidate.stock.deduct(Resource.PLANTS, qtyToRemove, {log: true, from: player});
        return undefined;
      });
    });

    return new OrOptions(...removalOptions);
  }
}

================
File: cards/chemical/base/57_AntarcticKrill.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {IPlayer, CanAffordOptions} from '../../../IPlayer';
import {RemoveResourcesFromCard} from '../../../deferredActions/RemoveResourcesFromCard';

export class AntarcticKrill extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ANTARCTIC_KRILL,
      tags: [Tag.ANIMAL],
      cost: 5,

      action: {
        addResources: 1,
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {temperature: -12},

      metadata: {
        cardNumber: 'xB57',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.minus().resource(CardResource.MICROBE, {amount: 2, all}).br;
          b.vpText('1 VP for every 2 animals on this card.');
        }),
        description: 'Requires -12°C or warmer. Remove 2 microbes from any player.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer, _canAffordOptions?: CanAffordOptions | undefined): boolean {
    if (player.game.isSoloMode()) {
      return true;
    }
    return RemoveResourcesFromCard.getAvailableTargetCards(player, CardResource.MICROBE).filter( (card) => card.resourceCount >= 2).length >= 1;
  }
  public override bespokePlay(player: IPlayer) {
    if (player.game.isSoloMode()) {
      return undefined;
    }
    player.game.defer(new RemoveResourcesFromCard(player, CardResource.MICROBE, 2, {mandatory: true}));
    return undefined;
  }
}

================
File: cards/chemical/base/58_AncientArthropods.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {IPlayer} from '../../../IPlayer';

export class AncientArthopods extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ANCIENT_ARTHROPODS,
      tags: [Tag.SCIENCE, Tag.ANIMAL],
      cost: 12,

      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 1},
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {oceans: 4},

      metadata: {
        cardNumber: 'xB58',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a science tag, including this, add an animal to this card', (eb) => {
            eb.tag(Tag.SCIENCE).startEffect.resource(CardResource.ANIMAL);
          }).br;
          b.production((pb) => pb.minus().plants(1, {all})).br;
          b.vpText('1 VP for every 2 animals on this card.');
        }),
        description: {
          text: 'Requires 4 ocean tiles. Decrease any plant production 1 step.',
          align: 'left',
        },
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const qty = player.tags.cardTagCount(card, Tag.SCIENCE);
    player.addResourceTo(this, {qty, log: true});
  }
}

================
File: cards/chemical/base/59_AdaptiveBiotics.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {Space} from '../../../boards/Space';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Board} from '../../../boards/Board';
import {IPlayer} from '../../../IPlayer';
import {GlobalParameter} from '../../../../common/GlobalParameter';

export class AdaptiveBiotics extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ADAPTIVE_BIOTICS,
      tags: [Tag.SCIENCE, Tag.ANIMAL],
      cost: 15,

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {tag: Tag.SCIENCE, count: 2},

      metadata: {
        cardNumber: 'xB59',
        renderData: CardRenderer.builder((b) => {
          b.effect('For every step you raise the temperature or oxygen, and for every ocean tile you place, add an animal to this card', (eb) => {
            eb.temperature(1).slash().oxygen(1).slash().oceans(1).startEffect.resource(CardResource.ANIMAL);
          }).br;
          b.vpText('1 VP for every 2 animals on this card.');
        }),
        description: 'Requires 2 science tags.',
      },
    });
  }

  onGlobalParameterIncrease?(player: IPlayer, parameter: GlobalParameter, steps: number) {
    if (parameter === GlobalParameter.TEMPERATURE || parameter === GlobalParameter.OXYGEN) {
      const qty = steps;
      player.addResourceTo(this, {qty, log: true});
    }
  }

  public onTilePlaced(cardOwner: IPlayer, _activePlayer: IPlayer, space: Space) {
    if (Board.isUncoveredOceanSpace(space)) {
      cardOwner.addResourceTo(this, {log: true});
    }
  }
}

================
File: cards/chemical/base/6_LargeThermalDetonator.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class LargeThermalDetonator extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.LARGE_THERMAL_DETONATOR,
      cost: 24,
      behavior: {
        ocean: {},
        stock: {heat: 12},
      },

      metadata: {
        cardNumber: 'xB6',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).nbsp;
          b.heat(12, {digit});
        }),
        description: 'Place an ocean tile and gain 12 heat.',
      },
    });
  }
}

================
File: cards/chemical/base/60_HabitatDomes.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class HabitatDomes extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.HABITAT_DOMES,
      tags: [Tag.ANIMAL, Tag.BUILDING],
      cost: 10,

      action: {
        spend: {megacredits: 2},
        addResourcesToAnyCard: {type: CardResource.ANIMAL, count: 1},
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},

      metadata: {
        cardNumber: 'xB60',
        renderData: CardRenderer.builder((b) => {
          b.action('spend 2 M€ to add 1 animal to ANY card.', (eb) => {
            eb.megacredits(2).startAction.resource(CardResource.ANIMAL).asterix();
          }).br;
          b.vpText('1 VP for every 2 animals on this card.');
        }),
      },
    });
  }
}

================
File: cards/chemical/base/61_Aquaponics.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {SelectOption} from '../../../inputs/SelectOption';
import {OrOptions} from '../../../inputs/OrOptions';
import {Resource} from '../../../../common/Resource';

export class Aquaponics extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.AQUAPONICS,
      tags: [Tag.ANIMAL, Tag.BUILDING],
      cost: 10,

      behavior: {
        addResources: 2,
      },

      requirements: [{tag: Tag.PLANT}, {tag: Tag.ANIMAL}, {tag: Tag.MICROBE}],
      resourceType: CardResource.ANIMAL,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'xB61',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.or().br;
          b.action('Gain 1 M€ for each animal here.', (eb) => {
            eb.empty().startAction.megacredits(1).slash().resource(CardResource.ANIMAL);
          }).br;
          b.resource(CardResource.ANIMAL, 2);
        }),
        description: 'Requires a plant tag, an animal tag, and a microbe tag. Add 2 animals to this card.',
      },
    });
  }
  public canAct(): boolean {
    return true;
  }

  public action(player: IPlayer) {
    const opts: Array<SelectOption> = [];

    if (this.resourceCount > 0) {
      opts.push(new SelectOption('Gain 1 M€ for each animal here', 'Gain M€').andThen( () => {
        player.stock.add(Resource.MEGACREDITS, this.resourceCount, {log: true});
        return undefined;
      }));
      opts.push(new SelectOption('Add 1 animal to this card', 'Add animal').andThen( () => {
        player.addResourceTo(this, {log: true});
        return undefined;
      }));
    } else {
      player.addResourceTo(this, {log: true});
      return undefined;
    }

    return new OrOptions(...opts);
  }
}

================
File: cards/chemical/base/62_SprawlingCity.ts
================
import {IProjectCard} from '../../IProjectCard';
import {ActionCard} from '../../ActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';

export class SprawlingCity extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SPRAWLING_CITY,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 25,
      resourceType: CardResource.BUILDING_RESOURCE,
      behavior: {
        city: {},
      },

      action: {
        production: {energy: -1, megacredits: 1},
        addResources: 1,
      },

      victoryPoints: {resourcesHere: {}, per: 1},

      metadata: {
        cardNumber: 'xB62',
        renderData: CardRenderer.builder((b) => {
          b.action('Decrease your energy production 1 step to increase your M€ production 1 step and add a building resource to this card.', (eb) => {
            eb.production((pb) => pb.energy(1)).startAction.production((pb) => pb.megacredits(1)).resource(CardResource.BUILDING_RESOURCE);
          }).br;
          b.city().br;
          b.vpText('1VP for each building resource on this card.');
        }),
        description: 'Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/base/63_ImperativeSettlement.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {TileType} from '../../../../common/TileType';
import {Space} from '../../../boards/Space';
import {CardName} from '../../../../common/cards/CardName';
import {AdjacencyBonus} from '../../../ares/AdjacencyBonus';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {Resource} from '../../../../common/Resource';

export class ImperativeSettlement extends Card implements IProjectCard {
  constructor(
    name = CardName.IMPERATIVE_SETTLEMENT,
    cost = 22,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: 'xB63',
      renderData: CardRenderer.builder((b) => {
        b.effect('Whenever any tile is placed adjacent to this city, increase your M€ production 2 steps.', (eb) => {
          eb.emptyTile('normal', {all}).tile(TileType.IMPERATIVE_SETTLEMENT, false).startEffect.production((pb) => pb.megacredits(2));
        }).br;
        b.production((pb) => pb.minus().energy(1)).nbsp.tile(TileType.IMPERATIVE_SETTLEMENT, false);
      }),
      description: 'Decrease your energy productuion 1 step and place this city tile.',
    },
  ) {
    super({
      type: CardType.ACTIVE,
      name,
      tags: [Tag.CITY, Tag.BUILDING],
      cost,
      adjacencyBonus,
      metadata,
      behavior: {
        production: {energy: -1},
        tile: {
          type: TileType.IMPERATIVE_SETTLEMENT,
          on: 'city',
          title: 'Select space for special city tile',
          adjacencyBonus: adjacencyBonus,
        },
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, player: IPlayer, space: Space) {
    const usedSpace = player.game.board.getSpaceByTileCard(this.name);
    if (usedSpace !== undefined && space.tile?.tileType !== TileType.MARS_NOMADS) {
      if (player.game.board.getAdjacentSpaces(space).includes(usedSpace)) {
        cardOwner.production.add(Resource.MEGACREDITS, 2);
      }
    }
  }
}

================
File: cards/chemical/base/64_EcoCentral.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class EcoCentral extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ECO_CENTRAL,
      tags: [Tag.PLANT, Tag.CITY, Tag.BUILDING],
      cost: 24,

      requirements: {temperature: -12},
      behavior: {
        city: {},
        production: {energy: -1, megacredits: 3},
        stock: {plants: 4},
      },

      metadata: {
        cardNumber: 'xB64',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you use the greenery standard project, you pay 3 M€ less for it.', (eb) => {
            eb.greenery().asterix().startEffect.megacredits(-3);
          }).br;
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          });
          b.city().plants(4, {digit});
        }),
        description: 'Requires -12°C or warmer. Decrease your energy production 1 step, increase your M€ production 3 steps, place a city tile, and gain 4 plants.',
      },
    });
  }
}

================
File: cards/chemical/base/65_Canals.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {IPlayer} from '../../../IPlayer';
import {Tag} from '../../../../common/cards/Tag';

export class Canals extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CANALS,
      cost: 9,
      tags: [Tag.BUILDING],

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'xB65',
        renderData: CardRenderer.builder((b) => {
          b.effect('Ocean tiles grant you adjacency bonus of +1 M€.', (eb) => {
            eb.emptyTile('normal', {size: Size.SMALL}).oceans(1, {size: Size.SMALL}).startEffect.nbsp.plus().megacredits(1);
          }).br;
          b.production((pb) => pb.megacredits(2));
        }),
        description: 'Increase your M€ production 2 steps.',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    player.oceanBonus += 1;
    return undefined;
  }

  public override onDiscard(player: IPlayer) {
    player.oceanBonus -= 1;
  }
}

================
File: cards/chemical/base/66_FreightShuttles.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Space} from '../../../boards/Space';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {Resource} from '../../../../common/Resource';
import {Priority} from '../../../deferredActions/Priority';
import {GainResources} from '../../../deferredActions/GainResources';
import {Board} from '../../../boards/Board';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {all} from '../../Options';

export class FreightShuttles extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.FREIGHT_SHUTTLES,
      tags: [Tag.SPACE],
      cost: 12,
      victoryPoints: 1,
      requirements: {oxygen: 5},

      behavior: {
        production: {megacredits: 5, energy: -2},
      },

      metadata: {
        cardNumber: 'xB66',
        renderData: CardRenderer.builder((b) => {
          b.effect('When any city tile is placed, gain 2 M€.', (eb) => {
            eb.city({size: Size.SMALL, all}).startEffect.megacredits(2);
          }).br;
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().megacredits(5);
          });
        }),
        description: 'Requires 5% oxygen. Decrease your energy production 2 steps and increase your M€ production 5 steps.',
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (Board.isCitySpace(space)) {
      cardOwner.game.defer(
        new GainResources(cardOwner, Resource.MEGACREDITS, {count: 2, log: true}),
        cardOwner.id !== activePlayer.id ? Priority.OPPONENT_TRIGGER : undefined,
      );
    }
    return undefined;
  }
}

================
File: cards/chemical/base/67_SiliconFactory.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class SiliconFactory extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SILICON_FACTORY,
      tags: [Tag.BUILDING],
      cost: 12,

      action: {
        spend: {energy: 4},
        global: {oxygen: 1},
        stock: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'xB67',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 4 energy to raise the oxygen 1 step and gain 2 M€', (eb) => {
            eb.energy(4, {digit}).startAction.oxygen(1).megacredits(2);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/base/68_AluminumFoundry.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class AluminumFoundry extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ALUMINUM_FOUNDRY,
      tags: [Tag.BUILDING],
      cost: 14,

      action: {
        spend: {energy: 4},
        global: {oxygen: 1},
        stock: {megacredits: 3},
      },

      metadata: {
        cardNumber: 'xB68',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 4 energy to raise the oxygen 1 step and gain 3 M€.', (eb) => {
            eb.energy(4, {digit}).startAction.oxygen(1).megacredits(3);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/base/69_ThawMining.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';

export class ThawMining extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.THAW_MINING,
      tags: [Tag.BUILDING],
      cost: 6,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 1 heat to gain 2 steel',
            spend: {heat: 1},
            stock: {steel: 2},
          },
          {
            title: 'Spend 1 heat to gain 1 titanium',
            spend: {heat: 1},
            stock: {titanium: 1},
          }],
        },
      },

      metadata: {
        cardNumber: 'xB69',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 heat to gain 2 steel or 1 titanium.', (eb) => {
            eb.heat(1).startAction.steel(2).or(Size.SMALL).titanium(1);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/base/7_HydrogenFromSaturn.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {IProjectCard} from '../../IProjectCard';

export class HydrogenFromSaturn extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.HYDROGEN_FROM_SATURN,
      type: CardType.EVENT,
      tags: [Tag.SPACE],
      cost: 22,
      victoryPoints: 1,

      behavior: {
        ocean: {},
        addResourcesToAnyCard: {count: {tag: Tag.JOVIAN}, type: CardResource.MICROBE},
      },

      metadata: {
        cardNumber: 'xB7',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).nbsp.nbsp;
          b.resource(CardResource.MICROBE).asterix().slash().tag(Tag.JOVIAN);
        }),
        description: 'Place an ocean tile. Add 1 microbe to ANY card for each Jovian tag you have.',
      },
    });
  }
}

================
File: cards/chemical/base/70_EcologicalContract.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';

export class EcologicalContract extends Card {
  constructor() {
    super({
      name: CardName.ECOLOGICAL_CONTRACT,
      type: CardType.ACTIVE,
      tags: [Tag.EARTH, Tag.PLANT],
      cost: 10,

      behavior: {
        production: {plants: 1},
      },

      metadata: {
        cardNumber: 'xB70',
        renderData: CardRenderer.builder((b) => {
          b.effect('When playing a plant tag, plants may be used as 3 M€ each.',
            (eb) => eb.tag(Tag.PLANT).startEffect.plants(1).equals().megacredits(3)).br;
          b.production((pb) => pb.plants(1)).br;
        }),
        description: 'Increase your plant production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/71_AdvancedGeneticAdaption.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {GlobalParameter} from '../../../../common/GlobalParameter';
import {Tag} from '../../../../common/cards/Tag';

export class AdvancedGeneticAdaption extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ADVANCED_GENETIC_ADAPTION,
      cost: 12,
      tags: [Tag.SCIENCE],
      globalParameterRequirementBonus: {parameter: GlobalParameter.OXYGEN, steps: 3},

      behavior: {
        production: {plants: 1},
      },

      metadata: {
        cardNumber: 'xB71',
        renderData: CardRenderer.builder((b) => {
          b.effect('Your oxygen requirements are +/- 3 steps, your choice in each case.', (eb) => {
            eb.plate('Oxygen requirements').startEffect.text('+/- 3');
          }).br;
          b.production((pb) => pb.plants(1));
        }),
        description: 'Increase your plant production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/72_EssentialSymbiotics.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import { CardResource } from '../../../../common/CardResource';

export class EssentialSymbiotics extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ESSENTIAL_SYMBIOTICS,
      cost: 8,
      tags: [Tag.MICROBE],

      behavior: {
        production: {plants: 1},
      },

      metadata: {
        cardNumber: 'xB72',
        renderData: CardRenderer.builder((b) => {
          b.effect('When adding microbe resources to a card, you may instead gain plant resources.', (eb) => {
            eb.plus().resource(CardResource.MICROBE).startEffect.plus().plants(1);
          }).br;
          b.production((pb) => pb.plants(1));
        }),
        description: 'Increase your plant production 1 step.',
      },
    });
  }
  // effect to be implemented
}

================
File: cards/chemical/base/73_MicrobeCultivationFacility.ts
================
import {IProjectCard} from '../../IProjectCard';
import {ActionCard} from '../../ActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';
import {CardResource} from '../../../../common/CardResource';

export class MicrobeCultivationFacility extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MICROBE_CULTIVATION_FACILITY,
      tags: [Tag.MICROBE, Tag.BUILDING],
      cost: 18,
      requirements: {tag: Tag.MICROBE, count: 2},

      behavior: {
        production: {plants: 1},
      },

      action: {
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 2},
      },

      metadata: {
        cardNumber: 'xB73',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 2 microbes to ANOTHER card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE, 2).asterix();
          }).br;
          b.production((pb) => pb.plants(1));
        }),
        description: 'Requires 2 microbe tags. Increase your plant production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/base/74_Biodomes.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {Resource} from '../../../../common/Resource';
import {CardRenderer} from '../../render/CardRenderer';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';
import {TITLES} from '../../../inputs/titles';

export class Biodomes extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.BIODOMES,
      tags: [Tag.BUILDING],
      cost: 8,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'xB74',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 8 M€ to increase your plant production 1 step. STEEL MAY BE USED as if you were playing a building card.', (eb) =>
            eb.megacredits(8).super((b) => b.steel(1)).startAction.production((pb) => pb.plants(1)),
          );
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.canAfford({cost: 8, steel: true});
  }
  public action(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 8, {canUseSteel: true, title: TITLES.payForCardAction(this.name)}))
      .andThen(() => player.production.add(Resource.PLANTS, 1));
    return undefined;
  }
}

================
File: cards/chemical/base/75_BiomassReactor.ts
================
import {IProjectCard} from '../../IProjectCard';
import {ActionCard} from '../../ActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';

export class BiomassReactor extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.BIOMASS_REACTOR,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 9,

      behavior: {
        stock: {energy: 2},
      },

      action: {
        spend: {plants: 1},
        stock: {energy: 3},
      },

      metadata: {
        cardNumber: 'xB75',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 plant to gain 3 energy.', (eb) => {
            eb.plants(1).startAction.energy(3);
          }).br;
          b.energy(2);
        }),
        description: 'Gain 2 energy.',
      },
    });
  }
}

================
File: cards/chemical/base/76_LocalTemperatureControl.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {GlobalParameter} from '../../../../common/GlobalParameter';

export class LocalTemperatureControl extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.LOCAL_TEMPERATURE_CONTROL,
      cost: 12,
      globalParameterRequirementBonus: {parameter: GlobalParameter.TEMPERATURE, steps: 4},

      behavior: {
        production: {heat: 2},
      },

      metadata: {
        cardNumber: 'xB76',
        renderData: CardRenderer.builder((b) => {
          b.effect('Your temperature requirements are +/- 4 steps, your choice in each case.', (eb) => {
            eb.plate('Temperature requirements').startEffect.text('+/- 4');
          }).br;
          b.production((pb) => pb.heat(2));
        }),
        description: 'Increase your heat production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/77_CO2Vents.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Space} from '../../../boards/Space';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {Resource} from '../../../../common/Resource';
import {CardRenderer} from '../../render/CardRenderer';
import {SpaceType} from '../../../../common/boards/SpaceType';
import {Size} from '../../../../common/cards/render/Size';

export class CO2Vents extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CO2_VENTS,
      tags: [Tag.BUILDING],
      cost: 10,

      behavior: {
        production: {heat: 1},
      },

      metadata: {
        cardNumber: 'xB77',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you place a tile ON MARS, gain 2 heat.', (eb) => {
            eb.emptyTile('normal', {size: Size.SMALL}).asterix().startEffect.heat(2);
          }).br;
          b.production((pb) => pb.heat(1));
        }),
        description: 'Increase your heat production 1 step.',
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, player: IPlayer, space: Space) {
    if (cardOwner.id === player.id && space.tile && space.spaceType !== SpaceType.COLONY) {
      cardOwner.stock.add(Resource.HEAT, 2);
    }
  }
}

================
File: cards/chemical/base/78_RegolithTreatment.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class RegolithTreatment extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.REGOLITH_TREATMENT,
      tags: [Tag.BUILDING],
      cost: 17,

      action: {
        spend: {energy: 3},
        tr: 1,
      },

      metadata: {
        cardNumber: 'xB78',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 3 energy to raise your TR 1 step', (eb) => {
            eb.energy(3).startAction.tr(1);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/base/79_EuropaWaterSplitting.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class EuropaWaterSplitting extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.EUROPA_WATER_SPLITTING,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 17,
      victoryPoints: 1,

      action: {
        spend: {energy: 3},
        global: {oxygen: 1},
      },

      metadata: {
        cardNumber: 'xB79',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 3 energy to raise the oxygen 1 step', (eb) => {
            eb.energy(3).startAction.oxygen(1);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/base/8_GiantCarbonateAsteroid.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all, digit} from '../../Options';
import {Tag} from '../../../../common/cards/Tag';

export class GiantCarbonateAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.GIANT_CARBONATE_ASTEROID,
      tags: [Tag.SPACE],
      cost: 35,
      behavior: {
        global: {temperature: 2},
        production: {heat: 4},
        removeAnyPlants: 6,
      },

      metadata: {
        cardNumber: 'xB8',
        renderData: CardRenderer.builder((b) => {
          b.temperature(2);
          b.production((pb) => pb.heat(4, {digit})).nbsp;
          b.minus().plants(6, {all, digit});
        }),
        description: 'Raise the temperature 2 steps and increase your heat production 4 steps. Remove up to 6 plants from any player.',
      },
    });
  }
}

================
File: cards/chemical/base/80_BiodiversityContract.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardRenderer} from '../../render/CardRenderer';
import {ICard} from '../../ICard';
import {CardResource} from '../../../../common/CardResource';
import {Resource} from '../../../../common/Resource';

export class BiodiversityContract extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.BIODIVERSITY_CONTRACT,
      tags: [Tag.EARTH],
      cost: 7,

      metadata: {
        cardNumber: 'xB80',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you gain a microbe or animal to ANY CARD, also gain 1 M€.', (eb) => {
            eb.resource(CardResource.MICROBE).asterix().slash().resource(CardResource.ANIMAL).asterix().startEffect.megacredits(1);
          }).br;
        }),
      },
    });
  }

  public onResourceAdded(player: IPlayer, card: ICard, count: number) {
    if (card.resourceType === CardResource.MICROBE || card.resourceType === CardResource.ANIMAL) {
      player.stock.add(Resource.MEGACREDITS, count, {log: true});
    }
  }
}

================
File: cards/chemical/base/81_TemperateRainforest.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Space} from '../../../boards/Space';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {Resource} from '../../../../common/Resource';
import {CardRenderer} from '../../render/CardRenderer';
import {Board} from '../../../boards/Board';
import {CardResource} from '../../../../common/CardResource';
import {Size} from '../../../../common/cards/render/Size';

export class TemperateRainforest extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TEMPERATE_RAINFOREST,
      tags: [Tag.ANIMAL, Tag.PLANT],
      cost: 28,
      requirements: {temperature: 0},

      behavior: {
        greenery: {},
        addResourcesToAnyCard: {type: CardResource.ANIMAL, count: 2},
      },

      metadata: {
        cardNumber: 'xB81',
        renderData: CardRenderer.builder((b) => {
          b.effect('Greenery tiles grant you an adjacency bonus of 1 M€.', (eb) => {
            eb.greenery({withO2: false, size: Size.SMALL}).emptyTile('normal', {size: Size.SMALL}).startEffect.megacredits(1);
          }).br;
          b.greenery().resource(CardResource.ANIMAL, 2).asterix();
        }),
        description: 'Requires 0°C or warmer. Place a greenery tile and add 2 animals to ANOTHER card.',
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, player: IPlayer, space: Space) {
    if (cardOwner.id === player.id && space.tile) {
      cardOwner.stock.add(Resource.MEGACREDITS, player.game.board.getAdjacentSpaces(space).filter(Board.isGreenerySpace).length);
    }
  }
}

================
File: cards/chemical/base/82_GeneticEngineeringLab.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class GeneticEngineeringLab extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.GENETIC_ENGINEERING_LAB,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 12,
      victoryPoints: 1,

      requirements: {tag: Tag.SCIENCE, count: 2},
      cardDiscount: [{tag: Tag.PLANT, amount: 3}, {tag: Tag.ANIMAL, amount: 3}, {tag: Tag.MICROBE, amount: 3}],

      metadata: {
        cardNumber: 'xB82',
        renderData: CardRenderer.builder((b) => {
          b.effect('Your plant tags, animal tags, and microbe tags cost 3 M€ less.', (eb) => {
            eb.tag(Tag.PLANT).slash().tag(Tag.ANIMAL).slash().tag(Tag.MICROBE).startEffect.megacredits(-3);
          });
        }),
        description: 'Requires 2 science tags.',
      },
    });
  }
}

================
File: cards/chemical/base/83_OceanographyResearch.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {GlobalParameter} from '../../../../common/GlobalParameter';
import {Tag} from '../../../../common/cards/Tag';

export class OceanographyResearch extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.OCEANOGRAPHY_RESEARCH,
      cost: 8,
      tags: [Tag.SCIENCE],
      globalParameterRequirementBonus: {parameter: GlobalParameter.OCEANS, steps: 2},

      behavior: {
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'xB83',
        renderData: CardRenderer.builder((b) => {
          b.effect('Your ocean requirements are +/- 2 steps, your choice in each case.', (eb) => {
            eb.plate('Ocean requirements').startEffect.text('+/- 2');
          }).br;
          b.cards(1);
        }),
        description: 'Draw a card.',
      },
    });
  }
}

================
File: cards/chemical/base/84_HeavyAerospaceTech.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';

export class HeavyAerospaceTech extends Card {
  constructor() {
    super({
      name: CardName.HEAVY_AEROSPACE_TECH,
      type: CardType.ACTIVE,
      tags: [Tag.SCIENCE],
      cost: 4,

      metadata: {
        cardNumber: 'xB84',
        renderData: CardRenderer.builder((b) => {
          b.effect('When playing a space tag, steel may be used as 2 M€ each.',
            (eb) => eb.tag(Tag.SPACE).startEffect.steel(1).equals().megacredits(2)).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/base/85_InsulatedCity.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class InsulatedCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INSULATED_CITY,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 19,

      behavior: {
        city: {},
        production: {heat: -2, megacredits: 4},
      },

      metadata: {
        cardNumber: 'xB85',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().heat(2).br;
            pb.plus().megacredits(4);
          });
          b.city();
        }),
        description: 'Decrease your heat production 2 steps and increase your M€ production 4 steps. Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/base/86_BuriedSettlement.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {max} from '../../Options';

export class BuriedSettlement extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BURIED_SETTLEMENT,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 12,
      requirements: {oxygen: 5, max},

      behavior: {
        city: {},
        production: {energy: -1, megacredits: 2},
      },

      metadata: {
        cardNumber: 'xB86',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(2);
          });
          b.city();
        }),
        description: 'Oxygen must be 5% or lower. Decrease your energy production 1 step and increase your M€ production 2 steps. Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/base/87_HugeCity.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {Space} from '../../../boards/Space';
import {SelectSpace} from '../../../inputs/SelectSpace';
import {CanAffordOptions} from '../../../IPlayer';

export class HugeCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HUGE_CITY,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 35,
      requirements: {cities: 2},

      behavior: {
        production: {energy: -2, megacredits: 6},
      },

      metadata: {
        cardNumber: 'xB87',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().megacredits(6);
          });
          b.city().city().asterix();
        }),
        description: 'Requires that you own 2 cities. Decrease your energy production 2 steps and increase your M€ production 6 steps. Place 2 adjacent city tiles.',
      },
    });
  }
  private getSpacesForFirstCity(player: IPlayer, canAffordOptions?: CanAffordOptions): ReadonlyArray<Space> {
    return player.game.board.getAvailableSpacesForCity(player, canAffordOptions)
      .filter((space) => this.getSpacesForSecondCity(player, space, canAffordOptions).length > 0);
  }
  private getSpacesForSecondCity(player: IPlayer, firstCity: Space, canAffordOptions?: CanAffordOptions): ReadonlyArray<Space> {
    return player.game.board.getAdjacentSpaces(firstCity)
      .filter((space) => player.game.board.getAvailableSpacesForCity(player, canAffordOptions).includes(space));
  }

  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions): boolean {
    return this.getSpacesForFirstCity(player, canAffordOptions).length > 0 && player.production.energy >= 2;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select a space for the first city', this.getSpacesForFirstCity(player)).andThen((firstCity) => {
      const spacesForSecondCity = this.getSpacesForSecondCity(player, firstCity);
      player.game.addCity(player, firstCity);
      return new SelectSpace('Select a space for the second city adjacent to the first city', spacesForSecondCity).andThen((secondCity) => {
        player.game.addCity(player, secondCity);
        return undefined;
      });
    });
  }
}

================
File: cards/chemical/base/88_MiningCommunity.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {Space} from '../../../boards/Space';
import {SpaceBonus} from '../../../../common/boards/SpaceBonus';
import {PlaceCityTile} from '../../../deferredActions/PlaceCityTile';

export class MiningCommunity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MINING_COMMUNITY,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 20,

      behavior: {
        production: {energy: -2, megacredits: 3, steel: 1},
      },

      metadata: {
        cardNumber: 'xB88',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().megacredits(3).steel(1);
          });
          b.city().asterix();
        }),
        description: 'Decrease your energy production 2 steps. Increase your M€ production 3 steps and your steel production 1 step. Place a city tile ON A STEEL PLACEMENT BONUS, regardless of adjacent city tiles.',
      },
    });
  }
  private getSpacesForCity(player: IPlayer): ReadonlyArray<Space> {
    return player.game.board.getAvailableSpacesOnLand(player).filter((space) => space.bonus.includes(SpaceBonus.STEEL));
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return this.getSpacesForCity(player).length > 0 && player.production.energy >= 2;
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(
      new PlaceCityTile(
        player,
        {
          spaces: this.getSpacesForCity(player),
          title: 'Select a space with a steel placement bonus',
        }));
    return undefined;
  }
}

================
File: cards/chemical/base/89_DeepBurrowSettlement.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class DeepBurrowSettlement extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DEEP_BURROW_SETTLEMENT,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 23,

      behavior: {
        city: {},
        production: {energy: -1, steel: 1, heat: 2},
      },

      metadata: {
        cardNumber: 'xB89',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().steel(1).heat(2);
          });
          b.city();
        }),
        description: 'Decrease your energy production 1 step. Increase your steel production 1 step and your heat production 2 steps. Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/base/9_CarbonateAsteroid.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all, digit} from '../../Options';
import {Tag} from '../../../../common/cards/Tag';

export class CarbonateAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.CARBONATE_ASTEROID,
      tags: [Tag.SPACE],
      cost: 22,
      behavior: {
        global: {temperature: 1},
        production: {heat: 3},
        removeAnyPlants: 3,
      },

      metadata: {
        cardNumber: 'xB9',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1);
          b.production((pb) => pb.heat(3, {digit})).nbsp;
          b.minus().plants(3, {all, digit});
        }),
        description: 'Raise the temperature 1 step and increase your heat production 3 steps. Remove up to 3 plants from any player.',
      },
    });
  }
}

================
File: cards/chemical/base/90_InstituteSettlement.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {max} from '../../Options';

export class InstituteSettlement extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INSTITUTE_SETTLEMENT,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 17,
      requirements: {temperature: -18, max},
      victoryPoints: 1,

      behavior: {
        city: {},
        production: {energy: -1, plants: 1},
      },

      metadata: {
        cardNumber: 'xB90',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().plants(1);
          });
          b.city();
        }),
        description: 'Requires -18°C or colder. Decrease your energy production 1 step and increase your plant production 1 step. Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/base/91_MultifunctionalDome.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {SelectOption} from '../../../inputs/SelectOption';
import {ALL_RESOURCES} from '../../../../common/Resource';
import {OrOptions} from '../../../inputs/OrOptions';

export class MultifunctionalDome extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MULTIFUNCTIONAL_DOME,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 20,

      behavior: {
        city: {},
        production: {energy: -1, megacredits: 1},
      },

      metadata: {
        cardNumber: 'xB91',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(1).wild(1);
          });
          b.city();
        }),
        description: 'Decrease your energy production 1 step. Increase your M€ production 1 step and ANY production 1 step. Place a city tile.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const orOptions = new OrOptions();

    ALL_RESOURCES.forEach((resource) => {
      orOptions.options.push(new SelectOption('Increase ' + resource + ' production 1 step', 'Select').andThen( () => {
        player.production.add(resource, 1, {log: true});
        return undefined;
      }),
      );
    });

    return orOptions;
  }
}

================
File: cards/chemical/base/92_IndependentSettlement.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class IndependentSettlement extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INDEPENDENT_SETTLEMENT,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 15,
      victoryPoints: 1,

      behavior: {
        city: {on: 'isolated'},
      },

      metadata: {
        cardNumber: 'xB92',
        renderData: CardRenderer.builder((b) => {
          b.city().asterix();
        }),
        description: 'Place a city tile NEXT TO NO OTHER TILE.',
      },
    });
  }
}

================
File: cards/chemical/base/93_GeothermalReserviorHeating.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class GeothermalReserviorHeating extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GEOTHERMAL_RESERVIOR_HEATING,
      cost: 18,
      tags: [Tag.BUILDING],

      behavior: {
        ocean: {},
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'xB93',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).production((pb) => pb.megacredits(2));
        }),
        description: 'Place an ocean tile and increase your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/base/94_MunicipalReservior.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {CanAffordOptions} from '../../../IPlayer';
import {Space} from '../../../boards/Space';
import {SelectSpace} from '../../../inputs/SelectSpace';
import {Tag} from '../../../../common/cards/Tag';

export class MunicipalReservior extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MUNICIPAL_RESERVIOR,
      cost: 10,
      tags: [Tag.BUILDING],

      behavior: {
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'xB94',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).asterix().nbsp.production((pb) => pb.megacredits(1));
        }),
        description: 'Place an ocean tile NEXT TO 3 OTHER TILES, THIS TILE MAY BE PLACED ON AN AREA NOT RESERVED FOR AN OCEAN. Increase your M€ production 1 step. ',
      },
    });
  }
  private adjacencyTest(player: IPlayer, space: Space) {
    return player.game.board.getAdjacentSpaces(space).filter((adjacentSpace) => adjacentSpace.tile !== undefined).length >= 3;
  }
  private getAvailableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): Array<Space> {
    return player.game.board.getAvailableSpacesForOcean(player).filter((space) => this.adjacencyTest(player, space))
      .concat(player.game.board.getAvailableSpacesOnLand(player, canAffordOptions).filter((space) => this.adjacencyTest(player, space)));
  }
  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions) {
    if (!player.game.canAddOcean()) return false;
    return this.getAvailableSpaces(player, canAffordOptions).length > 0;
  }
  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select space next to 3 other tiles', this.getAvailableSpaces(player))
      .andThen((requestedSpace: Space) => {
        player.game.addOcean(player, requestedSpace);
        return undefined;
      });
  }
}

================
File: cards/chemical/base/95_FreshwaterLake.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {CanAffordOptions} from '../../../IPlayer';
import {Board} from '../../../boards/Board';
import {Space} from '../../../boards/Space';
import {SelectSpace} from '../../../inputs/SelectSpace';
import {CardResource} from '../../../../common/CardResource';

export class FreshwaterLake extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FRESHWATER_LAKE,
      cost: 25,
      requirements: {temperature: 0},
      victoryPoints: 1,

      behavior: {
        addResourcesToAnyCard: {type: CardResource.ANIMAL, count: 2},
      },

      metadata: {
        cardNumber: 'xB95',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).asterix().nbsp.resource(CardResource.ANIMAL, 2).asterix();
        }),
        description: 'Requires 0°C or warmer. Place an ocean tile ON LAND, AND NEXT TO NO OTHER OCEAN. Add 2 animals to ANOTHER card.',
      },
    });
  }
  private getAvailableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): Array<Space> {
    return player.game.board.getAvailableSpacesOnLand(player, canAffordOptions).filter((space) => player.game.board.getAdjacentSpaces(space).filter(Board.isOceanSpace).length === 0);
  }
  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions) {
    if (!player.game.canAddOcean()) return false;
    return this.getAvailableSpaces(player, canAffordOptions).length > 0;
  }
  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select space on land next to no other ocean', this.getAvailableSpaces(player))
      .andThen((requestedSpace: Space) => {
        player.game.addOcean(player, requestedSpace);
        return undefined;
      });
  }
}

================
File: cards/chemical/base/96_HugeGlacier.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {max} from '../../Options';

export class HugeGlacier extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HUGE_GLACIER,
      cost: 26,
      requirements: {temperature: -10, max},
      victoryPoints: 1,

      behavior: {
        ocean: {count: 2},
      },

      metadata: {
        cardNumber: 'xB96',
        renderData: CardRenderer.builder((b) => {
          b.oceans(2);
        }),
        description: 'Requires -10°C or colder. Place 2 ocean tiles.',
      },
    });
  }
}

================
File: cards/chemical/base/97_DeepWellPump.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {Tag} from '../../../../common/cards/Tag';

export class DeepWellPump extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DEEP_WELL_PUMP,
      cost: 7,
      tags: [Tag.BUILDING],

      behavior: {
        ocean: {},
      },

      metadata: {
        cardNumber: 'xB97',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).nbsp.minus().energy(2);
        }),
        description: 'Place an ocean tile and lose 2 energy.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.energy >= 2;
  }
  public override bespokePlay(player: IPlayer) {
    player.energy -= 2;
    return undefined;
  }
}

================
File: cards/chemical/base/98_CommercialImports.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {all} from '../../Options';
import {Size} from '../../../../common/cards/render/Size';

export class CommercialImports extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.COMMERCIAL_IMPORTS,
      cost: 16,
      tags: [Tag.EARTH, Tag.SPACE],
      victoryPoints: 1,

      behavior: {
        production: {megacredits: {cities: {where: 'everywhere'}, all: true}},
      },

      metadata: {
        cardNumber: 'xB98',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).slash().city({size: Size.SMALL, all});
          });
        }),
        description: 'Increase your M€ production 1 step for every city tile.',
      },
    });
  }
}

================
File: cards/chemical/base/99_UrbanDevelopment.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {all} from '../../Options';
import {Size} from '../../../../common/cards/render/Size';

export class UrbanDevelopment extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.URBAN_DEVELOPMENT,
      cost: 8,
      tags: [Tag.BUILDING],
      victoryPoints: 1,

      behavior: {
        production: {energy: -1, megacredits: {cities: {where: 'everywhere'}}},
      },

      metadata: {
        cardNumber: 'xB99',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(1).slash().city({size: Size.SMALL, all});
          });
        }),
        description: 'Decrease your energy production 1 step and increase your M€ production 1 step for every city tile.',
      },
    });
  }
}

================
File: cards/chemical/base/Primates.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';

export class Primates extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PRIMATES,
      tags: [Tag.ANIMAL],
      cost: 12,

      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 1},
      },

      action: {
        addResources: 1,
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}},
      requirements: {oxygen: 11},

      metadata: {
        cardNumber: 'x339',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.production((pb) => pb.minus().plants(1, {all})).br;
          b.vpText('1 VP for each animal on this card.');
        }),
        description: {
          text: 'Requires 11% oxygen. Decrease any plant production 1 step.',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/chemical/ChemicalCardManifest.ts
================
import {CardName} from '../../../common/cards/CardName';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {ModuleManifest} from '../ModuleManifest';
import {SubcrustVaporTrapping} from './base/1_SubcrustVaporTrapping';
import {ConvoyFromTitan} from './base/2_ConvoyFromTitan';
import {HighSpeedComet} from './base/3_HighSpeedComet';
import {TitaniumComet} from './base/4_TitaniumComet';
import {ExpeditionToDione} from './base/5_ExpeditionToDione';
import {LargeThermalDetonator} from './base/6_LargeThermalDetonator';
import {HydrogenFromSaturn} from './base/7_HydrogenFromSaturn';
import {GiantCarbonateAsteroid} from './base/8_GiantCarbonateAsteroid';
import {CarbonateAsteroid} from './base/9_CarbonateAsteroid';
import {ArtificialAsteroid} from './base/10_ArtificialAsteroid';
import {InstantiatedSolarFlare} from './base/11_InstantiatedSolarFlare';
import {AcceleratedImpactor} from './base/12_AcceleratedImpactor';
import {IronRichAsteroid} from './base/13_IronRichAsteroid';
import {Overgrowth} from './base/14_Overgrowth';
import {CondensedGasConvoy} from './base/15_CondensedGasConvoy';
import {TemporarySmeltingPlant} from './base/16_TemporarySmeltingPlant';
import {CyanobacteriaBloom} from './base/17_CyanobacteriaBloom';
import {OxygenShipment} from './base/18_OxygenShipment';
import {SpecialAerosols} from './base/19_SpecialAerosols';
import {ImportedFuel} from './base/20_ImportedFuel';
import {AsteroidMiningExpedition} from './base/21_AsteroidMiningExpedition';
import {LowlandExpedition} from './base/22_LowlandExpedition';
import {PowerSurge} from './base/23_PowerSurge';
import {MinorImpactor} from './base/24_MinorImpactor';
import {ControlledBurn} from './base/25_ControlledBurn';
import {EcologicalShipment} from './base/26_EcologicalShipment';
import {PanspermiaSurvey} from './base/27_PanspermiaSurvey';
import {HabitatConservation} from './base/28_HabitatConservation';
import {AsteroidStudy} from './base/29_AsteroidStudy';
import {NitrogenAsteroids} from './base/30_NitrogenAsteroids';
import {OxygenatedComets} from './base/31_OxygenatedComets';
import {KuiperBeltIceAsteroids} from './base/32_KuiperBeltIceAsteroids';
import {CeresMiningOperations} from './base/33_CeresMiningOperations';
import {AmmoniaHeavyAsteroids} from './base/34_AmmoniaHeavyAsteroids';
import {MTypeAsteroidMining} from './base/35_MTypeAsteroidMining';
import {FloatingWeatherProbes} from './base/36_FloatingWeatherProbes';
import {ProductionDrones} from './base/37_ProductionDrones';
import {EuropanBacteria} from './base/38_EuropanBacteria';
import {Termites} from './base/39_Termites';
import {MartianThermophiles} from './base/40_MartianThermophiles';
import {MimicryArchaea} from './base/41_MimicryArchaea';
import {Macroplankton} from './base/42_Macroplankton';
import {WaterSplittingMicrobes} from './base/43_WaterSplittingMicrobes';
import {HalogenReconstructors} from './base/44_HalogenReconstructors';
import {AntiOxidationBacteria} from './base/45_AntiOxidationBacteria';
import {ThallophyteProtists} from './base/46_ThallophyteProtists';
import {CarbonLatticeMicrobes} from './base/47_CarbonLatticeMicrobes';
import {ElectroplaqueMicrobes} from './base/48_ElectroplaqueMicrobes';
import {LargeAquaticMammals} from './base/49_LargeAquaticMammals';
import {TundraWildlife} from './base/50_TundraWildlife';
import {Raptors} from './base/51_Raptors';
import {FishFarmingLake} from './base/52_FishFarmingLake';
import {Cephalopods} from './base/53_Cephalopods';
import {EndangeredSpeciesRefuge} from './base/54_EndangeredSpeciesRefuge';
import {NonHypoxicSmallAnimals} from './base/55_NonHypoxicSmallAnimals';
import {SubterranianCreatures} from './base/56_SubterranianCreatures';
import {AntarcticKrill} from './base/57_AntarcticKrill';
import {AncientArthopods} from './base/58_AncientArthropods';
import {AdaptiveBiotics} from './base/59_AdaptiveBiotics';
import {HabitatDomes} from './base/60_HabitatDomes';
import {Aquaponics} from './base/61_Aquaponics';
import {SprawlingCity} from './base/62_SprawlingCity';
import {ImperativeSettlement} from './base/63_ImperativeSettlement';
import {EcoCentral} from './base/64_EcoCentral';
import {Canals} from './base/65_Canals';
import {FreightShuttles} from './base/66_FreightShuttles';
import {SiliconFactory} from './base/67_SiliconFactory';
import {AluminumFoundry} from './base/68_AluminumFoundry';
import {ThawMining} from './base/69_ThawMining';
import {EcologicalContract} from './base/70_EcologicalContract';
import {AdvancedGeneticAdaption} from './base/71_AdvancedGeneticAdaption';
//import {EssentialSymbiotics} from './base/72_EssentialSymbiotics';
import {MicrobeCultivationFacility} from './base/73_MicrobeCultivationFacility';
import {Biodomes} from './base/74_Biodomes';
import {BiomassReactor} from './base/75_BiomassReactor';
import {LocalTemperatureControl} from './base/76_LocalTemperatureControl';
import {CO2Vents} from './base/77_CO2Vents';
import {RegolithTreatment} from './base/78_RegolithTreatment';
import {EuropaWaterSplitting} from './base/79_EuropaWaterSplitting';
import {BiodiversityContract} from './base/80_BiodiversityContract';
import {TemperateRainforest} from './base/81_TemperateRainforest';
import {GeneticEngineeringLab} from './base/82_GeneticEngineeringLab';
import {OceanographyResearch} from './base/83_OceanographyResearch';
import {HeavyAerospaceTech} from './base/84_HeavyAerospaceTech';
import {InsulatedCity} from './base/85_InsulatedCity';
import {BuriedSettlement} from './base/86_BuriedSettlement';
import {HugeCity} from './base/87_HugeCity';
import {MiningCommunity} from './base/88_MiningCommunity';
import {DeepBurrowSettlement} from './base/89_DeepBurrowSettlement';
import {InstituteSettlement} from './base/90_InstituteSettlement';
import {MultifunctionalDome} from './base/91_MultifunctionalDome';
import {IndependentSettlement} from './base/92_IndependentSettlement';
import {GeothermalReserviorHeating} from './base/93_GeothermalReserviorHeating';
import {MunicipalReservior} from './base/94_MunicipalReservior';
import {FreshwaterLake} from './base/95_FreshwaterLake';
import {HugeGlacier} from './base/96_HugeGlacier';
import {DeepWellPump} from './base/97_DeepWellPump';
import {CommercialImports} from './base/98_CommercialImports';
import {UrbanDevelopment} from './base/99_UrbanDevelopment';
import {ExplosivesTestSite} from './base/100_ExplosivesTestSite';
import {GrandStadium} from './base/101_GrandStadium';
import {PolarOutpost} from './base/102_PolarOutpost';
import {RuralHousing} from './base/103_RuralHousing';
import {TunnelBoring} from './base/104_TunnelBoring';
import {LithiumMine} from './base/105_LithiumMine';
import {ChasmaExcavation} from './base/106_ChasmaExcavation';
import {DeepPolarExtraction} from './base/107_DeepPolarExtraction';
import {CallistoOperations} from './base/108_CallistoOperations';
import {SaturnGasMine} from './base/109_SaturnGasMine';
import {LaserDrillMining} from './base/110_LaserDrillMining';
import {HydrualicMining} from './base/111_HydrualicMining';
import {EnzymaticTreatment} from './base/112_EnzymaticTreatment';
import {RegolithAeration} from './base/113_RegolithAeration';
import {Mixotrophs} from './base/114_Mixotrophs';
import {BotanicalLab} from './base/115_BotanicalLab';
import {IndustrialComposting} from './base/116_IndustrialComposting';
import {ExtremeNitrophiles} from './base/117_ExtremeNitrophiles';
import {VascularTundraPlants} from './base/118_VascularTundraPlants';
import {Bamboo} from './base/119_Bamboo';
import {ErosionReducingGreenery} from './base/120_ErosionReducingGreenery';
import {ParasiticPlants} from './base/121_ParasiticPlants';
import {Wildberries} from './base/122_Wildberries';
import {AnaerobicEnergyCropping} from './base/123_AnaerobicEnergyCropping';
import {AdaptedHardwood} from './base/124_AdaptedHardwood';
import {AquaticBiodomes} from './base/125_AquaticBiodomes';
import {Conifers} from './base/126_Conifers';
import {WildBarley} from './base/127_WildBarley';
import {WetlandsChemical} from './base/128_WetlandsChemical';
import {Cacti} from './base/129_Cacti';
import {AdaptedFruitFarming} from './base/130_AdaptedFruitFarming';
import {RiceFields} from './base/131_RiceFields';
import {CoralReef} from './base/132_CoralReef';
import {CyanobacteriaChemical} from './base/133_CyanobacteriaChemical';
import {HydroponicsFacility} from './base/134_HydroponicsFacility';
import {RedAlgae} from './base/135_RedAlgae';
import {Irrigation} from './base/136_Irrigation';
import {Monsoons} from './base/137_Monsoons';
import {HeavyRespirators} from './base/138_HeavyRespirators';
import {BeeFarming} from './base/139_BeeFarming';
import {SyntheticGrowthHormones} from './base/140_SyntheticGrowthHormones';
import {SpaceBasedSolarPower} from './base/141_SpaceBasedSolarPower';
import {EfficientBatteries} from './base/142_EfficientBatteries';
import {LargePowerPlant} from './base/143_LargePowerPlant';
import {HydrocarbonSynthesis} from './base/144_HydrocarbonSynthesis';
import {AtmosphericProcessing} from './base/145_AtmosphericProcessing';
import {UraniumDeposit} from './base/146_UraniumDeposit';
import {AlgaeBioreactorsChemical} from './base/147_AlgaeBioreactors';
import {MassiveSolarFarm} from './base/148_MassiveSolarFarm';
import {AdvancedHydropower} from './base/149_AdvancedHydropower';
import {EnrichmentPlant} from './base/150_EnrichmentPlant';
import {FuelCellProduction} from './base/151_FuelCellProduction';
import {EnergyMohole} from './base/152_EnergyMohole';
import {HighPowerBetavoltaics} from './base/153_HighPowerBetavoltaics';
import {CentralPowerPlant} from './base/154_CentralPowerPlant';
import {IsotopeEnrichingBacteria} from './base/155_IsotopeEnrichingBacteria';
import {AnaerobicBacteria} from './base/156_AnaerobicBacteria';
import {SolidStateWildEnergy} from './base/157_SolidStateWildEnergy';
import {AtmosphericPressureEngine} from './base/158_AtmosphericPressureEngine';
import {LaserCannon} from './base/159_LaserCannon';
import {PerfluorocarbonProduction} from './base/160_PerfluorocarbonProduction';
import {GHGFactoryDistrict} from './base/161_GHGFactoryDistrict';
import {NaturalGasExtraction} from './base/162_NaturalGasExtraction';
import {HydrothermalVents} from './base/163_HydrothermalVents';
import {OzoneFactories} from './base/164_OzoneFactories';
import {ProbioticTreatment} from './base/165_ProbioticTreatment';
import {MirandaLabs} from './base/166_MirandaLabs';
import {MarsLifeScienceInstitute} from './base/167_MarsLifeScienceInstitute';
import {SpeciesCryopreservation} from './base/168_SpeciesCryopreservation';
import {AquiferRelocation} from './corpera/1_AquiferRelocation';
import {SpeculativeMarkets} from './corpera/2_SpeculativeMarkets';
import {ResearchGrantChemical} from './corpera/3_ResearchGrant';
import {SmallSupplyDrop} from './corpera/4_SmallSupplyDrop';
import {HermesMission} from './corpera/5_HermesMission';
import {AssetLiquidation} from './corpera/6_AssetLiquidation';
import {Parasite} from './corpera/7_Parasite';
import {RoboticsExhibition} from './corpera/8_RoboticsExhibition';
import {PatentTrading} from './corpera/9_PatentTrading';
import {PublicRecords} from './corpera/10_PublicRecords';
import {AcidRain} from './corpera/11_AcidRain';
import {PowerFailure} from './corpera/12_PowerFailure';
import {AstrophysicsCenter} from './corpera/13_AstrophysicsCenter';
import {CentaurLandings} from './corpera/14_CentaurLandings';
import {VestaObservatory} from './corpera/15_VestaObservatory';
import {MeasurementDrones} from './corpera/16_MeasurementDrones';
import {AdvancedBiomachinery} from './corpera/17_AdvancedBiomachinery';
import {LongTermEvolutionStudy} from './corpera/18_LongTermEvolutionStudy';
import {ScientificLogs} from './corpera/19_ScientificLogs';
import {ConstructionCenter} from './corpera/20_ConstructionCenter';
import {HomeworldHeadquarters} from './corpera/21_HomeworldHeadquarters';
import {MartianInvestments} from './corpera/22_MartianInvestments';
import {LaserLightsails} from './corpera/23_LaserLightsails';
import {SponsoredResearchFirm} from './corpera/24_SponsoredResearchFirm';
import {JovianSuppliers} from './corpera/25_JovianSuppliers';
import {OlympusArchives} from './corpera/26_OlympusArchives';
import {NeuralEnhancement} from './corpera/27_NeuralEnchancement';
import {Superpolymers} from './corpera/28_Superpolymers';
import {AlloyFactory} from './corpera/29_AlloyFactory';
import {NovaFoundry} from './corpera/30_NovaFoundry';
import {KugelblitzEngine} from './corpera/31_KugelblitzEngine';
import {ExoticMatterReactor} from './corpera/32_ExoticMatterReactor';
import {SolarStation} from './corpera/33_SolarStation';
import {UndergroundTestSite} from './corpera/34_UndergroundTestSite';
import {StandardAlloys} from './corpera/35_StandardAlloys';
import {OverseerCommittee} from './corpera/36_OverseerCommittee';

import {ViralAmeboid} from './corpera/ViralAmeboid';
import {ScientificMegaopolis} from './corpera/ScientificMegaopolis';
import {SteelExports} from './corpera/SteelExports';
import {ProjectAdvancement} from './corpera/ProjectAdvancement';
import {SuccessfulCommerce} from './corpera/SuccessfulCommerce';
import {ScientificSupport} from './corpera/ScientificSupport';
import {GalileanGovernor} from './corpera/GalileanGovernor';
import {MediaConglomerate} from './corpera/MediaConglomerate';
import {MilitaryBase} from './corpera/MilitaryBase';
import {MilitarySpacePort} from './corpera/MilitarySpacePort';
import {MartianBanking} from './corpera/MartianBanking';
import {ChemicalPlant} from './corpera/ChemicalPlant';
import {SaltMine} from './corpera/SaltMine';
import {LuxuryResort} from './corpera/LuxuryResort';
import {ManufacturingPlant} from './corpera/ManufacturingPlant';
import {ContractedConstruction} from './corpera/ContractedConstruction';
import {MolecularScienceLab} from './corpera/MolecularScienceLab';
import {Crowdfunding} from './corpera/Crowdfunding';
import {CommunicationsHub} from './corpera/CommunicationsHub';
import {TitanTradeHub} from './corpera/TitanTradeHub';
import {ConcreteFactory} from './corpera/ConcreteFactory';
import {MountaintopRemoval} from './corpera/MountaintopRemoval';
import {ExplosiveMining} from './corpera/ExplosiveMining';
import {PrintManufacturing} from './corpera/PrintManufacturing';
import {VolcanicFoundry} from './corpera/VolcanicFoundry';
import {Shipyard} from './corpera/Shipyard';
import {UpperMantleBoring} from './corpera/UpperMantleBoring';
import {SeedSuppliers} from './corpera/SeedSuppliers';
import {CashCrops} from './corpera/CashCrops';
import {ExtremePowerEfficiency} from './corpera/ExtremePowerEfficiency';
import {ColdFusionPower} from './corpera/ColdFusionPower';
import {NuclearForcePower} from './corpera/NuclearForcePower';
import {ArtificialMicrobialLife} from './corpera/ArtificialMicrobialLife';
import {AcquiredResearchFirm} from './corpera/AcquiredResearchFirm';
import {InterstellarProbe} from './corpera/InterstallarProbe';
import {TheoryOfEverything} from './corpera/TheoryOfEverything';
import {GreatHarbor} from './corpera/GreatHarbor';
import {FloaterAcquisition} from './venus/FloaterAcquisition';
import {IonicGasSequestration} from './venus/IonicGasSequestration'; // import {ImportedNeutralGasses} from './ImportedNeutralGasses';
import {NearMissRotaryAsteroid} from './venus/NearMissRotaryAsteroid';
import {DwarfPlanetCollision} from './venus/DwarfPlanetCollision';
import {ConvoyToVenus} from './venus/ConvoyToVenus';
import {HugeWaterShipments} from './venus/HugeWaterShipments';
import {NitrogenFromVenus} from './venus/NitrogenFromVenus';
import {AtmosphereLiftingDetonations} from './venus/AtmosphereLiftingDetonations';
import {VenusMiningExpedition} from './venus/VenusMiningExpedition';
import {UltralightFloaters} from './venus/UltralightFloaters';
import {DanuMontesRover} from './venus/DanuMontesRover';
import {CollaborationProject} from './venus/CollaborationProject';
import {ConsistentBombardment} from './venus/ConsistentBombardment';
import {PanSolarMining} from './venus/PanSolarMining';
import {FloatingResearchBase} from './venus/FloatingResearchBase';
import {FloaterDocks} from './venus/FloaterDocks';
import {MesosphereShades} from './venus/MesosphereShades';
import {LowLevelScrappers} from './venus/LowLevelScrappers';
import {CarbonSolidification} from './venus/CarbonSolidifcation';
import {LocalMagneticShielding} from './venus/LocalMagneticShielding';
import {AerialMassDrivers} from './venus/AerialMassDrivers';
import {SkyCommunications} from './venus/SkyCommunications';
import {FloatingBiodomes} from './venus/FloatingBiodomes';
import {EndemicVenusianArchaea} from './venus/EndemicVenusianArchaea';
import {AirborneMicrobes} from './venus/AirborneMicrobes';
import {PHNeutralizers} from './venus/PHNeutralizers';
import {CarbonFixingMicrobes} from './venus/CarbonFixingMicrobes';
import {DesignedFlyers} from './venus/DesignedFlyers';
import {VenusSurfaceDwellers} from './venus/VenusSurfaceDwellers';
import {BioengineeringStudies} from './venus/BioengineeringStudies';
import {VenusBiolab} from './venus/VenusBiolab';
import {LocalDecompression} from './venus/LocalDecompression';
import {UndergroundVenusBase} from './venus/UndergroundVenusBase';
import {TowersOfFreyja} from './venus/TowersOfFreyja';
import {VeneraOutpost} from './venus/VeneraOutpost'; // import {VenusianInvertebrates} from './venus/VenusianInvertebrates';
import {VenusSolarWaystation} from './venus/VenusSolarWaystation';
import {DryIceRings} from './venus/DryIceRings';
import {TheBehemoth} from './venus/TheBehemoth';
import {VenusMiningIndustries} from './venus/VenusMiningIndustries';
import {OvdaCity} from './venus/OvdaCity';
import {CapitalOfVenus} from './venus/CapitalOfVenus';
import {HydrogenInjection} from './venus/HydrogenInjection';
import {AtmosphericSolarCollectors} from './venus/AtmoshpericSolarCollectors'; // import {SpinInducingMassDrivers} from './SpinInducingMassDrivers';
import {SwarmShaders} from './venus/SwarmShaders';
import {VortexEngine} from './venus/VortexEngine';
import {PhotonicMetamaterials} from './venus/PhontoicMetamaterials';
import {NeutralizerDrones} from './venus/NeutralizerDrones';
import {CondenstationCatalysts} from './venus/CondenstationCatalysts';
import {BasaltMining} from './venus/BasaltMining';
import {VenusianFungi} from './venus/VenusianFungi';
import {LakeOfAphrodite} from './venus/LakeOfAphrodite';
import {SuperCarbonCollectors} from './venus/SuperCarbonCollectors';
import {SulphurProcessing} from './venus/SulphurProcessing';
import {StellarCruisers} from './venus/StellarCruisers';
import {DistributionCenter} from './venus/DistirbutionCenter';
import {WorldGovernmentOffices} from './venus/WorldGovernmentOffices';
import {VenusTourism} from './venus/VenusTourism';
import {SurfaceHabs} from './venus/SurfaceHabs';
import {ThemisBiodomes} from './venus/ThemisBiodomes';
import {AtenGroupMining} from './venus/AtenGroupMining';
import {RhizobiomeResearch} from './venus/RhizobiomeResearch';
import {FloatingPowerStation} from './venus/FloatingPowerStation';
import {DeuteriumFusion} from './venus/DeuteriumFusion';
import {VenusPowerPlant} from './venus/VenusPowerPlant';
import {TerrestrialAlliance} from './venus/TerrestrialAlliance';
import {EclipseStation} from './venus/EclipseStation';
import {VenusPlantation} from './venus/VenusPlantation';
import {WorkerDrones} from './venus/WorkerDrones';
import {FloatingArchitechture} from './venus/FloatingArchitechture';
import {BiomechanicalFoliage} from './venus/BiomechanicalFoliage';
import {VenusGeologicalSurvey} from './venus/VenusGeologicalSurvey';
import {IshtarComplex} from './venus/IshtarComplex';
import {CoordinatedRaidChemical} from './colonies/CoordinatedRaidChemcial';
import {SponsoredFlight} from './colonies/SponsoredFlight';
import {LargeTradingFleet} from './colonies/LargeTradingFleet';
import {OuterSolarMission} from './colonies/OuterSolarMission';
import {CommissionedFleet} from './colonies/CommissionedFleet';
import {MarketSiphon} from './colonies/MarketSiphon';
import {PlanetaryTrade} from './colonies/PlanetaryTrade';
import {FloatingTechResearch} from './colonies/FloatingTechResearch';
import {DeepJupiterProbe} from './colonies/DeepJupiterProbe';
import {JovianMoonMapping} from './colonies/JovianMoonMapping';
import {IceMoonCollision} from './colonies/IceMoonCollision';
import {ProductivityQuota} from './colonies/ProductivityQuota';
import {CeresLaunchpad} from './colonies/CeresLaunchpad';
import {AsteroidBeltColony} from './colonies/AsteroidBeltColony';
import {SpaceTethers} from './colonies/SpaceTethers';
import {FloatingColony} from './colonies/FloatingColony';
import {GasGiantHabs} from './colonies/GasGiantHabs';
import {TitanReseachOutpost} from './colonies/TitanResearchOutpost';
import {JovianConstructionYard} from './colonies/JovianConstructionYard';
import {WaterFromTitan} from './colonies/WaterFromTitan';
import {MethaneExports} from './colonies/MethaneExports';
import {GalileanMiningNetwork} from './colonies/GalileanMiningNetwork';
import {TitanFuelStation} from './colonies/TitanFuelStation';
import {JupiterFloatingCity} from './colonies/JupiterFloatingCity';
import {FloaterFacility} from './colonies/FloaterFacility';
import {FloatingTechInvestments} from './colonies/FloatingTechInvestments';
import {Primates} from './base/Primates';
import {ColonySuppliers} from './colonies/ColonySuppliers';
import {FuelSubsidies} from './colonies/FuelSubsidies';
import {RemoteTestZone} from './colonies/RemoteTestZone';
import {WaypointColony} from './colonies/WaypointColony';
import {PrivateColony} from './colonies/PrivateColony';
import {RemoteMiningBase} from './colonies/RemoteMiningBase';
import {ResearchMissions} from './colonies/ResearchMissions';
import {VenusTradeStation} from './VenusTradeStation';
import {RimPopulationCenter} from './colonies/RimPopulationCenter';
import {BusinessColony} from './colonies/BusinessColony';
import {SelfSufficientColony} from './colonies/SelfSufficientColony';
import {IndustrialColony} from './colonies/IndustrialColony';
import {DomeFarmingColony} from './colonies/DomeFarmingColony';
import {EnergyBeamColony} from './colonies/EnergyBeamColony';
import {KuiperBeltColony} from './colonies/KuiperBeltColony';
import {ThermalReservior} from './colonies/ThermalReservior';
import {SlumCity} from './colonies/SlumCity';
import {LunarPort} from './colonies/LunarPort';
import {MuseumOfLuna} from './colonies/MuseumOfLuna';
import {LunarResort} from './colonies/LunarResort';
import {LunaColonizationInvestments} from './colonies/LunaColonizationInvestments';
import {MicrogravityLab} from './colonies/MicrogravityLab';
import {MilitarySpaceStation} from './colonies/MilitarySpaceStation';
import {LunarH3Mining} from './colonies/LunarH3Mining';
import {ColonyMiningInfrastructure} from './colonies/ColonyMiningInfrastructure';
import {CassiniEnterprises} from './colonies/CassiniEnterprises';
import {HemeraBunker} from './colonies/HemeraBunker';
import {OrbitalBiodomes} from './colonies/OrbitalBiodomes';
import {AzaleaBushes} from './colonies/AzaleaBushes';
import {Wildflowers} from './colonies/Wildflowers';
import {ColonySpaceMirrors} from './colonies/ColonySpaceMirrors';
import {LunarPowerGrid} from './colonies/LunarPowerGrid';
import {ProtoDysonSwarm} from './colonies/ProtoDysonSwarm';
import {EarthEmbassyChemical} from './colonies/EarthEmbassyChemical';
import {MercurialSunshade} from './colonies/MercurialSunshade';
import {HighOrbitResearchStation} from './colonies/HighOrbitResearchStation';
import {TerrestrialResearchSummit} from './colonies/TerrestrialResearchSummit';
import {ArcticEndoliths} from './colonies/ArcticEndoliths';
import {HyperExtremophileFungi} from './colonies/HyperExtremophileFungi';
import {BiodiversityBoom} from './colonies/BiodiversityBoom';
import {ColonyReforms} from './colonies/ColonyReforms';
import {DirectedSabotageImpact} from './turmoil/DirectedSabotageImpact';
import {FusionBombing} from './turmoil/FusionBombing';
// import {DemocraticReform} from './DemocraticReform';
import {MediaManipulation} from './turmoil/MediaManipulation';
import {InaugurationCeremony} from './turmoil/InaugurationCeremony';
import {PoliticalDonations} from './turmoil/PoliticalDonations';
import {DesignedOrganisms} from './turmoil/DesignedOrganisms';
import {TellurianEcosystems} from './turmoil/TellurianEcosystems';
import {Preservationism} from './turmoil/Preservationism';
import {InterplanetaryDiplomacy} from './turmoil/InterplanetaryDiplomacy';
import {WorldGovernmentDiplomats} from './turmoil/WorldGovernmentDiplomats';
import {HybridVessels} from './turmoil/HybridVessels';
import {ShortTermBonuses} from './turmoil/ShortTermBonuses';
import {MartianResearchNetwork} from './turmoil/MartianResearchNetwork';
import {EnergyLab} from './turmoil/EnergyLab';
// import {StimulusPrograms} from './StimulusPrograms',
import {CommitteeCoalition} from './turmoil/CommitteeCoalition';
import {LegalFirm} from './turmoil/LegalFirm';
import {Kickbacks} from './turmoil/Kickbacks';
import {RemoteAreaSuppliers} from './turmoil/RemoteAreaSuppliers';
import {MedicalInstitute} from './turmoil/MedicalInstitute';
import {MicrobialSupport} from './turmoil/MicrobialSupport';
import {VenusSocietySupport} from './turmoil/VenusSocietySupport';
// import {PrimalNationalPark} from './PrimalNationalPark';
import {CorporateCitadel} from './turmoil/CorporateCitadel';
import {PreservationistSettlement} from './turmoil/PreservationistSettlement';
import {AuthoritarianState} from './turmoil/AuthoritarianState';
import {IndustryDevelopment} from './turmoil/IndustryDevelopment';
import {AcquiredBioengineeringFirm} from './turmoil/AcquiredBioengineeringFirm';
import {IonizingRadiationBeam} from './turmoil/IonizingRadiationBeam';
import {ReducedSnowCoverage} from './turmoil/ReducedSnowCoverage';
import {SocialWelfare} from './turmoil/SocialWelfare';
import {ExoplanetLanding} from './turmoil/ExoplanetLanding';
import {FirstMaritanMemorial} from './turmoil/FirstMartianMemorial';
import {TerraformingUnion} from './turmoil/TerraformingUnion';
import {AcquiredConsultingFirm} from './turmoil/AcquiredConsultingFirm';
import {ResearchBase} from './preludes/1_ResearchBase';
import {HeavyMetalComet} from './preludes/2_HeavyMetalComet';
import {LegalExperts} from './preludes/3_LegalExperts';
import {MaterialLoan} from './preludes/4_MaterialLoan';
import {ResearchLoan} from './preludes/5_ResearchLoan';
import {EntertainmentIndustry} from './preludes/6_EntertainmentIndustry';
import {CoerciveDealings} from './preludes/7_CoerciveDealings';
import {AquaponicsFacility} from './preludes/8_AquaponicsFacility';
import {NoctisSettlement} from './preludes/9_NoctisSettlement';
import {WildlifeSponsors} from './preludes/10_WildlifeSponsors';
import {BlueprintAI} from './preludes/11_BlueprintAI';
import {Bioplastics} from './preludes/12_Bioplastics';
import {InfrastructureSupport} from './preludes/13_InfrastructureSupport';
import {IndustryAllies} from './preludes/14_IndustryAllies';
import {NuclearFuelMining} from './preludes/15_NuclearFuelMining';
import {LunarMiningIndustries} from './preludes/16_LunarMiningIndustries';
import {LaserMining} from './preludes/17_LaserMining';
import {CyanobacteriaPods} from './preludes/18_CyanobacteriaPods';
import {GlacialAlgae} from './preludes/19_GlacialAlgae';
import {AmmoniaAsteroid} from './preludes/20_AmmoniaAsteroid';
import {AdaptedVascularGreenery} from './preludes/21_AdaptedVascularGreenery';
import {EcologicalReserve} from './preludes/22_EcologicalReserve';
import {ProtistLifeforms} from './preludes/23_ProtistLifeforms';
import {PowerCore} from './preludes/24_PowerCore';
import {EnergyBeam} from './preludes/25_EnergyBeam';
import {ThermalPlant} from './preludes/26_ThermalPlant';
import {AdvancedHeatingTech} from './preludes/27_AdvancedHeatingTech';
import {TerritoryOccupation} from './preludes/28_TerritoryOccupation';
import {RareMineralReserve} from './preludes/29_RareMineralReserve';
import {CorporateEspionage} from './preludes/30_CorporateEspionage';
import {VenusFirstChemical} from './preludes/31_VenusFirstChemical';
import {AirScrappingOperations} from './preludes/32_AirScrappingOperations';
import {TerrestrialPlanetMission} from './preludes/33_TerrestrialPlanetMission';
import {HydrogenBombardmentChemical} from './preludes/34_HydrogenBombardmentChemical';
import {ExperimentalOrganisms} from './preludes/35_ExperimentalOrganisms';
import {VenusianIndustries} from './preludes/36_VenusianIndustries';
import {VenusGHGExports} from './preludes/37_VenusGHGExports';
import {SisterPlanetResearch} from './preludes/38_SisterPlanetResearch';
import {FloatingCity} from './preludes/39_FloatingCity';
import {EarlyColony} from './preludes/40_EarlyColony';
import {IsolatedEcologyResearch} from './preludes/41_IsolatedEcologyResearch';
import {JovianProjectBase} from './preludes/42_JovianProjectBase';
import {InterplanetaryTradingPort} from './preludes/43_InterplanetaryTradingPort';
import {TradingNetwork} from './preludes/44_TradingNetwork';
import {GasMine} from './preludes/45_GasMine';
import {PhobosSpacePort} from './preludes/46_PhobosSpacePort';
import {TitanSettlement} from './preludes/47_TitanSettlement';
import {TradeInfrastructure} from './preludes/48_TradeInfrastructure';

import {CommitteeRepresentative} from './preludes/CommitteeRepresentative';
import {ByElectionChemical} from './preludes/ByElectionChemical';
import {ExecutiveOrderChemical} from './preludes/ExecutiveOrderChemical';
// import {ContractedIntelligenceAgency} from './ContractedIntelligenceAgency';
import {PartyInsiders} from './preludes/PartyInsiders';
import {PoliticalUprisingChemical} from './preludes/PoliticalUprisingChemical';
import {MartianRepublic} from './preludes/MartianRepublic';
import {IntellectualistMovement} from './globalevents/IntellectualistMovement';
import {CorporateAlliance} from './preludes/CorporateAlliance';
import {GreenMarsInitiative} from './preludes/GreenMarsInitiative';
import {PreservationistCampaign} from './preludes/PreservationistCampaign';
import {HeatFirstInitiative} from './globalevents/HeatFirstInitiative';
import {LandDelegation} from './globalevents/LandDelegation';
import {IntellectualistMovements} from './preludes/IntellectualistMovements';
import {MandatoryInsurance} from './globalevents/MandatoryInsurance';
import {TradeEmbargo} from './globalevents/TradeEmbargo';
import {Insurgency} from './globalevents/Insurgency';
import {LaborRevolt} from './globalevents/LaborRevolt';
import {InterplanetaryCommunities} from './globalevents/InterplanetaryCommunities';
import {ChemicalPollution} from './globalevents/ChemicalPollution';
import {PesticideApplication} from './globalevents/PesticideApplication';
import {Cyberattacks} from './globalevents/Cyberattacks';
import {MiningIndustries} from './globalevents/MiningIndustries';
import {Famine} from './globalevents/Famine';
import {NanotechInnovation} from './globalevents/NanotechInnovation';
import {PowerSurplus} from './globalevents/PowerSurplus';
import {LandRun} from './globalevents/LandRun';
import {EradicationOfGeneticIllness} from './globalevents/EradicationOfGeneticIllness';
import {MagneticFieldFailure} from './globalevents/MagneticFieldFailure';
import {FoodSupply} from './globalevents/FoodSupply';
import {ConstitutionalReformation} from './globalevents/ConstitutionalReformation';
import {EcologyProjects} from './globalevents/EcologyProjects';
import {EcosystemDisruption} from './globalevents/EcosystemDisruption';
import {RedUprising} from './globalevents/RedUprising';
import {WildfiresEvent} from './globalevents/WildfiresEvent';
import {EgalitarianMovements} from './globalevents/EgalitarianMovements';
import {MarsStockExchange} from './globalevents/MarsStockExchange';
import {ColonizationOfMercury} from './globalevents/ColonizationOfMercury';
import {RevisedPatentLaw} from './globalevents/RevisedPatentLaw';
import {EcologicalSupport} from './globalevents/EcologicalSupport';
import {AbstinanceBonus} from './globalevents/AbstinanceBonus';
import {RedTourism} from './globalevents/RedTourism';
import {PreferentialLoans} from './globalevents/PreferentialLoans';
import {SevereMarsquake} from './globalevents/SevereMarsquake';
import {ExtinctionEvent} from './globalevents/ExtinctionEvent';
import {SpaceTravelLimitations} from './globalevents/SpaceTravelLimitations';
import {RimShortages} from './globalevents/RimShortages';
import {MicrobialBoom} from './globalevents/MicrobialBoom';
import {TechnologicalRegression} from './globalevents/TechnologicalRegression';
import {PowerGenerationSubsidies} from './globalevents/PowerGenerationSubsidies';
import {TaxationOfVenus} from './globalevents/TaxationOfVenus';
import {VenusMining} from './globalevents/VenusMining';
import {DegredationOfVenus} from './globalevents/DegredationOfVenus';
import {FloaterTechnologyEvent} from './globalevents/FloaterTechnologyEvent';
import {VenusianEcosystems} from './globalevents/VenusianEcosystems';
import {SocietiesOfVenus} from './globalevents/SocietiesOfVenus';
import {AnticorrosiveMaterials} from './globalevents/AnticorrosiveMaterials';
import {LowlandFlooding} from './globalevents/LowlandFlooding';
import {CommunityServicesEvent} from './globalevents/CommunityServicesEvent';
import {PowerFailureEvent} from './globalevents/PowerFailureEvent';
import {InterstallarColonization} from './globalevents/InterstallarColonization';
import {ColonyProductivity} from './globalevents/ColonyProductivity';
import {CommandEconomy} from './globalevents/CommandEconomy';
import {JovianWar} from './globalevents/JovianWar';
import {RefugeeCrisis} from './globalevents/RefugeeCrisis';
import {EconomicDepression} from './globalevents/EconomicDepression';

//andy added
import {PublicSpacelineChemical} from './pathfinders/PublicSpaceline';

//andy RB
import {BactoviralResearchRebalance} from './rebalance/Project_BactoviralResearchRB';
import {AdvancedAlloysRebalance} from './rebalance/Project_AdvancedAlloysRB';
import {AerobrakedAmmoniaAsteroidRebalance} from './rebalance/Project_AerobrakedAmmoniaAsteroidRB';
import {AsteroidHollowingRebalance } from './rebalance/Project_AsteroidHollowingRB';
import { BlackPolarDustRebalance } from './rebalance/Project_BlackPolarDustRB';
import { BuildingIndustriesRebalance } from './rebalance/Project_BuildingIndustriesRB';
import { CartelRebalance } from './rebalance/Project_CartelRB';
import { CloudSeedingRebalance } from './rebalance/Project_CloudSeedingRB';
import { CommunityServicesRebalance } from './rebalance/Project_CommunityServicesRB';
import { CorporateStrongholdRebalance } from './rebalance/Project_CorporateStrongholdRB';
import { CuttingEdgeTechnologyRebalance } from './rebalance/Project_CuttingEdgeTechnologyRB';
import { EarthCatapultRebalance } from './rebalance/Project_EarthCatapultRB';
import { EarthOfficeRebalance } from './rebalance/Project_EarthOfficeRB';
import { EnergyMarketRebalance } from './rebalance/Project_EnergyMarketRB';
import { ExtractorBalloonsRebalance } from './rebalance/Project_ExtractorBalloonsRB';
import { EnergySavingRebalance } from './rebalance/Project_EnergySavingRB';
import { ForcedPrecipitationRebalance } from './rebalance/Project_ForcedPrecipitationRB';
import { GHGImportFromVenusRebalance } from './rebalance/Project_GHGImportFromVenusRB';
import { GMOContractRebalance } from './rebalance/Project_GMOContractRB';
import { HackerRebalance } from './rebalance/Project_HackersRB';
import { HeatTrappersRebalance } from './rebalance/Project_HeatTrappersRB';
import { IndustrialCenterRebalance } from './rebalance/Project_IndustrialCenterAresRB';
import { InsectsRebalance } from './rebalance/Project_InsectsRB';
import { JetStreamMicroscrappersRebalance } from './rebalance/Project_JetStreamMicroscrappersRB';
import { MarsUniversityRebalance } from './rebalance/Project_MarsUniversityRB';
import { MassConverterRebalance } from './rebalance/Project_MassConverterRB';
import { MeatIndustryRebalance } from './rebalance/Project_MeatIndustryRB';
import { MicroMillsRebalance } from './rebalance/Project_MicroMillsRB';
import { OrbitalCleanupRebalance } from './rebalance/Project_OrbitalCleanupRB';
import { OutdoorSportsRebalance } from './rebalance/Project_OutdoorSportsRB';
import { ReleaseOfInertGasesRebalance } from './rebalance/Project_ReleaseOfInertGasesRB';
import { ResearchOutpostRebalance } from './rebalance/Project_ResearchOutpostRB';
import { RotatorImpactsRebalance } from './rebalance/Project_RotatorImpactsRB';
import { SkyDocksRebalance } from './rebalance/Project_SkyDocksRB';
import { SnowAlgaeRebalance } from './rebalance/Project_SnowAlgaeRB';
import { SoilFactoryRebalance } from './rebalance/Project_SoilFactoryRB';
import { SolarPowerRebalance } from './rebalance/Project_SolarPowerRB';
import { SpinoffDepartmentRebalance } from './rebalance/Project_SpinoffDepartmentRB';
import { StratopolisRebalance } from './rebalance/Project_StratopolisRB';
import { StripMineRebalance } from './rebalance/Project_StripMineRB';
import { TitanAirScrappingRebalance } from './rebalance/Project_TitanAirScrappingRB';
import { TopsoilContractRebalance } from './rebalance/Project_TopsoilContractRB';
import { TropicalResortRebalance } from './rebalance/Project_TropicalResortRB';
import { TollStationRebalance } from './rebalance/Project_TollStationRB';
import { UndergroundCityRebalance } from './rebalance/Project_UndergroundCityRB';
import { UndergroundDetonationsRebalance } from './rebalance/Project_UndergroundDetonationsRB';
import { ViralEnhancersRebalance } from './rebalance/Project_ViralEnhancersRB';
import { WarpDriveRebalance } from './rebalance/Project_WarpDriveRB';
import { ZeppelinsRebalance } from './rebalance/Project_ZeppelinsRB';

//andy preludes
import { BiofuelsRebalance } from './rebalance/Prelude_BiofuelsRB';
import { BiosphereSupportRebalance } from './rebalance/Prelude_BiosphereSupportRB';
import { DomeFarmingRebalance } from './rebalance/Prelude_DomeFarmingRB';
import { EarlySettlementRebalance } from './rebalance/Prelude_EarlySettlementRB';
import { EccentricSponsorRebalance } from './rebalance/Prelude_EccentricSponsorRB';
import { GalileanMiningRebalance } from './rebalance/Prelude_GalileanMiningRB';
import { HugeAsteroidRebalance } from './rebalance/Prelude_HugeAsteroidRB';
import { IoResearchOutpostRebalance } from './rebalance/Prelude_IoResearchOutpostRB';
import { LoanRebalance } from './rebalance/Prelude_LoanRB';
import { MartianIndustriesRebalance } from './rebalance/Prelude_MartianIndustriesRB';
import { MetalsCompanyRebalance } from './rebalance/Prelude_MetalsCompanyRB';
import { MoholeRebalance } from './rebalance/Prelude_MoholeRB';
import { MoholeExcavationRebalance } from './rebalance/Prelude_ MoholeExcavationRB';
import { NitrogenShipmentRebalance } from './rebalance/Prelude_NitrogenShipmentRB';
import { OrbitalConstructionYardRebalance } from './rebalance/Prelude_OrbitalConstructionYardRB';
import { PolarIndustriesRebalance } from './rebalance/Prelude_PolarIndustriesRB';
import { SelfSufficientSettlementRebalance } from './rebalance/Prelude_SelfSufficientSettlementRB';
import { SmeltingPlantRebalance } from './rebalance/Prelude_SmeltingPlantRB';
import { SocietySupportRebalance } from './rebalance/Prelude_SocietySupportRB';

//andy corps
import { AphroditeRebalanced } from './rebalance/Corp_AphroditeRB';
import { ArcadianCommunitiesRebalanced } from './rebalance/Corp_ArcadianCommunitiesRB';
import { ArklightRebalance } from './rebalance/Corp_ArklightRB';
import { AstrodrillRebalance } from './rebalance/Corp_AstrodrillRB';
import { CelesticRebalance } from './rebalance/Corp_CelesticRB';
import { CheungShingMARSRebalance } from './rebalance/Corp_CheungShingMARSRB';
import { FactorumRebalanced } from './rebalance/Corp_FactorumRB';
import { HelionRebalance } from './rebalance/Corp_HelionRB';
import { InterplanetaryCinematicsRebalance } from './rebalance/Corp_InterplanetaryCinematicsRB';
import { InventrixRebalance } from './rebalance/Corp_InventrixRB';
import { MiningGuildRebalance } from './rebalance/Corp_MiningGuildRB';
import { MorningStarIncRebalance } from './rebalance/Corp_MorningStarIncRB';
import { PhoboLogRebalance } from './rebalance/Corp_PhoboLogRB';
import { PointLunaRebalance } from './rebalance/Corp_PointLunaRB';
import { PolyphemosRebalance } from './rebalance/Corp_PolyphemosRB';
import { PoseidonRebalance } from './rebalance/Corp_PoseidonRB';
import { PristarRebalance } from './rebalance/Corp_PristarRB';
import { RecyclonRebalance } from './rebalance/Corp_ RecyclonRB';
import { RobinsonIndustriesRebalance } from './rebalance/Corp_RobinsonIndustriesRB';
import { SpliceRebalance } from './rebalance/Corp_SpliceRB';
import { StormCraftIncorporatedRebalance } from './rebalance/Corp_StormCraftIncorporatedRB';
import { TerralabsResearchRebalance } from './rebalance/Corp_TerralabsResearchRB';
import { TharsisRepublicRebalance } from './rebalance/Corp_TharsisRepublicRB';





export const CHEMICAL_CARD_MANIFEST = new ModuleManifest({
  module: 'chemical',
  corporationCards: {

    //andy added
    [CardName.APHRODITE_RB]: {Factory: AphroditeRebalanced, compatibility: 'venus'},
    [CardName.ARCADIAN_COMMUNITIES_RB]: {Factory: ArcadianCommunitiesRebalanced, compatibility: 'promo'},
    [CardName.ARKLIGHT_RB]: {Factory: ArklightRebalance, compatibility: 'colonies'},
    [CardName.ASTRODRILL_RB]: {Factory: AstrodrillRebalance, compatibility: 'promo'},
    [CardName.CELESTIC_RB]: {Factory: CelesticRebalance, compatibility: 'venus'},
    [CardName.CHEUNG_SHING_MARS_RB]: {Factory: CheungShingMARSRebalance, compatibility: 'prelude'},
    [CardName.FACTORUM_RB]: {Factory: FactorumRebalanced, compatibility: 'promo'},
    [CardName.HELION_RB]: {Factory: HelionRebalance},
    [CardName.INTERPLANETARY_CINEMATICS_RB]: {Factory: InterplanetaryCinematicsRebalance},
    [CardName.INVENTRIX_RB]: {Factory: InventrixRebalance},
    [CardName.MINING_GUILD_RB]: {Factory: MiningGuildRebalance},
    [CardName.MORNING_STAR_INC_RB]: {Factory: MorningStarIncRebalance, compatibility: 'venus'},
    [CardName.PHOBOLOG_RB]: {Factory: PhoboLogRebalance},
    [CardName.POINT_LUNA_RB]: {Factory: PointLunaRebalance, compatibility: 'prelude'},
    [CardName.POLYPHEMOS_RB]: {Factory: PolyphemosRebalance, compatibility: 'colonies'},
    [CardName.POSEIDON_RB]: {Factory: PoseidonRebalance, compatibility: 'colonies'},
    [CardName.PRISTAR_RB]: {Factory: PristarRebalance, compatibility: 'turmoil'},
    [CardName.RECYCLON_RB]: {Factory: RecyclonRebalance, compatibility: 'promo'},
    [CardName.ROBINSON_INDUSTRIES_RB]: {Factory: RobinsonIndustriesRebalance, compatibility: 'prelude'},
    [CardName.SPLICE_RB]: {Factory: SpliceRebalance, compatibility: 'promo'},
    [CardName.STORMCRAFT_INCORPORATED_RB]: {Factory: StormCraftIncorporatedRebalance, compatibility: 'colonies'},
    [CardName.TERRALABS_RESEARCH_RB]: {Factory: TerralabsResearchRebalance, compatibility: 'turmoil'},
    [CardName.THARSIS_REPUBLIC_RB]: {Factory: TharsisRepublicRebalance},
    
  },
  preludeCards: {
    [CardName.RESEARCH_BASE]: {Factory: ResearchBase},
    [CardName.HEAVY_METAL_COMET]: {Factory: HeavyMetalComet},
    [CardName.LEGAL_EXPERTS]: {Factory: LegalExperts},
    [CardName.MATERIAL_LOAN]: {Factory: MaterialLoan},
    [CardName.RESEARCH_LOAN]: {Factory: ResearchLoan},
    [CardName.ENTERTAINMENT_INDUSTRY]: {Factory: EntertainmentIndustry},
    [CardName.COERCIVE_DEALINGS]: {Factory: CoerciveDealings},
    [CardName.AQUAPONICS_FACILITY]: {Factory: AquaponicsFacility},
    [CardName.NOCTIS_SETTLEMENT]: {Factory: NoctisSettlement},
    [CardName.WILDLIFE_SPONSORS]: {Factory: WildlifeSponsors},
    [CardName.BLUEPRINT_AI]: {Factory: BlueprintAI},
    [CardName.BIOPLASTICS]: {Factory: Bioplastics},
    [CardName.INFRASTRUCTURE_SUPPORT]: {Factory: InfrastructureSupport},
    [CardName.INDUSTRY_ALLIES]: {Factory: IndustryAllies},
    [CardName.NUCLEAR_FUEL_MINING]: {Factory: NuclearFuelMining},
    [CardName.LUNAR_MINING_INDUSTRIES]: {Factory: LunarMiningIndustries},
    [CardName.LASER_MINING]: {Factory: LaserMining},
    [CardName.CYANOBACTERIA_PODS]: {Factory: CyanobacteriaPods},
    [CardName.GLACIAL_ALGAE]: {Factory: GlacialAlgae},
    [CardName.AMMONIA_ASTEROID]: {Factory: AmmoniaAsteroid},
    [CardName.ADAPTED_VASCULAR_GREENERY]: {Factory: AdaptedVascularGreenery},
    [CardName.ECOLOGICAL_RESERVE]: {Factory: EcologicalReserve},
    [CardName.PROTIST_LIFEFORMS]: {Factory: ProtistLifeforms},
    [CardName.POWER_CORE]: {Factory: PowerCore},
    [CardName.ENERGY_BEAM]: {Factory: EnergyBeam},
    [CardName.THERMAL_PLANT]: {Factory: ThermalPlant},
    [CardName.ADVANCED_HEATING_TECH]: {Factory: AdvancedHeatingTech},
    [CardName.TERRITORY_OCCUPATION]: {Factory: TerritoryOccupation},
    [CardName.RARE_MINERAL_RESERVE]: {Factory: RareMineralReserve},
    [CardName.CORPORATE_ESPIONAGE]: {Factory: CorporateEspionage},
    [CardName.VENUS_FIRST_CHEMICAL]: {Factory: VenusFirstChemical, compatibility: 'venus'},
    [CardName.AIR_SCRAPPING_OPERATIONS]: {Factory: AirScrappingOperations, compatibility: 'venus'},   
    [CardName.TERRESTRIAL_PLANET_MISSION]: {Factory: TerrestrialPlanetMission, compatibility: 'venus'}, 
    [CardName.HYDROGEN_BOMBARDMENT_CHEMICAL]: {Factory: HydrogenBombardmentChemical, compatibility: 'venus'},
    [CardName.EXPERIMENTAL_ORGANISMS]: {Factory: ExperimentalOrganisms, compatibility: 'venus'},
    [CardName.VENUSIAN_INDUSTRIES]: {Factory: VenusianIndustries, compatibility: 'venus'},
    [CardName.VENUS_GHG_EXPORTS]: {Factory: VenusGHGExports, compatibility: 'venus'},
    [CardName.SISTER_PLANET_RESEARCH]: {Factory: SisterPlanetResearch, compatibility: 'venus'},
    [CardName.FLOATING_CITY]: {Factory: FloatingCity, compatibility: 'venus'},
    [CardName.EARLY_COLONY]: {Factory: EarlyColony, compatibility: 'colonies'},
    [CardName.ISOLATED_ECOLOGY_RESEARCH]: {Factory: IsolatedEcologyResearch, compatibility: 'colonies'},
    [CardName.JOVIAN_PROJECT_BASE]: {Factory: JovianProjectBase, compatibility: 'colonies'},
    [CardName.INTERPLANETARY_TRADING_PORT]: {Factory: InterplanetaryTradingPort, compatibility: 'colonies'},
    [CardName.TRADING_NETWORK]: {Factory: TradingNetwork, compatibility: 'colonies'},
    [CardName.GAS_MINE]: {Factory: GasMine, compatibility: 'colonies'},
    [CardName.PHOBOS_SPACE_PORT]: {Factory: PhobosSpacePort, compatibility: 'colonies'},
    [CardName.TITAN_SETTLEMENT]: {Factory: TitanSettlement, compatibility: 'colonies'},
    [CardName.TRADE_INFRASTRUCTURE]: {Factory: TradeInfrastructure, compatibility: 'colonies'},
   
    [CardName.COMMITTEE_REPRESENTATIVE]: {Factory: CommitteeRepresentative, compatibility: 'turmoil'},
    [CardName.BY_ELECTION_CHEMICAL]: {Factory: ByElectionChemical, compatibility: 'turmoil'},
    [CardName.EXECUTIVE_ORDER_CHEMICAL]: {Factory: ExecutiveOrderChemical, compatibility: 'turmoil'},
    // [CardName.CONTRACTED_INTELLIGENCE_AGENCY]: {Factory: ContractedIntelligenceAgency, compatibiliy: 'turmoil'},
    [CardName.PARTY_INSIDERS]: {Factory: PartyInsiders, compatibility: 'turmoil'},
    [CardName.POLITICAL_UPRISING_CHEMICAL]: {Factory: PoliticalUprisingChemical, compatibility: 'turmoil'},
    [CardName.MARTIAN_REPUBLIC]: {Factory: MartianRepublic, compatibility: 'turmoil'},
    [CardName.INTELLECTUALIST_MOVEMENT]: {Factory: IntellectualistMovement, compatibility: 'turmoil'},
    [CardName.CORPORATE_ALLIANCE]: {Factory: CorporateAlliance, compatibility: 'turmoil'},
    [CardName.GREEN_MARS_INITIATIVE]: {Factory: GreenMarsInitiative, compatibility: 'turmoil'},
    [CardName.PRESERVATIONIST_CAMPAIGN]: {Factory: PreservationistCampaign, compatibility: 'turmoil'},
    [CardName.HEAT_FIRST_INITIATIVE]: {Factory: HeatFirstInitiative, compatibility: 'turmoil'},

    //andy preludes
    [CardName.BIOFUELS_RB]: {Factory: BiofuelsRebalance, compatibility: 'prelude'},
    [CardName.BIOSPHERE_SUPPORT_RB]: {Factory: BiosphereSupportRebalance, compatibility: 'prelude'},
    [CardName.DOME_FARMING_RB]: {Factory: DomeFarmingRebalance, compatibility: 'prelude'},
    [CardName.EARLY_SETTLEMENT_RB]: {Factory: EarlySettlementRebalance, compatibility: 'prelude'},
    [CardName.ECCENTRIC_SPONSOR_RB]: {Factory: EccentricSponsorRebalance, compatibility: 'prelude'},
    [CardName.GALILEAN_MINING_RB]: {Factory: GalileanMiningRebalance, compatibility: 'prelude'},
    [CardName.HUGE_ASTEROID_RB]: {Factory: HugeAsteroidRebalance, compatibility: 'prelude'},
    [CardName.IO_RESEARCH_OUTPOST_RB]: {Factory: IoResearchOutpostRebalance, compatibility: 'prelude'},
    [CardName.LOAN_RB]: {Factory: LoanRebalance, compatibility: 'prelude'},
    [CardName.MARTIAN_INDUSTRIES_RB]: {Factory: MartianIndustriesRebalance, compatibility: 'prelude'},
    [CardName.METALS_COMPANY_RB]: {Factory: MetalsCompanyRebalance, compatibility: 'prelude'},
    [CardName.MOHOLE_RB]: {Factory: MoholeRebalance, compatibility: 'prelude'},
    [CardName.MOHOLE_EXCAVATION_RB]: {Factory: MoholeExcavationRebalance, compatibility: 'prelude'},
    [CardName.NITROGEN_SHIPMENT_RB]: {Factory: NitrogenShipmentRebalance, compatibility: 'prelude'},
    [CardName.ORBITAL_CONSTRUCTION_YARD_RB]: {Factory: OrbitalConstructionYardRebalance, compatibility: 'prelude'},
    [CardName.POLAR_INDUSTRIES_RB]: {Factory: PolarIndustriesRebalance, compatibility:'prelude'},
    [CardName.SELF_SUFFICIENT_SETTLEMENT_RB]: {Factory: SelfSufficientSettlementRebalance, compatibility: 'prelude'},
    [CardName.SMELTING_PLANT_RB]: {Factory: SmeltingPlantRebalance, compatibility: 'prelude'},
    [CardName.SOCIETY_SUPPORT_RB]: {Factory: SocietySupportRebalance, compatibility: 'prelude'},
  },
  projectCards: {
    //Andy added
    [CardName.PUBLIC_SPACELINE_CHEMICAL]: {Factory: PublicSpacelineChemical, compatibility: 'pathfinders'},

    //Andy rebalance
    [CardName.BACTOVIRAL_RESEARCH_RB]: {Factory: BactoviralResearchRebalance, compatibility: 'promo'},
    [CardName.ADVANCED_ALLOYS_RB]: {Factory: AdvancedAlloysRebalance,},
    [CardName.AEROBRAKED_AMMONIA_ASTEROID_RB]: {Factory: AerobrakedAmmoniaAsteroidRebalance,},
    [CardName.ASTEROID_HOLLOWING_RB]: {Factory: AsteroidHollowingRebalance, compatibility: 'promo'},
    [CardName.BLACK_POLAR_DUST_RB]: {Factory: BlackPolarDustRebalance},
    [CardName.BUILDING_INDUSTRIES_RB]: {Factory: BuildingIndustriesRebalance},
    [CardName.CARTEL_RB]: {Factory: CartelRebalance},
    [CardName.CLOUD_SEEDING_RB]: {Factory: CloudSeedingRebalance},
    [CardName.COMMUNITY_SERVICES_RB]: {Factory: CommunityServicesRebalance,  compatibility: 'colonies'},
    [CardName.CORPORATE_STRONGHOLD_RB]: {Factory: CorporateStrongholdRebalance},
    [CardName.CUTTING_EDGE_TECHNOLOGY_RB]: {Factory: CuttingEdgeTechnologyRebalance, compatibility: 'promo'},
    [CardName.EARTH_CATAPULT_RB]: {Factory: EarthCatapultRebalance},
    [CardName.EARTH_OFFICE_RB]: {Factory: EarthOfficeRebalance},
    [CardName.ENERGY_MARKET_RB]: {Factory: EnergyMarketRebalance, compatibility: 'promo'},    
    [CardName.ENERGY_SAVING_RB]: {Factory: EnergySavingRebalance},
    [CardName.EXTRACTOR_BALLOONS_RB]: {Factory: ExtractorBalloonsRebalance, compatibility: 'venus'},
    [CardName.FORCED_PRECIPITATION_RB]: {Factory: ForcedPrecipitationRebalance, compatibility: 'venus'},
    [CardName.GHG_IMPORT_FROM_VENUS_RB]: {Factory: GHGImportFromVenusRebalance, compatibility: 'venus'},
    [CardName.GMO_CONTRACT_RB]: {Factory: GMOContractRebalance, compatibility: 'turmoil'},
    [CardName.HACKERS_RB]: {Factory: HackerRebalance, compatibility: 'corpera'},
    [CardName.HEAT_TRAPPERS_RB]: {Factory: HeatTrappersRebalance},
    [CardName.INDUSTRIAL_CENTER_RB]: {Factory: IndustrialCenterRebalance, compatibility: 'corpera'},
    [CardName.INSECTS_RB]: {Factory: InsectsRebalance},
    [CardName.JET_STREAM_MICROSCRAPPERS_RB]: {Factory: JetStreamMicroscrappersRebalance, compatibility: 'venus'},
    [CardName.MARS_UNIVERSITY_RB]: {Factory: MarsUniversityRebalance, compatibility: 'corpera'},
    [CardName.MASS_CONVERTER_RB]: {Factory: MassConverterRebalance, compatibility: 'corpera'},
    [CardName.MEAT_INDUSTRY_RB]: {Factory: MeatIndustryRebalance, compatibility: 'promo'},
    [CardName.MICRO_MILLS_RB]: {Factory: MicroMillsRebalance},
    [CardName.ORBITAL_CLEANUP_RB]: {Factory: OrbitalCleanupRebalance, compatibility: 'promo'},
    [CardName.OUTDOOR_SPORTS_RB]: {Factory: OutdoorSportsRebalance, compatibility: 'promo'},
    [CardName.RELEASE_OF_INERT_GASES_RB]: {Factory: ReleaseOfInertGasesRebalance},
    [CardName.RESEARCH_OUTPOST_RB]: {Factory: ResearchOutpostRebalance},
    [CardName.ROTATOR_IMPACTS_RB]: {Factory: RotatorImpactsRebalance, compatibility: 'venus'},
    [CardName.SKY_DOCKS_RB]: {Factory: SkyDocksRebalance, compatibility: 'colonies'},
    [CardName.SNOW_ALGAE_RB]: {Factory: SnowAlgaeRebalance, compatibility: 'promo'},
    [CardName.SOIL_FACTORY_RB]: {Factory: SoilFactoryRebalance},
    [CardName.SOLAR_POWER_RB]: {Factory: SolarPowerRebalance},
    [CardName.SPINOFF_DEPARTMENT_RB]: {Factory: SpinoffDepartmentRebalance, compatibility: 'colonies'},
    [CardName.STRATOPOLIS_RB]: {Factory: StratopolisRebalance, compatibility: 'venus'},
    [CardName.STRIP_MINE_RB]: {Factory: StripMineRebalance},
    [CardName.TITAN_AIRSCRAPPING_RB]: {Factory: TitanAirScrappingRebalance, compatibility: 'colonies'},
    [CardName.TOLL_STATION_RB]: {Factory: TollStationRebalance, compatibility: 'corpera'},
    [CardName.TOPSOIL_CONTRACT_RB]: {Factory: TopsoilContractRebalance, compatibility: 'promo'},
    [CardName.TROPICAL_RESORT_RB]: {Factory: TropicalResortRebalance, compatibility: 'corpera'},
    [CardName.UNDERGROUND_CITY_RB]: {Factory: UndergroundCityRebalance},
    [CardName.UNDERGROUND_DETONATIONS_RB]: {Factory: UndergroundDetonationsRebalance},
    [CardName.VIRAL_ENHANCERS_RB]: {Factory: ViralEnhancersRebalance, compatibility: 'corpera'},
    [CardName.WARP_DRIVE_RB]: {Factory: WarpDriveRebalance, compatibility: 'colonies'},
    [CardName.ZEPPELINS_RB]: {Factory: ZeppelinsRebalance},
    

    [CardName.SUBCRUST_VAPOR_TRAPPING]: {Factory: SubcrustVaporTrapping},
    [CardName.CONVOY_FROM_TITAN]: {Factory: ConvoyFromTitan},
    [CardName.HIGH_SPEED_COMET]: {Factory: HighSpeedComet},
    [CardName.TITANIUM_COMET]: {Factory: TitaniumComet},
    [CardName.EXPEDITION_TO_DIONE]: {Factory: ExpeditionToDione},
    [CardName.LARGE_THERMAL_DETONATOR]: {Factory: LargeThermalDetonator},
    [CardName.HYDROGEN_FROM_SATURN]: {Factory: HydrogenFromSaturn},
    [CardName.GIANT_CARBONATE_ASTEROID]: {Factory: GiantCarbonateAsteroid},
    [CardName.CARBONATE_ASTEROID]: {Factory: CarbonateAsteroid},
    [CardName.ARTIFICIAL_ASTEROID]: {Factory: ArtificialAsteroid},
    [CardName.INSTANTIATED_SOLAR_FLARE]: {Factory: InstantiatedSolarFlare},
    [CardName.ACCELERATED_IMPACTOR]: {Factory: AcceleratedImpactor},
    [CardName.IRON_RICH_ASTEROID]: {Factory: IronRichAsteroid},
    [CardName.OVERGROWTH]: {Factory: Overgrowth},
    [CardName.CONDENSED_GAS_CONVOY]: {Factory: CondensedGasConvoy},
    [CardName.TEMPORARY_SMELTING_PLANT]: {Factory: TemporarySmeltingPlant},
    [CardName.CYANOBACTERIA_BLOOM]: {Factory: CyanobacteriaBloom},
    [CardName.OXYGEN_SHIPMENT]: {Factory: OxygenShipment},
    [CardName.SPECIAL_AEROSOLS]: {Factory: SpecialAerosols},
    [CardName.IMPORTED_FUEL]: {Factory: ImportedFuel},
    [CardName.ASTEROID_MINING_EXPEDITION]: {Factory: AsteroidMiningExpedition},
    [CardName.LOWLAND_EXPEDITION]: {Factory: LowlandExpedition},
    [CardName.POWER_SURGE]: {Factory: PowerSurge},
    [CardName.MINOR_IMPACTOR]: {Factory: MinorImpactor},
    [CardName.CONTROLLED_BURN]: {Factory: ControlledBurn},
    [CardName.ECOLOGICAL_SHIPMENT]: {Factory: EcologicalShipment},
    [CardName.PANSPERMIA_SURVEY]: {Factory: PanspermiaSurvey},
    [CardName.HABITAT_CONSERVATION]: {Factory: HabitatConservation},
    [CardName.ASTEROID_STUDY]: {Factory: AsteroidStudy},
    [CardName.NITROGEN_ASTEROIDS]: {Factory: NitrogenAsteroids},
    [CardName.OXYGENATED_COMETS]: {Factory: OxygenatedComets}, 
    [CardName.KUIPER_BELT_ICE_ASTEROIDS]: {Factory: KuiperBeltIceAsteroids},
    [CardName.CERES_MINING_OPERATIONS]: {Factory: CeresMiningOperations},
    [CardName.AMMONIA_HEAVY_ASTEROIDS]: {Factory: AmmoniaHeavyAsteroids},
    [CardName.M_TYPE_ASTEROID_MINING]: {Factory: MTypeAsteroidMining},
    [CardName.FLOATING_WEATHER_PROBES]: {Factory: FloatingWeatherProbes},
    [CardName.PRODUCTION_DRONES]: {Factory: ProductionDrones},
    [CardName.EUROPAN_BACTERIA]: {Factory: EuropanBacteria},
    [CardName.TERMITES]: {Factory: Termites},
    [CardName.MARTIAN_THERMOPHILES]: {Factory: MartianThermophiles},
    [CardName.MIMICRY_ARCHAEA]: {Factory: MimicryArchaea},
    [CardName.MACROPLANKTON]: {Factory: Macroplankton},    
    [CardName.WATER_SPLITTING_MICROBES]: {Factory: WaterSplittingMicrobes},
    [CardName.HALOGEN_RECONSTRUCTORS]: {Factory: HalogenReconstructors},
    [CardName.ANTI_OXIDATION_BACTERIA]: {Factory: AntiOxidationBacteria},
    [CardName.THALLOPHYTE_PROTISTS]: {Factory: ThallophyteProtists},
    [CardName.CARBON_LATTICE_MICROBES]: {Factory: CarbonLatticeMicrobes},
    [CardName.ELECTROPLAQUE_MICROBES]: {Factory: ElectroplaqueMicrobes},
    [CardName.LARGE_AQUATIC_MAMMALS]: {Factory: LargeAquaticMammals},
    [CardName.TUNDRA_WILDLIFE]: {Factory: TundraWildlife},
    [CardName.RAPTORS]: {Factory: Raptors},
    [CardName.FISH_FARMING_LAKE]: {Factory: FishFarmingLake},
    [CardName.CEPHALOPODS]: {Factory: Cephalopods},
    [CardName.ENDANGERED_SPECIES_REFUGE]: {Factory: EndangeredSpeciesRefuge},
    [CardName.NON_HYPOXIC_SMALL_ANIMALS]: {Factory: NonHypoxicSmallAnimals},
    [CardName.SUBTERRANEAN_CREATURES]: {Factory: SubterranianCreatures},
    [CardName.ANTARCTIC_KRILL]: {Factory: AntarcticKrill},
    [CardName.ANCIENT_ARTHROPODS]: {Factory: AncientArthopods},
    [CardName.ADAPTIVE_BIOTICS]: {Factory: AdaptiveBiotics},
    [CardName.HABITAT_DOMES]: {Factory: HabitatDomes},
    [CardName.AQUAPONICS]: {Factory: Aquaponics},
    [CardName.SPRAWLING_CITY]: {Factory: SprawlingCity},
    [CardName.IMPERATIVE_SETTLEMENT]: {Factory: ImperativeSettlement},
    [CardName.ECO_CENTRAL]: {Factory: EcoCentral},
    [CardName.CANALS]: {Factory: Canals},
    [CardName.FREIGHT_SHUTTLES]: {Factory: FreightShuttles},
    [CardName.SILICON_FACTORY]: {Factory: SiliconFactory},
    [CardName.ALUMINUM_FOUNDRY]: {Factory: AluminumFoundry},
    [CardName.THAW_MINING]: {Factory: ThawMining},
    [CardName.ECOLOGICAL_CONTRACT]: {Factory: EcologicalContract},
    [CardName.ADVANCED_GENETIC_ADAPTION]: {Factory: AdvancedGeneticAdaption},
    //[CardName.ESSENTIAL_SYMBIOTICS]: {Factory: EssentialSymbiotics},
    [CardName.MICROBE_CULTIVATION_FACILITY]: {Factory: MicrobeCultivationFacility},
    [CardName.BIODOMES]: {Factory: Biodomes},
    [CardName.BIOMASS_REACTOR]: {Factory: BiomassReactor},
    [CardName.LOCAL_TEMPERATURE_CONTROL]: {Factory: LocalTemperatureControl},
    [CardName.CO2_VENTS]: {Factory: CO2Vents},
    [CardName.REGOLITH_TREATMENT]: {Factory: RegolithTreatment},
    [CardName.EUROPA_WATER_SPLITTING]: {Factory: EuropaWaterSplitting},  
    [CardName.BIODIVERSITY_CONTRACT]: {Factory: BiodiversityContract},
    [CardName.TEMPERATE_RAINFOREST]: {Factory: TemperateRainforest},
    [CardName.GENETIC_ENGINEERING_LAB]: {Factory: GeneticEngineeringLab},
    [CardName.OCEANOGRAPHY_RESEARCH]: {Factory: OceanographyResearch},
    [CardName.HEAVY_AEROSPACE_TECH]: {Factory: HeavyAerospaceTech},
    [CardName.INSULATED_CITY]: {Factory: InsulatedCity},
    [CardName.BURIED_SETTLEMENT]: {Factory: BuriedSettlement},
    [CardName.HUGE_CITY]: {Factory: HugeCity},
    [CardName.MINING_COMMUNITY]: {Factory: MiningCommunity},
    [CardName.DEEP_BURROW_SETTLEMENT]: {Factory: DeepBurrowSettlement},
    [CardName.INSTITUTE_SETTLEMENT]: {Factory: InstituteSettlement},
    [CardName.MULTIFUNCTIONAL_DOME]: {Factory: MultifunctionalDome},
    [CardName.INDEPENDENT_SETTLEMENT]: {Factory: IndependentSettlement},
    [CardName.GEOTHERMAL_RESERVIOR_HEATING]: {Factory: GeothermalReserviorHeating},
    [CardName.MUNICIPAL_RESERVIOR]: {Factory: MunicipalReservior},
    [CardName.FRESHWATER_LAKE]: {Factory: FreshwaterLake},
    [CardName.HUGE_GLACIER]: {Factory: HugeGlacier},
    [CardName.DEEP_WELL_PUMP]: {Factory: DeepWellPump},
    [CardName.COMMERCIAL_IMPORTS]: {Factory: CommercialImports},
    [CardName.URBAN_DEVELOPMENT]: {Factory: UrbanDevelopment},
    [CardName.EXPLOSIVES_TEST_SITE]: {Factory: ExplosivesTestSite},
    [CardName.POLAR_OUTPOST]: {Factory: PolarOutpost},
    [CardName.RURAL_HOUSING]: {Factory: RuralHousing},
    [CardName.TUNNEL_BORING]: {Factory: TunnelBoring},
    [CardName.LITHIUM_MINE]: {Factory: LithiumMine},
    [CardName.CHASMA_EXCAVATION]: {Factory: ChasmaExcavation},
    [CardName.DEEP_POLAR_EXTRACTION]: {Factory: DeepPolarExtraction},
    [CardName.CALLISTO_OPERATIONS]: {Factory: CallistoOperations},
    [CardName.SATURN_GAS_MINE]: {Factory: SaturnGasMine},
    [CardName.LASER_DRILL_MINING]: {Factory: LaserDrillMining},
    [CardName.HYDRUALIC_MINING]: {Factory: HydrualicMining},
    [CardName.ENZYMATIC_TREATMENT]: {Factory: EnzymaticTreatment},
    [CardName.REGOLITH_AERATION]: {Factory: RegolithAeration},
    [CardName.MIXOTROPHS]: {Factory: Mixotrophs},
    [CardName.BOTANICAL_LAB]: {Factory: BotanicalLab},
    [CardName.INDUSTRIAL_COMPOSTING]: {Factory: IndustrialComposting},
    [CardName.EXTREME_NITROPHILES]: {Factory: ExtremeNitrophiles},
    [CardName.VASCULAR_TUNDRA_PLANTS]: {Factory: VascularTundraPlants},
    [CardName.BAMBOO]: {Factory: Bamboo},
    [CardName.EROSION_REDUCING_GREENERY]: {Factory: ErosionReducingGreenery},
    [CardName.PARASITIC_PLANTS]: {Factory: ParasiticPlants},
    [CardName.WILDBERRIES]: {Factory: Wildberries},
    [CardName.ANAEROBIC_ENERGY_CROPPING]: {Factory: AnaerobicEnergyCropping},
    [CardName.ADAPTED_HARDWOOD]: {Factory: AdaptedHardwood},
    [CardName.AQUATIC_BIODOMES]: {Factory: AquaticBiodomes},
    [CardName.CONIFERS]: {Factory: Conifers},
    [CardName.WILD_BARLEY]: {Factory: WildBarley},
    [CardName.WETLANDS_CHEMICAL]: {Factory: WetlandsChemical},
    [CardName.CACTI]: {Factory: Cacti},
    [CardName.ADAPTED_FRUIT_FARMING]: {Factory: AdaptedFruitFarming},
    [CardName.RICE_FIELDS]: {Factory: RiceFields},
    [CardName.CORAL_REEF]: {Factory: CoralReef},
    [CardName.CYANOBACTERIA_CHEMICAL]: {Factory: CyanobacteriaChemical},
    [CardName.HYDROPONICS_FACILITY]: {Factory: HydroponicsFacility},
    [CardName.RED_ALGAE]: {Factory: RedAlgae},
    [CardName.IRRIGATION]: {Factory: Irrigation},
    [CardName.MONSOONS]: {Factory: Monsoons},
    [CardName.HEAVY_RESPIRATORS]: {Factory: HeavyRespirators},
    [CardName.BEE_FARMING]: {Factory: BeeFarming},
    [CardName.SYNTHETIC_GROWTH_HORMONES]: {Factory: SyntheticGrowthHormones},
    [CardName.SPACE_BASED_SOLAR_POWER]: {Factory: SpaceBasedSolarPower},
    [CardName.EFFICIENT_BATTERIES]: {Factory: EfficientBatteries},
    [CardName.LARGE_POWER_PLANT]: {Factory: LargePowerPlant},
    [CardName.HYDROCARBON_SYNTHESIS]: {Factory: HydrocarbonSynthesis},
    [CardName.ATMOSPHERIC_PROCESSING]: {Factory: AtmosphericProcessing},
    [CardName.URANIUM_DEPOSIT]: {Factory: UraniumDeposit},
    [CardName.ALGAE_BIOREACTORS_CHEMICAL]: {Factory: AlgaeBioreactorsChemical},
    [CardName.MASSIVE_SOLAR_FARM]: {Factory: MassiveSolarFarm},
    [CardName.ADVANCED_HYDROPOWER]: {Factory: AdvancedHydropower},
    [CardName.ENRICHMENT_PLANT]: {Factory: EnrichmentPlant},    
    [CardName.FUEL_CELL_PRODUCTION]: {Factory: FuelCellProduction},
    [CardName.ENERGY_MOHOLE]: {Factory: EnergyMohole},
    [CardName.HIGH_POWER_BETAVOLTAICS]: {Factory: HighPowerBetavoltaics},
    [CardName.CENTRAL_POWER_PLANT]: {Factory: CentralPowerPlant},
    [CardName.ISOTOPE_ENRICHING_BACTERIA]: {Factory: IsotopeEnrichingBacteria},
    [CardName.ANAEROBIC_BACTERIA]: {Factory: AnaerobicBacteria},
    [CardName.SOLID_STATE_WIND_ENERGY]: {Factory: SolidStateWildEnergy},
    [CardName.ATMOSPHERIC_PRESSURE_ENGINE]: {Factory: AtmosphericPressureEngine},
    [CardName.LASER_CANNON]: {Factory: LaserCannon},
    [CardName.PERFLUOROCARBON_PRODUCTION]: {Factory: PerfluorocarbonProduction},
    [CardName.GHG_FACTORY_DISTRICT]: {Factory: GHGFactoryDistrict},
    [CardName.NATURAL_GAS_EXTRACTION]: {Factory: NaturalGasExtraction},
    [CardName.HYDROTHERMAL_VENTS]: {Factory: HydrothermalVents},
    [CardName.OZONE_FACTORIES]: {Factory: OzoneFactories},
    [CardName.PROBIOTIC_TREATMENT]: {Factory: ProbioticTreatment},
    [CardName.MIRANDA_LABS]: {Factory: MirandaLabs},
    [CardName.MARS_LIFE_SCIENCE_INSTITUTE]: {Factory: MarsLifeScienceInstitute},
    [CardName.SPECIES_CRYOPRESERVATION]: {Factory: SpeciesCryopreservation},

    [CardName.AQUIFER_RELOCATION]: {Factory: AquiferRelocation, compatibility: 'corpera'},
    [CardName.SPECULATIVE_MARKETS]: {Factory: SpeculativeMarkets, compatibility: 'corpera'},
    [CardName.RESEARCH_GRANT_CHEMICAL]: {Factory: ResearchGrantChemical, compatibility: 'corpera'},
    [CardName.SMALL_SUPPLY_DROP]: {Factory: SmallSupplyDrop, compatibility: 'corpera'},
    [CardName.HERMES_MISSION]: {Factory: HermesMission, compatibility: 'corpera'},
    [CardName.ASSET_LIQUIDATION]: {Factory: AssetLiquidation, compatibility: 'corpera'},
    [CardName.PARASITE]: {Factory: Parasite, compatibility: 'corpera'},
    [CardName.ROBOTICS_EXHIBITION]: {Factory: RoboticsExhibition, compatibility: 'corpera'},
    [CardName.PATENT_TRADING]: {Factory: PatentTrading, compatibility: 'corpera'},
    [CardName.PUBLIC_RECORDS]: {Factory: PublicRecords, compatibility: 'corpera'},
    [CardName.ACID_RAIN]: {Factory: AcidRain, compatibility: 'corpera'},
    [CardName.POWER_FAILURE]: {Factory: PowerFailure, compatibility: 'corpera'},
    [CardName.ASTROPHYSICS_CENTER]: {Factory: AstrophysicsCenter, compatibility: 'corpera'},
    [CardName.CENTAUR_LANDINGS]: {Factory: CentaurLandings, compatibility: 'corpera'},
    [CardName.VESTA_OBSERVATORY]: {Factory: VestaObservatory, compatibility: 'corpera'},    
    [CardName.MEASUREMENT_DRONES]: {Factory: MeasurementDrones, compatibility: 'corpera'},
    [CardName.ADVANCED_BIOMACHINERY]: {Factory: AdvancedBiomachinery, compatibility: 'corpera'},
    [CardName.LONG_TERM_EVOLUTION_STUDY]: {Factory: LongTermEvolutionStudy, compatibility: 'corpera'},
    [CardName.SCIENTIFIC_LOGS]: {Factory: ScientificLogs, compatibility: 'corpera'},
    [CardName.CONSTRUCTION_CENTER]: {Factory: ConstructionCenter, compatibility: 'corpera'},
    [CardName.HOMEWORLD_HEADQUARTERS]: {Factory: HomeworldHeadquarters, compatibility: 'corpera'},
    [CardName.MARTIAN_INVESTMENTS]: {Factory: MartianInvestments, compatibility: 'corpera'},
    [CardName.LASER_LIGHTSAILS]: {Factory: LaserLightsails, compatibility: 'corpera'},
    [CardName.SPONSORED_RESEARCH_FIRM]: {Factory: SponsoredResearchFirm, compatibility: 'corpera'},
    [CardName.JOVIAN_SUPPLIERS]: {Factory: JovianSuppliers, compatibility: 'corpera'},
    [CardName.OLYMPUS_ARCHIVES]: {Factory: OlympusArchives, compatibility: 'corpera'},
    [CardName.NEURAL_ENCHANCEMENT]: {Factory: NeuralEnhancement, compatibility: 'corpera'},
    [CardName.SUPERPOLYMERS]: {Factory: Superpolymers, compatibility: 'corpera'},
    [CardName.ALLOY_FACTORY]: {Factory: AlloyFactory, compatibility: 'corpera'},
    [CardName.NOVA_FOUNDRY]: {Factory: NovaFoundry, compatibility: 'corpera'},
    [CardName.KUGELBLITZ_ENGINE]: {Factory: KugelblitzEngine, compatibility: 'corpera'},
    [CardName.EXOTIC_MATTER_REACTOR]: {Factory: ExoticMatterReactor, compatibility: 'corpera'},
    [CardName.SOLAR_STATION]: {Factory: SolarStation, compatibility: 'corpera'},
    [CardName.UNDERGROUND_TEST_SITE]: {Factory: UndergroundTestSite, compatibility: 'corpera'},
    [CardName.STANDARD_ALLOYS]: {Factory: StandardAlloys, compatibility: 'corpera'},
    [CardName.OVERSEER_COMMITTEE]: {Factory: OverseerCommittee, compatibility: 'corpera'},
    
    [CardName.VIRAL_AMEBOID]: {Factory: ViralAmeboid, compatibility: 'corpera'},
    [CardName.SCIENTIFIC_MEGAOPOLIS]: {Factory: ScientificMegaopolis, compatibility: 'corpera'},
    [CardName.STEEL_EXPORTS]: {Factory: SteelExports, compatibility: 'corpera'},
    [CardName.PROJECT_ADVANCEMENT]: {Factory: ProjectAdvancement, compatibility: 'corpera'},
    [CardName.SUCCESSFUL_COMMERCE]: {Factory: SuccessfulCommerce, compatibility: 'corpera'},
    [CardName.SCIENTIFIC_SUPPORT]: {Factory: ScientificSupport, compatibility: 'corpera'},
    [CardName.GALILEAN_GOVERNOR]: {Factory: GalileanGovernor, compatibility: 'corpera'},
    [CardName.MEDIA_CONGLOMARATE]: {Factory: MediaConglomerate, compatibility: 'corpera'},
    [CardName.MARTIAN_BANKING]: {Factory: MartianBanking, compatibility: 'corpera'},
    [CardName.MILITARY_BASE]: {Factory: MilitaryBase, compatibility: 'corpera'},
    [CardName.MILITARY_SPACE_PORT]: {Factory: MilitarySpacePort, compatibility: 'corpera'},
    [CardName.CHEMICAL_PLANT]: {Factory: ChemicalPlant, compatibility: 'corpera'},
    [CardName.SALT_MINE]: {Factory: SaltMine, compatibility: 'corpera'},
    [CardName.GRAND_STADIUM]: {Factory: GrandStadium, compatibility: 'corpera'},
    [CardName.LUXURY_RESORT]: {Factory: LuxuryResort, compatibility: 'corpera'},
    [CardName.MANUFACTURING_PLANT]: {Factory: ManufacturingPlant, compatibility: 'corpera'},
    [CardName.CONTRACTED_CONSTRUCTION]: {Factory: ContractedConstruction, compatibility: 'corpera'},
    [CardName.MOLECULAR_SCIENCE_LAB]: {Factory: MolecularScienceLab, compatibility: 'corpera'},
    [CardName.CROWDFUNDING]: {Factory: Crowdfunding, compatibility: 'corpera'},
    [CardName.COMMUNICATIONS_HUB]: {Factory: CommunicationsHub, compatibility: 'corpera'},
    [CardName.TITAN_TRADE_HUB]: {Factory: TitanTradeHub, compatibility: 'corpera'},
    [CardName.CONCRETE_FACTORY]: {Factory: ConcreteFactory, compatibility: 'corpera'},
    [CardName.MOUNTAINTOP_REMOVAL]: {Factory: MountaintopRemoval, compatibility: 'corpera'},
    [CardName.EXPLOSIVE_MINING]: {Factory: ExplosiveMining, compatibility: 'corpera'},
    [CardName.PRINT_MANUFACTURING]: {Factory: PrintManufacturing, compatibility: 'corpera'},
    [CardName.VOLCANIC_FOUNDRY]: {Factory: VolcanicFoundry, compatibility: 'corpera'},
    [CardName.SHIPYARD]: {Factory: Shipyard, compatibility: 'corpera'},
    [CardName.UPPER_MANTLE_BORING]: {Factory: UpperMantleBoring, compatibility: 'corpera'},
    [CardName.SEED_SUPPLIERS]: {Factory: SeedSuppliers, compatibility: 'corpera'},
    [CardName.CASH_CROPS]: {Factory: CashCrops, compatibility: 'corpera'},
    [CardName.EXTREME_POWER_EFFICIENCY]: {Factory: ExtremePowerEfficiency, compatibility: 'corpera'},
    [CardName.COLD_FUSION_POWER]: {Factory: ColdFusionPower, compatibility: 'corpera'},
    [CardName.NUCLEAR_FORCE_POWER]: {Factory: NuclearForcePower, compatibility: 'corpera'},
    [CardName.ARTIFICIAL_MICROBIAL_LIFE]: {Factory: ArtificialMicrobialLife, compatibility: 'corpera'},
    [CardName.ACQUIRED_RESEARCH_FIRM]: {Factory: AcquiredResearchFirm, compatibility: 'corpera'},
    [CardName.INTERSTELLAR_PROBE]: {Factory: InterstellarProbe, compatibility: 'corpera'},
    [CardName.THEORY_OF_EVERYTHING]: {Factory: TheoryOfEverything, compatibility: 'corpera'},
    [CardName.GREAT_HARBOR]: {Factory: GreatHarbor, compatibility: 'corpera'},

    [CardName.FLOATER_ACQUISITION]: {Factory: FloaterAcquisition, compatibility: 'venus'},
    [CardName.IONIC_GAS_SEQUESTRATION]: {Factory: IonicGasSequestration, compatibility: 'venus'},
    [CardName.NEAR_MISS_ROTARY_ASTEROID]: {Factory: NearMissRotaryAsteroid, compatibility: 'venus'},
    [CardName.DWARF_PLANET_COLLISION]: {Factory: DwarfPlanetCollision, compatibility: 'venus'},
    [CardName.CONVOY_TO_VENUS]: {Factory: ConvoyToVenus, compatibility: 'venus'},
    [CardName.HUGE_WATER_SHIPMENTS]: {Factory: HugeWaterShipments, compatibility: 'venus'},
    [CardName.NITROGEN_FROM_VENUS]: {Factory: NitrogenFromVenus, compatibility: 'venus'},
    [CardName.ATMOSPHERE_LIFTING_DETONATIONS]: {Factory: AtmosphereLiftingDetonations, compatibility: 'venus'},
    [CardName.VENUS_MINING_EXPEDITION]: {Factory: VenusMiningExpedition, compatibility: 'venus'},
    [CardName.ULTRALIGHT_FLOATERS]: {Factory: UltralightFloaters, compatibility: 'venus'},
    [CardName.DANU_MONTES_ROVER]: {Factory: DanuMontesRover, compatibility: 'venus'},
    [CardName.COLLABORATION_PROJECT]: {Factory: CollaborationProject, compatibility: 'venus'},
    [CardName.CONSISTENT_BOMBARDMENT]: {Factory: ConsistentBombardment, compatibility: 'venus'},
    [CardName.PAN_SOLAR_MINING]: {Factory: PanSolarMining, compatibility: 'venus'},
    [CardName.FLOATING_RESEARCH_BASE]: {Factory: FloatingResearchBase, compatibility: 'venus'},
    [CardName.FLOATER_DOCKS]: {Factory: FloaterDocks, compatibility: 'venus'},
    [CardName.MESOSPHERE_SHADES]: {Factory: MesosphereShades, compatibility: 'venus'},
    [CardName.LOW_LEVEL_SCRAPPERS]: {Factory: LowLevelScrappers, compatibility: 'venus'},
    [CardName.CARBON_SOLIDIFICATION]: {Factory: CarbonSolidification, compatibility: 'venus'},
    [CardName.LOCAL_MAGNETIC_SHIELDING]: {Factory: LocalMagneticShielding, compatibility: 'venus'},
    [CardName.AERIAL_MASS_DRIVERS]: {Factory: AerialMassDrivers, compatibility: 'venus'},
    [CardName.SKY_COMMUNICATIONS]: {Factory: SkyCommunications, compatibility: 'venus'},
    [CardName.FLOATING_BIODOMES]: {Factory: FloatingBiodomes, compatibility: 'venus'},
    [CardName.ENDEMIC_VENUSIAN_ARCHAEA]: {Factory: EndemicVenusianArchaea, compatibility: 'venus'},
    [CardName.AIRBORNE_MICROBES]: {Factory: AirborneMicrobes, compatibility: 'venus'},
    [CardName.PH_NEUTRALIZERS]: {Factory: PHNeutralizers, compatibility: 'venus'},
    [CardName.CARBON_FIXING_MICROBES]: {Factory: CarbonFixingMicrobes, compatibility: 'venus'},
    [CardName.DESIGNED_FLYERS]: {Factory: DesignedFlyers, compatibility: 'venus'},
    [CardName.VENUS_SURFACE_DWELLERS]: {Factory: VenusSurfaceDwellers, compatibility: 'venus'},
    [CardName.VENERA_OUTPOST]: {Factory: VeneraOutpost, compatibility: 'venus'},
    [CardName.BIOENGINEERING_STUDIES]: {Factory: BioengineeringStudies, compatibility: 'venus'},
    [CardName.VENUS_BIOLAB]: {Factory: VenusBiolab, compatibility: 'venus'},
    [CardName.LOCAL_DECOMPRESSION]: {Factory: LocalDecompression, compatibility: 'venus'},
    [CardName.UNDERGROUND_VENUS_BASE]: {Factory: UndergroundVenusBase, compatibility: 'venus'},
    [CardName.TOWERS_OF_FREYJA]: {Factory: TowersOfFreyja, compatibility: 'venus'},
    [CardName.VENUS_SOLAR_WAYSTATION]: {Factory: VenusSolarWaystation, compatibility: 'venus'},
    [CardName.DRY_ICE_RINGS]: {Factory: DryIceRings, compatibility: 'venus'},
    [CardName.THE_BEHEMOTH]: {Factory: TheBehemoth, compatibility: 'venus'},
    [CardName.VENUS_MINING_INDUSTIRES]: {Factory: VenusMiningIndustries, compatibility: 'venus'},
    [CardName.OVDA_CITY]: {Factory: OvdaCity, compatibility: 'venus'},
    [CardName.CAPITAL_OF_VENUS]: {Factory: CapitalOfVenus, compatibility: 'venus'},
    [CardName.HYDROGEN_INJECTION]: {Factory: HydrogenInjection, compatibility: 'venus'},
    [CardName.ATMOSPHERIC_SOLAR_COLLECTORS]: {Factory: AtmosphericSolarCollectors, compatibility: 'venus'},
    [CardName.SWARM_SHADERS]: {Factory: SwarmShaders, compatibility: 'venus'},
    [CardName.VORTEX_ENGINE]: {Factory: VortexEngine, compatibility: 'venus'},
    [CardName.PHOTONIC_METAMATERIALS]: {Factory: PhotonicMetamaterials, compatibility: 'venus'},
    [CardName.NEUTRALIZER_DRONES]: {Factory: NeutralizerDrones, compatibility: 'venus'},
    [CardName.CONDENSATION_CATALYSTS]: {Factory: CondenstationCatalysts, compatibility: 'venus'},
    [CardName.BASALT_MINING]: {Factory: BasaltMining, compatibility: 'venus'},
    [CardName.VENUSIAN_FUNGI]: {Factory: VenusianFungi, compatibility: 'venus'},
    [CardName.LAKE_OF_APHRODITE]: {Factory: LakeOfAphrodite, compatibility: 'venus'},
    [CardName.SUPER_CARBON_COLLECTORS]: {Factory: SuperCarbonCollectors, compatibility: 'venus'},
    [CardName.SULPHUR_PROCESSING]: {Factory: SulphurProcessing, compatibility: 'venus'},
    [CardName.STELLAR_CRUISERS]: {Factory: StellarCruisers, compatibility: 'venus'},
    [CardName.DISTRIBUTION_CENTER]: {Factory: DistributionCenter, compatibility: 'venus'},
    [CardName.WORLD_GOVERNMENT_OFFICES]: {Factory: WorldGovernmentOffices, compatibility: 'venus'},
    [CardName.VENUS_TOURISM]: {Factory: VenusTourism, compatibility: 'venus'},
    [CardName.ISHTAR_COMPLEX]: {Factory: IshtarComplex, compatibility: 'venus'},
    [CardName.SURFACE_HABS]: {Factory: SurfaceHabs, compatibility: 'venus'},
    [CardName.THEMIS_BIODOMES]: {Factory: ThemisBiodomes, compatibility: 'venus'},
    [CardName.ATEN_GROUP_MINING]: {Factory: AtenGroupMining, compatibility: 'venus'},
    [CardName.RHIZOBIOME_RESEARCH]: {Factory: RhizobiomeResearch, compatibility: 'venus'},
    [CardName.FLOATING_POWER_STATION]: {Factory: FloatingPowerStation, compatibility: 'venus'},
    [CardName.DEUTERIUM_FUSION]: {Factory: DeuteriumFusion, compatibility: 'venus'},
    [CardName.VENUS_POWER_PLANT]: {Factory: VenusPowerPlant, compatibility: 'venus'},
    [CardName.TERRESTRIAL_ALLIANCE]: {Factory: TerrestrialAlliance, compatibility: 'venus'},
    [CardName.ECLIPSE_STATION]: {Factory: EclipseStation, compatibility: 'venus'},
    [CardName.VENUS_PLANTATION]: {Factory: VenusPlantation, compatibility: 'venus'},
    [CardName.WORKER_DRONES]: {Factory: WorkerDrones, compatibility: 'venus'},
    [CardName.FLOATING_ARCHITECHTURE]: {Factory: FloatingArchitechture, compatibility: 'venus'},
    [CardName.BIOMECHANICAL_FOLIAGE]: {Factory: BiomechanicalFoliage, compatibility: 'venus'},
    [CardName.VENUS_GEOLOGICAL_SURVEY]: {Factory: VenusGeologicalSurvey, compatibility: 'venus'},

    [CardName.COORDINATED_RAID_CHEMICAL]: {Factory: CoordinatedRaidChemical, compatibility: 'colonies'},
    [CardName.SPONSORED_FLIGHT]: {Factory: SponsoredFlight, compatibility: 'colonies'},
    [CardName.LARGE_TRADING_FLEET]: {Factory: LargeTradingFleet, compatibility: 'colonies'},
    [CardName.OUTER_SOLAR_MISSION]: {Factory: OuterSolarMission, compatibility: 'colonies'},
    [CardName.COMMISSIONED_FLEET]: {Factory: CommissionedFleet, compatibility: 'colonies'},
    [CardName.MARKET_SIPHON]: {Factory: MarketSiphon, compatibility: 'colonies'},
    [CardName.PLANETARY_TRADE]: {Factory: PlanetaryTrade, compatibility: 'colonies'},
    [CardName.FLOATING_TECH_RESEARCH]: {Factory: FloatingTechResearch, compatibility: 'colonies'},
    [CardName.DEEP_JUPITER_PROBE]: {Factory: DeepJupiterProbe, compatibility: 'colonies'},
    [CardName.JOVIAN_MOON_MAPPING]: {Factory: JovianMoonMapping, compatibility: 'colonies'},
    [CardName.ICE_MOON_COLLISION]: {Factory: IceMoonCollision, compatibility: 'colonies'},
    [CardName.PRODUCTIVITY_QUOTA]: {Factory: ProductivityQuota, compatibility: 'colonies'},
    [CardName.CERES_LAUNCHPAD]: {Factory: CeresLaunchpad, compatibility: 'colonies'},
    [CardName.ASTEROID_BELT_COLONY]: {Factory: AsteroidBeltColony, compatibility: 'colonies'},
    [CardName.SPACE_TETHERS]: {Factory: SpaceTethers, compatibility: 'colonies'},
    [CardName.FLOATING_COLONY]: {Factory: FloatingColony, compatibility: 'colonies'},
    [CardName.GAS_GIANT_HABS]: {Factory: GasGiantHabs, compatibility: 'colonies'},
    [CardName.TITAN_RESEARCH_OUTPOST]: {Factory: TitanReseachOutpost, compatibility: 'colonies'},
    [CardName.JOVIAN_CONSTRUCTION_YARD]: {Factory: JovianConstructionYard, compatibility: 'colonies'},
    [CardName.WATER_FROM_TITAN]: {Factory: WaterFromTitan, compatibility: 'colonies'},
    [CardName.METHANE_EXPORTS]: {Factory: MethaneExports, compatibility: 'colonies'},
    [CardName.GALILEAN_MINING_NETWORK]: {Factory: GalileanMiningNetwork, compatibility: 'colonies'},
    [CardName.TITAN_FUEL_STATION]: {Factory: TitanFuelStation, compatibility: 'colonies'},
    [CardName.JUPITER_FLOATING_CITY]: {Factory: JupiterFloatingCity, compatibility: 'colonies'},
    [CardName.FLOATER_FACILITY]: {Factory: FloaterFacility, compatibility: 'colonies'},
    [CardName.FLOATING_TECH_INVESTMENTS]: {Factory: FloatingTechInvestments, compatibility: 'colonies'},
    [CardName.PRIMATES]: {Factory: Primates, compatibility: 'colonies'},
    [CardName.COLONY_SUPPLIERS]: {Factory: ColonySuppliers, compatibility: 'colonies'},
    [CardName.FUEL_SUBSIDIES]: {Factory: FuelSubsidies, compatibility: 'colonies'},
    [CardName.REMOTE_TEST_ZONE]: {Factory: RemoteTestZone, compatibility: 'colonies'},
    [CardName.WAYPOINT_COLONY]: {Factory: WaypointColony, compatibility: 'colonies'},
    [CardName.PRIVATE_COLONY]: {Factory: PrivateColony, compatibility: 'colonies'},
    [CardName.REMOTE_MINING_BASE]: {Factory: RemoteMiningBase, compatibility: 'colonies'},
    [CardName.RESEARCH_MISSIONS]: {Factory: ResearchMissions, compatibility: 'colonies'},
    [CardName.VENUS_TRADE_STATION]: {Factory: VenusTradeStation, compatibility: 'colonies'},
    [CardName.RIM_POPULATION_CENTER]: {Factory: RimPopulationCenter, compatibility: 'colonies'},
    [CardName.BUSINESS_COLONY]: {Factory: BusinessColony, compatibility: 'colonies'},
    [CardName.SELF_SUFFICIENT_COLONY]: {Factory: SelfSufficientColony, compatibility: 'colonies'},
    [CardName.INDUSTRIAL_COLONY]: {Factory: IndustrialColony, compatibility: 'colonies'},
    [CardName.DOME_FARMING_COLONY]: {Factory: DomeFarmingColony, compatibility: 'colonies'},
    [CardName.ENERGY_BEAM_COLONY]: {Factory: EnergyBeamColony, compatibility: 'colonies'},
    [CardName.KUIPER_BELT_COLONY]: {Factory: KuiperBeltColony, compatibility: 'colonies'},
    [CardName.THERMAL_RESERVIOR]: {Factory: ThermalReservior, compatibility: 'colonies'},
    [CardName.SLUM_CITY]: {Factory: SlumCity, compatibility: 'colonies'},
    [CardName.LUNAR_PORT]: {Factory: LunarPort, compatibility: 'colonies'},
    [CardName.MUSEUM_OF_LUNA]: {Factory: MuseumOfLuna, compatibility: 'colonies'},
    [CardName.LUNAR_RESORT]: {Factory: LunarResort, compatibility: 'colonies'},
    [CardName.LUNA_COLONIZATION_INVESTMENTS]: {Factory: LunaColonizationInvestments, compatibility: 'colonies'},
    [CardName.MICROGRAVITY_LAB]: {Factory: MicrogravityLab, compatibility: 'colonies'},
    [CardName.MILITARY_SPACE_STATION]: {Factory: MilitarySpaceStation, compatibility: 'colonies'},
    [CardName.LUNAR_H3_MINING]: {Factory: LunarH3Mining, compatibility: 'colonies'},
    [CardName.COLONY_MINING_INFRASTRUCTURE]: {Factory: ColonyMiningInfrastructure, compatibility: 'colonies'},
    [CardName.CASSINI_ENTERPRISES]: {Factory: CassiniEnterprises, compatibility: 'colonies'},
    [CardName.HEMERA_BUNKER]: {Factory: HemeraBunker, compatibility: 'colonies'},
    [CardName.ORBITAL_BIODOMES]: {Factory: OrbitalBiodomes, compatibility: 'colonies'},
    [CardName.AZALEA_BUSHES]: {Factory: AzaleaBushes, compatibility: 'colonies'},
    [CardName.WILDFLOWERS]: {Factory: Wildflowers, compatibility: 'colonies'},
    [CardName.COLONY_SPACE_MIRRORS]: {Factory: ColonySpaceMirrors, compatibility: 'colonies'},
    [CardName.LUNAR_POWER_GRID]: {Factory: LunarPowerGrid, compatibility: 'colonies'},
    [CardName.PROTO_DYSON_SWARM]: {Factory: ProtoDysonSwarm, compatibility: 'colonies'},

    [CardName.EARTH_EMBASSY_CHEMICAL]: {Factory: EarthEmbassyChemical, compatibility: 'colonies'},
    [CardName.MERCURIAL_SUNSHADE]: {Factory: MercurialSunshade, compatibility: 'colonies'},
    [CardName.HIGH_ORBIT_RESEARCH_STATION]: {Factory: HighOrbitResearchStation, compatibility: 'colonies'},
    [CardName.TERRESTRIAL_RESEARCH_SUMMIT]: {Factory: TerrestrialResearchSummit, compatibility: 'colonies'},
    [CardName.ARCTIC_ENDOLITHS]: {Factory: ArcticEndoliths, compatibility: 'colonies'},
    [CardName.HYPER_EXTREMOPHILE_FUNGI]: {Factory: HyperExtremophileFungi, compatibility: 'colonies'},
    [CardName.BIODIVERSITY_BOOM]: {Factory: BiodiversityBoom, compatibility: 'colonies'},
    [CardName.COLONY_REFORMS]: {Factory: ColonyReforms, compatibility: 'colonies'},

    [CardName.DIRECTED_SABOTAGE_IMPACT]: {Factory: DirectedSabotageImpact, compatibility: 'turmoil'},
    [CardName.FUSION_BOMBING]: {Factory: FusionBombing, compatibility: 'turmoil'},
    // [CardName.DEMOCRATIC_REFORM]: {Factory: DemocraticReform, compatibility: 'turmoil'},
    [CardName.MEDIA_MANIPULATION]: {Factory: MediaManipulation, compatibility: 'turmoil'},
    [CardName.INAUGURATION_CEREMONY]: {Factory: InaugurationCeremony, compatibility: 'turmoil'},
    [CardName.POLITICAL_DONATIONS]: {Factory: PoliticalDonations, compatibility: 'turmoil'},
    [CardName.DESIGNED_ORGANISMS_CHEMICAL]: {Factory: DesignedOrganisms, compatibility: 'turmoil'},
    [CardName.TELLURIAN_ECOSYSTEMS]: {Factory: TellurianEcosystems, compatibility: 'turmoil'},
    [CardName.PRESERVATIONISM]: {Factory: Preservationism, compatibility: 'turmoil'},
    [CardName.INTERPLANETARY_DIPLOMACY]: {Factory: InterplanetaryDiplomacy, compatibility: 'turmoil'},
    [CardName.WORLD_GOVERNMENT_DIPLOMATS]: {Factory: WorldGovernmentDiplomats, compatibility: 'turmoil'},
    [CardName.HYBRID_VESSELS]: {Factory: HybridVessels, compatibility: 'turmoil'},
    [CardName.SHORT_TERM_BONUSES]: {Factory: ShortTermBonuses, compatibility: 'turmoil'},
    [CardName.MARTIAN_RESEARCH_NETWORK]: {Factory: MartianResearchNetwork, compatibility: 'turmoil'},
    [CardName.ENERGY_LAB]: {Factory: EnergyLab, compatibility: 'turmoil'},
    // [CardName.STIMULUS_PROGRAMS]: {Factory: StimulusPrograms, compatibility: 'turmoil'},
    [CardName.COMMITTEE_COALITION]: {Factory: CommitteeCoalition, compatibility: 'turmoil'},
    [CardName.LEGAL_FIRM]: {Factory: LegalFirm, compatibility: 'turmoil'},
    [CardName.KICKBACKS]: {Factory: Kickbacks, compatibility: 'turmoil'},
    [CardName.REMOTE_AREA_SUPPLIERS]: {Factory: RemoteAreaSuppliers, compatibility: 'turmoil'},
    [CardName.MEDICAL_INSTITUTE]: {Factory: MedicalInstitute, compatibility: 'turmoil'},
    [CardName.MICROBIAL_SUPPORT]: {Factory: MicrobialSupport, compatibility: 'turmoil'},
    [CardName.VENUS_SOCIETY_SUPPORT]: {Factory: VenusSocietySupport, compatibility: 'turmoil'},
    // [CardName.PRIMAL_NATIONAL_PARK]: {Factory: PrimalNationalPark, compatability: 'turmoil'},
    [CardName.CORPORATE_CITADEL]: {Factory: CorporateCitadel, compatibility: 'turmoil'},
    [CardName.PRESERVATIONIST_SETTLEMENT]: {Factory: PreservationistSettlement, compatibility: 'turmoil'},
    [CardName.AUTHORITARIAN_STATE]: {Factory: AuthoritarianState, compatibility: 'turmoil'},
    [CardName.INDUSTRY_DEVELOPMENT]: {Factory: IndustryDevelopment, compatibility: 'turmoil'},
    [CardName.ACQUIRED_BIOENGINEERING_FIRM]: {Factory: AcquiredBioengineeringFirm, compatibility: 'turmoil'},
    [CardName.IONIZING_RADIATION_BEAM]: {Factory: IonizingRadiationBeam, compatibility: 'turmoil'},
    [CardName.REDUCED_SNOW_COVERAGE]: {Factory: ReducedSnowCoverage, compatibility: 'turmoil'},
    [CardName.SOCIAL_WELFARE]: {Factory: SocialWelfare, compatibility: 'turmoil'},
    [CardName.EXOPLANET_LANDING]: {Factory: ExoplanetLanding, compatibility: 'turmoil'},
    [CardName.FIRST_MARTIAN_MEMORIAL]: {Factory: FirstMaritanMemorial, compatibility: 'turmoil'},
    [CardName.TERRAFORMING_UNION]: {Factory: TerraformingUnion, compatibility: 'turmoil'},
    [CardName.ACQUIRED_CONSULTING_FIRM]: {Factory: AcquiredConsultingFirm, compatibility: 'turmoil'},

  },
  globalEvents: {
    [GlobalEventName.LAND_DELEGATION]: {Factory: LandDelegation},
    [GlobalEventName.INTELLECTUALIST_MOVEMENTS]: {Factory: IntellectualistMovements},
    [GlobalEventName.MANDATORY_INSURANCE]: {Factory: MandatoryInsurance},
    [GlobalEventName.TRADE_EMBARGO]: {Factory: TradeEmbargo},
    [GlobalEventName.INSURGENCY]: {Factory: Insurgency},
    [GlobalEventName.LABOR_REVOLT]: {Factory: LaborRevolt},
    [GlobalEventName.INTERPLANETARY_COMMUNITIES]: {Factory: InterplanetaryCommunities},
    [GlobalEventName.CHEMICAL_POLLUTION]: {Factory: ChemicalPollution},
    [GlobalEventName.PESTICIDE_APPLICATION]: {Factory: PesticideApplication},
    [GlobalEventName.CYBERATTACKS]: {Factory: Cyberattacks},
    [GlobalEventName.MINING_INDUSTRIES]: {Factory: MiningIndustries},
    [GlobalEventName.FAMINE]: {Factory: Famine},
    [GlobalEventName.NANOTECH_INNOVATION]: {Factory: NanotechInnovation},
    [GlobalEventName.POWER_SURPLUS]: {Factory: PowerSurplus},
    [GlobalEventName.LAND_RUN]: {Factory: LandRun},
    [GlobalEventName.ERADICATION_OF_GENETIC_ILLNESS]: {Factory: EradicationOfGeneticIllness},
    [GlobalEventName.MAGNETIC_FIELD_FAILURE]: {Factory: MagneticFieldFailure},
    [GlobalEventName.FOOD_SUPPLY]: {Factory: FoodSupply},
    [GlobalEventName.CONSTITUTIONAL_REFORMATION]: {Factory: ConstitutionalReformation},
    [GlobalEventName.ECOLOGY_PROJECTS]: {Factory: EcologyProjects},
    [GlobalEventName.ECOSYSTEM_DISRUPTION]: {Factory: EcosystemDisruption},
    [GlobalEventName.RED_UPRISING]: {Factory: RedUprising},
    [GlobalEventName.WILDFIRES]: {Factory: WildfiresEvent},
    [GlobalEventName.EGALITARIAN_MOVEMENTS]: {Factory: EgalitarianMovements},
    [GlobalEventName.MARS_STOCK_EXCHANGE]: {Factory: MarsStockExchange},
    [GlobalEventName.COLONIZATION_OF_MERCURY]: {Factory: ColonizationOfMercury},
    [GlobalEventName.REVISED_PATENT_LAW]: {Factory: RevisedPatentLaw},
    [GlobalEventName.ECOLOGICAL_SUPPORT]: {Factory: EcologicalSupport},
    [GlobalEventName.ABSTINANCE_BONUS]: {Factory: AbstinanceBonus},
    [GlobalEventName.RED_TOURISM]: {Factory: RedTourism},
    [GlobalEventName.PREFERENTIAL_LOANS]: {Factory: PreferentialLoans},
    [GlobalEventName.SEVERE_MARSQUAKE]: {Factory: SevereMarsquake},
    [GlobalEventName.EXTINCTION_EVENT]: {Factory: ExtinctionEvent},
    [GlobalEventName.SPACE_TRAVEL_LIMITATIONS]: {Factory: SpaceTravelLimitations},
    [GlobalEventName.RIM_SHORTAGES]: {Factory: RimShortages},
    [GlobalEventName.MICROBIAL_BOOM]: {Factory: MicrobialBoom},
    [GlobalEventName.TECHNOLOGICAL_REGRESSION]: {Factory: TechnologicalRegression},
    [GlobalEventName.POWER_GENERATION_SUBSIDIES]: {Factory: PowerGenerationSubsidies},
    [GlobalEventName.TAXATION_OF_VENUS]: {Factory: TaxationOfVenus, compatibility: 'venus'},
    [GlobalEventName.VENUS_MINING]: {Factory: VenusMining, compatibility: 'venus'},
    [GlobalEventName.DEGREDATION_OF_VENUS]: {Factory: DegredationOfVenus, compatibility: 'venus'},
    [GlobalEventName.FLOATER_TECHNOLOGY]: {Factory: FloaterTechnologyEvent, compatibility: 'venus'},
    [GlobalEventName.VENUSIAN_ECOSYSTEMS]: {Factory: VenusianEcosystems, compatibility: 'venus'},
    [GlobalEventName.SOCIETIES_OF_VENUS]: {Factory: SocietiesOfVenus, compatibility: 'venus'},
    [GlobalEventName.ANTICORROSIVE_MATERIALS]: {Factory: AnticorrosiveMaterials, compatibility: 'venus'},
    [GlobalEventName.LOWLAND_FLOODING]: {Factory: LowlandFlooding, compatibility: 'venus'},
    [GlobalEventName.COMMUNITY_SERVICES]: {Factory: CommunityServicesEvent, compatibility: 'colonies'},
    [GlobalEventName.POWER_FAILURE]: {Factory: PowerFailureEvent, compatibility: 'colonies'},
    [GlobalEventName.INTERSTELLAR_COLONIZATION]: {Factory: InterstallarColonization, compatibility: 'colonies'},
    [GlobalEventName.COLONY_PRODUCTIVITY]: {Factory: ColonyProductivity, compatibility: 'colonies'},
    [GlobalEventName.COMMAND_ECONOMY]: {Factory: CommandEconomy, compatibility: 'colonies'},
    [GlobalEventName.JOVIAN_WAR]: {Factory: JovianWar, compatibility: 'colonies'},
    [GlobalEventName.REFUGEE_CRISIS]: {Factory: RefugeeCrisis, compatibility: 'colonies'},
    [GlobalEventName.ECONOMIC_DEPRESSION]: {Factory: EconomicDepression, compatibility: 'colonies'},
  },
  //andy cards to remove
  cardsToRemove: [
    CardName.ADVANCED_ALLOYS,
    CardName.AEROBRAKED_AMMONIA_ASTEROID,
    CardName.ASTEROID_HOLLOWING,
    CardName.BACTOVIRAL_RESEARCH,
    CardName.BLACK_POLAR_DUST,
    CardName.BUILDING_INDUSTRIES,
    CardName.CARTEL,
    CardName.CLOUD_SEEDING,
    CardName.COMMUNITY_SERVICES,
    CardName.CORPORATE_STRONGHOLD,
    CardName.CUTTING_EDGE_TECHNOLOGY,
    CardName.EARTH_CATAPULT,
    CardName.EARTH_OFFICE,
    CardName.ENERGY_MARKET,
    CardName.ENERGY_SAVING,
    CardName.EXTRACTOR_BALLOONS,
    CardName.FORCED_PRECIPITATION,
    CardName.GHG_IMPORT_FROM_VENUS,
    CardName.GMO_CONTRACT,
    CardName.HACKERS,
    CardName.HEAT_TRAPPERS,
    CardName.INDUSTRIAL_CENTER_ARES,
    CardName.INSECTS,
    CardName.JET_STREAM_MICROSCRAPPERS,
    CardName.MARS_UNIVERSITY,
    CardName.MASS_CONVERTER,
    CardName.MEAT_INDUSTRY,
    CardName.MICRO_MILLS,
    CardName.ORBITAL_CLEANUP,
    CardName.OUTDOOR_SPORTS,
    CardName.RELEASE_OF_INERT_GASES,
    CardName.RESEARCH_OUTPOST,
    CardName.ROTATOR_IMPACTS,
    CardName.SKY_DOCKS,
    CardName.SNOW_ALGAE,
    CardName.SOIL_FACTORY,
    CardName.SOLAR_POWER,
    CardName.SPINOFF_DEPARTMENT,
    CardName.STRATOPOLIS,
    CardName.STRIP_MINE,
    CardName.TITAN_AIRSCRAPPING,
    CardName.TOLL_STATION,
    CardName.TOPSOIL_CONTRACT,
    CardName.TROPICAL_RESORT,
    CardName.UNDERGROUND_CITY,
    CardName.UNDERGROUND_DETONATIONS,
    CardName.VIRAL_ENHANCERS,
    CardName.WARP_DRIVE,
    CardName.ZEPPELINS,
  ],
});

================
File: cards/chemical/colonies/ArcticEndoliths.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';
import {max} from '../../Options';

export class ArcticEndoliths extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ARCTIC_ENDOLITHS,
      cost: 7,
      tags: [Tag.MICROBE],
      requirements: {temperature: -16, max},
      victoryPoints: 1,

      behavior: {
        stock: {plants: 2},
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 1},
      },

      metadata: {
        cardNumber: 'x381',
        renderData: CardRenderer.builder((b) => {
          b.plants(2).nbsp.resource(CardResource.MICROBE).asterix();
        }),
        description: 'Requires -16°C or colder. Gain 2 plants and add a microbe to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/colonies/AsteroidBeltColony.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class AsteroidBeltColony extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ASTEROID_BELT_COLONY,
      tags: [Tag.SPACE],
      cost: 22,
      resourceType: CardResource.ASTEROID,

      behavior: {
        colonies: {buildColony: {}},
      },

      action: {
        spend: {megacredits: 2},
        addResourcesToAnyCard: {type: CardResource.ASTEROID, count: 1},
      },

      metadata: {
        cardNumber: 'x326',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 M€ to add an asteroid to ANY card.', (eb) => {
            eb.megacredits(2).startAction.resource(CardResource.ASTEROID).asterix();
          }).br;
          b.effect('Asteroids on this card may be used as 5 M€ when paying for cards with space tags.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.resource(CardResource.ASTEROID).equals().megacredits(5);
          }).br;
          b.colonies(1);
        }),
        description: 'Place a colony.',
      },
    });
  }
}

================
File: cards/chemical/colonies/AzaleaBushes.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class AzaleaBushes extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.AZALEA_BUSHES,
      cost: 7,
      tags: [Tag.PLANT],
      requirements: {temperature: -6},
      victoryPoints: 1,

      behavior: {
        production: {plants: 1},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'x369',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).plants(2);
        }),
        description: 'Requires -6°C or warmer. Increase your plant production 1 step and gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/colonies/BiodiversityBoom.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {AddResourcesToCard} from '../../../deferredActions/AddResourcesToCard';
import {CardResource} from '../../../../common/CardResource';
import {digit} from '../../Options';

export class BiodiversityBoom extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BIODIVERSITY_BOOM,
      cost: 14,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'x383',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.ANIMAL).asterix().nbsp.or().nbsp;
          b.tag(Tag.ANIMAL, {amount: 3, digit}).colon().nbsp.resource(CardResource.ANIMAL, {amount: 3, digit}).asterix();
        }),
        description: 'Add an animal to ANOTHER card or add 3 animals to ANOTHER card if you have 3 animal tags.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new AddResourcesToCard(player, CardResource.ANIMAL, {count: player.tags.count(Tag.ANIMAL) >= 3 ? 3 : 1}));
    return undefined;
  }
}

================
File: cards/chemical/colonies/BusinessColony.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';
import {IPlayer, CanAffordOptions} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {BuildColony} from '../../../deferredActions/BuildColony';
import {Resource} from '../../../../common/Resource';

export class BusinessColony extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BUSINESS_COLONY,
      tags: [Tag.SPACE],
      cost: 20,

      metadata: {
        cardNumber: 'x350',
        renderData: CardRenderer.builder((b) => {
          b.colonies(1).production((pb) => pb.megacredits(1).slash().colonies(1, {size: Size.SMALL}));
        }),
        description: 'Place a colony, then increase your M€ production 1 step for each colony you own.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer, _canAffordOptions?: CanAffordOptions | undefined): boolean {
    return player.colonies.getPlayableColonies().length > 0;
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    player.game.defer(new BuildColony(player).andThen(() => {
      player.production.add(Resource.MEGACREDITS, player.getColoniesCount(), {log: true});
      return undefined;
    }));
    return undefined;
  }
}

================
File: cards/chemical/colonies/CassiniEnterprises.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';
import {IPlayer} from '../../../IPlayer';
import {ICard} from '../../ICard';
import {SelectCard} from '../../../inputs/SelectCard';
import { digit } from '../../Options';

export class CassiniEnterprises extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CASSINI_ENTERPRISES,
      cost: 20,
      tags: [Tag.JOVIAN, Tag.SPACE],
      requirements: {tag: Tag.JOVIAN, count: 1},
      victoryPoints: 1,

      behavior: {
        production: {titanium: 1},
      },

      metadata: {
        cardNumber: 'x379',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).br.resource(CardResource.ASTEROID, 2).asterix().nbsp.or().nbsp.resource(CardResource.FLOATER, {amount: 3, digit}).asterix();
        }),
        description: 'Requires a Jovian tag. Raise your titanium production 1 step and add 2 asteroids or 3 floaters to ANOTHER card.',
      },
    });
  }
  public getResCards(player: IPlayer): ICard[] {
    let resourceCards = player.getResourceCards(CardResource.ASTEROID);
    resourceCards = resourceCards.concat(player.getResourceCards(CardResource.FLOATER));
    return resourceCards;
  }
  public amount(card: ICard): number {
    return card.resourceType === CardResource.FLOATER ? 3 : 2;
  }

  public override bespokePlay(player: IPlayer) {
    const cards = this.getResCards(player);

    if (cards.length > 1) {
      return new SelectCard(
        'Select card to add resources',
        'Add resources',
        cards)
        .andThen(([card]) => {
          player.addResourceTo(card, {qty: this.amount(card), log: true});
          return undefined;
        });
    }

    if (cards.length === 1) {
      player.addResourceTo(cards[0], {qty: this.amount(cards[0]), log: true});
    }
    return undefined;
  }
}

================
File: cards/chemical/colonies/CeresLaunchpad.ts
================
import {IActionCard} from '../../ICard';
import {PlayerInput} from '../../../PlayerInput';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {SelectColony} from '../../../inputs/SelectColony';
import {IColony} from '../../../colonies/IColony';
import {ColoniesHandler} from '../../../colonies/ColoniesHandler';

export class CeresLaunchpad extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.CERES_LAUNCHPAD,
      type: CardType.ACTIVE,
      tags: [Tag.SPACE],
      cost: 23,
      resourceType: CardResource.ASTEROID,
      victoryPoints: 2,

      behavior: {
        colonies: {addTradeFleet: 1},
      },

      metadata: {
        cardNumber: 'x335',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 asteroid to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ASTEROID);
          }).br;
          b.or().br;
          b.action('Spend 1 asteroid to trade, first increasing the colony track one step.', (eb) => {
            eb.resource(CardResource.ASTEROID).startAction.trade().colon().text('+ 1');
          }).br;
          b.tradeFleet();
        }),
        description: 'Gain a trade fleet.',
      },
    });
  }
  public canAct(): boolean {
    return true;
  }
  public action(player: IPlayer) {
    const opts: Array<PlayerInput> = [];

    const addResource = new SelectOption('Add 1 asteroid to this card', 'Add asteroid').andThen( () => {
      player.addResourceTo(this, {log: true});
      return undefined;
    });
    const tradeableColonies = ColoniesHandler.tradeableColonies(player.game);
    const spendResource = new SelectColony('Select colony tile for trade', 'trade', tradeableColonies)
      .andThen((colony: IColony) => {
        this.resourceCount -= 1;
        colony.trade(player, {}, 1);
        return undefined;
      });

    opts.push(addResource);

    if (this.resourceCount > 0 && player.colonies.getFleetSize() > player.colonies.tradesThisGeneration) {
      opts.push(spendResource);
    } else {
      player.addResourceTo(this, {log: true});
      return undefined;
    }

    return new OrOptions(...opts);
  }
}

================
File: cards/chemical/colonies/ColonyMiningInfrastructure.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ColonyMiningInfrastructure extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.COLONY_MINING_INFRASTRUCTURE,
      cost: 5,
      requirements: {colonies: 2},

      behavior: {
        production: {titanium: 1},
      },

      metadata: {
        cardNumber: 'x366',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1));
        }),
        description: 'Requires you own 2 colonies. Increase your titanium production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/colonies/ColonyReforms.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {CanAffordOptions, IPlayer} from '../../../IPlayer';
import {SelectColony} from '../../../inputs/SelectColony';

export class ColonyReforms extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 5,
      name: CardName.COLONY_REFORMS,
      type: CardType.AUTOMATED,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'x384',
        renderData: CardRenderer.builder((b) => {
          b.colonyTile().asterix().nbsp.colon().text('+ 1');
        }),
        description: 'Increase the colony track of a colony tile that you have a colony on 1 step.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer, _canAffordOptions?: CanAffordOptions | undefined): boolean {
    return player.getColoniesCount() > 0;
  }
  public override bespokePlay(player: IPlayer) {
    const colonies = player.game.colonies.filter((colony) => colony.colonies.filter((owner) => owner === player.id).length > 0);
    return new SelectColony('Select a colony to increase the track of', 'Increase track', colonies).andThen((colony) => {
      colony.increaseTrack(1);
      return undefined;
    });
  }
}

================
File: cards/chemical/colonies/ColonySpaceMirrors.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {Size} from '../../../../common/cards/render/Size';

export class ColonySpaceMirrors extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.COLONY_SPACE_MIRRORS,
      tags: [Tag.POWER, Tag.SPACE],
      cost: 18,

      behavior: {
        production: {energy: {colonies: {colonies: {}}, all: true}},
      },

      metadata: {
        cardNumber: 'x371',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).slash().colonies(1, {all, size: Size.SMALL}));
        }),
        description: 'Increase your energy production 1 step for each colony in play.',
      },
    });
  }
}

================
File: cards/chemical/colonies/ColonySuppliers.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {IColony} from '../../../colonies/IColony';

export class ColonySuppliers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.COLONY_SUPPLIERS,
      cost: 10,

      behavior: {
        colonies: {addTradeFleet: 1},
      },

      metadata: {
        cardNumber: 'x340',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you trade, gain 1 M€ for each colony on the tile you trade with.', (eb) => {
            eb.trade().startEffect.megacredits(1).slash().colonies(1).asterix();
          }).br;
          b.tradeFleet();
        }),
        description: 'Gain a trade fleet.',
      },
    });
  }

  public onTrade(cardOwner: IPlayer, activePlayer: IPlayer, colony: IColony) {
    if (cardOwner.id === activePlayer.id) {
      cardOwner.stock.add(Resource.MEGACREDITS, colony.colonies.length, {log: true});
    }
  }
}

================
File: cards/chemical/colonies/CommissionedFleet.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {SelectColony} from '../../../inputs/SelectColony';
import {IColony} from '../../../colonies/IColony';
import {Tag} from '../../../../common/cards/Tag';
import {ColoniesHandler} from '../../../colonies/ColoniesHandler';

export class CommissionedFleet extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 8,
      name: CardName.COMMISSIONED_FLEET,
      type: CardType.EVENT,
      tags: [Tag.SPACE],

      behavior: {
        colonies: {addTradeFleet: 1},
      },

      metadata: {
        cardNumber: 'x317',
        renderData: CardRenderer.builder((b) => {
          b.tradeFleet().nbsp.trade();
        }),
        description: 'Gain a trade fleet, then trade for free.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const tradeableColonies = ColoniesHandler.tradeableColonies(player.game);
    return new SelectColony('Select colony tile for trade', 'trade', tradeableColonies)
      .andThen((colony: IColony) => {
        colony.trade(player);
        return undefined;
      });
  }
}

================
File: cards/chemical/colonies/CoordinatedRaidChemcial.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {SelectColony} from '../../../inputs/SelectColony';
import {IColony} from '../../../colonies/IColony';
import {ColoniesHandler} from '../../../colonies/ColoniesHandler';

export class CoordinatedRaidChemical extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 5,
      name: CardName.COORDINATED_RAID_CHEMICAL,
      type: CardType.EVENT,

      metadata: {
        cardNumber: 'x313',
        renderData: CardRenderer.builder((b) => b.trade().asterix()),
        description: 'Trade for free. Collect the colony bonus for every colony on this tile. Other players do not get their colony bonuses from this action.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.colonies.getFleetSize() > player.colonies.tradesThisGeneration;
  }

  public override bespokePlay(player: IPlayer) {
    const tradeableColonies = ColoniesHandler.tradeableColonies(player.game);
    return new SelectColony('Select colony tile for trade', 'trade', tradeableColonies)
      .andThen((colony: IColony) => {
        colony.trade(player, {selfishTrade: true});
        return undefined;
      });
  }
}

================
File: cards/chemical/colonies/DeepJupiterProbe.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {CardResource} from '../../../../common/CardResource';
import {Tag} from '../../../../common/cards/Tag';

export class DeepJupiterProbe extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 11,
      name: CardName.DEEP_JUPITER_PROBE,
      type: CardType.EVENT,
      tags: [Tag.JOVIAN],
      victoryPoints: 1,

      behavior: {
        drawCard: 1,
        addResourcesToAnyCard: {type: CardResource.FLOATER, tag: Tag.JOVIAN, count: 2},
      },

      metadata: {
        cardNumber: 'x321',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.JOVIAN}).nbsp.cards(1);
        }),
        description: 'Add 2 floaters to any Jovian card and draw a card.',
      },
    });
  }
}

================
File: cards/chemical/colonies/DomeFarmingColony.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class DomeFarmingColony extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DOME_FARMING_COLONY,
      tags: [Tag.PLANT, Tag.SPACE],
      cost: 20,

      behavior: {
        production: {plants: 1},
        colonies: {buildColony: {}},
      },

      metadata: {
        cardNumber: 'x353',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).colonies(1);
        }),
        description: 'Increase your plant production 1 step and place a colony.',
      },
    });
  }
}

================
File: cards/chemical/colonies/EarthEmbassyChemical.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class EarthEmbassyChemical extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.EARTH_EMBASSY_CHEMICAL,
      tags: [Tag.EARTH, Tag.BUILDING],
      cost: 14,
      victoryPoints: 1,

      behavior: {
        tr: 1,
      },

      metadata: {
        cardNumber: 'x375',
        renderData: CardRenderer.builder((b) => {
          b.tr(1);
        }),
        description: 'Raise your TR 1 step.',
      },
    });
  }
}

================
File: cards/chemical/colonies/EnergyBeamColony.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class EnergyBeamColony extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ENERGY_BEAM_COLONY,
      tags: [Tag.POWER, Tag.SPACE],
      cost: 27,

      behavior: {
        production: {energy: 2, heat: 2, megacredits: -2},
        colonies: {buildColony: {}},
      },

      metadata: {
        cardNumber: 'x354',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().megacredits(2).br;
            pb.plus().energy(2).br;
            pb.plus().heat(2).br;
          }).colonies(1);
        }),
        description: 'Decrease your M€ production 1 step. Increase your energy production 2 steps and your heat production 2 steps. Place a colony.',
      },
    });
  }
}

================
File: cards/chemical/colonies/FloaterFacility.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardResource} from '../../../../common/CardResource';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class FloaterFacility extends ActionCard implements IProjectCard {
  constructor() {
    super({
      cost: 6,
      tags: [Tag.BUILDING],
      name: CardName.FLOATER_FACILITY,
      type: CardType.ACTIVE,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Add a floater to ANY card',
            addResourcesToAnyCard: {type: CardResource.FLOATER, count: 1},
          },
          {
            title: 'gain 2 M€',
            stock: {megacredits: 2},
          }],
        },
      },

      metadata: {
        cardNumber: 'x337',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to ANY card or gain 2 M€.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER).asterix().nbsp.or().nbsp.megacredits(2);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/colonies/FloatingColony.ts
================
import {IActionCard} from '../../ICard';
import {PlayerInput} from '../../../PlayerInput';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {SelectAmount} from '../../../inputs/SelectAmount';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {SelectCard} from '../../../inputs/SelectCard';

export class FloatingColony extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.FLOATING_COLONY,
      type: CardType.ACTIVE,
      tags: [Tag.SPACE],
      cost: 20,
      requirements: {floaters: 3},
      resourceType: CardResource.FLOATER,

      behavior: {
        colonies: {buildColony: {}},
      },

      metadata: {
        cardNumber: 'x328',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to ANY card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER).asterix();
          }).br;
          b.or().br;
          b.action('Spend any number of floaters here to gain triple amount of M€.', (eb) => {
            eb.text('X').resource(CardResource.FLOATER).startAction.text('X').megacredits(3);
          }).br;
          b.colonies(1);
        }),
        description: 'Requires 3 floaters. Place a colony.',
      },
    });
  }
  public canAct(): boolean {
    return true;
  }
  public action(player: IPlayer) {
    const opts: Array<PlayerInput> = [];
    const resourceCards = player.getResourceCards(this.resourceType);
    const addResource = new SelectOption('Add 1 floater to any card', 'Add floater').andThen( () => {
      if (resourceCards.length === 1) {
        player.addResourceTo(this, 1);
        return undefined;
      }
      return new SelectCard(
        'Select card to add 1 floater',
        'Add floater',
        resourceCards)
        .andThen(
          ([card]) => {
            player.addResourceTo(card, 1);
            return undefined;
          },
        );
    });
    const spendResource = new SelectAmount('Remove any number of floaters to gain 3 M€ per floater removed', 'Remove floaters', 1, this.resourceCount, true)
      .andThen((amount) => this.spendResource(player, amount));

    opts.push(addResource);

    if (this.resourceCount > 0) {
      opts.push(spendResource);
    }

    return new OrOptions(...opts);
  }

  private spendResource(player: IPlayer, amount: number) {
    player.removeResourceFrom(this, amount, {log: false});

    const mcGained = 3 * amount;
    player.megaCredits += mcGained;

    player.game.log('${0} removed ${1} asteroids from ${2} to gain ${3} M€', (b) =>
      b.player(player).number(amount).card(this).number(mcGained));

    return undefined;
  }
}

================
File: cards/chemical/colonies/FloatingTechInvestments.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardRenderer} from '../../render/CardRenderer';
import {ICard} from '../../ICard';
import {CardResource} from '../../../../common/CardResource';
import {Resource} from '../../../../common/Resource';

export class FloatingTechInvestments extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.FLOATING_TECH_INVESTMENTS,
      cost: 3,

      behavior: {
        production: {megacredits: -1},
      },

      metadata: {
        cardNumber: 'x338',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you gain a floater to ANY CARD, also gain 1 M€.', (eb) => {
            eb.resource(CardResource.FLOATER).asterix().startEffect.megacredits(1);
          }).br;
          b.production((pb) => pb.minus().megacredits(1));
        }),
        description: 'Decrease your M€ production 1 step.',
      },
    });
  }

  public onResourceAdded(player: IPlayer, card: ICard, count: number) {
    if (card.resourceType === CardResource.FLOATER) {
      player.stock.add(Resource.MEGACREDITS, count, {log: true});
    }
  }
}

================
File: cards/chemical/colonies/FloatingTechResearch.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {CardResource} from '../../../../common/CardResource';

export class FloatingTechResearch extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 10,
      name: CardName.FLOATING_TECH_RESEARCH,
      type: CardType.EVENT,

      behavior: {
        drawCard: 2,
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2},
      },

      metadata: {
        cardNumber: 'x320',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.FLOATER, 2).asterix().nbsp.cards(2);
        }),
        description: 'Add 2 floaters to ANY card and draw 2 cards.',
      },
    });
  }
}

================
File: cards/chemical/colonies/FuelSubsidies.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class FuelSubsidies extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.FUEL_SUBSIDIES,
      tags: [Tag.EARTH],
      cost: 3,
      requirements: {tag: Tag.EARTH, count: 2},

      behavior: {
        stock: {energy: 2},
      },

      metadata: {
        cardNumber: 'x341',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you trade, you pay 5 M€ less.', (eb) => {
            eb.trade().startEffect.megacredits(-5);
          }).br;
          b.energy(2);
        }),
        description: 'Requires 2 Earth tags. Gain 2 energy.',
      },
    });
  }
}

================
File: cards/chemical/colonies/GalileanMiningNetwork.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardResource} from '../../../../common/CardResource';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class GalileanMiningNetwork extends ActionCard implements IProjectCard {
  constructor() {
    super({
      cost: 19,
      tags: [Tag.JOVIAN],
      name: CardName.GALILEAN_MINING_NETWORK,
      type: CardType.ACTIVE,
      resourceType: CardResource.FLOATER,
      victoryPoints: 1,

      behavior: {
        stock: {titanium: 2},
      },

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Remove 2 floaters to increase your titanium production 1 step',
            spend: {resourcesHere: 2},
            production: {titanium: 1},
          },
          {
            title: 'Add a floater to any Jovian card',
            addResourcesToAnyCard: {type: CardResource.FLOATER, count: 1, tag: Tag.JOVIAN},
          }],
        },
      },

      metadata: {
        cardNumber: 'x334',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to any Jovian card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER, {secondaryTag: Tag.JOVIAN});
          }).br;
          b.or().br;
          b.action('Spend 1 floater here to increase your titanium production 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.production((pb) => pb.titanium(1));
          }).br;
          b.titanium(2);
        }),
        description: 'Gain 2 titanium.',
      },
    });
  }
}

================
File: cards/chemical/colonies/GasGiantHabs.ts
================
import {IActionCard} from '../../ICard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class GasGiantHabs extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.GAS_GIANT_HABS,
      type: CardType.ACTIVE,
      tags: [Tag.JOVIAN],
      cost: 10,

      resourceType: CardResource.FLOATER,
      victoryPoints: {resourcesHere: {}, per: 2},

      action: {
        spend: {megacredits: 2},
        addResourcesToAnyCard: {type: CardResource.FLOATER, tag: Tag.JOVIAN, count: 1, autoSelect: true},
      },

      requirements: {tag: Tag.JOVIAN, count: 2},
      metadata: {
        cardNumber: 'x329',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 M€ to add 1 floater to any Jovian card', (eb) => {
            eb.megacredits(2).startAction.resource(CardResource.FLOATER, {secondaryTag: Tag.JOVIAN});
          }).br;
          b.vpText('1 VP for every 2nd Floater on this card.').br;
          b.resource(CardResource.FLOATER, 2);
        }),
        description: 'Requires 2 Jovian tags. Add 2 floaters to this card.',
      },
    });
  }
}

================
File: cards/chemical/colonies/HemeraBunker.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class HemeraBunker extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HEMERA_BUNKER,
      cost: 18,
      tags: [Tag.SCIENCE, Tag.SPACE],
      requirements: {tag: Tag.SCIENCE, count: 3},
      victoryPoints: 2,

      behavior: {
        production: {titanium: 1},
        drawCard: 2,
      },

      metadata: {
        cardNumber: 'x367',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).cards(2);
        }),
        description: 'Requires 3 science tags. Increase your titanium production 1 step and draw 2 cards.',
      },
    });
  }
}

================
File: cards/chemical/colonies/HighOrbitResearchStation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class HighOrbitResearchStation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HIGH_ORBIT_RESEARCH_STATION,
      cost: 12,
      tags: [Tag.SCIENCE, Tag.SPACE],
      requirements: {tag: Tag.SPACE, count: 5},
      victoryPoints: 2,

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: 'x376',
        renderData: CardRenderer.builder((b) => {
          b.cards(2);
        }),
        description: 'Requires 5 space tags. Draw 2 cards.',
      },
    });
  }
}

================
File: cards/chemical/colonies/HyperExtremophileFungi.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';
import {all} from '../../Options';

export class HyperExtremophileFungi extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HYPER_EXTREMOPHILE_FUNGI,
      cost: 12,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      requirements: {tag: Tag.SCIENCE, count: 6},
      victoryPoints: 1,

      behavior: {
        stock: {plants: {colonies: {colonies: {}}, all: true, each: 2}},
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 2},
      },

      metadata: {
        cardNumber: 'x382',
        renderData: CardRenderer.builder((b) => {
          b.plants(2).slash().colonies(1, {all}).nbsp.resource(CardResource.MICROBE, 2).asterix();
        }),
        description: 'Requires 6 science tags. Gain 2 plants for each colony in play and add 2 microbes to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/colonies/IceMoonCollision.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {digit, all} from '../../Options';

export class IceMoonCollision extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 28,
      name: CardName.ICE_MOON_COLLISION,
      type: CardType.EVENT,
      requirements: {tag: Tag.JOVIAN, count: 2},
      tags: [Tag.SPACE],

      behavior: {
        global: {temperature: 1},
        ocean: {count: 2},
        removeAnyPlants: 4,
      },

      metadata: {
        cardNumber: 'x323',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1).oceans(2).minus().plants(4, {digit, all});
        }),
        description: 'Requires 2 Jovian tags. Raise the temperature 1 step, place 2 ocean tiles, and remove up to 4 plants from any player.',
      },
    });
  }
}

================
File: cards/chemical/colonies/IndustrialColony.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class IndustrialColony extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INDUSTRIAL_COLONY,
      tags: [Tag.POWER, Tag.SPACE],
      cost: 24,

      behavior: {
        production: {energy: 1, steel: 1},
        colonies: {buildColony: {}},
      },

      metadata: {
        cardNumber: 'x352',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).steel(1)).colonies(1);
        }),
        description: 'Increase your energy production 1 step and your steel production 1 step. Place a colony.',
      },
    });
  }
}

================
File: cards/chemical/colonies/JovianConstructionYard.ts
================
import {IActionCard} from '../../ICard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class JovianConstructionYard extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.JOVIAN_CONSTRUCTION_YARD,
      type: CardType.ACTIVE,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 23,
      victoryPoints: 1,

      resourceType: CardResource.FLOATER,

      behavior: {
        production: {titanium: 1},
      },

      action: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, tag: Tag.JOVIAN, count: 1, autoSelect: true},
      },

      metadata: {
        cardNumber: 'x331',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to any Jovian card', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER, {secondaryTag: Tag.JOVIAN});
          }).br;
          b.effect('Floaters on this card mey be used as 3 M€ when paying for cards with Jovian tags.', (eb) => {
            eb.tag(Tag.JOVIAN).startEffect.resource(CardResource.FLOATER).equals().megacredits(3);
          }).br;
          b.production((pb) => pb.titanium(1));
        }),
        description: 'Increase your titanium production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/colonies/JovianMoonMapping.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class JovianMoonMapping extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 8,
      name: CardName.JOVIAN_MOON_MAPPING,
      type: CardType.EVENT,
      requirements: {tag: Tag.JOVIAN, count: 1},
      tags: [Tag.JOVIAN],
      victoryPoints: 1,

      behavior: {
        stock: {titanium: 2},
      },

      metadata: {
        cardNumber: 'x322',
        renderData: CardRenderer.builder((b) => {
          b.titanium(2);
        }),
        description: 'Requires 1 Jovian tag. Gain 2 titanium.',
      },
    });
  }
}

================
File: cards/chemical/colonies/JupiterFloatingCity.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardResource} from '../../../../common/CardResource';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';
import {SpaceName} from '../../../SpaceName';

export class JupiterFloatingCity extends ActionCard implements IProjectCard {
  constructor() {
    super({
      cost: 24,
      tags: [Tag.CITY, Tag.JOVIAN],
      name: CardName.JUPITER_FLOATING_CITY,
      type: CardType.ACTIVE,
      requirements: {tag: Tag.SCIENCE, count: 4},
      victoryPoints: {tag: Tag.JOVIAN},

      behavior: {
        production: {energy: -1},
        city: {space: SpaceName.JUPITER_FLOATING_CITY},
      },

      action: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2, tag: Tag.JOVIAN},
      },

      metadata: {
        cardNumber: 'x336',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 2 floaters to any Jovian card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.JOVIAN});
          }).br;
          b.vpText('1 VP per Jovian tag you have').br;
          b.production((pb) => pb.minus().energy(1)).nbsp.city().asterix();
        }),
        description: 'Requires 4 science tags. Decrease your energy production 1 step. Place a city tile ON THE RESERVED AREA.',
      },
    });
  }
}

================
File: cards/chemical/colonies/KuiperBeltColony.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class KuiperBeltColony extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.KUIPER_BELT_COLONY,
      tags: [Tag.SPACE],
      cost: 25,
      victoryPoints: 2,

      behavior: {
        drawCard: 1,
        colonies: {buildColony: {}},
      },

      metadata: {
        cardNumber: 'x355',
        renderData: CardRenderer.builder((b) => {
          b.colonies(1).cards(1);
        }),
        description: 'Place a colony and draw a card.',
      },
    });
  }
}

================
File: cards/chemical/colonies/LargeTradingFleet.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {SelectColony} from '../../../inputs/SelectColony';
import {IColony} from '../../../colonies/IColony';
import {Tag} from '../../../../common/cards/Tag';
import {ColoniesHandler} from '../../../colonies/ColoniesHandler';

export class LargeTradingFleet extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 10,
      name: CardName.LARGE_TRADING_FLEET,
      type: CardType.EVENT,
      tags: [Tag.SPACE],

      behavior: {
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'x315',
        renderData: CardRenderer.builder((b) => {
          b.trade().colon().text('+ 1').nbsp.cards(1);
        }),
        description: 'Trade for free, first increasing the colony track of the tile you trade with one step. Draw a card.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.colonies.getFleetSize() > player.colonies.tradesThisGeneration;
  }

  public override bespokePlay(player: IPlayer) {
    const tradeableColonies = ColoniesHandler.tradeableColonies(player.game);
    return new SelectColony('Select colony tile for trade', 'trade', tradeableColonies)
      .andThen((colony: IColony) => {
        colony.trade(player, {}, 1);
        return undefined;
      });
  }
}

================
File: cards/chemical/colonies/LunaColonizationInvestments.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class LunaColonizationInvestments extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LUNA_COLONIZATION_INVESTMENTS,
      tags: [Tag.EARTH],
      cost: 8,
      requirements: {tag: Tag.EARTH, count: 2},
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'x361',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2));
        }),
        description: 'Requires 2 Earth tags. Increase your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/colonies/LunarH3Mining.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class LunarH3Mining extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LUNAR_H3_MINING,
      tags: [Tag.POWER, Tag.EARTH],
      cost: 16,

      behavior: {
        production: {titanium: 1, energy: 1},
      },

      metadata: {
        cardNumber: 'x365',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1).energy(1));
        }),
        description: 'Increase your titanium production 1 step and your energy production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/colonies/LunarPort.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class LunarPort extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LUNAR_PORT,
      tags: [Tag.EARTH],
      cost: 16,
      victoryPoints: 1,

      behavior: {
        colonies: {addTradeFleet: 1},
        production: {megacredits: 3},
      },

      metadata: {
        cardNumber: 'x358',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(3));
          b.tradeFleet();
        }),
        description: 'Increase your M€ production 3 steps and gain a trade fleet.',
      },
    });
  }
}

================
File: cards/chemical/colonies/LunarPowerGrid.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class LunarPowerGrid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LUNAR_POWER_GRID,
      tags: [Tag.POWER, Tag.EARTH],
      cost: 7,

      behavior: {
        production: {energy: {tag: Tag.EARTH, per: 2}},
      },

      metadata: {
        cardNumber: 'x372',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).slash().tag(Tag.EARTH, 2));
        }),
        description: 'Increase your energy production 1 step for every 2 Earth tags you have, including this.',
      },
    });
  }
}

================
File: cards/chemical/colonies/LunarResort.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class LunarResort extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LUNAR_RESORT,
      tags: [Tag.EARTH],
      cost: 10,

      behavior: {
        production: {megacredits: {tag: Tag.EARTH}},
      },

      metadata: {
        cardNumber: 'x360',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).slash().tag(Tag.EARTH));
        }),
        description: 'Increase your M€ production 1 step for each Earth tag you have, including this.',
      },
    });
  }
}

================
File: cards/chemical/colonies/MarketSiphon.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {Resource} from '../../../../common/Resource';
import {all} from '../../Options';

export class MarketSiphon extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 2,
      name: CardName.MARKET_SIPHON,
      type: CardType.EVENT,
      tags: [Tag.EARTH],
      requirements: {tag: Tag.EARTH, count: 1},

      behavior: {
        decreaseAnyProduction: {type: Resource.MEGACREDITS, count: 1},
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'x318',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).nbsp.megacredits(-1, {all}));
        }),
        description: 'Requires 1 Earth tag. Increase your M€ production 1 step and decrease any players M€ production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/colonies/MercurialSunshade.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class MercurialSunshade extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MERCURIAL_SUNSHADE,
      cost: 24,
      tags: [Tag.SPACE],
      requirements: {tag: Tag.SCIENCE, count: 3},
      victoryPoints: 1,

      metadata: {
        cardNumber: 'x342',
        renderData: CardRenderer.builder((b) => {
          b.tr(3);
        }),
        description: 'Requires 3 science tags. Raise your TR 3 steps.',
      },
    });
  }
}

================
File: cards/chemical/colonies/MethaneExports.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardResource} from '../../../../common/CardResource';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class MethaneExports extends ActionCard implements IProjectCard {
  constructor() {
    super({
      cost: 16,
      tags: [Tag.JOVIAN],
      name: CardName.METHANE_EXPORTS,
      type: CardType.ACTIVE,
      resourceType: CardResource.FLOATER,
      victoryPoints: 1,

      behavior: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2, tag: Tag.JOVIAN},
      },

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 1 floater to increase your heat production 1 step',
            spend: {resourcesHere: 1},
            production: {heat: 1},
          },
          {
            title: 'Add a floater to this card',
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: 'x333',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER);
          }).br;
          b.or().br;
          b.action('Remove 1 floater from this card to increase your heat production 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER).startAction.production((pb) => pb.heat(1));
          }).br;
          b.resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.JOVIAN});
        }),
        description: 'Add 2 floaters to any Jovian card.',
      },
    });
  }
}

================
File: cards/chemical/colonies/MicrogravityLab.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class MicrogravityLab extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MICROGRAVITY_LAB,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 10,
      requirements: {tag: Tag.SCIENCE, count: 4},
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 2, energy: -1},
        stock: {megacredits: {colonies: {colonies: {}}, each: 5}},
      },

      metadata: {
        cardNumber: 'x362',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(2);
          });
          b.megacredits(5).slash().colonies(1);
        }),
        description: 'Requires 4 science tags. Decrease your energy production 1 step, increase your M€ production 2 steps, and gain 5 M€ for each colony you own.',
      },
    });
  }
}

================
File: cards/chemical/colonies/MilitarySpaceStation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class MilitarySpaceStation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MILITARY_SPACE_STATION,
      tags: [Tag.SPACE],
      cost: 19,
      victoryPoints: -1,

      behavior: {
        production: {energy: -1, megacredits: 1, titanium: 1},
        stock: {titanium: 4},
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'x364',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().energy(1).br.plus().megacredits(1).titanium(1)).cards(1).titanium(4, {digit});
        }),
        description: 'Decrease your energy production 1 step. Increase your M€ production 1 step and your titatium production 1 step. Draw a card and gain 4 titanium.',
      },
    });
  }
}

================
File: cards/chemical/colonies/MuseumOfLuna.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class MuseumOfLuna extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MUSEUM_OF_LUNA,
      tags: [Tag.EARTH],
      cost: 11,
      victoryPoints: 1,

      behavior: {
        drawCard: 1,
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'x359',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1));
          b.cards(1);
        }),
        description: 'Increase your M€ production 1 step and draw a card.',
      },
    });
  }
}

================
File: cards/chemical/colonies/OrbitalBiodomes.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class OrbitalBiodomes extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ORBITAL_BIODOMES,
      cost: 15,
      tags: [Tag.PLANT, Tag.SPACE],

      behavior: {
        production: {plants: 2},
      },

      metadata: {
        cardNumber: 'x368',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(2));
        }),
        description: 'Increase your plant production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/colonies/OuterSolarMission.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {SelectColony} from '../../../inputs/SelectColony';
import {IColony} from '../../../colonies/IColony';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';
import {ColoniesHandler} from '../../../colonies/ColoniesHandler';

export class OuterSolarMission extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 12,
      name: CardName.OUTER_SOLAR_MISSION,
      type: CardType.EVENT,
      tags: [Tag.SPACE],

      behavior: {
        stock: {titanium: 2},
        addResourcesToAnyCard: {type: CardResource.FLOATER, tag: Tag.JOVIAN, count: 2},
      },

      metadata: {
        cardNumber: 'x316',
        renderData: CardRenderer.builder((b) => {
          b.trade().br;
          b.titanium(2).resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.JOVIAN});
        }),
        description: 'Trade for free. Gain 2 titanium and add 2 floaters to any Jovian card.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.colonies.getFleetSize() > player.colonies.tradesThisGeneration;
  }

  public override bespokePlay(player: IPlayer) {
    const tradeableColonies = ColoniesHandler.tradeableColonies(player.game);
    return new SelectColony('Select colony tile for trade', 'trade', tradeableColonies)
      .andThen((colony: IColony) => {
        colony.trade(player);
        return undefined;
      });
  }
}

================
File: cards/chemical/colonies/PlanetaryTrade.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';

export class PlanetaryTrade extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 10,
      name: CardName.PLANETARY_TRADE,
      type: CardType.EVENT,
      tags: [Tag.EARTH],

      metadata: {
        cardNumber: 'x319',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(2).slash().diverseTag();
        }),
        description: 'Gain 2 M€ for each unique tag you have (not including the tags on this card).',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    const distinctTagCount = player.tags.distinctCount('default');
    player.stock.add(Resource.MEGACREDITS, distinctTagCount * 2, {log: true});
    return undefined;
  }
}

================
File: cards/chemical/colonies/PrivateColony.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {SelectOption} from '../../../inputs/SelectOption';
import {OrOptions} from '../../../inputs/OrOptions';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';

export class PrivateColony extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 10,
      tags: [Tag.SPACE],
      name: CardName.PRIVATE_COLONY,
      type: CardType.ACTIVE,

      metadata: {
        cardNumber: 'x345',
        renderData: CardRenderer.builder((b) => {
          b.action('Move one of your trade fleets from the Trade Fleets Tile to this card to raise your M€ prodcution 1 step or gain 4 M€. Fleets on this card may no longer trade, and return to the Trade Fleets Tile during the Solar Phase.', (eb) => {
            eb.tradeFleet().asterix().startAction.production((pb) => pb.megacredits(1)).nbsp.or().nbsp.megacredits(4);
          }).br;
        }),
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.colonies.getFleetSize() > player.colonies.tradesThisGeneration;
  }
  public action(player: IPlayer) {
    player.colonies.tradesThisGeneration++;
    const opts: Array<SelectOption> = [];
    opts.push(new SelectOption('Gain 4 M€', 'Gain M€').andThen( () => {
      player.stock.add(Resource.MEGACREDITS, 4, {log: true});
      return undefined;
    }));
    opts.push(new SelectOption('Raise your M€ production 1 step', 'Raise M€ production').andThen( () => {
      player.production.add(Resource.MEGACREDITS, 1, {log: true});
      return undefined;
    }));
    return new OrOptions(...opts);
  }
}

================
File: cards/chemical/colonies/ProductivityQuota.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';

export class ProductivityQuota extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 0,
      name: CardName.PRODUCTIVITY_QUOTA,
      type: CardType.EVENT,

      metadata: {
        cardNumber: 'x324',
        renderData: CardRenderer.builder((b) => {
          b.text('ALL').colonyTile().colon().text('+ 1');
        }),
        description: 'Increase the colony tracks of all colony tiles 1 step.',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    const activeColonies = player.game.colonies.filter((colony) => colony.isActive);
    activeColonies.forEach((colony) => {
      colony.increaseTrack(1);
    });
    return undefined;
  }
}

================
File: cards/chemical/colonies/ProtoDysonSwarm.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class ProtoDysonSwarm extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PROTO_DYSON_SWARM,
      tags: [Tag.POWER, Tag.SPACE],
      cost: 44,
      victoryPoints: 4,

      behavior: {
        production: {energy: 6},
      },

      metadata: {
        cardNumber: 'x373',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(6, {digit}));
        }),
        description: 'Increase your energy production 6 steps.',
      },
    });
  }
}

================
File: cards/chemical/colonies/RemoteMiningBase.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';

export class RemoteMiningBase extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 13,
      tags: [Tag.SPACE],
      name: CardName.REMOTE_MINING_BASE,
      type: CardType.ACTIVE,

      metadata: {
        cardNumber: 'x346',
        renderData: CardRenderer.builder((b) => {
          b.action('Move one of your trade fleets from the Trade Fleets Tile to this card to gain 2 titanium. Fleets on this card may no longer trade, and return to the Trade Fleets Tile during the Solar Phase.', (eb) => {
            eb.tradeFleet().asterix().startAction.titanium(2);
          }).br;
        }),
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.colonies.getFleetSize() > player.colonies.tradesThisGeneration;
  }
  public action(player: IPlayer) {
    player.colonies.tradesThisGeneration++;
    player.stock.add(Resource.TITANIUM, 2, {log: true});
    return undefined;
  }
}

================
File: cards/chemical/colonies/RemoteTestZone.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class RemoteTestZone extends ActionCard implements IProjectCard {
  constructor() {
    super({
      cost: 15,
      tags: [Tag.SPACE],
      name: CardName.REMOTE_TEST_ZONE,
      type: CardType.ACTIVE,

      behavior: {
        colonies: {buildColony: {}},
      },

      action: {
        spend: {megacredits: 3},
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'x343',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 3 M€ to draw a card.', (eb) => {
            eb.megacredits(3).startAction.cards(1);
          }).br;
          b.colonies(1);
        }),
        description: 'Place a colony.',
      },
    });
  }
}

================
File: cards/chemical/colonies/ResearchMissions.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {IPlayer} from '../../../IPlayer';

export class ResearchMissions extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 13,
      tags: [Tag.SCIENCE],
      name: CardName.RESEARCH_MISSIONS,
      type: CardType.ACTIVE,

      metadata: {
        cardNumber: 'x347',
        renderData: CardRenderer.builder((b) => {
          b.action('Move one of your trade fleets from the Trade Fleets Tile to this card to draw a card. Fleets on this card may no longer trade, and return to the Trade Fleets Tile during the Solar Phase.', (eb) => {
            eb.tradeFleet().asterix().startAction.cards(1);
          }).br;
        }),
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.colonies.getFleetSize() > player.colonies.tradesThisGeneration;
  }
  public action(player: IPlayer) {
    player.colonies.tradesThisGeneration++;
    player.drawCard(1);
    return undefined;
  }
}

================
File: cards/chemical/colonies/RimPopulationCenter.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class RimPopulationCenter extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.RIM_POPULATION_CENTER,
      tags: [Tag.SPACE],
      cost: 7,

      behavior: {
        production: {energy: -1},
        colonies: {buildColony: {}},
      },

      metadata: {
        cardNumber: 'x349',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().energy(1)).colonies(1);
        }),
        description: 'Decrease your energy production 1 step and place a colony.',
      },
    });
  }
}

================
File: cards/chemical/colonies/SelfSufficientColony.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class SelfSufficientColony extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SELF_SUFFICIENT_COLONY,
      tags: [Tag.SPACE],
      cost: 26,
      victoryPoints: 2,

      behavior: {
        production: {energy: -1, megacredits: 2},
        colonies: {buildColony: {}},
      },

      metadata: {
        cardNumber: 'x351',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(2);
          }).colonies(1);
        }),
        description: 'Decrease your energy production 1 step, increase your M€ production 2 steps, and place a colony.',
      },
    });
  }
}

================
File: cards/chemical/colonies/SlumCity.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class SlumCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SLUM_CITY,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 12,
      victoryPoints: -1,

      behavior: {
        city: {},
        production: {energy: -1, megacredits: 2},
      },

      metadata: {
        cardNumber: 'x357',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(2);
          });
          b.city();
        }),
        description: 'Decrease your energy production 1 step and increase your M€ production 2 steps. Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/colonies/SpaceTethers.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class SpaceTethers extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SPACE_TETHERS,
      tags: [Tag.SPACE],
      cost: 12,
      resourceType: CardResource.FLOATER,
      victoryPoints: 1,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 1 floater to gain 5 M€',
            spend: {resourcesHere: 1},
            stock: {megacredits: 5},
          },
          {
            title: 'Add 1 floater to ANY card',
            addResourcesToAnyCard: {type: CardResource.FLOATER, count: 1},
          }],
        },
      },

      metadata: {
        cardNumber: 'x327',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to ANY card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER).asterix();
          }).br;
          b.or().br;
          b.action('Remove 1 floater from this card to gain 5 M€.', (eb) => {
            eb.resource(CardResource.FLOATER).startAction.megacredits(5);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/colonies/SponsoredFlight.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';
import {SelectColony} from '../../../inputs/SelectColony';
import {IColony} from '../../../colonies/IColony';
import {Tag} from '../../../../common/cards/Tag';
import {ColoniesHandler} from '../../../colonies/ColoniesHandler';

export class SponsoredFlight extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 1,
      name: CardName.SPONSORED_FLIGHT,
      type: CardType.EVENT,
      tags: [Tag.EARTH, Tag.SPACE],
      requirements: {tag: Tag.EARTH, count: 1},

      metadata: {
        cardNumber: 'x314',
        renderData: CardRenderer.builder((b) => b.trade()),
        description: 'Requires 1 Earth tag. Trade for free.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.colonies.getFleetSize() > player.colonies.tradesThisGeneration;
  }

  public override bespokePlay(player: IPlayer) {
    const tradeableColonies = ColoniesHandler.tradeableColonies(player.game);
    return new SelectColony('Select colony tile for trade', 'trade', tradeableColonies)
      .andThen((colony: IColony) => {
        colony.trade(player);
        return undefined;
      });
  }
}

================
File: cards/chemical/colonies/TerrestrialResearchSummit.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class TerrestrialResearchSummit extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TERRESTRIAL_RESEARCH_SUMMIT,
      cost: 10,
      tags: [Tag.SCIENCE, Tag.EARTH],
      requirements: {tag: Tag.EARTH, count: 2},
      victoryPoints: 1,

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: 'x377',
        renderData: CardRenderer.builder((b) => {
          b.cards(2);
        }),
        description: 'Requires 2 Earth tags. Draw 2 cards.',
      },
    });
  }
}

================
File: cards/chemical/colonies/ThermalReservior.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {SelectAmount} from '../../../inputs/SelectAmount';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {AddResourcesToCard} from '../../../deferredActions/AddResourcesToCard';
import {CardResource} from '../../../../common/CardResource';

export class ThermalReservior extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.THERMAL_RESERVIOR,
      tags: [Tag.BUILDING],
      cost: 25,

      behavior: {
        ocean: {},
      },

      metadata: {
        cardNumber: 'x356',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).production((pb) => pb.text('-X').heat(1)).text('+X').resource(CardResource.MICROBE).asterix();
        }),
        description: 'Place an ocean tile. Decrease your heat production any number of steps and add the same number of microbes to ANOTHER card.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    return player.production.heat >= 1;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectAmount('Select amount of heat production to decrease', 'Decrease', 1, player.production.heat)
      .andThen((amount) => {
        player.production.add(Resource.HEAT, -amount, {log: true});
        player.game.defer(new AddResourcesToCard(player, CardResource.MICROBE, {count: amount}));
        return undefined;
      });
  }
}

================
File: cards/chemical/colonies/TitanFuelStation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {Priority} from '../../../deferredActions/Priority';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';

export class TitanFuelStation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TITAN_FUEL_STATION,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 18,
      resourceType: CardResource.FLOATER,
      victoryPoints: 1,

      metadata: {
        cardNumber: '335',
        renderData: CardRenderer.builder((b) => {
          b.tag(Tag.SPACE).colon().resource(CardResource.FLOATER).br;
          b.or().br;
          b.minus().resource(CardResource.FLOATER).plus().titanium(2).br;
          b.description('When you play a space tag, including this, either add a floater to this card, or remove 1 floater from this card to gain 2 titanium.').br;
        }),
      },
    });
  }


  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    const spaceTags = player.tags.cardTagCount(card, Tag.SPACE);
    for (let i = 0; i < spaceTags; i++) {
      player.game.defer(new SimpleDeferredAction(
        player,
        () => {
          // Can't remove a resource
          if (this.resourceCount === 0) {
            player.addResourceTo(this, 1);
            return undefined;
          }
          const options = new OrOptions(
            new SelectOption('Remove a floater from this card to gain 2 titanium', 'Remove floater').andThen(() => {
              player.removeResourceFrom(this);
              player.stock.add(Resource.TITANIUM, 2);
              return undefined;
            }),
            new SelectOption('Add a floater to this card', 'Add floater').andThen(() => {
              player.addResourceTo(this, 1);
              return undefined;
            }),
          );
          options.title = 'Select an option for Titan Fuel Station';
          return options;
        },
      ), Priority.SUPERPOWER); // Unshift that deferred action
    }
    return undefined;
  }
}

================
File: cards/chemical/colonies/TitanResearchOutpost.ts
================
import {IActionCard} from '../../ICard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class TitanReseachOutpost extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.TITAN_RESEARCH_OUTPOST,
      type: CardType.ACTIVE,
      tags: [Tag.SCIENCE, Tag.JOVIAN],
      cost: 14,

      resourceType: CardResource.FLOATER,
      victoryPoints: {resourcesHere: {}, per: 3},

      behavior: {
        drawCard: 2,
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2},
      },

      action: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, tag: Tag.JOVIAN, count: 1, autoSelect: true},
      },

      requirements: {tag: Tag.SCIENCE, count: 3},
      metadata: {
        cardNumber: 'x330',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to any Jovian card', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER, {secondaryTag: Tag.JOVIAN});
          }).br;
          b.vpText('1 VP for every 3rd Floater on this card.').br;
          b.cards(2).resource(CardResource.FLOATER, 2).asterix();
        }),
        description: 'Requires 3 science tags. Draw 2 cards and add 2 floaters to ANY card.',
      },
    });
  }
}

================
File: cards/chemical/colonies/WaterFromTitan.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardResource} from '../../../../common/CardResource';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class WaterFromTitan extends ActionCard implements IProjectCard {
  constructor() {
    super({
      cost: 25,
      tags: [Tag.JOVIAN],
      name: CardName.WATER_FROM_TITAN,
      type: CardType.ACTIVE,
      resourceType: CardResource.FLOATER,
      victoryPoints: 2,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Remove 2 floaters to place an ocean tile',
            spend: {resourcesHere: 2},
            ocean: {},
          },
          {
            title: 'Spend 1 titanium to add 2 floaters to this card',
            spend: {titanium: 1},
            addResources: 2,
          }],
        },
      },

      metadata: {
        cardNumber: 'x332',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add 2 floaters here.', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.FLOATER, 2);
          }).br;
          b.or().br;
          b.action('Remove 2 floaters from this card to place an ocean tile.', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.oceans(1);
          });
        }),
      },
    });
  }
}

================
File: cards/chemical/colonies/WaypointColony.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';

export class WaypointColony extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 20,
      tags: [Tag.SPACE],
      name: CardName.WAYPOINT_COLONY,
      type: CardType.ACTIVE,

      behavior: {
        colonies: {buildColony: {}},
      },

      cardDiscount: {tag: Tag.SPACE, amount: 2},
      metadata: {
        cardNumber: 'x344',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-2);
          }).br;
          b.colonies(1);
        }),
        description: 'Place a colony.',
      },
    });
  }
}

================
File: cards/chemical/colonies/Wildflowers.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class Wildflowers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.WILDFLOWERS,
      cost: 8,
      tags: [Tag.PLANT],
      requirements: {temperature: -4},
      victoryPoints: 1,

      behavior: {
        production: {plants: 1},
        stock: {plants: 3},
      },

      metadata: {
        cardNumber: 'x370',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).plants(3);
        }),
        description: 'Requires -4°C or warmer. Increase your plant production 1 step and gain 3 plants.',
      },
    });
  }
}

================
File: cards/chemical/corpera/1_AquiferRelocation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {CanAffordOptions, IPlayer} from '../../../IPlayer';
import {SelectSpace} from '../../../inputs/SelectSpace';
import {TileType} from '../../../../common/TileType';

export class AquiferRelocation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.AQUIFER_RELOCATION,
      cost: 12,

      metadata: {
        cardNumber: 'xCE1',
        description: 'Remove an ocean tile from the board then place an ocean tile in a new location.',
        renderData: CardRenderer.builder((b) => {
          b.minus().oceans(1, {all}).nbsp.plus().oceans(1);
        }),
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer, _canAffordOptions?: CanAffordOptions | undefined): boolean {
    return player.game.board.getAvailableSpacesForOcean(player).length > 0 && player.game.board.spaces.filter((space) => space.tile?.tileType === TileType.OCEAN).length > 0;
  }
  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select ocean to remove', player.game.board.spaces.filter((space) => space.tile?.tileType === TileType.OCEAN)).andThen((removedOcean) => {
      player.game.removeTile(removedOcean.id);
      return new SelectSpace('Select a space for the new ocean', player.game.board.getAvailableSpacesForOcean(player).filter((space) => space.id !== removedOcean.id)).andThen((newOcean) => {
        player.game.addOcean(player, newOcean);
        return undefined;
      });
    });
  }
}

================
File: cards/chemical/corpera/10_PublicRecords.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class PublicRecords extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.PUBLIC_RECORDS,
      cost: 0,

      metadata: {
        cardNumber: 'xCE10',
        description: 'For your next action this generation, act as if you had an additional wild tag in play.',
        renderData: CardRenderer.builder((b) => {
          b.tag(Tag.WILD).asterix();
        }),
      },
    });
  }
  // Behavior handled in player/Tags.ts
}

================
File: cards/chemical/corpera/11_AcidRain.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {OrOptions} from '../../../inputs/OrOptions';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {SelectOption} from '../../../inputs/SelectOption';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {all, digit} from '../../Options';
import {message} from '../../../logs/MessageBuilder';

export class AcidRain extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ACID_RAIN,
      cost: 0,

      metadata: {
        cardNumber: 'xCE11',
        renderData: CardRenderer.builder((b) => {
          b.minus().steel(3, {all, digit}).nbsp.or(Size.SMALL).nbsp;
          b.minus().plants(3, {all, digit});
        }),
        description: 'Remove up to 3 steel or 3 plants from any player',
      },
    });
  }

  private title(amount: number, type: string, target: IPlayer) {
    return message('Remove ${0} ${1} from ${2}', (b) => b.number(amount).string(type).player(target));
  }

  public override bespokePlay(player: IPlayer) {
    if (player.game.isSoloMode()) return undefined;

    const availableActions = new OrOptions();

    player.getOpponents().forEach((target) => {
      if (target.steel > 0 && !target.alloysAreProtected()) {
        const amountRemoved = Math.min(3, target.steel);
        const optionTitle = this.title(amountRemoved, 'steel', target);
        availableActions.options.push(new SelectOption(optionTitle).andThen(() => {
          target.stock.deduct(Resource.STEEL, 3, {log: true, from: player});
          return undefined;
        }));
      }

      if (target.plants > 0) {
        const amountRemoved = Math.min(3, target.steel);
        const optionTitle = this.title(amountRemoved, 'plants', target);
        availableActions.options.push(new SelectOption(optionTitle).andThen(() => {
          target.stock.deduct(Resource.PLANTS, 3, {log: true, from: player});
          return undefined;
        }));
      }
    });

    if (availableActions.options.length > 0) {
      availableActions.options.push(new SelectOption('Do not remove resource').andThen(() => {
        return undefined;
      }));
      return availableActions;
    }
    return undefined;
  }
}

================
File: cards/chemical/corpera/12_PowerFailure.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';

export class PowerFailure extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.POWER_FAILURE,
      cost: 1,

      behavior: {
        decreaseAnyProduction: {type: Resource.ENERGY, count: 1},
      },

      metadata: {
        cardNumber: 'xCE12',
        description: 'Decrease any energy production 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1, {all});
          });
        }),
      },
    });
  }
}

================
File: cards/chemical/corpera/13_AstrophysicsCenter.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';

export class AstrophysicsCenter extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ASTROPHYSICS_CENTER,
      tags: [Tag.SCIENCE, Tag.SPACE, Tag.BUILDING],
      cost: 18,

      resourceType: CardResource.ASTEROID,
      victoryPoints: {resourcesHere: {}},
      requirements: {tag: Tag.SPACE, count: 7},

      metadata: {
        cardNumber: 'xCE13',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a science tag, including this, add an asteroid to this card', (eb) => {
            eb.tag(Tag.SCIENCE).startEffect.resource(CardResource.ASTEROID);
          }).br;
          b.vpText('1 VP for every asteroid on this card.');
        }),
        description: 'Requires 7 space tags',
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const qty = player.tags.cardTagCount(card, Tag.SCIENCE);
    player.addResourceTo(this, {qty, log: true});
  }
}

================
File: cards/chemical/corpera/14_CentaurLandings.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class CentaurLandings extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CENTAUR_LANDINGS,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 9,

      action: {
        spend: {titanium: 1},
        addResources: 1,
      },

      resourceType: CardResource.ASTEROID,
      victoryPoints: {resourcesHere: {}},
      requirements: {tag: Tag.JOVIAN, count: 2},

      metadata: {
        cardNumber: 'xCE14',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add an asteroid to this card.', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.ASTEROID);
          }).br;
          b.vpText('1 VP for every asteroid on this card.');
        }),
        description: 'Requires 2 Jovian tags',
      },
    });
  }
}

================
File: cards/chemical/corpera/15_VestaObservatory.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {SelectAmount} from '../../../inputs/SelectAmount';
import {Resource} from '../../../../common/Resource';

export class VestaObservatory extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.VESTA_OBSERVATORY,
      tags: [Tag.SCIENCE, Tag.SPACE],
      cost: 11,

      resourceType: CardResource.ASTEROID,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'xCE15',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a science tag, including this, add an asteroid to this card', (eb) => {
            eb.tag(Tag.SCIENCE).startEffect.resource(CardResource.ASTEROID);
          }).br;
          b.action('Spend 1 titanium to remove X asteroids from this card and look at X cards from the deck, take 1 into your hand, and discard the rest.', (eb) => {
            eb.titanium(1).startAction.minus().text('X').resource(CardResource.ASTEROID).nbsp.plus().text('X').cards(1).asterix();
          }).br;
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const qty = player.tags.cardTagCount(card, Tag.SCIENCE);
    player.addResourceTo(this, {qty, log: true});
  }
  public canAct(player: IPlayer): boolean {
    return player.titanium > 0 && this.resourceCount > 0;
  }
  public action(player: IPlayer) {
    return new SelectAmount('Select amount of asteroids to remove', 'OK', 1, this.resourceCount)
      .andThen((amount) => {
        player.stock.deduct(Resource.TITANIUM, 1);
        this.resourceCount -= amount;
        if (amount === 1) {
          player.drawCard();
          return undefined;
        }
        player.drawCardKeepSome(amount, {keepMax: 1});
        return undefined;
      });
  }
}

================
File: cards/chemical/corpera/16_MeasurementDrones.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';

export class MeasurementDrones extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MEASUREMENT_DRONES,
      tags: [Tag.SCIENCE, Tag.JOVIAN],
      cost: 15,
      victoryPoints: 1,
      resourceType: CardResource.FLOATER,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 floaters to draw a card',
            spend: {resourcesHere: 2},
            drawCard: 1,
          },
          {
            title: 'Add a floater to this card',
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: 'xCE16',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a science tag, add a floater to this card', (eb) => {
            eb.tag(Tag.SCIENCE).startEffect.resource(CardResource.FLOATER);
          }).br;
          b.action('Add a floater to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER);
          }).br;
          b.or().br;
          b.action('Spend 2 floaters here to draw a card.', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.cards(1);
          }).br;
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const qty = player.tags.cardTagCount(card, Tag.SCIENCE);
    player.addResourceTo(this, {qty, log: true});
  }
}

================
File: cards/chemical/corpera/17_AdvancedBiomachinery.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class AdvancedBiomachinery extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ADVANCED_BIOMACHINERY,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      cost: 10,
      victoryPoints: 1,
      resourceType: CardResource.MICROBE,
      requirements: {tag: Tag.MICROBE, count: 2},

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 1 microbe to draw a card',
            spend: {resourcesHere: 1},
            drawCard: 1,
          },
          {
            title: 'Add a microbe to ANY card',
            addResourcesToAnyCard: {type: CardResource.MICROBE, count: 1},
          }],
        },
      },

      metadata: {
        cardNumber: 'xCE17',
        renderData: CardRenderer.builder((b) => {
          b.action('Add a microbe to ANY card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE).asterix();
          }).br;
          b.or().br;
          b.action('Spend 1 microbe here to draw a card.', (eb) => {
            eb.resource(CardResource.MICROBE).startAction.cards(1);
          }).br;
        }),
        description: 'Requires 2 microbe tags.',
      },
    });
  }
}

================
File: cards/chemical/corpera/18_LongTermEvolutionStudy.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class LongTermEvolutionStudy extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.LONG_TERM_EVOLUTION_STUDY,
      tags: [Tag.SCIENCE, Tag.ANIMAL],
      cost: 5,
      resourceType: CardResource.ANIMAL,

      behavior: {
        production: {megacredits: -1},
      },

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 1 animal to draw a card',
            spend: {resourcesHere: 1},
            drawCard: 1,
          },
          {
            title: 'Add an animal to this card',
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: 'xCE18',
        renderData: CardRenderer.builder((b) => {
          b.action('Add an animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.or().br;
          b.action('Remove 1 animal from this card to draw a card.', (eb) => {
            eb.resource(CardResource.ANIMAL).startAction.cards(1);
          }).br;
          b.production((pb) => pb.megacredits(-1));
        }),
        description: 'Decrease your M€ production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/corpera/19_ScientificLogs.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {CardRenderer} from '../../render/CardRenderer';
import {Priority} from '../../../deferredActions/Priority';

export class ScientificLogs extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SCIENTIFIC_LOGS,
      tags: [Tag.SCIENCE],
      cost: 5,
      resourceType: CardResource.SCIENCE,

      metadata: {
        cardNumber: 'xCE19',
        renderData: CardRenderer.builder((b) => {
          b.tag(Tag.EVENT).colon().resource(CardResource.SCIENCE).br;
          b.or().br;
          b.minus().resource(CardResource.SCIENCE, 2).nbsp.plus().cards(1);
        }),
        description: 'When you play an event card, either add a science resource to this card, or remove 2 science resources from this card to draw a card.',
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.type === CardType.EVENT) {
      player.game.defer(new SimpleDeferredAction(
        player,
        () => {
          // Can't remove a resource
          if (this.resourceCount < 2) {
            player.addResourceTo(this, 1);
            return undefined;
          }
          const options = new OrOptions(
            new SelectOption('Remove 2 science resources from this card to draw a card', 'Remove resources').andThen(() => {
              this.resourceCount -= 2;
              player.drawCard();
              return undefined;
            }),
            new SelectOption('Add a science resource to this card', 'Add resource').andThen(() => {
              player.addResourceTo(this, 1);
              return undefined;
            }),
          );
          options.title = 'Select an option for Scientific Logs';
          return options;
        },
      ), Priority.SUPERPOWER);
    }
    return undefined;
  }
}

================
File: cards/chemical/corpera/2_SpeculativeMarkets.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {Tag} from '../../../../common/cards/Tag';
import {digit} from '../../Options';
import {Resource} from '../../../../common/Resource';

export class SpeculativeMarkets extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SPECULATIVE_MARKETS,
      cost: 6,

      metadata: {
        cardNumber: 'xCE2',
        description: 'Increase your M€ production 2 steps or 3 steps if you have 3 Earth tags.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2).nbsp.or().nbsp.tag(Tag.EARTH, {amount: 3, digit}).colon().megacredits(3));
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    if (player.tags.count(Tag.EARTH) < 3) {
      player.production.add(Resource.MEGACREDITS, 2, {log: true});
    } else {
      player.production.add(Resource.MEGACREDITS, 3, {log: true});
    }
    return undefined;
  }
}

================
File: cards/chemical/corpera/20_ConstructionCenter.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';

export class ConstructionCenter extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CONSTRUCTION_CENTER,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 26,
      cardDiscount: {tag: Tag.BUILDING, amount: 2},

      behavior: {
        production: {energy: -1, megacredits: 3},
        city: {},
      },

      metadata: {
        cardNumber: 'xCE20',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a buiding tag, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.BUILDING).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          });
          b.city();
        }),
        description: 'Decrease your energy production 1 step and increase your M€ production 3 steps. Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/corpera/21_HomeworldHeadquarters.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class HomeworldHeadquarters extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.HOMEWORLD_HEADQUARTERS,
      tags: [Tag.EARTH],
      cost: 18,

      behavior: {
        production: {megacredits: 4},
      },

      cardDiscount: {tag: Tag.EARTH, amount: 3},
      metadata: {
        cardNumber: 'xCE21',
        description: 'Increase your M€ production 4 steps.',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an Earth tag, you pay 3 M€ less for it.', (eb) => {
            eb.tag(Tag.EARTH).startEffect.megacredits(-3);
          }).br;
          b.production((pb) => pb.megacredits(4));
        }),
      },
    });
  }
}

================
File: cards/chemical/corpera/22_MartianInvestments.ts
================
import {IProjectCard} from '../../IProjectCard';
import {ActionCard} from '../../ActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';

export class MartianInvestments extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MARTIAN_INVESTMENTS,
      cost: 6,
      requirements: {cities: 2, all},

      behavior: {
        production: {megacredits: -2},
      },

      action: {
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'x201',
        renderData: CardRenderer.builder((b) => {
          b.action('Increase your M€ production 1 step.', (eb) => {
            eb.empty().startAction.production((pb) => pb.megacredits(1));
          }).br;
          b.production((pb) => pb.minus().megacredits(2));
        }),
        description: 'Requires any 2 cities. Decrease your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/23_LaserLightsails.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';

export class LaserLightsails extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.LASER_LIGHTSAILS,
      tags: [Tag.SPACE],
      cost: 8,

      behavior: {
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'xCE23',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space tag, including this, you may choose to lose 1 energy to gain 3 M€.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.minus().energy(1).nbsp.plus().megacredits(3);
          }).br;
          b.production((pb) => pb.megacredits(1));
        }),
        description: 'Increase your M€ production 1 step.',
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.tags.includes(Tag.SPACE) && player.stock.energy > 0) {
      const useEffect = new SelectOption('Lose 1 energy resource to gain 3 M€ from Laser Lightsails', 'Lose energy').andThen( () => {
        player.stock.add(Resource.MEGACREDITS, 3);
        player.stock.deduct(Resource.ENERGY, 1);
        return undefined;
      });
      const abstain = new SelectOption('Do nothing', 'Do nothing').andThen( () => {
        return undefined;
      } );
      player.game.defer(new SimpleDeferredAction(player, () => new OrOptions(useEffect, abstain)));
    }
    return undefined;
  }
}

================
File: cards/chemical/corpera/24_SponsoredResearchFirm.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {Card} from '../../Card';

export class SponsoredResearchFirm extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SPONSORED_RESEARCH_FIRM,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 14,

      behavior: {
        production: {megacredits: 1},
      },

      requirements: {tag: Tag.EARTH, count: 2},

      metadata: {
        cardNumber: 'xCE24',
        renderData: CardRenderer.builder((b) => {
          b.action('Draw a card ONLY IF you\'ve raised your TR this generation.', (eb) => {
            eb.plus().tr(1).asterix().nbsp.colon().nbsp.startAction.cards(1);
          }).br;
          b.production((pb) => pb.megacredits(1)).br;
        }),
        description: 'Requires 2 Earth tags. Increase your M€ production 1 step.',
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.generationData.hasRaisedTR;
  }
  public action(player: IPlayer) {
    player.drawCard(1);
  }
}

================
File: cards/chemical/corpera/25_JovianSuppliers.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {Resource} from '../../../../common/Resource';

export class JovianSuppliers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.JOVIAN_SUPPLIERS,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 18,
      victoryPoints: 2,

      metadata: {
        cardNumber: 'xCE25',
        renderData: CardRenderer.builder((b) => {
          b.effect('Whenever any player plays a Jovian tag, gain 2 M€.', (eb) => {
            eb.tag(Tag.JOVIAN, {all}).startEffect.megacredits(2);
          });
        }),
      },
    });
  }
  public onCardPlayedFromAnyPlayer(thisCardOwner: IPlayer, _playedCardOwner: IPlayer, card: IProjectCard) {
    if (card.tags.includes(Tag.JOVIAN)) {
      thisCardOwner.stock.add(Resource.MEGACREDITS, 2);
    }
    return undefined;
  }
}

================
File: cards/chemical/corpera/26_OlympusArchives.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {Resource} from '../../../../common/Resource';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';

export class OlympusArchives extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.OLYMPUS_ARCHIVES,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 20,
      requirements: {tag: Tag.SCIENCE, count: 2},
      victoryPoints: 1,

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: 'xCE26',
        renderData: CardRenderer.builder((b) => {
          b.effect('Whenever any player plays an event card, gain 2 M€.', (eb) => {
            eb.tag(Tag.EVENT, {all}).startEffect.megacredits(2);
          }).br;
          b.cards(2);
        }),
        description: 'Requires 2 science tags. Draw 2 cards.',
      },
    });
  }

  public onCardPlayedFromAnyPlayer(thisCardOwner: IPlayer, _playedCardOwner: IPlayer, card: IProjectCard) {
    if (card.type === CardType.EVENT) {
      thisCardOwner.stock.add(Resource.MEGACREDITS, 2, {log: true, from: this});
    }
    return undefined;
  }
}

================
File: cards/chemical/corpera/27_NeuralEnchancement.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';

export class NeuralEnhancement extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.NEURAL_ENCHANCEMENT,
      tags: [Tag.SCIENCE],
      cost: 12,
      victoryPoints: 1,
      requirements: {tag: Tag.SCIENCE, count: 3},
      cardDiscount: {amount: 1},

      metadata: {
        cardNumber: 'xCE27',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a card, you pay 1 M€ less for it.', (eb) => {
            eb.empty().startEffect.megacredits(-1);
          });
        }),
        description: 'Requires 3 science tags.',
      },
    });
  }
}

================
File: cards/chemical/corpera/28_Superpolymers.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {IProjectCard} from '../../IProjectCard';

export class Superpolymers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SUPERPOLYMERS,
      tags: [Tag.SCIENCE],
      cost: 17,

      behavior: {
        steelValue: 1,
        production: {steel: 1},
      },

      metadata: {
        cardNumber: 'xCE28',
        renderData: CardRenderer.builder((b) => {
          b.effect('Your steel resources are worth 1 M€ extra.', (eb) => {
            eb.empty().startEffect.plus().steel(1);
          }).br;
          b.production((pb) => pb.steel(1));
        }),
        description: 'Increase your steel production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/corpera/29_AlloyFactory.ts
================
import {IProjectCard} from '../../IProjectCard';
import {ActionCard} from '../../ActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class AlloyFactory extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ALLOY_FACTORY,
      tags: [Tag.BUILDING],
      cost: 5,

      behavior: {
        stock: {energy: 4},
      },

      action: {
        spend: {energy: 2},
        stock: {steel: 2},
      },

      metadata: {
        cardNumber: 'xCE29',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 energy to gain 2 steel.', (eb) => {
            eb.energy(2).startAction.steel(2);
          }).br;
          b.energy(4, {digit});
        }),
        description: 'Gain 4 energy.',
      },
    });
  }
}

================
File: cards/chemical/corpera/3_ResearchGrant.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ResearchGrantChemical extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.RESEARCH_GRANT_CHEMICAL,
      tags: [Tag.EARTH],
      cost: 7,

      behavior: {
        drawCard: 1,
        stock: {megacredits: {tag: Tag.SCIENCE, each: 2}},
      },

      metadata: {
        cardNumber: 'xCE3',
        renderData: CardRenderer.builder((b) => {
          b.cards(1).nbsp.megacredits(2).slash().tag(Tag.SCIENCE);
        }),
        description: 'Draw a card and gain 2 M€ for each science tag you have.',
      },
    });
  }
}

================
File: cards/chemical/corpera/30_NovaFoundry.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {IProjectCard} from '../../IProjectCard';

export class NovaFoundry extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.NOVA_FOUNDRY,
      tags: [Tag.SPACE],
      cost: 24,
      requirements: {tag: Tag.SCIENCE, count: 5},
      victoryPoints: 2,

      behavior: {
        titanumValue: 1,
        production: {titanium: 2, heat: 2},
      },

      metadata: {
        cardNumber: 'xCE30',
        renderData: CardRenderer.builder((b) => {
          b.effect('Your titanium resources are worth 1 M€ extra.', (eb) => {
            eb.empty().startEffect.plus().titanium(1);
          }).br;
          b.production((pb) => pb.titanium(2).br.heat(2));
        }),
        description: 'Requires 5 science tags. Increase your titanium production 2 steps and your heat production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/31_KugelblitzEngine.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class KugelblitzEngine extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.KUGELBLITZ_ENGINE,
      tags: [Tag.POWER, Tag.SCIENCE],
      cost: 20,
      requirements: {tag: Tag.POWER, count: 4},
      victoryPoints: 2,

      behavior: {
        production: {energy: 4},
      },

      cardDiscount: {tag: Tag.SPACE, amount: 2},
      metadata: {
        cardNumber: 'xCE31',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => pb.energy(4, {digit}));
        }),
        description: 'Requires 4 power tags. Increase your energy production 4 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/32_ExoticMatterReactor.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class ExoticMatterReactor extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.EXOTIC_MATTER_REACTOR,
      tags: [Tag.POWER, Tag.SCIENCE],
      cost: 20,
      requirements: {tag: Tag.SCIENCE, count: 6},

      behavior: {
        production: {energy: 6},
      },

      cardDiscount: {tag: Tag.SPACE, amount: 2},
      metadata: {
        cardNumber: 'xCE31',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => pb.energy(6, {digit}));
        }),
        description: 'Requires 6 science tags. Increase your energy production 6 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/33_SolarStation.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';
import {IProjectCard} from '../../IProjectCard';

export class SolarStation extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SOLAR_STATION,
      tags: [Tag.SPACE],
      cost: 13,
      requirements: {tag: Tag.SCIENCE, count: 4},
      victoryPoints: 1,

      behavior: {
        production: {heat: 1},
        stock: {heat: 3},
      },

      action: {
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'xCE33',
        renderData: CardRenderer.builder((b) => {
          b.action('Draw a card.', (eb) => {
            eb.empty().startAction.cards(1);
          }).br;
          b.production((pb) => pb.heat(1)).heat(3);
        }),
        description: 'Requires 4 science tags. Increase your heat production 1 step and gain 3 heat.',
      },
    });
  }
}

================
File: cards/chemical/corpera/34_UndergroundTestSite.ts
================
import {IProjectCard} from '../../IProjectCard';
import {ActionCard} from '../../ActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';

export class UndergroundTestSite extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.UNDERGROUND_TEST_SITE,
      tags: [Tag. SCIENCE, Tag.BUILDING],
      cost: 12,

      behavior: {
        drawCard: 2,
      },

      action: {
        spend: {energy: 2},
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'xCE34',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 energy to draw a card.', (eb) => {
            eb.energy(2).startAction.cards(1);
          }).br;
          b.cards(2);
        }),
        description: 'Draw 2 cards.',
      },
    });
  }
}

================
File: cards/chemical/corpera/35_StandardAlloys.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';

export class StandardAlloys extends Card {
  constructor() {
    super({
      name: CardName.STANDARD_ALLOYS,
      type: CardType.ACTIVE,
      tags: [Tag.BUILDING],
      cost: 3,

      metadata: {
        cardNumber: 'xB84',
        renderData: CardRenderer.builder((b) => {
          b.effect('When playing a standard project, steel may be used as 2 M€ each.',
            (eb) => eb.plate('Standard projects').startEffect.steel(1).equals().megacredits(2)).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/corpera/36_OverseerCommittee.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import { IPlayer } from '../../../IPlayer';
import { DiscardCards } from '../../../deferredActions/DiscardCards';
import { ICard, isIActionCard } from '../../ICard';
import { PlayerInput } from '../../../PlayerInput';
import { OrOptions } from '../../../inputs/OrOptions';
import { SelectOption } from '../../../inputs/SelectOption';

export class OverseerCommittee extends Card implements ICard {
  constructor() {
    super({
      name: CardName.OVERSEER_COMMITTEE,
      type: CardType.ACTIVE,
      tags: [Tag.EARTH],
      cost: 6,

      metadata: {
        cardNumber: 'xCE36',
        description: 'Requires that you discard 2 cards.',
        renderData: CardRenderer.builder((b) => {
          b.effect('When playing a blue action card, you may immediately use that card\'s action while still being able to use that action again this generation.',
            (eb) => eb.empty().startEffect.nbsp.arrow()).br;
          b.minus().cards(2);
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: ICard): void | PlayerInput | undefined {
    if (isIActionCard(card) && card.canAct(player)) {
      const takeCardAction = new SelectOption(`Preform the action of ${card.name} through Overseer Committee`).andThen(() => {
        player.game.log('${0} used ${1} action through ${2}', (b) => b.player(player).card(card).card(this));
        return card.action(player);
      });
      const ignore = new SelectOption('Do Nothing');
      player.defer(new OrOptions(takeCardAction, ignore));
    }
  }
  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.cardsInHand.length > 2; // this card and at least 2 others
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new DiscardCards(player, 2, 2))
    return undefined;
  }
}

================
File: cards/chemical/corpera/4_SmallSupplyDrop.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class SmallSupplyDrop extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SMALL_SUPPLY_DROP,
      cost: 2,

      behavior: {
        stock: {steel: 2, plants: 2},
      },

      metadata: {
        cardNumber: 'xCE4',
        description: 'Gain 2 steel and 2 plants.',
        renderData: CardRenderer.builder((b) => {
          b.steel(2).plants(2);
        }),
      },
    });
  }
}

================
File: cards/chemical/corpera/5_HermesMission.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import { Tag } from '../../../../common/cards/Tag';

export class HermesMission extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.HERMES_MISSION,
      cost: 6,
      tags: [Tag.SPACE],
      requirements: {tag: Tag.SCIENCE, count: 2},

      behavior: {
        stock: {titanium: 2},
        drawCard: {count: 2, tag: Tag.SPACE},
      },

      metadata: {
        cardNumber: 'xCE5',
        description: 'Gain 2 titanium and draw 2 cards with space tags.',
        renderData: CardRenderer.builder((b) => {
          b.titanium(2).cards(2, {secondaryTag: Tag.SPACE});
        }),
      },
    });
  }
}

================
File: cards/chemical/corpera/6_AssetLiquidation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';
import {IPlayer} from '../../../IPlayer';
import {OrOptions} from '../../../inputs/OrOptions';
import {ALL_RESOURCES, Resource} from '../../../../common/Resource';
import {PlayerInput} from '../../../PlayerInput';
import {SelectOption} from '../../../inputs/SelectOption';

export class AssetLiquidation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ASSET_LIQUIDATION,
      cost: 0,

      metadata: {
        cardNumber: 'xCE6',
        description: 'Decrease any production 1 step to gain 5 of the SAME TYPE of resource.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().wild(1)).nbsp.plus().wild(5, {digit}).asterix();
        }),
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const orOptions = new OrOptions();

    ALL_RESOURCES.forEach((resource) => {
      if (player.production.get(resource) > (resource === Resource.MEGACREDITS ? -5 : 0)) {
        orOptions.options.push(new SelectOption('Lower ' + resource + ' production 1 step and gain 5 ' + resource, 'Select').andThen( () => {
          player.production.add(resource, -1, {log: true});
          player.stock.add(resource, 5, {log: true});
          return undefined;
        }));
      }
    });

    return orOptions;
  }
}

================
File: cards/chemical/corpera/7_Parasite.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {OrOptions} from '../../../inputs/OrOptions';
import {PlayerInput} from '../../../PlayerInput';
import {CardName} from '../../../../common/cards/CardName';
import {SelectOption} from '../../../inputs/SelectOption';
import {CardResource} from '../../../../common/CardResource';
import {RemoveResourcesFromCard} from '../../../deferredActions/RemoveResourcesFromCard';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {Size} from '../../../../common/cards/render/Size';

export class Parasite extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.PARASITE,
      cost: 1,
      behavior: {
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 1},
      },

      metadata: {
        cardNumber: 'xCE7',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.MICROBE).asterix().br;
          b.nbsp.minus().resource(CardResource.MICROBE, {amount: 2, all}).nbsp.or(Size.SMALL).nbsp.minus().resource(CardResource.ANIMAL, {all});
        }),
        description: 'Add 1 microbe to ANOTHER card. Remove up to 2 microbes or 1 animal from any player.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    if (player.game.isSoloMode()) {
      return undefined;
    }

    const orOptionsAnimals = new RemoveResourcesFromCard(player, CardResource.ANIMAL, 1, {mandatory: false}).execute() as OrOptions;
    const orOptionsMicrobes = new RemoveResourcesFromCard(player, CardResource.MICROBE, 2, {mandatory: false}).execute() as OrOptions;
    const removeAnimals = orOptionsAnimals !== undefined ?
      orOptionsAnimals.options[0] :
      undefined;
    const removeMicrobes = orOptionsMicrobes !== undefined ?
      orOptionsMicrobes.options[0] :
      undefined;

    // If no other player has resources to remove
    // assume player will remove nothing from themselves
    if (removeAnimals === undefined && removeMicrobes === undefined) {
      player.game.log('There was nobody to remove resources from.');
      return undefined;
    }

    const orOptions = new OrOptions();
    if (removeAnimals !== undefined) {
      orOptions.options.push(removeAnimals);
    }
    if (removeMicrobes !== undefined) {
      orOptions.options.push(removeMicrobes);
    }
    orOptions.options.push(new SelectOption('Skip removal', 'Confirm')
      .andThen(() => {
        return undefined;
      }),
    );

    return orOptions;
  }
}

================
File: cards/chemical/corpera/8_RoboticsExhibition.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class RoboticsExhibition extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ROBOTICS_EXHIBITION,
      tags: [Tag.SCIENCE],
      cost: 2,

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: 'x177',
        renderData: CardRenderer.builder((b) => {
          b.minus().energy(2).nbsp.cards(2);
        }),
        description: 'Lose 2 energy and draw 2 cards.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.energy >= 2;
  }
  public override bespokePlay(player: IPlayer) {
    player.energy -= 2;
    return undefined;
  }
}

================
File: cards/chemical/corpera/9_PatentTrading.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {DiscardCards} from '../../../deferredActions/DiscardCards';
import {DrawCards} from '../../../deferredActions/DrawCards';
import {Tag} from '../../../../common/cards/Tag';

export class PatentTrading extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.PATENT_TRADING,
      tags: [Tag.EARTH],
      cost: 3,

      metadata: {
        cardNumber: 'xCE9',
        description: 'Discard a card, then draw a card for every 2 Earth tags you have, including this.',
        renderData: CardRenderer.builder((b) => {
          b.minus().cards(1).nbsp.plus().cards(1).slash().tag(Tag.EARTH, 2);
        }),
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.cardsInHand.length > 1; // this card and at least one other
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new DiscardCards(player)).andThen(() =>
      player.game.defer(DrawCards.keepAll(player, Math.floor((player.tags.count(Tag.EARTH) + 1)/ 2))),
    );
    return undefined;
  }
}

================
File: cards/chemical/corpera/AcquiredResearchFirm.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class AcquiredResearchFirm extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ACQUIRED_RESEARCH_FIRM,
      tags: [Tag.SCIENCE, Tag.EARTH],
      cost: 8,

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: 'x237',
        renderData: CardRenderer.builder((b) => {
          b.cards(2);
        }),
        description: 'Draw 2 cards.',
      },
    });
  }
}

================
File: cards/chemical/corpera/ArtificialMicrobialLife.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';
import {CardResource} from '../../../../common/CardResource';

export class ArtificialMicrobialLife extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ARTIFICIAL_MICROBIAL_LIFE,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      cost: 16,
      requirements: {tag: Tag.MICROBE, count: 3},
      victoryPoints: 2,

      behavior: {
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 4},
      },

      metadata: {
        cardNumber: 'x236',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.MICROBE, {amount: 4, digit}).asterix();
        }),
        description: 'Requires 3 microbe tags. Add 4 microbes to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/corpera/CashCrops.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class CashCrops extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CASH_CROPS,
      cost: 7,
      tags: [Tag.PLANT],
      requirements: {temperature: -4},

      behavior: {
        production: {plants: 1, megacredits: 3},
        stock: {plants: 1},
      },

      metadata: {
        cardNumber: 'x232',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(3).plants(1)).plants(1);
        }),
        description: 'Requires -4°C or warmer. Increase your M€ production 3 steps and your plant production 1 step. Gain 1 plant.',
      },
    });
  }
}

================
File: cards/chemical/corpera/ChemicalPlant.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ChemicalPlant extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CHEMICAL_PLANT,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 11,

      behavior: {
        production: {energy: -1, megacredits: 3},
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'x213',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          });
          b.cards(1);
        }),
        description: 'Decrease your energy production 1 step, increase your M€ production 3 steps, and draw a card.',
      },
    });
  }
}

================
File: cards/chemical/corpera/ColdFusionPower.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ColdFusionPower extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.COLD_FUSION_POWER,
      tags: [Tag.SCIENCE, Tag.POWER, Tag.BUILDING],
      cost: 16,
      requirements: {tag: Tag.SCIENCE, count: 4},
      victoryPoints: 2,

      behavior: {
        production: {energy: 3},
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'x234',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(3)).cards(1);
        }),
        description: 'Requires 4 science tags. Increase your energy production 3 steps and draw a card.',
      },
    });
  }
}

================
File: cards/chemical/corpera/CommunicationsHub.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class CommunicationsHub extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.COMMUNICATIONS_HUB,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 18,

      behavior: {
        city: {},
        production: {energy: -1, megacredits: {tag: Tag.EARTH}},
      },

      metadata: {
        cardNumber: 'x221',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(1).slash().tag(Tag.EARTH);
          }).nbsp;
          b.city();
        }),
        description: 'Decrease your energy production 1 step and increase your M€ production 1 step for each Earth tag you have. Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/corpera/ConcreteFactory.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {digit} from '../../Options';

export class ConcreteFactory extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CONCRETE_FACTORY,
      cost: 12,
      tags: [Tag.BUILDING],

      behavior: {
        production: {steel: 1},
        stock: {steel: 4},
      },

      metadata: {
        cardNumber: 'x223',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(1)).nbsp.steel(4, {digit});
        }),
        description: 'Increase your steel production 1 step and gain 4 steel.',
      },
    });
  }
}

================
File: cards/chemical/corpera/ContractedConstruction.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ContractedConstruction extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CONTRACTED_CONSTRUCTION,
      tags: [Tag.BUILDING],
      cost: 9,
      requirements: {tag: Tag.BUILDING, count: 5},

      behavior: {
        production: {steel: -1, megacredits: 5},
      },

      metadata: {
        cardNumber: 'x218',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().steel(1).br;
            pb.plus().megacredits(5);
          });
        }),
        description: 'Requires 5 building tags. Decrease your steel production 1 step and increase your M€ production 5 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/Crowdfunding.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class Crowdfunding extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CROWDFUNDING,
      tags: [Tag.EARTH],
      cost: 3,

      behavior: {
        production: {megacredits: {tag: Tag.EARTH, per: 2}},
      },

      metadata: {
        cardNumber: 'x220',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).slash().tag(Tag.EARTH, 2));
        }),
        description: 'Increase your M€ production 1 step for every 2 Earth tags you have.',
      },
    });
  }
}

================
File: cards/chemical/corpera/ExplosiveMining.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class ExplosiveMining extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.EXPLOSIVE_MINING,
      cost: 15,
      tags: [Tag.BUILDING],

      behavior: {
        production: {steel: 1, heat: 2},
      },

      metadata: {
        cardNumber: 'x225',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.steel(1).br;
            pb.heat(2);
          });
        }),
        description: 'Increase your steel production 1 step and your heat production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/ExtremePowerEfficiency.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ExtremePowerEfficiency extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.EXTREME_POWER_EFFICIENCY,
      tags: [Tag.POWER],
      cost: 11,

      behavior: {
        production: {energy: {tag: Tag.BUILDING, per: 2}},
      },

      metadata: {
        cardNumber: 'x233',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).slash().tag(Tag.BUILDING, 2));
        }),
        description: 'Increase your energy production 1 step for every 2 building tags you have.',
      },
    });
  }
}

================
File: cards/chemical/corpera/GalileanGovernor.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class GalileanGovernor extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GALILEAN_GOVERNOR,
      tags: [Tag.JOVIAN],
      cost: 4,

      behavior: {
        production: {megacredits: 2},
      },

      requirements: {tag: Tag.JOVIAN, count: 2},
      metadata: {
        cardNumber: 'x208',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(2);
          });
        }),
        description: 'Requires 2 Jovian tags. Increase M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/GreatHarbor.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {TileType} from '../../../../common/TileType';
import {AdjacencyBonus} from '../../../ares/AdjacencyBonus';
import {Size} from '../../../../common/cards/render/Size';
import {IPlayer} from '../../../IPlayer';
import {CanAffordOptions} from '../../../IPlayer';
import {Board} from '../../../boards/Board';
import {Space} from '../../../boards/Space';
import {SelectSpace} from '../../../inputs/SelectSpace';
import {Resource} from '../../../../common/Resource';

export class GreatHarbor extends Card implements IProjectCard {
  constructor(
    name = CardName.GREAT_HARBOR,
    cost = 12,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: 'x240',
      renderData: CardRenderer.builder((b) => {
        b.tile(TileType.GREAT_HARBOR, false).asterix().nbsp.megacredits(1).slash().emptyTile('normal', {size: Size.SMALL}).oceans(1, {size: Size.SMALL});
      }),
      description: 'Requires +2°C or warmer. Place this tile NEXT TO AN OCEAN, then gain 1 M€ for each tile you own adjacent to an ocean, including this.',
    },
  ) {
    super({
      type: CardType.AUTOMATED,
      name,
      cost,
      tags: [Tag.BUILDING],
      requirements: {temperature: 2},
      victoryPoints: 1,
      adjacencyBonus,
      metadata,
    });
  }
  private getAvailableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): Array<Space> {
    return player.game.board.getAvailableSpacesOnLand(player, canAffordOptions)
      .filter((space) => player.game.board.getAdjacentSpaces(space).filter(Board.isOceanSpace).length > 0);
  }
  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions): boolean {
    return this.getAvailableSpaces(player, canAffordOptions).length > 0;
  }
  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select space next to greenery for special tile', this.getAvailableSpaces(player))
      .andThen((requestedSpace) => {
        player.game.addTile(player, requestedSpace, {
          tileType: TileType.GREAT_HARBOR,
        });
        requestedSpace.adjacency = this.adjacencyBonus;
        player.stock.add(Resource.MEGACREDITS, player.game.board.spaces.filter((space: Space) => space.player === player && player.game.board.getAdjacentSpaces(space).filter(Board.isOceanSpace).length > 0).length);
        return undefined;
      });
  }
}

================
File: cards/chemical/corpera/InterstallarProbe.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class InterstellarProbe extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INTERSTELLAR_PROBE,
      tags: [Tag.SCIENCE, Tag.SPACE],
      cost: 8,
      requirements: {tag: Tag.SCIENCE, count: 3},
      victoryPoints: 1,

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: 'x238',
        renderData: CardRenderer.builder((b) => {
          b.cards(2);
        }),
        description: 'Requires 3 science tags. Draw 2 cards.',
      },
    });
  }
}

================
File: cards/chemical/corpera/LuxuryResort.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class LuxuryResort extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LUXURY_RESORT,
      tags: [Tag.BUILDING],
      cost: 9,
      victoryPoints: 1,
      requirements: {temperature: 0},

      behavior: {
        production: {energy: -1, megacredits: 4},
      },

      metadata: {
        cardNumber: 'x216',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(4);
          }).nbsp;
        }),
        description: 'Requires 0°C or warmer. Decrease your energy production 1 step and increase your M€ production 4 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/ManufacturingPlant.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ManufacturingPlant extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MANUFACTURING_PLANT,
      tags: [Tag.BUILDING],
      cost: 7,

      behavior: {
        production: {steel: -1, megacredits: 4},
      },

      metadata: {
        cardNumber: 'x217',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().steel(1).br;
            pb.plus().megacredits(4);
          });
        }),
        description: 'Decrease your steel production 1 step and Increase your M€ production 4 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/MartianBanking.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';

export class MartianBanking extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MARTIAN_BANKING,
      tags: [Tag.BUILDING],
      cost: 10,

      behavior: {
        production: {megacredits: 4},
      },

      metadata: {
        cardNumber: 'x210',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(4).nbsp.megacredits(1, {all});
          });
        }),
        description: 'Increase M€ production 4 steps. ALL OPPONENTS increase their M€ production 1 step',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    const otherPlayers = player.game.getPlayers().filter((p) => p.id !== player.id);
    for (const p of otherPlayers) {
      p.production.add(Resource.MEGACREDITS, 1);
    }
    return undefined;
  }
}

================
File: cards/chemical/corpera/MediaConglomerate.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class MediaConglomerate extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MEDIA_CONGLOMARATE,
      tags: [Tag.EARTH],
      cost: 8,

      behavior: {
        production: {megacredits: 4},
      },

      requirements: {tag: Tag.EVENT, count: 5},
      metadata: {
        cardNumber: 'x209',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(4);
          });
        }),
        description: 'Requires that you\'ve played 5 event cards. Increase M€ production 4 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/MilitaryBase.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {TileType} from '../../../../common/TileType';
import {AdjacencyBonus} from '../../../ares/AdjacencyBonus';

export class MilitaryBase extends Card implements IProjectCard {
  constructor(
    name = CardName.MILITARY_BASE,
    cost = 10,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: 'x211',
      renderData: CardRenderer.builder((b) => {
        b.production((pb) => pb.megacredits(2)).nbsp.cards(1).nbsp.tile(TileType.MILITARY_BASE, false);
      }),
      description: 'Increase your M€ production 2 steps, draw a card, and place this tile.',
    },
  ) {
    super({
      type: CardType.AUTOMATED,
      name,
      cost,
      tags: [Tag.BUILDING],
      victoryPoints: -1,
      adjacencyBonus,
      behavior: {
        production: {megacredits: 2},
        drawCard: 1,
        tile: {
          type: TileType.MILITARY_BASE,
          on: 'land',
          title: 'Select space for special tile',
          adjacencyBonus: adjacencyBonus,
        },
      },
      metadata,
    });
  }
}

================
File: cards/chemical/corpera/MilitarySpacePort.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class MilitarySpacePort extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MILITARY_SPACE_PORT,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 23,
      victoryPoints: -1,

      behavior: {
        city: {},
        production: {energy: -1, megacredits: 3},
        drawCard: 1,
        stock: {titanium: 2},
      },

      metadata: {
        cardNumber: 'x212',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).nbsp;
            pb.plus().megacredits(3);
          }).br;
          b.city().cards(1).titanium(2);
        }),
        description: 'Decrease your energy production 1 step, increase your M€ production 3 steps, place a city tile, draw a card, and gain 2 titanium.',
      },
    });
  }
}

================
File: cards/chemical/corpera/MolecularScienceLab.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class MolecularScienceLab extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MOLECULAR_SCIENCE_LAB,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 14,
      victoryPoints: 1,

      behavior: {
        production: {megacredits: {tag: Tag.MICROBE}},
      },

      metadata: {
        cardNumber: 'x219',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).slash().tag(Tag.MICROBE));
        }),
        description: 'Increase your M€ production 1 step for each microbe tag you have.',
      },
    });
  }
}

================
File: cards/chemical/corpera/MountaintopRemoval.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class MountaintopRemoval extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MOUNTAINTOP_REMOVAL,
      cost: 8,
      tags: [Tag.BUILDING],

      behavior: {
        production: {megacredits: -1, steel: 2},
      },

      metadata: {
        cardNumber: 'x224',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().megacredits(1).br;
            pb.plus().steel(2);
          });
        }),
        description: 'Decrease your M€ production 1 step and increase your steel production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/NuclearForcePower.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class NuclearForcePower extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.NUCLEAR_FORCE_POWER,
      tags: [Tag.SCIENCE, Tag.POWER, Tag.BUILDING],
      cost: 14,
      requirements: {tag: Tag.SCIENCE, count: 5},
      victoryPoints: 2,

      behavior: {
        production: {energy: 4},
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'x235',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(4, {digit})).cards(1);
        }),
        description: 'Requires 5 science tags. Increase your energy production 4 steps and draw a card.',
      },
    });
  }
}

================
File: cards/chemical/corpera/PrintManufacturing.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class PrintManufacturing extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PRINT_MANUFACTURING,
      tags: [Tag.BUILDING],
      cost: 8,

      behavior: {
        production: {energy: -1, megacredits: 2, steel: 1},
      },

      metadata: {
        cardNumber: 'x226',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(2).steel(1);
          });
        }),
        description: 'Decrease your energy production 1 step. Increase your M€ production 2 steps and your steel production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/corpera/ProjectAdvancement.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {CanAffordOptions, IPlayer} from '../../../IPlayer';
import {OrOptions} from '../../../inputs/OrOptions';
import {ALL_RESOURCES} from '../../../../common/Resource';
import {PlayerInput} from '../../../PlayerInput';
import {SelectOption} from '../../../inputs/SelectOption';
import {Tag} from '../../../../common/cards/Tag';
import {message} from '../../../logs/MessageBuilder';

export class ProjectAdvancement extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PROJECT_ADVANCEMENT,
      cost: 5,
      tags: [Tag.EARTH],

      metadata: {
        cardNumber: 'x205',
        description: 'Increase any production that YOU\'VE ALREADY RAISED THIS GENERATION.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.wild(1)).asterix();
        }),
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer, _canAffordOptions?: CanAffordOptions | undefined): boolean {
    return ALL_RESOURCES.some((resource) => player.generationData.hasRaisedProduction[resource] === true);
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const orOptions = new OrOptions();
    ALL_RESOURCES.forEach((resource) => {
      if (player.generationData.hasRaisedProduction[resource]) {
        orOptions.options.push(new SelectOption(message('Raise ${0} production', (b) => b.string(resource)), 'Select').andThen( () => {
          player.production.add(resource, 1, {log: true});
          return undefined;
        }));
      }
    });
    return orOptions;
  }
}

================
File: cards/chemical/corpera/SaltMine.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class SaltMine extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SALT_MINE,
      tags: [Tag.BUILDING],
      cost: 14,

      behavior: {
        production: {energy: -1, megacredits: 3},
        global: {oxygen: 1},
      },

      metadata: {
        cardNumber: 'x214',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          }).nbsp;
          b.oxygen(1);
        }),
        description: 'Lower your energy production 1 step, increase your M€ production 3 steps, and raise the oxygen 1 step.',
      },
    });
  }
}

================
File: cards/chemical/corpera/ScientificMegaopolis.ts
================
import {IProjectCard} from '../../IProjectCard';
import {ActionCard} from '../../ActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';

export class ScientificMegaopolis extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SCIENTIFIC_MEGAOPOLIS,
      tags: [Tag.SCIENCE, Tag.CITY, Tag.BUILDING],
      cost: 32,

      behavior: {
        city: {},
      },

      action: {
        spend: {energy: 2},
        drawCard: 2,
      },

      metadata: {
        cardNumber: 'x192',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 energy to draw 2 cards.', (eb) => {
            eb.energy(2).startAction.cards(2);
          }).br;
          b.city();
        }),
        description: 'Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/corpera/ScientificSupport.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ScientificSupport extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SCIENTIFIC_SUPPORT,
      tags: [Tag.EARTH],
      cost: 3,

      behavior: {
        production: {megacredits: 2},
      },

      requirements: {tag: Tag.SCIENCE, count: 2},
      metadata: {
        cardNumber: 'x207',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(2);
          });
        }),
        description: 'Requires 2 science tags. Increase your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/SeedSuppliers.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {digit} from '../../Options';

export class SeedSuppliers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SEED_SUPPLIERS,
      cost: 15,
      tags: [Tag.PLANT, Tag.EARTH],

      behavior: {
        production: {plants: 1},
        stock: {plants: 4},
      },

      metadata: {
        cardNumber: 'x231',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).nbsp.plants(4, {digit});
        }),
        description: 'Increase your plant production 1 step and gain 4 plants.',
      },
    });
  }
}

================
File: cards/chemical/corpera/Shipyard.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class Shipyard extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SHIPYARD,
      cost: 13,
      tags: [Tag.BUILDING],

      behavior: {
        production: {titanium: 1},
        stock: {titanium: 2},
      },

      metadata: {
        cardNumber: 'x228',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).nbsp.titanium(2);
        }),
        description: 'Increase your titanium production 1 step and gain 2 titanium.',
      },
    });
  }
}

================
File: cards/chemical/corpera/SteelExports.ts
================
import {IProjectCard} from '../../IProjectCard';
import {ActionCard} from '../../ActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';

export class SteelExports extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.STEEL_EXPORTS,
      tags: [Tag.SPACE, Tag.BUILDING],
      cost: 10,

      action: {
        spend: {steel: 3},
        stock: {megacredits: 10},
      },

      metadata: {
        cardNumber: 'x203',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 3 steel to gain 10 M€.', (eb) => {
            eb.steel(3).startAction.megacredits(10);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/corpera/SuccessfulCommerce.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class SuccessfulCommerce extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SUCCESSFUL_COMMERCE,
      tags: [Tag.EARTH],
      cost: 8,

      behavior: {
        production: {megacredits: 3},
      },

      requirements: {tag: Tag.EARTH, count: 2},
      metadata: {
        cardNumber: 'x206',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(3);
          });
        }),
        description: 'Requires 2 Earth tags. Increase your M€ production 3 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/TheoryOfEverything.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class TheoryOfEverything extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.THEORY_OF_EVERYTHING,
      tags: [Tag.SCIENCE, Tag.SCIENCE],
      cost: 25,
      requirements: {tag: Tag.SCIENCE, count: 7},
      victoryPoints: 5,

      behavior: {
        drawCard: 3,
      },

      metadata: {
        cardNumber: 'x239',
        renderData: CardRenderer.builder((b) => {
          b.cards(3);
        }),
        description: 'Requires 7 science tags. Playing this card counts as playing 2 science cards. Draw 3 cards.',
      },
    });
  }
}

================
File: cards/chemical/corpera/TitanTradeHub.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class TitanTradeHub extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TITAN_TRADE_HUB,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 28,
      victoryPoints: {tag: Tag.JOVIAN},

      behavior: {
        production: {megacredits: 3},
      },

      metadata: {
        cardNumber: 'x222',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(3);
          }).br;
          b.vpText('1 VP per Jovian tag you have.');
        }),
        description: 'Increase your M€ production 3 steps.',
      },
    });
  }
}

================
File: cards/chemical/corpera/UpperMantleBoring.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class UpperMantleBoring extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.UPPER_MANTLE_BORING,
      tags: [Tag.BUILDING],
      cost: 15,
      requirements: {tag: Tag.SCIENCE, count: 4},
      victoryPoints: 1,

      behavior: {
        production: {energy: -1, titanium: 2},
        stock: {titanium: 3},
      },

      metadata: {
        cardNumber: 'x230',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().titanium(2);
          });
          b.titanium(3);
        }),
        description: 'Requires 4 science tags. Decrease your energy production 1 step, increase your titanium production 2 steps, and gain 3 titanium.',
      },
    });
  }
}

================
File: cards/chemical/corpera/ViralAmeboid.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardResource} from '../../../../common/CardResource';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';

export class ViralAmeboid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.VIRAL_AMEBOID,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      cost: 5,
      requirements: {temperature: -20},
      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 3},

      metadata: {
        cardNumber: 'x187',
        renderData: CardRenderer.builder((b) => {
          b.effect('When any player plays a microbe tag, including this, add a microbe to this card.', (eb) => {
            eb.tag(Tag.MICROBE, {all}).startEffect.resource(CardResource.MICROBE);
          }).br;
          b.vpText('1 VP per 3 Microbes on this card.').br;
        }),
        description: 'Requires -20°C or warmer.',
      },
    });
  }
  public onCardPlayedFromAnyPlayer(thisCardOwner: IPlayer, _playedCardOwner: IPlayer, card: IProjectCard) {
    if (card.tags.includes(Tag.MICROBE)) {
      thisCardOwner.addResourceTo(this, {qty: 1, log: true});
    }
    return undefined;
  }
}

================
File: cards/chemical/corpera/VolcanicFoundry.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class VolcanicFoundry extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.VOLCANIC_FOUNDRY,
      tags: [Tag.BUILDING],
      cost: 5,

      behavior: {
        production: {heat: -2, steel: 1, titanium: 1},
      },

      metadata: {
        cardNumber: 'x227',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().heat(2).br;
            pb.plus().steel(1).titanium(1);
          });
        }),
        description: 'Decrease your heat production 2 steps. Increase your steel production 1 step and your titanium production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/globalevents/AbstinanceBonus.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {GainResources} from '../../../inputs/GainResources';
import {Size} from '../../../../common/cards/render/Size';
import {message} from '../../../logs/MessageBuilder';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.tr(1, {size: Size.SMALL, cancelled: true}).colon().megacredits(5).nbsp.wild(1).slash().influence();
});

export class AbstinanceBonus extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.ABSTINANCE_BONUS,
      description: 'Gain 5 M€ if you did not raised your TR this generation. Gain 1 standard resource per influence.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      if (!player.generationData.hasRaisedTR) {
        player.stock.add(Resource.MEGACREDITS, 5, {from: this.name, log: true});
      }
      const count = turmoil.getPlayerInfluence(player);
      if (count > 0) {
        player.defer(new GainResources(
          player,
          count,
          message('Abstinance Bonus Global Event - Gain ${0} resource(s) for influence', (b) => b.number(count)),
        ));
      }
    });
  }
}

================
File: cards/chemical/globalevents/AnticorrosiveMaterials.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';
import {AddResourcesToCard} from '../../../deferredActions/AddResourcesToCard';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.VENUS}).nbsp.wild(1, {secondaryTag: Tag.VENUS}).slash().influence();
});

export class AnticorrosiveMaterials extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.ANTICORROSIVE_MATERIALS,
      description: 'Add 2 floaters to a Venus card. Add any Venus resource for each influence to a card.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      game.defer(new AddResourcesToCard(player, CardResource.FLOATER, {count: 2, restrictedTag: Tag.VENUS}));
      const amount = turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        game.defer(new AddResourcesToCard(player, undefined, {count: amount, restrictedTag: Tag.VENUS}));
      }
    });
  }
}

================
File: cards/chemical/globalevents/ChemicalPollution.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-1).slash().emptyTile('normal', {size: Size.SMALL}).influence({size: Size.SMALL});
});

export class ChemicalPollution extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.CHEMICAL_POLLUTION,
      description: 'Lose 1 M€ for each tile you have (no limit), then reduced by influence.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.max(game.board.spaces.filter((space) => space.player === player).length - turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.MEGACREDITS, Math.min(amount, player.stock.megacredits), {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/ColonizationOfMercury.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.production((pb) => pb.megacredits(1)).slash().tag(Tag.SPACE, 2).influence({size: Size.SMALL});
});

export class ColonizationOfMercury extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.COLONIZATION_OF_MERCURY,
      description: 'Increase your M€ production 1 step for every 2 space tags you have (no limit), influence counts as space tags.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.floor((player.tags.count(Tag.SPACE, 'raw') + turmoil.getPlayerInfluence(player)) / 2);
      player.production.add(Resource.MEGACREDITS, amount, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/ColonyProductivity.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {GainResources} from '../../../inputs/GainResources';
import {message} from '../../../logs/MessageBuilder';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.text('GAIN ALL YOUR COLONY BONUSES').br.wild(1).slash().influence();
});

export class ColonyProductivity extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.COLONY_PRODUCTIVITY,
      description: 'Gain 1 standard ressource per influence.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.game.colonies.forEach((colony) => {
        colony.colonies.filter((owner) => owner === player.id).forEach((owner) => {
          player.game.defer(new SimpleDeferredAction(player, () => colony.giveColonyBonus(player.game.getPlayerById(owner))));
        });
      });
      const count = turmoil.getPlayerInfluence(player);
      if (count > 0) {
        player.defer(new GainResources(
          player,
          count,
          message('Colony Productivity Global Event - Gain ${0} resource(s) for influence', (b) => b.number(count)),
        ));
      }
    });
  }
}

================
File: cards/chemical/globalevents/CommandEconomy.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';


const RENDER_DATA = CardRenderer.builder((b) => {
  b.text('ALL').colonyTile().colon().text('+ 1').br.megacredits(4).slash().influence();
});

export class CommandEconomy extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.COMMAND_ECONOMY,
      description: 'Increase all colony tracks 1 step. Gain 4 M€ per influence.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.stock.add(Resource.MEGACREDITS, turmoil.getPlayerInfluence(player) * 3, {log: true, from: this.name});
    });
    const activeColonies = game.colonies.filter((colony) => colony.isActive);
    activeColonies.forEach((colony) => {
      colony.increaseTrack(1);
    });
  }
}

================
File: cards/chemical/globalevents/CommunityServicesEvent.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Size} from '../../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().noTags().influence({size: Size.SMALL});
});

export class CommunityServicesEvent extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.COMMUNITY_SERVICES,
      description: 'Gain 2 M€ for each card with no tags (max 5) and influence.',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(player.tags.numberOfCardsWithNoTags(), 5) + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.MEGACREDITS, amount * 2, {from: this.name, log: true});
    });
  }
}

================
File: cards/chemical/globalevents/ConstitutionalReformation.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(3).slash().partyLeaders(1).nbsp.tr(1).slash().influence();
});

export class ConstitutionalReformation extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.CONSTITUTIONAL_REFORMATION,
      description: 'Gain 3 M€ for each party leader you have. Gain 1 TR per influence.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const partyLeaders = turmoil.parties.filter((party) => party.partyLeader === player).length;
      player.stock.add(Resource.MEGACREDITS, partyLeaders * 3, {log: true, from: this.name});
      player.increaseTerraformRating(turmoil.getPlayerInfluence(player), {log: true});
    });
  }
}

================
File: cards/chemical/globalevents/Cyberattacks.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-3).slash().tag(Tag.SCIENCE).influence({size: Size.SMALL});
});

export class Cyberattacks extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.CYBERATTACKS,
      description: 'Lose 3 M€ for each science tag you have (max 5), then reduced by influence.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.max(Math.min(5, player.tags.count(Tag.SCIENCE, 'raw')) - turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.MEGACREDITS, Math.min(amount * 3, player.stock.megacredits), {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/DegredationOfVenus.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {message} from '../../../logs/MessageBuilder';
import {GainResources} from '../../../inputs/GainResources';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().venus(1).nbsp.wild(1).slash().influence();
});

export class DegredationOfVenus extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.DEGREDATION_OF_VENUS,
      description: 'Lower Venus 1 step. Gain 1 standard resource per influence.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.increaseVenusScaleLevel(game.getPlayersInGenerationOrder()[0], -1);
    game.getPlayersInGenerationOrder().forEach((player) => {
      const count = turmoil.getPlayerInfluence(player);
      if (count > 0) {
        player.defer(new GainResources(
          player,
          count,
          message('Degredation of Venus Global Event - Gain ${0} resource(s) for influence', (b) => b.number(count)),
        ));
      }
    });
  }
}

================
File: cards/chemical/globalevents/EcologicalSupport.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(3).slash().tag(Tag.ANIMAL).influence({size: Size.SMALL});
});

export class EcologicalSupport extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.ECOLOGICAL_SUPPORT,
      description: 'Gain 3 M€ for each animal tag you have (max 5) and influence.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(5, player.tags.count(Tag.ANIMAL, 'raw')) + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.MEGACREDITS, amount * 3, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/EcologyProjects.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {PlayerInput} from '../../../PlayerInput';
import {CardResource} from '../../../../common/CardResource';
import {SelectOption} from '../../../inputs/SelectOption';
import {SelectCard} from '../../../inputs/SelectCard';
import {message} from '../../../logs/MessageBuilder';
import {OrOptions} from '../../../inputs/OrOptions';
import {digit} from '../../Options';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.plants(3, {digit}).or().resource(CardResource.MICROBE, {amount: 3, digit}).or().resource(CardResource.ANIMAL, {amount: 2, digit}).br.cards(1).slash().influence();
});

export class EcologyProjects extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.ECOLOGY_PROJECTS,
      description: 'Gain 3 plants, add 3 microbes to any card, or add 2 animals to any card. Draw a card per influence.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      game.defer(new SimpleDeferredAction(player, () => {
        const availableMicrobeCards = player.getResourceCards(CardResource.MICROBE);
        const availableAnimalCards = player.getResourceCards(CardResource.ANIMAL);
        const gainPlants = function() {
          player.stock.add(Resource.PLANTS, 3, {log: true});
          return undefined;
        };

        if (availableMicrobeCards.length === 0 && availableAnimalCards.length === 0) {
          return gainPlants();
        }

        const availableActions: Array<PlayerInput> = [];
        const gainPlantsOption = new SelectOption('Gain 3 plants', 'Gain plants').andThen(gainPlants);
        availableActions.push(gainPlantsOption);

        if (availableMicrobeCards.length === 1) {
          const targetMicrobeCard = availableMicrobeCards[0];
          availableActions.push(new SelectOption(message('Add ${0} microbes to ${1}', (b) => b.number(3).card(targetMicrobeCard)), 'Add microbes').andThen(() => {
            player.addResourceTo(targetMicrobeCard, {qty: 3, log: true});
            return undefined;
          }));
        } else if (availableMicrobeCards.length > 1) {
          availableActions.push(new SelectCard('Add 3 microbes to a card',
            'Add microbes',
            availableMicrobeCards)
            .andThen(([card]) => {
              player.addResourceTo(card, {qty: 3, log: true});
              return undefined;
            }));
        }
        if (availableAnimalCards.length === 1) {
          const targetAnimalCard = availableAnimalCards[0];
          availableActions.push(new SelectOption(message('Add ${0} animals to ${1}', (b) => b.number(2).card(targetAnimalCard)), 'Add animals').andThen(() => {
            player.addResourceTo(targetAnimalCard, {qty: 2, log: true});
            return undefined;
          }));
        } else if (availableAnimalCards.length > 1) {
          availableActions.push(new SelectCard('Add 2 animals to a card', 'Add animals', availableAnimalCards)
            .andThen(([card]) => {
              player.addResourceTo(card, {qty: 2, log: true});
              return undefined;
            }));
        }
        return new OrOptions(...availableActions);
      }));
      player.drawCard(turmoil.getPlayerInfluence(player));
    });
  }
}

================
File: cards/chemical/globalevents/EconomicDepression.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().tr(2).nbsp.megacredits(-4).slash().tag(Tag.EARTH).influence({size: Size.SMALL});
});

export class EconomicDepression extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.ECONOMIC_DEPRESSION,
      description: 'Lower your TR 2 steps. Lose 4 M€ for each Earth tag (max 5), then reduced by influence.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.max(Math.min(5, player.tags.count(Tag.EARTH, 'raw')) - turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.MEGACREDITS, amount * 4, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/EcosystemDisruption.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {CardResource} from '../../../../common/CardResource';
import {SelectOption} from '../../../inputs/SelectOption';
import {SelectCard} from '../../../inputs/SelectCard';
import {OrOptions} from '../../../inputs/OrOptions';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-8).nbsp.or().nbsp.minus().resource(CardResource.MICROBE).nbsp.plants(1).slash().influence();
});

export class EcosystemDisruption extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.ECOSYSTEM_DISRUPTION,
      description: 'Lose 8 M€ or remove 2 microbes from any card. Gain 1 plant per influence.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      game.defer(new SimpleDeferredAction(player, () => {
        const microbeCards = player.getCardsWithResources(CardResource.MICROBE).filter((card) => (card.resourceCount ?? 0) >= 2);
        const selectAction = new OrOptions();
        const payMC = new SelectOption('Lose up to 8 M€', 'Lose M€').andThen(() => {
          player.stock.deduct(Resource.MEGACREDITS, 8, {log: true, from: this.name});
          return undefined;
        });
        const removeMicrobes = new SelectCard('Select card to remove 2 microbes from', 'Remove microbes', microbeCards).andThen(([card]) => {
          player.removeResourceFrom(card, 2);
          return undefined;
        });
        selectAction.options.push(payMC, removeMicrobes);
        if (microbeCards.length === 0) {
          payMC.cb(undefined);
          return undefined;
        }
        return selectAction;
      }));
      player.stock.add(Resource.PLANTS, turmoil.getPlayerInfluence(player), {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/EgalitarianMovements.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-2).slash().tag(Tag.EARTH).plus().influence();
});

export class EgalitarianMovements extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.EGALITARIAN_MOVEMENTS,
      description: 'Lose 2 M€ for each Earth tag (max 5) and influence.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(player.tags.count(Tag.EARTH, 'raw'), 5) + turmoil.getPlayerInfluence(player);
      player.stock.deduct(Resource.MEGACREDITS, Math.min(amount * 2, player.megaCredits), {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/EradicationOfGeneticIllness.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {IPlayer} from '../../../IPlayer';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.influence().plus().tag(Tag.SCIENCE).colon().br;
  b.text('1st:', Size.SMALL).tr(2).nbsp.text('2nd:', Size.SMALL).tr(1);
});

export class EradicationOfGeneticIllness extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.ERADICATION_OF_GENETIC_ILLNESS,
      description: 'Count your influence plus science tags (no limits). The player(s) with the most (or 6 in solo) gains 2 TR. The player(s) with the 2nd most (or 3 in solo) gains 1 TR.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    // Solo
    if (game.isSoloMode()) {
      const player = game.getPlayers()[0];
      if (this.getScore(player, turmoil) >= 6) {
        player.increaseTerraformRating(2, {log: true});
      } else if (this.getScore(player, turmoil) >= 3) {
        player.increaseTerraformRating(1, {log: true});
      }
    } else {
      const players = game.getPlayers().slice().sort(
        (p1, p2) => this.getScore(p2, turmoil) - this.getScore(p1, turmoil),
      );

      // We have one rank 1 player
      if (this.getScore(players[0], turmoil) > this.getScore(players[1], turmoil)) {
        players[0].increaseTerraformRating(2, {log: true});
        players.shift();

        if (players.length === 1) {
          players[0].increaseTerraformRating(1, {log: true});
        } else if (players.length > 1) {
          const score = this.getScore(players[0], turmoil);
          while (players.length > 0 && this.getScore(players[0], turmoil) === score) {
            players[0].increaseTerraformRating(1, {log: true});
            players.shift();
          }
        }
        // We have at least two rank 1 players
      } else {
        const score = this.getScore(players[0], turmoil);
        while (players.length > 0 && this.getScore(players[0], turmoil) === score) {
          players[0].increaseTerraformRating(2, {log: true});
          players.shift();
        }
      }
    }
  }

  public getScore(player: IPlayer, turmoil: Turmoil) {
    return turmoil.getPlayerInfluence(player) + player.tags.count(Tag.SCIENCE, 'raw');
  }
}

================
File: cards/chemical/globalevents/ExtinctionEvent.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().oxygen(1).nbsp.minus().plants(1).slash().tag(Tag.PLANT).influence({size: Size.SMALL});
});

export class ExtinctionEvent extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.EXTINCTION_EVENT,
      description: 'Lower the oxygen 1 step. Lose 1 plant for each plant tag (max 5), then reduced by influence.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.increaseOxygenLevel(game.getPlayersInGenerationOrder()[0], -1);
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.max(Math.min(5, player.tags.count(Tag.PLANT, 'raw')) - turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.PLANTS, amount, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/Famine.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().plants(2).nbsp.megacredits(-3).slash().tag(Tag.BUILDING).influence({size: Size.SMALL});
});

export class Famine extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.FAMINE,
      description: 'Lose 2 plants. Lose 3 M€ for each building tag you have (max 5), then reduced by influence.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      if (player.stock.plants > 0) {
        player.stock.deduct(Resource.PLANTS, 2, {log: true, from: this.name});
      }
      const amount = Math.max(Math.min(5, player.tags.count(Tag.BUILDING, 'raw')) - turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.MEGACREDITS, Math.min(amount * 3, player.stock.megacredits), {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/FloaterTechnologyEvent.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {CardResource} from '../../../../common/CardResource';
import {AddResourcesToCard} from '../../../deferredActions/AddResourcesToCard';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().resource(CardResource.FLOATER).nbsp.resource(CardResource.FLOATER).slash().influence();
});

export class FloaterTechnologyEvent extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.FLOATER_TECHNOLOGY,
      description: 'Gain 2 M€ for each floater (max 5). Then, add a floater for each influence to a card.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const floaters = Math.min(player.getResourceCount(CardResource.FLOATER), 5);
      player.stock.add(Resource.MEGACREDITS, floaters * 2, {from: this.name, log: true});
      const amount = turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        game.defer(new AddResourcesToCard(player, CardResource.FLOATER, {count: amount}));
      }
    });
  }
}

================
File: cards/chemical/globalevents/FoodSupply.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().tag(Tag.PLANT).influence({size: Size.SMALL});
});

export class FoodSupply extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.FOOD_SUPPLY,
      description: 'Gain 2 M€ for each plant tag you have (max 5) and influence.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(5, player.tags.count(Tag.PLANT, 'raw')) + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.MEGACREDITS, amount * 2, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/HeatFirstInitiative.ts
================
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PartyName} from '../../../../common/turmoil/PartyName';

export class HeatFirstInitiative extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.HEAT_FIRST_INITIATIVE,

      behavior: {
        turmoil: {sendDelegates: {count: 2, party: PartyName.KELVINISTS}},
        global: {temperature: 2},
      },

      metadata: {
        cardNumber: 'xP61',
        renderData: CardRenderer.builder((b) => {
          b.delegates(2).kelvinists().nbsp.temperature(2);
        }),
        description: 'Place 2 delegates into Kelvinists and raise the temperature 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/globalevents/Insurgency.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {IPlayer} from '../../../IPlayer';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Board} from '../../../boards/Board';
import {Resource} from '../../../../common/Resource';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.influence().plus().city({size: Size.SMALL}).colon().nbsp.text('1st:', Size.SMALL).megacredits(-9).br;
  b.text('2nd:', Size.SMALL).megacredits(-6).nbsp.text('3rd & below:', Size.SMALL).megacredits(-3);
});

export class Insurgency extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.INSURGENCY,
      description: 'Count your influence plus city tiles (no limits). The player(s) with the most (or 4 in solo) loses 9 M€. The player(s) with the 2nd most (or 2 in solo) loses 6 M€. All other players lose 3 M€.',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    // Solo
    if (game.isSoloMode()) {
      const player = game.getPlayers()[0];
      if (this.getScore(player, turmoil, game) >= 4) {
        player.stock.deduct(Resource.MEGACREDITS, 9, {log: true, from: this.name});
      } else if (this.getScore(player, turmoil, game) >= 2) {
        player.stock.deduct(Resource.MEGACREDITS, 6, {log: true, from: this.name});
      } else {
        player.stock.deduct(Resource.MEGACREDITS, 3, {log: true, from: this.name});
      }
    } else {
      const players = game.getPlayers().slice().sort(
        (p1, p2) => this.getScore(p2, turmoil, game) - this.getScore(p1, turmoil, game),
      );

      // We have one rank 1 player
      if (this.getScore(players[0], turmoil, game) > this.getScore(players[1], turmoil, game)) {
        players[0].stock.deduct(Resource.MEGACREDITS, 9, {log: true, from: this.name});
        players.shift();

        const score = this.getScore(players[0], turmoil, game);
        while (players.length > 0 && this.getScore(players[0], turmoil, game) === score) {
          players[0].stock.deduct(Resource.MEGACREDITS, 6, {log: true, from: this.name});
          players.shift();
        }
        // We have at least two rank 1 players
      } else {
        const score = this.getScore(players[0], turmoil, game);
        while (players.length > 0 && this.getScore(players[0], turmoil, game) === score) {
          players[0].stock.deduct(Resource.MEGACREDITS, 9, {log: true, from: this.name});
          players.shift();
        }
      }
      const score = this.getScore(players[0], turmoil, game);
      while (players.length > 0 && this.getScore(players[0], turmoil, game) === score) {
        players[0].stock.deduct(Resource.MEGACREDITS, 3, {log: true, from: this.name});
        players.shift();
      }
    }
  }

  public getScore(player: IPlayer, turmoil: Turmoil, game: IGame) {
    return turmoil.getPlayerInfluence(player) + game.board.spaces.filter((space) => Board.isCitySpace(space) && space.player === player).length;
  }
}

================
File: cards/chemical/globalevents/IntellectualistMovement.ts
================
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {Tag} from '../../../../common/cards/Tag';

export class IntellectualistMovement extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.INTELLECTUALIST_MOVEMENT,
      tags: [Tag.SCIENCE],

      behavior: {
        turmoil: {sendDelegates: {count: 2, party: PartyName.SCIENTISTS}},
        drawCard: 3,
      },

      metadata: {
        cardNumber: 'xP59',
        renderData: CardRenderer.builder((b) => {
          b.delegates(2).scientists().cards(3);
        }),
        description: 'Place 2 delegates into Scientists and draw 3 cards.',
      },
    });
  }
}

================
File: cards/chemical/globalevents/InterplanetaryCommunities.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(1).slash().diverseTag().nbsp.cards(1).slash().influence();
});

export class InterplanetaryCommunities extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.INTERPLANETARY_COMMUNITIES,
      description: 'Gain 1 M€ for each unique tag you have. Draw a card for each influence.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.stock.add(Resource.MEGACREDITS, player.tags.distinctCount('globalEvent'), {log: true, from: this.name});
      player.drawCard(turmoil.getPlayerInfluence(player));
    });
  }
}

================
File: cards/chemical/globalevents/InterstallarColonization.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().colonies().nbsp.influence().colon().megacredits(5);
});

export class InterstallarColonization extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.INTERSTELLAR_COLONIZATION,
      description: 'Gain 2 M€ for each colony (max 5). The player(s) with the most influence gains 5 M€.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const colonies = Math.min(player.getColoniesCount(), 5);
      player.stock.add(Resource.MEGACREDITS, colonies * 2, {from: this.name, log: true});
    });
    const players = game.getPlayers().slice().sort(
      (p1, p2) => turmoil.getPlayerInfluence(p2) - turmoil.getPlayerInfluence(p1),
    );
    const score = turmoil.getPlayerInfluence(players[0]);
    while (players.length > 0 && turmoil.getPlayerInfluence(players[0]) === score) {
      players[0].stock.add(Resource.MEGACREDITS, 5, {log: true, from: this.name});
      players.shift();
    }
  }
}

================
File: cards/chemical/globalevents/JovianWar.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {IPlayer} from '../../../IPlayer';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.influence().plus().tag(Tag.JOVIAN).plus().colonies().colon().br;
  b.text('1st:', Size.SMALL).minus().tr(2).nbsp;
  b.text('2nd:', Size.SMALL).minus().tr(1);
});

export class JovianWar extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.JOVIAN_WAR,
      description: 'Count your influence plus Jovian tags and colonies (no limits). The player(s) with the most (or 4 in solo) loses 2 TR. The player(s) with the 2nd most loses 1 TR.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    // Solo
    if (game.isSoloMode()) {
      const player = game.getPlayers()[0];
      if (this.getScore(player, turmoil) >= 4) {
        player.decreaseTerraformRating(2);
      }
    } else {
      const players = game.getPlayers().slice().sort(
        (p1, p2) => this.getScore(p2, turmoil) - this.getScore(p1, turmoil),
      );

      // We have one rank 1 player
      if (this.getScore(players[0], turmoil) > this.getScore(players[1], turmoil)) {
        players[0].decreaseTerraformRating(2);
        players.shift();

        const score = this.getScore(players[0], turmoil);
        while (players.length > 0 && this.getScore(players[0], turmoil) === score) {
          players[0].decreaseTerraformRating(1);
          players.shift();
        }
        // We have at least two rank 1 players
      } else {
        const score = this.getScore(players[0], turmoil);
        while (players.length > 0 && this.getScore(players[0], turmoil) === score) {
          players[0].decreaseTerraformRating(2);
          players.shift();
        }
      }
    }
  }

  public getScore(player: IPlayer, turmoil: Turmoil) {
    return turmoil.getPlayerInfluence(player) + player.tags.count(Tag.JOVIAN, 'raw') + player.getColoniesCount();
  }
}

================
File: cards/chemical/globalevents/LaborRevolt.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().steel(1).energy(1).slash().tag(Tag.BUILDING).influence({size: Size.SMALL});
});

export class LaborRevolt extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.LABOR_REVOLT,
      description: 'Lose 1 steel and 1 energy for each building tag you have (max 5), then reduced by influence.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.max(Math.min(5, player.tags.count(Tag.BUILDING, 'raw')) - turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.STEEL, Math.min(amount, player.stock.steel), {log: true, from: this.name});
      player.stock.deduct(Resource.ENERGY, Math.min(amount, player.stock.energy), {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/LandDelegation.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {IPlayer} from '../../../IPlayer';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {SelectSpace} from '../../../inputs/SelectSpace';
import {LogHelper} from '../../../LogHelper';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.influence().plus().emptyTile('normal', {size: Size.SMALL}).colon().nbsp;
  b.text('1st & 2nd:', Size.SMALL).community();
});

export class LandDelegation extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.LAND_DELEGATION,
      description: 'Count your influence plus tiles (no limits). The player(s) with the most places their player marker on an unreserved area. Then, the player(s) with the 2nd most place of of theirs. Only those players may place tiles on their respective marked areas.',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    // Solo
    if (game.isSoloMode()) {
      const player = game.getPlayers()[0];
      player.defer(this.landClaim(player));
    } else {
      const players = game.getPlayers().slice().sort(
        (p1, p2) => this.getScore(p2, turmoil, game) - this.getScore(p1, turmoil, game),
      );

      // We have one rank 1 player
      if (this.getScore(players[0], turmoil, game) > this.getScore(players[1], turmoil, game)) {
        players[0].defer(this.landClaim(players[0]));
        players.shift();

        if (players.length === 1) {
          players[0].defer(this.landClaim(players[0]));
        } else if (players.length > 1) {
          const score = this.getScore(players[0], turmoil, game);
          while (players.length > 0 && this.getScore(players[0], turmoil, game) === score) {
            players[0].defer(this.landClaim(players[0]));
            players.shift();
          }
        }
        // We have at least two rank 1 players
      } else {
        const score = this.getScore(players[0], turmoil, game);
        while (players.length > 0 && this.getScore(players[0], turmoil, game) === score) {
          players[0].defer(this.landClaim(players[0]));
          players.shift();
        }
      }
    }
  }

  public getScore(player: IPlayer, turmoil: Turmoil, game: IGame) {
    return turmoil.getPlayerInfluence(player) + game.board.spaces.filter((space) => space.tile !== undefined && space.player === player).length;
  }
  private landClaim(player: IPlayer): SelectSpace {
    return new SelectSpace(
      'Select space for claim',
      player.game.board.getNonReservedLandSpaces())
      .andThen((space) => {
        space.player = player;
        LogHelper.logBoardTileAction(player, space, 'land claim');
        return undefined;
      });
  }
}

================
File: cards/chemical/globalevents/LandRun.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(1).slash().emptyTile('normal', {size: Size.SMALL}).influence({size: Size.SMALL});
});

export class LandRun extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.LAND_RUN,
      description: 'Gain 1 M€ for each tile you have (no limit) and influence.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = game.board.spaces.filter((space) => space.player === player).length + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.MEGACREDITS, amount, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/LowlandFlooding.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {SelectSpace} from '../../../inputs/SelectSpace';
import {TileType} from '../../../../common/TileType';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().oceans(1, {all: true}).nbsp.plus().oceans(1).nbsp.megacredits(-2).slash().tag(Tag.BUILDING).influence({size: Size.SMALL});
});

export class LowlandFlooding extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.LOWLAND_FLOODING,
      description: 'The first player removes an ocean tile from the board and places an ocean in a new location, if possible. Lose 2 M€ for each building tag (max 5), then reduced by influence.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    const firstPlayer = game.getPlayersInGenerationOrder()[0];
    if (game.canRemoveOcean() && game.board.getAvailableSpacesForOcean(firstPlayer).length > 0) {
      game.defer(new SimpleDeferredAction(firstPlayer, () => {
        return new SelectSpace('Select ocean to remove', game.board.spaces.filter((space) => space.tile?.tileType === TileType.OCEAN)).andThen((removedOcean) => {
          game.removeTile(removedOcean.id);
          return new SelectSpace('Select a space for the new ocean', game.board.getAvailableSpacesForOcean(firstPlayer).filter((space) => space.id !== removedOcean.id)).andThen((newOcean) => {
            game.addOcean(firstPlayer, newOcean);
            return undefined;
          });
        });
      }));
    }
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.max(Math.min(5, player.tags.count(Tag.BUILDING, 'raw')) - turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.MEGACREDITS, amount * 2, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/MagneticFieldFailure.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().megacredits(8).nbsp.or().nbsp.minus().energy(3).br.minus().plants(3).nbsp.influence().colon().megacredits(4);
});

export class MagneticFieldFailure extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.MAGNETIC_FIELD_FAILURE,
      description: 'Lose 8 M€ or 3 energy. Lose 3 plants. The player(s) with the most influence gains 4 M€.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      if (player.plants > 0) {
        player.stock.deduct(Resource.PLANTS, 3, {log: true, from: this.name});
      }
      game.defer(new SimpleDeferredAction(player, () => {
        if (player.energy < 3) {
          player.megaCredits -= 8;
          return undefined;
        }
        const orOptions = new OrOptions();
        orOptions.options.push(new SelectOption('Lose 3 energy', 'Confirm').andThen( () => {
          player.energy -= 3;
          return undefined;
        }));
        orOptions.options.push(new SelectOption('Lose 8 M€', 'Confirm').andThen( () => {
          player.megaCredits -= 8;
          return undefined;
        }));
        return orOptions;
      }));
    });
    const players = game.getPlayers().slice().sort(
      (p1, p2) => turmoil.getPlayerInfluence(p2) - turmoil.getPlayerInfluence(p1),
    );
    const score = turmoil.getPlayerInfluence(players[0]);
    while (players.length > 0 && turmoil.getPlayerInfluence(players[0]) === score) {
      players[0].stock.add(Resource.MEGACREDITS, 4, {log: true, from: this.name});
      players.shift();
    }
  }
}

================
File: cards/chemical/globalevents/MandatoryInsurance.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';


const RENDER_DATA = CardRenderer.builder((b) => {
  b.production((pb) => pb.minus().megacredits(3)).nbsp.megacredits(3).slash().influence();
});

export class MandatoryInsurance extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.MANDATORY_INSURANCE,
      description: 'Decrease your M€ production 3 steps. Gain 3 M€ per influence.',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      if (player.production.megacredits > -5) {
        const decreaseAmount = -Math.min(player.production.megacredits + 5, 3);
        player.production.add(Resource.MEGACREDITS, decreaseAmount, {log: true, from: this.name});
      }
      player.stock.add(Resource.MEGACREDITS, turmoil.getPlayerInfluence(player) * 3, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/MarsStockExchange.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.production((pb) => pb.megacredits(2)).nbsp.megacredits(1).slash().tag(Tag.BUILDING).influence({size: Size.SMALL});
});

export class MarsStockExchange extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.MARS_STOCK_EXCHANGE,
      description: 'Increase your M€ production 2 steps. Gain 1 M€ for each building tag (no limit) and influence.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.production.add(Resource.MEGACREDITS, 2, {log: true, from: this.name});
      const amount = player.tags.count(Tag.BUILDING, 'raw') + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.MEGACREDITS, amount, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/MicrobialBoom.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardResource} from '../../../../common/CardResource';
import {AddResourcesToCard} from '../../../deferredActions/AddResourcesToCard';
import {CardRenderer} from '../../render/CardRenderer';
import {AltSecondaryTag} from '../../../../common/cards/render/AltSecondaryTag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.cards(1, {secondaryTag: AltSecondaryTag.MICROBE}).colon().resource(CardResource.MICROBE).nbsp;
  b.resource(CardResource.MICROBE).slash().influence();
});

export class MicrobialBoom extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.MICROBIAL_BOOM,
      description: 'Add a microbe to each card that can collect microbes. Add 1 microbe for each influence to a card.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const resourceCards = player.getResourceCards(CardResource.MICROBE);
      resourceCards.forEach((card) => {
        player.addResourceTo(card, 1);
      });
      const amount = turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        game.defer(new AddResourcesToCard(player, CardResource.MICROBE, {count: amount}));
      }
    });
  }
}

================
File: cards/chemical/globalevents/MiningIndustries.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.oxygen(1).nbsp.steel(1).slash().tag(Tag.BUILDING, 2).influence({size: Size.SMALL});
});

export class MiningIndustries extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.MINING_INDUSTRIES,
      description: 'Raise the oxygen 1 step. Gain 1 steel for every 2 building tags you have (no limit), influence counts as building tags.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.increaseOxygenLevel(game.getPlayersInGenerationOrder()[0], 1);
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.floor((player.tags.count(Tag.BUILDING, 'raw') + turmoil.getPlayerInfluence(player)) / 2);
      player.stock.add(Resource.MEGACREDITS, amount, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/NanotechInnovation.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().tag(Tag.MICROBE).influence({size: Size.SMALL});
});

export class NanotechInnovation extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.NANOTECH_INNOVATION,
      description: 'Gain 2 M€ for each microbe tag you have (max 5) and influence.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(5, player.tags.count(Tag.MICROBE, 'raw')) + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.MEGACREDITS, amount * 2, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/PesticideApplication.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-3).slash().tag(Tag.MICROBE).influence({size: Size.SMALL});
});

export class PesticideApplication extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.PESTICIDE_APPLICATION,
      description: 'Lose 3 M€ for each microbe tag you have (max 5), then reduced by influence.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.max(Math.min(5, player.tags.count(Tag.MICROBE, 'raw')) - turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.MEGACREDITS, Math.min(amount * 3, player.stock.megacredits), {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/PowerFailureEvent.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';


const RENDER_DATA = CardRenderer.builder((b) => {
  b.text('lose all').energy(1).br.megacredits(-5).nbsp.energy(1).slash().influence();
});

export class PowerFailureEvent extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.POWER_FAILURE,
      description: 'Lose all energy and 5 M€. Then, gain 1 energy for each influence.',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.stock.deduct(Resource.ENERGY, player.stock.energy, {log: true, from: this.name});
      player.stock.deduct(Resource.MEGACREDITS, 5, {log: true, from: this.name});
      player.stock.add(Resource.ENERGY, turmoil.getPlayerInfluence(player), {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/PowerGenerationSubsidies.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().tag(Tag.POWER).influence({size: Size.SMALL});
});

export class PowerGenerationSubsidies extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.POWER_GENERATION_SUBSIDIES,
      description: 'Gain 2 M€ for each power tag you have (max 5) and influence.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(5, player.tags.count(Tag.POWER, 'raw')) + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.MEGACREDITS, amount * 2, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/PowerSurplus.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.energy(2).slash().tag(Tag.POWER).influence({size: Size.SMALL});
});

export class PowerSurplus extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.POWER_SURPLUS,
      description: 'Gain 2 energy for each power tag you have (max 5) and influence.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(5, player.tags.count(Tag.POWER, 'raw')) + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.ENERGY, amount * 2, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/PreferentialLoans.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {IPlayer} from '../../../IPlayer';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.tr(1).colon().nbsp.text('1st:', Size.SMALL).megacredits(10).production((pb) => pb.megacredits(-2)).br;
  b.text('2nd:', Size.SMALL).megacredits(5).production((pb) => pb.megacredits(-1)).nbsp.megacredits(2).slash().influence();
});

export class PreferentialLoans extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.PREFERENTIAL_LOANS,
      description: 'The player with the most TR (or in solo) gains 10 M€ and decreases their M€ production 2 steps. The player with the second most gains 5 M€ and lowers their M€ production 1 step. Gain 2 M€ per influence',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.stock.add(Resource.MEGACREDITS, turmoil.getPlayerInfluence(player), {log: true, from: this.name});
    });
    // Solo
    if (game.isSoloMode()) {
      const player = game.getPlayers()[0];
      this.firstPlaceReward(player);
    } else {
      const players = game.getPlayers().slice().sort(
        (p1, p2) => this.getScore(p2) - this.getScore(p1),
      );

      // We have one rank 1 player
      if (this.getScore(players[0]) > this.getScore(players[1])) {
        this.firstPlaceReward(players[0]);
        players.shift();

        const score = this.getScore(players[0]);
        while (players.length > 0 && this.getScore(players[0]) === score) {
          this.secondPlaceReward(players[0]);
          players.shift();
        }
        // We have at least two rank 1 players
      } else {
        const score = this.getScore(players[0]);
        while (players.length > 0 && this.getScore(players[0]) === score) {
          this.firstPlaceReward(players[0]);
          players.shift();
        }
      }
    }
  }

  public getScore(player: IPlayer) {
    return player.getTerraformRating();
  }
  private firstPlaceReward(player: IPlayer) {
    player.stock.add(Resource.MEGACREDITS, 10, {log: true, from: this.name});
    if (player.production.megacredits > -5) {
      const decreaseAmount = -Math.min(player.production.megacredits + 5, 2);
      player.production.add(Resource.MEGACREDITS, decreaseAmount, {log: true, from: this.name});
    }
  }
  private secondPlaceReward(player: IPlayer) {
    player.stock.add(Resource.MEGACREDITS, 5, {log: true, from: this.name});
    if (player.production.megacredits > -5) {
      player.production.add(Resource.MEGACREDITS, -1, {log: true, from: this.name});
    }
  }
}

================
File: cards/chemical/globalevents/RedTourism.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {Space} from '../../../boards/Space';
import {isHazardTileType} from '../../../../common/AresTileType';
import {SpaceType} from '../../../../common/boards/SpaceType';
import {IPlayer} from '@/server/IPlayer';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(1).slash().text('2').emptyTile('normal', {size: Size.SMALL}).asterix().influence({size: Size.SMALL});
});

export class RedTourism extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.RED_TOURISM,
      description: 'Gain 1 M€ for every 2 empty spaces next to your tiles (no limit), and influence.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }
  private static hasRealTile(space: Space) {
    return space.tile !== undefined && !isHazardTileType(space.tile.tileType);
  }
  private getAdjacentEmptyTiles(player: IPlayer): number {
    const board = player.game.board;
    return board.spaces.filter((space) => {
      if (space.spaceType === SpaceType.COLONY) {
        return false;
      }
      if (RedTourism.hasRealTile(space)) {
        return false;
      }
      return board.getAdjacentSpaces(space).some((adj) => {
        return RedTourism.hasRealTile(adj) && adj.player === player;
      });
    }).length;
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.floor(this.getAdjacentEmptyTiles(player) / 2) + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.MEGACREDITS, amount, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/RedUprising.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.plus().tr(1).colon().megacredits(-10).nbsp.production((pb) => pb.megacredits(1)).slash().influence();
});

export class RedUprising extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.RED_UPRISING,
      description: 'Lose 10 M€ if you raised your TR this generation. Raise your M€ production 1 step per influence.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      if (player.generationData.hasRaisedTR) {
        player.stock.deduct(Resource.MEGACREDITS, 10, {from: this.name, log: true});
      }
      player.production.add(Resource.MEGACREDITS, turmoil.getPlayerInfluence(player), {from: this.name, log: true});
    });
  }
}

================
File: cards/chemical/globalevents/RefugeeCrisis.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Size} from '../../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-2).slash().city().plus().colonies().influence({size: Size.SMALL});
});

export class RefugeeCrisis extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.REFUGEE_CRISIS,
      description: 'Lose 2 M€ for each city and colony (max 5 each), then reduced by influence.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.max(Math.min(5, game.board.getCities(player).length +
        player.getColoniesCount()) +
        turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.MEGACREDITS, amount * 2, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/RevisedPatentLaw.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {digit} from '../../Options';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.cards(8, {digit}).colon().megacredits(-8).nbsp.cards(1).slash().influence();
});

export class RevisedPatentLaw extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.REVISED_PATENT_LAW,
      description: 'Lose 8 M€ if you have 8 or more cards in hand. Then, draw a card per influence.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      if (player.cardsInHand.length >= 8) {
        player.stock.deduct(Resource.MEGACREDITS, 8, {log: true, from: this.name});
      }
      player.drawCard(turmoil.getPlayerInfluence(player));
    });
  }
}

================
File: cards/chemical/globalevents/RimShortages.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-4).slash().tag(Tag.JOVIAN).influence({size: Size.SMALL});
});

export class RimShortages extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.RIM_SHORTAGES,
      description: 'Lose 4 M€ for each Jovian tag (max 5), then reduced by influence.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.max(Math.min(5, player.tags.count(Tag.JOVIAN, 'raw')) - turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.MEGACREDITS, amount * 4, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/SevereMarsquake.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {digit} from '../../Options';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().megacredits(12).nbsp.or().nbsp.minus().steel(4, {digit}).br.influence().colon().cards(1);
});

export class SevereMarsquake extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SEVERE_MARSQUAKE,
      description: 'Lose 12 M€ or 4 steel. The player(s) with the most influence draws a card.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      game.defer(new SimpleDeferredAction(player, () => {
        if (player.steel < 4) {
          player.megaCredits -= 12;
          return undefined;
        }
        const orOptions = new OrOptions();
        orOptions.options.push(new SelectOption('Lose 4 steel', 'Confirm').andThen( () => {
          player.steel -= 4;
          return undefined;
        }));
        orOptions.options.push(new SelectOption('Lose 12 M€', 'Confirm').andThen( () => {
          player.megaCredits -= 12;
          return undefined;
        }));
        return orOptions;
      }));
    });
    const players = game.getPlayers().slice().sort(
      (p1, p2) => turmoil.getPlayerInfluence(p2) - turmoil.getPlayerInfluence(p1),
    );
    const score = turmoil.getPlayerInfluence(players[0]);
    while (players.length > 0 && turmoil.getPlayerInfluence(players[0]) === score) {
      players[0].drawCard(1);
      players.shift();
    }
  }
}

================
File: cards/chemical/globalevents/SocietiesOfVenus.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.production((pb) => pb.megacredits(1)).slash().tag(Tag.VENUS).nbsp.heat(2).slash().influence();
});

export class SocietiesOfVenus extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SOCIETIES_OF_VENUS,
      description: 'Increase your M€ production 1 step for every Venus tag you have (max 5). Gain 2 heat per influence.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(player.tags.count(Tag.VENUS, 'raw'), 5);
      player.production.add(Resource.MEGACREDITS, amount, {log: true, from: this.name});
      player.stock.add(Resource.HEAT, turmoil.getPlayerInfluence(player), {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/SpaceTravelLimitations.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().titanium(3).nbsp.megacredits(-2).slash().tag(Tag.SPACE).influence({size: Size.SMALL});
});

export class SpaceTravelLimitations extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SPACE_TRAVEL_LIMITATIONS,
      description: 'Lose 3 titanium. Lose 2 M€ for each space tag (max 5), then reduced by influence.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.stock.deduct(Resource.TITANIUM, 3, {log: true, from: this.name});
      const amount = Math.max(Math.min(5, player.tags.count(Tag.SPACE, 'raw')) - turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.MEGACREDITS, amount * 2, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/TaxationOfVenus.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-2).slash().tag(Tag.VENUS).influence({size: Size.SMALL});
});

export class TaxationOfVenus extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.TAXATION_OF_VENUS,
      description: 'Lose 2 M€ for each Venus tag (max 5), then reduced by influence.',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.max(Math.min(5, player.tags.count(Tag.VENUS, 'raw')) - turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.MEGACREDITS, amount * 2, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/TechnologicalRegression.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-1).slash().tag(Tag.SCIENCE).tag(Tag.SPACE).tag(Tag.POWER).influence({size: Size.SMALL});
});

export class TechnologicalRegression extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.TECHNOLOGICAL_REGRESSION,
      description: 'Lose 1 M€ for each power, space, and science tag (max 5 each tag), then reduced by influence.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.max(Math.min(5, player.tags.count(Tag.SPACE, 'raw')) +
        Math.min(5, player.tags.count(Tag.POWER, 'raw')) +
        Math.min(5, player.tags.count(Tag.SCIENCE, 'raw')) -
        turmoil.getPlayerInfluence(player), 0);
      player.stock.deduct(Resource.MEGACREDITS, amount, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/TradeEmbargo.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';


const RENDER_DATA = CardRenderer.builder((b) => {
  b.text('lose all').steel(1).titanium(1).br.influence().colon().megacredits(6);
});

export class TradeEmbargo extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.TRADE_EMBARGO,
      description: 'Lose all steel and titanium. The player(s) with the most influence gains 6 M€.',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.stock.deduct(Resource.STEEL, player.stock.steel, {log: true, from: this.name});
      player.stock.deduct(Resource.TITANIUM, player.stock.titanium, {log: true, from: this.name});
    });
    const players = game.getPlayers().slice().sort(
      (p1, p2) => turmoil.getPlayerInfluence(p2) - turmoil.getPlayerInfluence(p1),
    );
    const score = turmoil.getPlayerInfluence(players[0]);
    while (players.length > 0 && turmoil.getPlayerInfluence(players[0]) === score) {
      players[0].stock.add(Resource.MEGACREDITS, 6, {log: true, from: this.name});
      players.shift();
    }
  }
}

================
File: cards/chemical/globalevents/VenusianEcosystems.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {AddResourcesToCard} from '../../../deferredActions/AddResourcesToCard';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.venus(1).nbsp.wild(1, {secondaryTag: Tag.VENUS}).slash().influence();
});

export class VenusianEcosystems extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.VENUSIAN_ECOSYSTEMS,
      description: 'Raise Venus 1 step. Add any Venus resource for each influence to a card.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.increaseVenusScaleLevel(game.getPlayersInGenerationOrder()[0], 1);
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        game.defer(new AddResourcesToCard(player, undefined, {count: amount, restrictedTag: Tag.VENUS}));
      }
    });
  }
}

================
File: cards/chemical/globalevents/VenusMining.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.titanium(1).slash().tag(Tag.VENUS).influence({size: Size.SMALL});
});

export class VenusMining extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.VENUS_MINING,
      description: 'Gain 1 titanium for each Venus tag you have (max 5) and influence.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(5, player.tags.count(Tag.VENUS, 'raw')) + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.TITANIUM, amount, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/globalevents/WildfiresEvent.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {TileType} from '../../../../common/TileType';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().plants(1).slash().greenery().nbsp.heat(2).slash().influence();
});

export class WildfiresEvent extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.WILDFIRES,
      description: 'Lose 1 plant for each greenery tile you own (max 5). Gain 2 heat per influence.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const greeneryTiles = game.board.spaces.filter((space) => space.player === player && space.tile?.tileType === TileType.GREENERY).length;
      player.stock.deduct(Resource.PLANTS, Math.min(greeneryTiles, player.plants), {log: true, from: this.name});
      player.stock.add(Resource.HEAT, turmoil.getPlayerInfluence(player) * 2, {log: true, from: this.name});
    });
  }
}

================
File: cards/chemical/pathfinders/PublicSpaceline.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class PublicSpacelineChemical extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PUBLIC_SPACELINE_CHEMICAL,
      cost: 18,
      tags: [Tag.EARTH, Tag.EARTH, Tag.JOVIAN, Tag.JOVIAN, Tag.VENUS, Tag.VENUS, Tag.MARS, Tag.MARS],

      requirements: {tag: Tag.SPACE, count: 5},

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'U770',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).br;
          b.plainText('Increase your M€ production 2 steps').br;
          b.tag(Tag.EARTH).tag(Tag.EARTH).tag(Tag.JOVIAN).tag(Tag.JOVIAN).br;
          b.tag(Tag.VENUS).tag(Tag.VENUS).tag(Tag.MARS).tag(Tag.MARS);
        }),
        description: 'Requires 5 space tags. This card has 2 Earth tags, 2 Jovian tags, 2 Venus tags, and 2 Mars tags.',
      },
    });
  }
}

================
File: cards/chemical/preludes/1_ResearchBase.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';

export class ResearchBase extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.RESEARCH_BASE,
      tags: [Tag.SCIENCE, Tag.CITY],

      behavior: {
        city: {},
        drawCard: 2,
      },
      startingMegacredits: -3,

      metadata: {
        cardNumber: 'xP1',
        renderData: CardRenderer.builder((b) => {
          b.city().nbsp.megacredits(-3).nbsp.cards(2);
        }),
        description: 'Place a city tile, lose 3 M€, and draw 2 cards.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer) {
    return player.canAfford(3);
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 3));
    return undefined;
  }
}

================
File: cards/chemical/preludes/10_WildlifeSponsors.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {AltSecondaryTag} from '../../../../common/cards/render/AltSecondaryTag';

export class WildlifeSponsors extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.WILDLIFE_SPONSORS,
      tags: [Tag.ANIMAL],

      behavior: {
        production: {megacredits: 3},
      },

      metadata: {
        cardNumber: 'xP11',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(3)).nbsp.cards(2, {secondaryTag: AltSecondaryTag.ANIMAL}).asterix();
        }),
        description: 'Increase your M€ production 3 steps and draw 2 cards with animal icons or tags.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const found: Array<CardName> = [];
    player.game.projectDeck.drawPile.forEach((card) => {
      const string = card.metadata.renderData !== undefined ? JSON.stringify(card.metadata.renderData) : '';
      if (string.includes('animals') || card.tags.includes(Tag.ANIMAL)) {
        found.push(card.name);
      }
      return undefined;
    });
    player.drawCard(2, {
      include: (card) => found.includes(card.name),
    });
    return undefined;
  }
}

================
File: cards/chemical/preludes/11_BlueprintAI.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class BlueprintAI extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.BLUEPRINT_AI,

      behavior: {
        production: {megacredits: 1},
        drawCard: {count: 2, tag: Tag.BUILDING},
      },

      cardDiscount: {tag: Tag.BUILDING, amount: 2},
      metadata: {
        cardNumber: 'xP11',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an building card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.BUILDING).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => pb.megacredits(1)).nbsp.cards(2, {secondaryTag: Tag.BUILDING});
        }),
        description: 'Increase your M€ production 1 step and draw 2 cards with building tags.',
      },
    });
  }
}

================
File: cards/chemical/preludes/12_Bioplastics.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {ActivePreludeCard} from '../../prelude2/ActivePreludeCard';
import {IProjectCard} from '../../IProjectCard';

export class Bioplastics extends ActivePreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.BIOPLASTICS,
      tags: [Tag.MICROBE],

      behavior: {
        production: {steel: 2},
        stock: {steel: 2, plants: 2},
      },

      metadata: {
        cardNumber: 'xP12',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(2)).br;
          b.steel(2).plants(2);
        }),
        description: 'Increase your steel production 2 steps, gain 2 steel, and gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/preludes/13_InfrastructureSupport.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {Tag} from '../../../../common/cards/Tag';

export class InfrastructureSupport extends PreludeCard {
  constructor() {
    super({
      name: CardName.INFRASTRUCTURE_SUPPORT,
      tags: [Tag.BUILDING],

      behavior: {
        stock: {steel: 3},
        production: {megacredits: 2, steel: 1},
      },

      metadata: {
        cardNumber: 'xP13',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2).steel(1)).steel(3);
        }),
        description: 'Increase your M€ production 1 step and you steel production 1 step. Gain 3 steel.',
      },
    });
  }
}

================
File: cards/chemical/preludes/14_IndustryAllies.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {IProjectCard} from '../../IProjectCard';
import { PreludeCard } from '../../prelude/PreludeCard';

export class IndustryAllies extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.INDUSTRY_ALLIES,
      tags: [Tag.BUILDING, Tag.BUILDING],

      behavior: {
        production: {steel: 1, energy: 1, heat: 1},
      },

      metadata: {
        cardNumber: 'xP14',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(1).energy(1).heat(1));
        }),
        description: 'Increase your steel, energy, and heat productions 1 step each.',
      },
    });
  }
}

================
File: cards/chemical/preludes/15_NuclearFuelMining.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {Tag} from '../../../../common/cards/Tag';
import {IProjectCard} from '../../IProjectCard';
import {IPlayer} from '../../../IPlayer';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';

export class NuclearFuelMining extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.NUCLEAR_FUEL_MINING,
      tags: [Tag.EARTH],

      behavior: {
        production: {steel: 1, energy: 2},
      },
      startingMegacredits: -2,

      metadata: {
        cardNumber: 'xP15',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(1).energy(2)).megacredits(-2);
        }),
        description: 'Increase your steel production 1 step and your energy production 2 steps. Lose 2 M€.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer) {
    return player.canAfford(2);
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 2));
    return undefined;
  }
}

================
File: cards/chemical/preludes/16_LunarMiningIndustries.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class LunarMiningIndustries extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNAR_MINING_INDUSTRIES,
      tags: [Tag.EARTH],

      behavior: {
        production: {titanium: 1},
        stock: {steel: 2},
      },

      cardDiscount: {tag: Tag.EARTH, amount: 3},
      metadata: {
        cardNumber: 'xP16',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an Earth card, you pay 3 M€ less for it.', (eb) => {
            eb.tag(Tag.EARTH).startEffect.megacredits(-3);
          }).br;
          b.production((pb) => pb.titanium(1)).steel(2);
        }),
        description: 'Increase your titanium production 1 step and gain 2 steel.',
      },
    });
  }
}

================
File: cards/chemical/preludes/17_LaserMining.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class LaserMining extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.LASER_MINING,
      tags: [Tag.SCIENCE],

      behavior: {
        production: {titanium: 1, heat: 1},
        stock: {heat: 3},
      },

      metadata: {
        cardNumber: 'xP17',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1).heat(1)).heat(3);
        }),
        description: 'Increase your titanium production 1 step and your heat production 1 step. Gain 3 heat.',
      },
    });
  }
}

================
File: cards/chemical/preludes/18_CyanobacteriaPods.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class CyanobacteriaPods extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.CYANOBACTERIA_PODS,
      tags: [Tag.MICROBE],

      behavior: {
        production: {plants: 2},
      },

      cardDiscount: {tag: Tag.MICROBE, amount: 2},
      metadata: {
        cardNumber: 'xP18',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a microbe card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.MICROBE).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => pb.plants(2));
        }),
        description: 'Increase your plant production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/preludes/19_GlacialAlgae.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class GlacialAlgae extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.GLACIAL_ALGAE,
      tags: [Tag.PLANT],

      behavior: {
        ocean: {},
        production: {plants: 1},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'xP19',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).production((pb) => pb.plants(1)).plants(2);
        }),
        description: 'Place an ocean tile, increase your plant production 1 step, and gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/preludes/2_HeavyMetalComet.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';

export class HeavyMetalComet extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.HEAVY_METAL_COMET,

      behavior: {
        stock: {steel: 3},
        ocean: {},
        global: {temperature: 1},
      },

      metadata: {
        cardNumber: 'xP2',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1).oceans(1).steel(3);
        }),
        description: 'Raise the temperature 1 step, place an ocean tile, and gain 3 steel.',
      },
    });
  }
}

================
File: cards/chemical/preludes/20_AmmoniaAsteroid.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';

export class AmmoniaAsteroid extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.AMMONIA_ASTEROID,

      behavior: {
        global: {temperature: 1},
        production: {plants: 1, heat: 2},
      },

      metadata: {
        cardNumber: 'xP20',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1).production((pb) => pb.plants(1).heat(2));
        }),
        description: 'Raise the temperature 1 step. Increase your plant production 1 step and your heat production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/preludes/21_AdaptedVascularGreenery.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class AdaptedVascularGreenery extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.ADAPTED_VASCULAR_GREENERY,
      tags: [Tag.PLANT],

      behavior: {
        production: {plants: 1},
        stock: {plants: 3},
        global: {oxygen: 1},
      },

      cardDiscount: {tag: Tag.PLANT, amount: 2},
      metadata: {
        cardNumber: 'xP21',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a plant card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.PLANT).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => pb.plants(1)).plants(3).oxygen(1);
        }),
        description: 'Increase your plant production 1 step, gain 3 plants, and raise the oxygan 1 step.',
      },
    });
  }
}

================
File: cards/chemical/preludes/22_EcologicalReserve.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';

export class EcologicalReserve extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.ECOLOGICAL_RESERVE,
      tags: [Tag.ANIMAL],
      victoryPoints: {resourcesHere: {}, per: 2},
      resourceType: CardResource.ANIMAL,

      behavior: {
        production: {plants: 1},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'xP22',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an animal or plant tag, including this, add an animal to this card.', (eb) => {
            eb.tag(Tag.ANIMAL).slash().tag(Tag.PLANT).startEffect.resource(CardResource.ANIMAL);
          }).br;
          b.vpText('1 VP per 2 animals on this card.').br;
          b.production((pb) => pb.plants(1)).plants(2);
        }),
        description: 'Increase your plant production 1 step and gain 2 plants.',
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const qty = player.tags.cardTagCount(card, [Tag.ANIMAL, Tag.PLANT]);
    player.addResourceTo(this, {qty, log: true});
  }
}

================
File: cards/chemical/preludes/23_ProtistLifeforms.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {ActivePreludeCard} from '../../prelude2/ActivePreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardResource} from '../../../../common/CardResource';

export class ProtistLifeforms extends ActivePreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.PROTIST_LIFEFORMS,
      tags: [Tag.MICROBE],
      victoryPoints: {resourcesHere: {}, per: 3},
      resourceType: CardResource.MICROBE,

      action: {
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 1},
      },

      behavior: {
        production: {plants: 1},
        drawCard: {count: 1, tag: Tag.MICROBE},
      },

      metadata: {
        cardNumber: 'xP23',
        renderData: CardRenderer.builder((b) => {
          b.action('Add a microbe to ANY card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE).asterix();
          }).br;
          b.vpText('1 VP per 3 Microbes on this card.').br;
          b.production((pb) => pb.plants(1)).nbsp.cards(1, {secondaryTag: Tag.MICROBE});
        }),
        description: 'Increase your plant production 1 step and draw a card with a microbe tag.',
      },
    });
  }
}

================
File: cards/chemical/preludes/24_PowerCore.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';

export class PowerCore extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.POWER_CORE,
      tags: [Tag.POWER],

      behavior: {
        production: {energy: 2},
        stock: {energy: 4},
        optionalEnergyConversion: true,
      },

      metadata: {
        cardNumber: 'xP24',
        renderData: CardRenderer.builder((b) => {
          b.text('EFFECT: CONVERTING ENERGY TO HEAT DURING PRODUCTION IS OPTIONAL FOR EACH ENERGY RESOURCE.', Size.SMALL).br;
          b.production((pb) => pb.energy(2)).br.energy(4);
        }),
        description: 'Increase your energy production 2 steps and gain 4 energy.',
      },
    });
  }
}

================
File: cards/chemical/preludes/25_EnergyBeam.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class EnergyBeam extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.ENERGY_BEAM,
      tags: [Tag.POWER],

      behavior: {
        production: {megacredits: -1, energy: 2, heat: 2},
      },

      metadata: {
        cardNumber: 'xP25',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(-1).energy(2).heat(2));
        }),
        description: 'Decrease your M€ production 1 step. Increase your energy production 2 steps and your heat production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/preludes/26_ThermalPlant.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class ThermalPlant extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.THERMAL_PLANT,
      tags: [Tag.POWER, Tag.BUILDING],

      behavior: {
        production: {energy: 1, heat: 2},
        stock: {megacredits: 5},
      },
      startingMegacredits: 5,

      metadata: {
        cardNumber: 'xP26',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).heat(2)).megacredits(5);
        }),
        description: 'Increase your energy production 1 step and your heat production 2 steps. Gain 5 M€',
      },
    });
  }
}

================
File: cards/chemical/preludes/27_AdvancedHeatingTech.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {AltSecondaryTag} from '../../../../common/cards/render/AltSecondaryTag';

export class AdvancedHeatingTech extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.ADVANCED_HEATING_TECH,

      behavior: {
        production: {heat: 3},
      },

      metadata: {
        cardNumber: 'xP27',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(3)).nbsp.cards(2, {secondaryTag: AltSecondaryTag.HEAT});
        }),
        description: 'Increase your heat production 3 steps and draw 2 cards with heat icons.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const found: Array<CardName> = [];
    player.game.projectDeck.drawPile.forEach((card) => {
      const string = card.metadata.renderData !== undefined ? JSON.stringify(card.metadata.renderData) : '';
      if (string.includes('heat')) {
        found.push(card.name);
      }
      return undefined;
    });
    player.drawCard(2, {
      include: (card) => found.includes(card.name),
    });
    return undefined;
  }
}

================
File: cards/chemical/preludes/28_TerritoryOccupation.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IPlayer} from '../../../IPlayer';
import {SelectSpace} from '../../../inputs/SelectSpace';
import {LogHelper} from '../../../LogHelper';
import {IProjectCard} from '../../IProjectCard';
import {BoardType} from '../../../boards/BoardType';
import {Space} from '../../../boards/Space';
import {Resource} from '../../../../common/Resource';
import {Size} from '../../../../common/cards/render/Size';

export class TerritoryOccupation extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.TERRITORY_OCCUPATION,

      behavior: {
        stock: {steel: 2, plants: 2},
      },

      metadata: {
        cardNumber: 'xP04',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you place a tile, gain 2 M€.', (b) => {
            b.emptyTile('normal', {size: Size.SMALL}).startEffect.megacredits(2);
          }).br;
          b.text('3').community().nbsp.steel(2).plants(2);
        }),
        description: 'Place 3 of your player markers on unreserved areas, only you may place tiles there. Gain 2 steel and 2 plants.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.game.board.getNonReservedLandSpaces().length >= 3;
  }
  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select first space for claim', player.game.board.getNonReservedLandSpaces()).andThen((space) => {
      space.player = player;
      LogHelper.logBoardTileAction(player, space, 'land claim');
      return new SelectSpace('Select second space for claim', player.game.board.getNonReservedLandSpaces()).andThen((space) => {
        space.player = player;
        LogHelper.logBoardTileAction(player, space, 'land claim');
        return new SelectSpace('Select third space for claim', player.game.board.getNonReservedLandSpaces()).andThen((space) => {
          space.player = player;
          LogHelper.logBoardTileAction(player, space, 'land claim');
          return undefined;
        });
      });
    });
  }
  onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, _space: Space, _boardType: BoardType): void {
    if (activePlayer.id === cardOwner.id) {
      cardOwner.stock.add(Resource.MEGACREDITS, 2, {log: true});
    }
  }
}

================
File: cards/chemical/preludes/29_RareMineralReserve.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {digit} from '../../Options';

export class RareMineralReserve extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.RARE_MINERAL_RESERVE,

      behavior: {
        stock: {steel: 4, titanium: 6},
      },

      metadata: {
        cardNumber: 'xP29',
        renderData: CardRenderer.builder((b) => {
          b.steel(4, {digit}).nbsp.titanium(6, {digit});
        }),
        description: 'Gain 4 steel and 6 titanium.',
      },
    });
  }
}

================
File: cards/chemical/preludes/3_LegalExperts.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {all} from '../../Options';

export class LegalExperts extends PreludeCard {
  constructor() {
    super({
      name: CardName.LEGAL_EXPERTS,
      tags: [Tag.EARTH],

      behavior: {
        stock: {megacredits: 14},
      },
      startingMegacredits: 14,

      metadata: {
        cardNumber: 'xP3',
        renderData: CardRenderer.builder((b) => {
          b.effect('When ANOTHER PLAYER removes your resources or lowers your production, steal 3 M€ from THAT PLAYER.',
            (eb) => eb.minus().wild(1).slash().production((pb) => pb.wild(1)).startEffect.text('Steal ').megacredits(3, {all}).asterix()).br;
          b.megacredits(14);
        }),
        description: 'Gain 14 M€.',
      },
    });
  }
}

================
File: cards/chemical/preludes/30_CorporateEspionage.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IPreludeCard, isPreludeCard} from '../../prelude/IPreludeCard';
import {IPlayer} from '../../../IPlayer';
import {PreludesExpansion} from '../../../preludes/PreludesExpansion';
import {PlayerInput} from '../../../PlayerInput';
import {all} from '../../Options';

export class CorporateEspionage extends PreludeCard implements IPreludeCard {
  constructor() {
    super({
      name: CardName.CORPORATE_ESPIONAGE,

      metadata: {
        cardNumber: 'xP30',
        renderData: CardRenderer.builder((b) => {
          b.text('COPY').nbsp.prelude({all}).asterix();
        }),
        description: 'As your first action, copy the direct effects of an opponent\'s prelude. SOLO: As your first action, draw 2 prelude cards. Play 1, and discard the other.',
      },
    });
  }
  initialAction(player: IPlayer): PlayerInput | undefined {
    const game = player.game;
    if (player.game.isSoloMode()) {
      const cards = [
        game.preludeDeck.drawOrThrow(player.game),
        game.preludeDeck.drawOrThrow(player.game),
      ];
      return PreludesExpansion.playPrelude(player, cards);
    }
    const opponentsPreludes: Array<IPreludeCard> = [];
    game.getPlayers().filter((p) => p.id !== player.id).forEach((p) => {
      p.playedCards.filter(isPreludeCard).filter((card) => card.canPlay(player)).forEach((prelude) => {
        opponentsPreludes.push(prelude);
      });
    });
    return PreludesExpansion.playPrelude(player, opponentsPreludes, 'action-only');
  }
}

================
File: cards/chemical/preludes/31_VenusFirstChemical.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class VenusFirstChemical extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.VENUS_FIRST_CHEMICAL,
      tags: [Tag.VENUS],

      behavior: {
        global: {venus: 2},
        drawCard: {count: 2, tag: Tag.VENUS},
      },

      metadata: {
        cardNumber: 'xP31',
        renderData: CardRenderer.builder((b) => {
          b.venus(2).cards(2, {secondaryTag: Tag.VENUS});
        }),
        description: 'Raise Venus 2 steps and draw 2 cards with Venus tags.',
      },
    });
  }
}

================
File: cards/chemical/preludes/32_AirScrappingOperations.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class AirScrappingOperations extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.AIR_SCRAPPING_OPERATIONS,
      tags: [Tag.VENUS],

      behavior: {
        global: {venus: 2},
        stock: {megacredits: 8},
      },

      metadata: {
        cardNumber: 'xP32',
        renderData: CardRenderer.builder((b) => {
          b.effect('The Air Scrapping standard project costs you 3 M€ less.', (eb) => {
            eb.venus(1).asterix().startEffect.megacredits(-3);
          }).br;
          b.venus(2).megacredits(8);
        }),
        description: 'Raise Venus 2 steps and gain 8 M€.',
      },
    });
  }
  // effect handled in the air scrapping standard project file
}

================
File: cards/chemical/preludes/33_TerrestrialPlanetMission.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class TerrestrialPlanetMission extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.TERRESTRIAL_PLANET_MISSION,

      behavior: {
        global: {venus: 1},
        drawCard: {count: 1, tag: Tag.VENUS},
        ocean: {},
      },

      metadata: {
        cardNumber: 'xP33',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).oceans(1).cards(1, {secondaryTag: Tag.VENUS});
        }),
        description: 'Raise Venus 1 step, place an ocean tile, and draw a card with a Venus tag.',
      },
    });
  }
}

================
File: cards/chemical/preludes/34_HydrogenBombardmentChemical.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class HydrogenBombardmentChemical extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.HYDROGEN_BOMBARDMENT_CHEMICAL,
      tags: [Tag.JOVIAN],

      behavior: {
        global: {venus: 1},
        production: {titanium: 1},
        stock: {megacredits: 5},
      },

      metadata: {
        cardNumber: 'xP34',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).production((pb) => pb.titanium(1)).megacredits(5);
        }),
        description: 'Raise Venus 1 step, increase your titanium production 1 step, and gain 5 M€.',
      },
    });
  }
}

================
File: cards/chemical/preludes/35_ExperimentalOrganisms.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {ActivePreludeCard} from '../../prelude2/ActivePreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardResource} from '../../../../common/CardResource';

export class ExperimentalOrganisms extends ActivePreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.EXPERIMENTAL_ORGANISMS,
      tags: [Tag.MICROBE, Tag.VENUS],
      victoryPoints: {resourcesHere: {}, per: 3},
      resourceType: CardResource.MICROBE,

      action: {
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 1},
      },

      behavior: {
        production: {plants: 1},
        global: {venus: 1},
      },

      metadata: {
        cardNumber: 'xP35',
        renderData: CardRenderer.builder((b) => {
          b.action('Add a microbe to ANY card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE).asterix();
          }).br;
          b.vpText('1 VP per 3 Microbes on this card.').br;
          b.venus(1).production((pb) => pb.plants(1));
        }),
        description: 'Raise Venus 1 step and increase your plant production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/preludes/36_VenusianIndustries.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {ActivePreludeCard} from '../../prelude2/ActivePreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardResource} from '../../../../common/CardResource';

export class VenusianIndustries extends ActivePreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.VENUSIAN_INDUSTRIES,
      tags: [Tag.POWER, Tag.VENUS],

      action: {
        or: {
          behaviors: [{
            stock: {megacredits: 2},
            title: 'Gain 2 M€',
          },
          {
            addResourcesToAnyCard: {type: CardResource.FLOATER, count: 1},
            title: 'Add a floater to ANY card.',
          }],
          autoSelect: true,
        },
      },

      behavior: {
        production: {energy: 1},
        global: {venus: 1},
      },

      metadata: {
        cardNumber: 'xP38',
        renderData: CardRenderer.builder((b) => {
          b.action('Add a floater to ANY card or gain 2 M€.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER).asterix().slash().megacredits(2);
          }).br;
          b.venus(1).production((pb) => pb.energy(1));
        }),
        description: 'Raise Venus 1 step and increase your energy production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/preludes/37_VenusGHGExports.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {all} from '../../Options';
import {IPlayer} from '../../../IPlayer';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';

export class VenusGHGExports extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.VENUS_GHG_EXPORTS,
      tags: [Tag.VENUS],

      behavior: {
        global: {venus: 1},
        production: {heat: 3},
        // player.cardIsInEffect() doesn't want to trigger until the turn after the card is played
        stock: {heat: 2},
      },
      startingMegacredits: -3,

      metadata: {
        cardNumber: 'xP37',
        renderData: CardRenderer.builder((b) => {
          b.effect('Whenever Venus is terraformed, gain 2 heat.', (eb) => {
            eb.venus(1, {all}).startEffect.heat(2);
          }).br;
          b.venus(1).production((pb) => pb.heat(3)).megacredits(-3);
        }),
        description: 'Raise Venus 1 step, increase your heat production 3 steps, and lose 3 M€.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer) {
    return player.canAfford(3);
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 3));
    return undefined;
  }
}

================
File: cards/chemical/preludes/38_SisterPlanetResearch.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class SisterPlanetResearch extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.SISTER_PLANET_RESEARCH,

      behavior: {
        production: {megacredits: 1},
        drawCard: {count: 3, tag: Tag.VENUS},
      },

      cardDiscount: {tag: Tag.VENUS, amount: 2},
      metadata: {
        cardNumber: 'xP38',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a Venus card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.VENUS).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => pb.megacredits(1)).nbsp.cards(3, {secondaryTag: Tag.VENUS});
        }),
        description: 'Increase your M€ production 1 step and draw 3 cards with Venus tags.',
      },
    });
  }
}

================
File: cards/chemical/preludes/39_FloatingCity.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {ActivePreludeCard} from '../../prelude2/ActivePreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardResource} from '../../../../common/CardResource';
import {AltSecondaryTag} from '../../../../common/cards/render/AltSecondaryTag';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';

export class FloatingCity extends ActivePreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.FLOATING_CITY,
      tags: [Tag.VENUS],
      victoryPoints: {resourcesHere: {}, per: 3},
      resourceType: CardResource.FLOATER,

      action: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2},
      },

      metadata: {
        cardNumber: 'xP39',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 2 floaters to ANY card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER, 2).asterix();
          }).br;
          b.vpText('1 VP per 3 Floaters on this card.').br;
          b.cards(2, {secondaryTag: AltSecondaryTag.FLOATER});
        }),
        description: 'Draw 2 cards with floater icons.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const found: Array<CardName> = [];
    player.game.projectDeck.drawPile.forEach((card) => {
      const string = card.metadata.renderData !== undefined ? JSON.stringify(card.metadata.renderData) : '';
      if (string.includes('floaters') || card.requirements?.some((req) => req.floaters !== undefined)) {
        found.push(card.name);
      }
      return undefined;
    });
    player.drawCard(2, {
      include: (card) => found.includes(card.name),
    });
    return undefined;
  }
}

================
File: cards/chemical/preludes/4_MaterialLoan.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {digit} from '../../Options';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {ALL_RESOURCES} from '../../../../common/Resource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {Resource} from '../../../../common/Resource';

export class MaterialLoan extends PreludeCard {
  constructor() {
    super({
      name: CardName.MATERIAL_LOAN,

      behavior: {
        stock: {megacredits: 19},
      },
      startingMegacredits: 19,

      metadata: {
        cardNumber: 'xP4',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().wild(1)).nbsp.plus().wild(5, {digit}).asterix().nbsp.megacredits(19);
        }),
        description: 'Decrease any production 1 step to gain 5 of the SAME TYPE of resource. Gain 19 M€.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const orOptions = new OrOptions();

    ALL_RESOURCES.forEach((resource) => {
      if (player.production.get(resource) > (resource === Resource.MEGACREDITS ? -5 : 0)) {
        orOptions.options.push(new SelectOption('Lower ' + resource + ' production 1 step and gain 5 ' + resource, 'Select').andThen( () => {
          player.production.add(resource, -1, {log: true});
          player.stock.add(resource, 5, {log: true});
          return undefined;
        }));
      }
    });

    return orOptions;
  }
}

================
File: cards/chemical/preludes/40_EarlyColony.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class EarlyColony extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.EARLY_COLONY,
      tags: [Tag.SPACE],

      behavior: {
        colonies: {buildColony: {}},
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'xP40',
        renderData: CardRenderer.builder((b) => {
          b.colonies(1).nbsp.production((pb) => pb.megacredits(1));
        }),
        description: 'Place a colony and increase your M€ production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/preludes/41_IsolatedEcologyResearch.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';

export class IsolatedEcologyResearch extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.ISOLATED_ECOLOGY_RESEARCH,
      tags: [Tag.PLANT, Tag.SPACE],

      behavior: {
        colonies: {buildColony: {}},
      },

      metadata: {
        cardNumber: 'xP44',
        renderData: CardRenderer.builder((b) => {
          b.effect('Each time you play a plant, animal or microbe tag, including this, gain 2 M€.', (be) => {
            be.tag(Tag.PLANT).slash().tag(Tag.ANIMAL).slash().tag(Tag.MICROBE);
            be.startEffect.megacredits(2);
          }).br;
          b.colonies(1);
        }),
        description: 'Place a colony.',
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const amount = player.tags.cardTagCount(card, [Tag.ANIMAL, Tag.PLANT, Tag.MICROBE]);
    if (amount > 0) {
      player.game.defer(
        new SimpleDeferredAction(player, () => {
          player.stock.add(Resource.MEGACREDITS, amount * 2, {log: true});
          return undefined;
        }),
      );
    }
  }
}

================
File: cards/chemical/preludes/42_JovianProjectBase.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class JovianProjectBase extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.JOVIAN_PROJECT_BASE,
      tags: [Tag.SPACE],

      behavior: {
        colonies: {buildColony: {}},
        drawCard: {count: 1, tag: Tag.JOVIAN},
      },

      metadata: {
        cardNumber: 'xP42',
        renderData: CardRenderer.builder((b) => {
          b.colonies(1).nbsp.cards(1, {secondaryTag: Tag.JOVIAN});
        }),
        description: 'Place a colony and draw a card with a Jovian tag.',
      },
    });
  }
}

================
File: cards/chemical/preludes/43_InterplanetaryTradingPort.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';

export class InterplanetaryTradingPort extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.INTERPLANETARY_TRADING_PORT,
      tags: [Tag.SPACE],

      behavior: {
        colonies: {buildColony: {}, addTradeFleet: 1},
      },

      metadata: {
        cardNumber: 'xP43',
        renderData: CardRenderer.builder((b) => {
          b.colonies(1).tradeFleet();
        }),
        description: 'Place a colony and gain a trade fleet.',
      },
    });
  }
}

================
File: cards/chemical/preludes/44_TradingNetwork.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {ColoniesHandler} from '../../../colonies/ColoniesHandler';
import {Size} from '../../../../common/cards/render/Size';

export class TradingNetwork extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.TRADING_NETWORK,

      behavior: {
        production: {megacredits: 2},
        colonies: {tradeOffset: 1},
      },

      metadata: {
        cardNumber: 'xP44',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you trade, you may first increase that Colony Tile track 1 step.', (eb) => {
            eb.trade().startEffect.text('+1', Size.LARGE);
          }).br;
          b.production((pb) => pb.megacredits(2)).nbsp.colonyTile();
        }),
        description: 'Increase your M€ production 2 steps and put an additional colony tile of your choice in play.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    ColoniesHandler.addColonyTile(player, {title: 'Select colony tile to add'});
    return undefined;
  }
}

================
File: cards/chemical/preludes/45_GasMine.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {ActivePreludeCard} from '../../prelude2/ActivePreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardResource} from '../../../../common/CardResource';

export class GasMine extends ActivePreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.GAS_MINE,
      tags: [Tag.JOVIAN],

      action: {
        or: {
          behaviors: [{
            stock: {heat: 2},
            title: 'Gain 2 heat',
          },
          {
            addResourcesToAnyCard: {type: CardResource.FLOATER, count: 1},
            title: 'Add a floater to ANY card.',
          }],
          autoSelect: true,
        },
      },

      behavior: {
        production: {megacredits: 2},
        stock: {megacredits: 4},
      },

      metadata: {
        cardNumber: 'xP45',
        renderData: CardRenderer.builder((b) => {
          b.action('Add a floater to ANY card or gain 2 heat.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER).asterix().slash().heat(2);
          }).br;
          b.production((pb) => pb.megacredits(2)).nbsp.megacredits(4);
        }),
        description: 'Increase your M€ production 2 steps and gain 4 M€.',
      },
    });
  }
}

================
File: cards/chemical/preludes/46_PhobosSpacePort.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
export class PhobosSpacePort extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.PHOBOS_SPACE_PORT,
      tags: [Tag.SPACE],

      behavior: {
        production: {titanium: 1},
        colonies: {addTradeFleet: 1},
      },

      cardDiscount: {tag: Tag.SPACE, amount: 2},
      metadata: {
        cardNumber: 'xP46',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => pb.titanium(1)).nbsp.tradeFleet();
        }),
        description: 'Increase your titanium production 1 step and gain a trade fleet.',
      },
    });
  }
}

================
File: cards/chemical/preludes/47_TitanSettlement.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {Tag} from '../../../../common/cards/Tag';
import {AltSecondaryTag} from '../../../../common/cards/render/AltSecondaryTag';

export class TitanSettlement extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.TITAN_SETTLEMENT,
      tags: [Tag.JOVIAN],

      behavior: {
        production: {titanium: 1},
      },

      metadata: {
        cardNumber: 'xP47',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).cards(2, {secondaryTag: AltSecondaryTag.FLOATER});
        }),
        description: 'Increase your titanium production 1 step. Draw 2 cards with floater icons.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const found: Array<CardName> = [];
    player.game.projectDeck.drawPile.forEach((card) => {
      const string = card.metadata.renderData !== undefined ? JSON.stringify(card.metadata.renderData) : '';
      if (string.includes('floaters') || card.requirements?.some((req) => req.floaters !== undefined)) {
        found.push(card.name);
      }
      return undefined;
    });
    player.drawCard(2, {
      include: (card) => found.includes(card.name),
    });
    return undefined;
  }
}

================
File: cards/chemical/preludes/48_TradeInfrastructure.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';

export class TradeInfrastructure extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.TRADE_INFRASTRUCTURE,

      behavior: {
        stock: {energy: 4},
        colonies: {addTradeFleet: 1, tradeDiscount: 1},
      },

      metadata: {
        cardNumber: 'xP48',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you trade, you pay 1 less resource for it.', (eb) => {
            eb.trade().startEffect.tradeDiscount(1);
          }).br;
          b.tradeFleet().energy(4);
        }),
        description: 'Gain a trade fleet and 4 energy.',
      },
    });
  }
}

================
File: cards/chemical/preludes/5_ResearchLoan.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {Tag} from '../../../../common/cards/Tag';

export class ResearchLoan extends PreludeCard {
  constructor() {
    super({
      name: CardName.RESEARCH_LOAN,
      tags: [Tag.SCIENCE],

      behavior: {
        stock: {megacredits: 15},
        production: {megacredits: -1},
        drawCard: {count: 1, tag: Tag.SCIENCE},
      },
      startingMegacredits: 15,

      metadata: {
        cardNumber: 'xP5',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().megacredits(1)).nbsp.megacredits(15).nbsp.cards(1, {secondaryTag: Tag.SCIENCE});
        }),
        description: 'Decrease your M€ production 1 step and Gain 15 M€. Reveal cards until you reveal a card with a science tag. Take it into your hand, discard the rest.',
      },
    });
  }
}

================
File: cards/chemical/preludes/6_EntertainmentIndustry.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IPlayer} from '../../../IPlayer';
import {IProjectCard} from '../../IProjectCard';
import {Resource} from '../../../../common/Resource';
import {Tag} from '../../../../common/cards/Tag';
import {PlayerInput} from '../../../PlayerInput';
import {CardType} from '../../../../common/cards/CardType';

export class EntertainmentIndustry extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.ENTERTAINMENT_INDUSTRY,
      tags: [Tag.EARTH],

      behavior: {
        stock: {megacredits: 4},
        production: {megacredits: 2},
      },
      startingMegacredits: 4,

      metadata: {
        cardNumber: 'xP6',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an event card, gain 2 M€.', (b) => {
            b.tag(Tag.EVENT).startEffect.megacredits(2);
          }).br;
          b.production((pb) => pb.megacredits(2)).nbsp.megacredits(4);
        }),
        description: 'Increase your M€ production 2 steps and gain 4 M€.',
      },
    });
  }
  onCardPlayed(player: IPlayer, card: IProjectCard): void | PlayerInput | undefined {
    if (card.type === CardType.EVENT) {
      player.stock.add(Resource.MEGACREDITS, 2, {log: true});
    }
  }
}

================
File: cards/chemical/preludes/7_CoerciveDealings.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IPlayer} from '../../../IPlayer';
import {IProjectCard} from '../../IProjectCard';
import {Resource} from '../../../../common/Resource';
import {PlayerInput} from '../../../PlayerInput';
import {all} from '../../Options';

export class CoerciveDealings extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.COERCIVE_DEALINGS,

      behavior: {
        stock: {megacredits: 10},
        production: {megacredits: 2},
      },
      startingMegacredits: 10,

      metadata: {
        cardNumber: 'xP7',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).nbsp.megacredits(10).nbsp.production((pb) => pb.megacredits(-1, {all})).asterix();
        }),
        description: 'Increase your M€ production 2 steps and gain 10 M€. Decrease ALL OPPONENT\'S M€ production 1 step.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    player.game.getPlayers().filter((p) => p.id !== player.id).forEach((opponent) => {
      opponent.production.add(Resource.MEGACREDITS, -1, {log: true});
    });
    return undefined;
  }
}

================
File: cards/chemical/preludes/8_AquaponicsFacility.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';

export class AquaponicsFacility extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.AQUAPONICS_FACILITY,
      tags: [Tag.ANIMAL, Tag.BUILDING],

      behavior: {
        stock: {megacredits: 3},
        production: {megacredits: 2},
        ocean: {},
      },
      startingMegacredits: 3,

      cardDiscount: {tag: Tag.ANIMAL, amount: 3},
      metadata: {
        cardNumber: 'xP8',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an animal card, you pay 3 M€ less for it.', (eb) => {
            eb.tag(Tag.ANIMAL).startEffect.megacredits(-3);
          }).br;
          b.production((pb) => pb.megacredits(2)).nbsp.megacredits(3).nbsp.oceans(1);
        }),
        description: 'Increase your M€ production 2 steps, gain 3 M€, and place an ocean tile.',
      },
    });
  }
}

================
File: cards/chemical/preludes/9_NoctisSettlement.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IPlayer} from '../../../IPlayer';
import {IProjectCard} from '../../IProjectCard';
import {Resource} from '../../../../common/Resource';
import {Board} from '../../../boards/Board';
import {all} from '../../Options';
import {Space} from '../../../boards/Space';
import {GainProduction} from '../../../deferredActions/GainProduction';
import {Priority} from '../../../deferredActions/Priority';
import {Tag} from '../../../../common/cards/Tag';

export class NoctisSettlement extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.NOCTIS_SETTLEMENT,
      tags: [Tag.BUILDING],

      behavior: {
        stock: {plants: 2},
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'xP9',
        renderData: CardRenderer.builder((b) => {
          b.effect('When a city tile is placed, including this, increase your M€ production 1 step.', (eb) => {
            eb.city({all}).startEffect.production((pb) => pb.megacredits(1));
          }).br;
          b.production((pb) => pb.megacredits(2)).plants(2);
        }),
        description: 'Increase your M€ production 2 steps and gain 2 plants.',
      },
    });
  }
  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (Board.isCitySpace(space)) {
      cardOwner.game.defer(
        new GainProduction(cardOwner, Resource.MEGACREDITS),
        cardOwner.id !== activePlayer.id ? Priority.OPPONENT_TRIGGER : undefined,
      );
    }
  }
}

================
File: cards/chemical/preludes/ByElectionChemical.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {IPlayer} from '../../../IPlayer';
import {IParty} from '../../../turmoil/parties/IParty';
import {Turmoil} from '../../../turmoil/Turmoil';
import {ChooseRulingPartyDeferred} from '../../../turmoil/ChooseRulingPartyDeferred';

export class ByElectionChemical extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.BY_ELECTION_CHEMICAL,

      behavior: {
        tr: 2,
        turmoil: {influenceBonus: 1},
      },

      metadata: {
        cardNumber: 'xP53',
        renderData: CardRenderer.builder((b) => {
          b.effect('You have +1 influence.', (be) => {
            be.startEffect.influence();
          }).br;
          b.rulingParty().chairman().delegates(2).asterix();
        }),
        description: 'Set the ruling party for this generation. Replace the neutral chairman with one of your own delegates and gain the associated TR. Place 2 delegates in the new ruling party.',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    Turmoil.ifTurmoil((game), (turmoil) => {
      game.defer(new ChooseRulingPartyDeferred(player, turmoil)).andThen((party: IParty) => {
        turmoil.delegateReserve.remove(player);
        turmoil.setNewChairman(player, game, false);
        turmoil.sendDelegateToParty(player, party.name, game);
        turmoil.sendDelegateToParty(player, party.name, game);
      });
    });
    return undefined;
  }
}

================
File: cards/chemical/preludes/CommitteeRepresentative.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {IPlayer} from '../../../IPlayer';
import {IAward} from '../../../awards/IAward';
import {SelectOption} from '../../../inputs/SelectOption';
import {message} from '../../../logs/MessageBuilder';
import {PlayerInput} from '../../../PlayerInput';
import {OrOptions} from '../../../inputs/OrOptions';

export class CommitteeRepresentative extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.COMMITTEE_REPRESENTATIVE,

      behavior: {
        tr: 2,
        turmoil: {sendDelegates: {count: 1}},
      },

      metadata: {
        cardNumber: 'xP52',
        renderData: CardRenderer.builder((b) => {
          b.tr(2).delegates(1).br.award();
        }),
        description: 'Raise your TR 2 steps, place a delegate, and fund an award for free.',
      },
    });
  }
  private selectAwardToFund(player: IPlayer, award: IAward): SelectOption {
    return new SelectOption(message('Fund ${0} award', (b) => b.award(award))).andThen(() => {
      player.game.fundAward(player, award);
      return undefined;
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const game = player.game;

    // Awards are disabled for 1 player games
    if (game.isSoloMode()) return;

    const freeAward = new OrOptions();
    freeAward.title = 'Select award to fund';
    freeAward.buttonLabel = 'Confirm';

    // If Vitor isn't going first and someone else funds awards, filter them out.
    const availableAwards = game.awards.filter((award) => !game.fundedAwards.map((fa) => fa.award).includes(award));
    freeAward.options = availableAwards.map((award) => this.selectAwardToFund(player, award));

    return freeAward;
  }
}

================
File: cards/chemical/preludes/ContractedIntelligenceAgency.ts
================
import {IPlayer} from '../../../IPlayer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Turmoil} from '../../../turmoil/Turmoil';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {message} from '../../../logs/MessageBuilder';
import {Size} from '../../../../common/cards/render/Size';

export class ContractedIntelligenceAgency extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.CONTRACTED_INTELLIGENCE_AGENCY,

      metadata: {
        cardNumber: 'xP55',
        renderData: CardRenderer.builder((b) => {
          b.action(undefined, (eb) => eb.empty().startAction.empty()).text('Action: Look at the top card and either buy it or discard it', Size.SMALL, true).br;
          b.text('3').globalEvent().asterix().nbsp.production((pb) => pb.megacredits(1));
        }),
        description: 'Draw 3 global events, and return them to the global events draw pile in any order you please. Increase your M€ production 1 step.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const turmoil = Turmoil.getTurmoil(player.game);
    const globalEvents: IGlobalEvent[] = [];

    for (let i = 0; i < 3; i++) {
      const event = turmoil.globalEventDealer.draw();
      if (event !== undefined) {
        globalEvents.push(event);
      }
    }

    player.game.defer(new SimpleDeferredAction(player, () => {
      return new OrOptions(
        ...globalEvents.map((event) => {
          // TODO(kberg): Render as SelectGlobalEvent
          const description = message('${0}: ${1} Neutral delegate added: ${2}', (b) => b.globalEvent(event).string(event.description).partyName(event.currentDelegate));
          return new SelectOption(description).andThen(() => {
            turmoil.currentGlobalEvent = event;
            turmoil.sendDelegateToParty('NEUTRAL', event.currentDelegate, player.game);

            globalEvents.forEach((ge) => {
              if (ge.name !== event.name) {
                turmoil.globalEventDealer.discard(ge);
              }
            });

            return undefined;
          });
        }),
      );
    }));
    return undefined;
  }
}

================
File: cards/chemical/preludes/CorporateAlliance.ts
================
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {Tag} from '../../../../common/cards/Tag';
import {ALL_RESOURCES} from '../../../../common/Resource';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';

export class CorporateAlliance extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.CORPORATE_ALLIANCE,
      tags: [Tag.EARTH],

      behavior: {
        turmoil: {sendDelegates: {count: 2, party: PartyName.UNITY}},
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'xP60',
        renderData: CardRenderer.builder((b) => {
          b.delegates(2).unity().production((pb) => pb.megacredits(1).wild(1));
        }),
        description: 'Place 2 delegates into Unity. Increase your M€ production 1 step and ANY production 1 step.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const orOptions = new OrOptions();

    ALL_RESOURCES.forEach((resource) => {
      orOptions.options.push(new SelectOption('Increase ' + resource + ' production 1 step', 'Select').andThen( () => {
        player.production.add(resource, 1, {log: true});
        return undefined;
      }),
      );
    });

    return orOptions;
  }
}

================
File: cards/chemical/preludes/ExecutiveOrderChemical.ts
================
import {IPlayer} from '../../../IPlayer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {SendDelegateToArea} from '../../../deferredActions/SendDelegateToArea';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';
import {Turmoil} from '../../../turmoil/Turmoil';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {message} from '../../../logs/MessageBuilder';

export class ExecutiveOrderChemical extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.EXECUTIVE_ORDER_CHEMICAL,

      metadata: {
        cardNumber: 'xP54',
        renderData: CardRenderer.builder((b) => {
          b.text('PLAY').globalEvent().asterix();
          b.br.br.br;
          b.delegates(2).megacredits(10).br.br;
        }),
        description: 'Draw 4 global events. Play 1 as the CURRENT GLOBAL EVENT and discard the rest. Place 2 delegates in any party. Gain 10 M€.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.stock.add(Resource.MEGACREDITS, 10, {log: true});
    const turmoil = Turmoil.getTurmoil(player.game);
    const globalEvents: IGlobalEvent[] = [];

    for (let i = 0; i < 4; i++) {
      const event = turmoil.globalEventDealer.draw();
      if (event !== undefined) {
        globalEvents.push(event);
      }
    }

    player.game.defer(new SimpleDeferredAction(player, () => {
      return new OrOptions(
        ...globalEvents.map((event) => {
          // TODO(kberg): Render as SelectGlobalEvent
          const description = message('${0}: ${1} Neutral delegate added: ${2}', (b) => b.globalEvent(event).string(event.description).partyName(event.currentDelegate));
          return new SelectOption(description).andThen(() => {
            turmoil.currentGlobalEvent = event;
            turmoil.sendDelegateToParty('NEUTRAL', event.currentDelegate, player.game);

            globalEvents.forEach((ge) => {
              if (ge.name !== event.name) {
                turmoil.globalEventDealer.discard(ge);
              }
            });

            return undefined;
          });
        }),
      );
    }));

    // This gets played -- after -- drawing the global event, so don't turn it into Behavior yet.
    player.game.defer(new SendDelegateToArea(player, 'Select where to send 2 delegates', {count: 2}));
    return undefined;
  }
}

================
File: cards/chemical/preludes/GreenMarsInitiative.ts
================
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {Tag} from '../../../../common/cards/Tag';

export class GreenMarsInitiative extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.GREEN_MARS_INITIATIVE,
      tags: [Tag.PLANT],

      behavior: {
        turmoil: {sendDelegates: {count: 2, party: PartyName.GREENS}},
        greenery: {},
      },

      metadata: {
        cardNumber: 'xP61',
        renderData: CardRenderer.builder((b) => {
          b.delegates(2).greens().nbsp.greenery();
        }),
        description: 'Place 2 delegates into Greens. Place a greenery tile and raise the oxygen 1 step.',
      },
    });
  }
}

================
File: cards/chemical/preludes/IntellectualistMovements.ts
================
import {IGlobalEvent} from '../../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IGame} from '../../../IGame';
import {Turmoil} from '../../../turmoil/Turmoil';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Tag} from '../../../../common/cards/Tag';
import {digit} from '../../Options';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.tag(Tag.SCIENCE, {amount: 5, digit}).influence({size: Size.SMALL}).colon().cards(2);
});

export class IntellectualistMovements extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.INTELLECTUALIST_MOVEMENTS,
      description: 'Draw 2 cards if you have 5 or more science tags. Influence counts as science tags.',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      if (player.tags.count(Tag.SCIENCE, 'raw') + turmoil.getPlayerInfluence(player) >= 5) {
        player.drawCard(2);
      }
    });
  }
}

================
File: cards/chemical/preludes/MartianRepublic.ts
================
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {Tag} from '../../../../common/cards/Tag';

export class MartianRepublic extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.MARTIAN_REPUBLIC,
      tags: [Tag.CITY, Tag.BUILDING],

      behavior: {
        turmoil: {sendDelegates: {count: 2, party: PartyName.MARS}},
        stock: {megacredits: 3},
        city: {},
      },
      startingMegacredits: 3,

      metadata: {
        cardNumber: 'xP58',
        renderData: CardRenderer.builder((b) => {
          b.delegates(2).marsFirst().city().megacredits(3);
        }),
        description: 'Place 2 delegates into Mars First, place a city tile, and gain 3 M€.',
      },
    });
  }
}

================
File: cards/chemical/preludes/PartyInsiders.ts
================
import {IPlayer} from '../../../IPlayer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Turmoil} from '../../../turmoil/Turmoil';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {SelectParty} from '../../../inputs/SelectParty';
import {digit} from '../../Options';

export class PartyInsiders extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.PARTY_INSIDERS,

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'xP56',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).nbsp.delegates(3, {digit}).asterix();
        }),
        description: 'Increase your M€ production 2 steps and place 3 delegates in SEPARATE PARTIES.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    const turmoil = Turmoil.getTurmoil(player.game);
    return turmoil.getAvailableDelegateCount(player) >= 3;
  }
  public override bespokePlay(player: IPlayer): undefined {
    const turmoil = Turmoil.getTurmoil(player.game);
    player.game.defer(new SimpleDeferredAction(player, () => new SelectParty('Select first party to add a delegate', 'add delegate', turmoil.parties.map((party) => party.name)).andThen((firstParty) => {
      turmoil.sendDelegateToParty(player, firstParty, player.game);
      return new SelectParty('Select second party to add a delegate', 'add delegate', turmoil.parties.map((party) => party.name).filter((party) => party !== firstParty)).andThen((secondParty) => {
        turmoil.sendDelegateToParty(player, secondParty, player.game);
        return new SelectParty('Select third party to add a delegate', 'add delegate', turmoil.parties.map((party) => party.name).filter((party) => party !== firstParty && party !== secondParty)).andThen((thirdParty) => {
          turmoil.sendDelegateToParty(player, thirdParty, player.game);
          return undefined;
        });
      });
    }),
    ));
    return undefined;
  }
}

================
File: cards/chemical/preludes/PoliticalUprisingChemical.ts
================
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class PoliticalUprisingChemical extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.POLITICAL_UPRISING_CHEMICAL,

      behavior: {
        turmoil: {sendDelegates: {count: 4, manyParties: true}},
        stock: {megacredits: 8},
      },

      metadata: {
        cardNumber: 'xP57',
        renderData: CardRenderer.builder((b) => {
          b.delegates(4).megacredits(8);
        }),
        description: 'Place 4 delegates and gain 8 M€.',
      },
    });
  }
}

================
File: cards/chemical/preludes/PreservationistCampaign.ts
================
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PartyName} from '../../../../common/turmoil/PartyName';

export class PreservationistCampaign extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.PRESERVATIONIST_CAMPAIGN,

      behavior: {
        turmoil: {sendDelegates: {count: 2, party: PartyName.REDS}},
        tr: -1,
        stock: {megacredits: 18},
      },
      startingMegacredits: 18,

      metadata: {
        cardNumber: 'xP61',
        renderData: CardRenderer.builder((b) => {
          b.delegates(2).reds().br;
          b.minus().tr(1).nbsp.megacredits(18);
        }),
        description: 'Place 2 delegates into Reds. Lower your TR 1 step and gain 18 M€.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Corp_ RecyclonRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {IPlayer} from '../../../IPlayer';
import {Tag} from '../../../../common/cards/Tag';
import {Resource} from '../../../../common/Resource';
import {CardResource} from '../../../../common/CardResource';
import {ICorporationCard} from '../../corporation/ICorporationCard';
import {ICard} from '../../ICard';
import {SelectOption} from '../../../inputs/SelectOption';
import {OrOptions} from '../../../inputs/OrOptions';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class RecyclonRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.RECYCLON_RB,
      tags: [Tag.MICROBE, Tag.BUILDING],
      startingMegaCredits: 40,
      resourceType: CardResource.MICROBE,

      behavior: {
        production: {steel: 2},
        addResources: 1,
      },

      metadata: {
        cardNumber: 'R26',
        description: 'You start with 40 M€ and 2 steel production.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(40).nbsp.production((pb) => pb.steel(2));
          b.corpBox('effect', (ce) => {
            ce.effect('When you play a building tag, including this, gain 1 microbe to this card, or remove 2 microbes here and raise your plant production 1 step.', (eb) => {
              eb.tag(Tag.BUILDING).colon().resource(CardResource.MICROBE).or();
              eb.resource(CardResource.MICROBE, {amount: 2, digit}).startEffect.production((pb) => pb.plants(1));
            });
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: ICard) {
    if (!player.isCorporation(this.name)) {
      return undefined;
    }

    if (card.tags.includes(Tag.BUILDING) === false || !player.isCorporation(this.name)) {
      return undefined;
    }
    if (this.resourceCount < 2) {
      player.addResourceTo(this);
      return undefined;
    }

    const addResource = new SelectOption('Add a microbe resource to this card', 'Add microbe').andThen(() => {
      player.addResourceTo(this);
      return undefined;
    });

    const spendResource = new SelectOption('Remove 2 microbes on this card and increase plant production 1 step', 'Remove microbes').andThen(() => {
      player.removeResourceFrom(this, 2);
      player.production.add(Resource.PLANTS, 1);
      return undefined;
    });
    return new OrOptions(spendResource, addResource);
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    return this.onCardPlayed(player, card);
  }
}

================
File: cards/chemical/rebalance/Corp_AphroditeRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';



export class AphroditeRebalanced extends CorporationCard {
  constructor() {
    super({
      name: CardName.APHRODITE_RB,
      tags: [Tag.PLANT, Tag.VENUS],
      startingMegaCredits: 50,

      behavior: {
        production: {plants: 2},
      },

      metadata: {
        cardNumber: 'R01',
        description: 'You start with 2 plant production and 50 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.production((pb) => pb.plants(2)).nbsp.megacredits(50);
          b.corpBox('effect', (ce) => {
            ce.effect('Whenever Venus is terraformed 1 step, you gain 3M€, and the player who raised it (NOT WGT) gains 2M€', (eb) => {
              eb.venus(1, {all}).startEffect.megacredits(3).asterix().megacredits(2);
            });
          });
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Corp_ArcadianCommunitiesRB.ts
================
import {IPlayer} from '../../../IPlayer';
import {CorporationCard} from '../../corporation/CorporationCard';
import {SelectSpace} from '../../../inputs/SelectSpace';
import {Space} from '../../../boards/Space';
import {IActionCard} from '../../ICard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {digit} from '../../Options';

export class ArcadianCommunitiesRebalanced extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.ARCADIAN_COMMUNITIES_RB,
      startingMegaCredits: 40,
      initialActionText: 'Place a community (player marker) on a non-reserved area',

      behavior: {
        stock: {steel: 10},
        production: {steel: 1}
      },

      metadata: {
        cardNumber: 'R44',
        description: 'You start with 42 M€, 10 steel and 1 steel production. AS YOUR FIRST ACTION, PLACE A COMMUNITY [PLAYER MARKER] ON A NON-RESERVED AREA.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(42).nbsp.steel(10, {digit}).production((pb) => pb.steel(1)).nbsp.community().asterix();
          b.corpBox('action', (ce) => {
            ce.text('ACTION: PLACE A COMMUNITY (PLAYER MARKER) ON A NON-RESERVED AREA ADJACENT TO ONE OF YOUR TILES OR MARKED AREAS.', Size.TINY, true);
            ce.vSpace(Size.MEDIUM);
            ce.text('EFFECT: MARKED AREAS ARE RESERVED FOR YOU. WHEN YOU PLACE A TILE THERE, GAIN 3 M€.', Size.TINY, true);
          });
        }),
      },
    });
  }

  public initialAction(player: IPlayer) {
    return new SelectSpace(
      'Select space for claim',
      player.game.board.getAvailableSpacesOnLand(player))
      .andThen((space: Space) => {
        space.player = player;
        player.game.log('${0} placed a Community (player marker)', (b) => b.player(player));
        return undefined;
      });
  }

  public getAvailableSpacesForMarker(player: IPlayer): Array<Space> {
    const board = player.game.board;
    const candidateSpaces = board.getAvailableSpacesOnLand(player);
    const spaces = candidateSpaces.filter((space) => {
      // Exclude spaces that already have a player marker.
      if (space.player !== undefined) return false;
      const adjacentSpaces = board.getAdjacentSpaces(space);
      return adjacentSpaces.find((adj) => adj.player === player) !== undefined;
    });
      // Remove duplicates
    return spaces.filter((space, index) => spaces.indexOf(space) === index);
  }

  public canAct(player: IPlayer): boolean {
    return this.getAvailableSpacesForMarker(player).length > 0;
  }

  public action(player: IPlayer) {
    return new SelectSpace('Select space for claim', this.getAvailableSpacesForMarker(player))
      .andThen((space) => {
        space.player = player;
        return undefined;
      });
  }
}

================
File: cards/chemical/rebalance/Corp_ArklightRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {IPlayer} from '../../../IPlayer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Resource} from '../../../../common/Resource';


export class ArklightRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.ARKLIGHT_RB,
      tags: [Tag.ANIMAL],
      startingMegaCredits: 50,
      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},

      behavior: {
       addResources: 1,
       production: {megacredits: 1}, 
      },

      metadata: {
        cardNumber: 'R04',
        description: 'You start with 50 M€. 1 VP per 2 animals on this card.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(50);
          b.corpBox('effect', (ce) => {
            ce.effect('When you play an animal or plant tag, including this, gain add 1M€ production and add 1 animal to this card.', (eb) => {
              eb.tag(Tag.ANIMAL).slash().tag(Tag.PLANT).startEffect.production((pb) => pb.megacredits(1)).resource(CardResource.ANIMAL);
            });
            ce.vSpace(); // to offset the description to the top a bit so it can be readable
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    if (player.isCorporation(this.name)) {
      const animalTagCount = player.tags.cardTagCount(card, Tag.ANIMAL);
      const plantTagCount = player.tags.cardTagCount(card, Tag.PLANT);
      const totalCount = animalTagCount + plantTagCount;

      if (totalCount > 0) {
        player.addResourceTo(this, {qty: totalCount, log: true});
        player.production.add(Resource.MEGACREDITS, totalCount, {log: true});
      }
    }
  }
}

================
File: cards/chemical/rebalance/Corp_AstrodrillRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {CorporationCard} from '../../corporation/CorporationCard';
import {IActionCard} from '../../ICard';
import {CardName} from '../../../../common/cards/CardName';
import {CardResource} from '../../../../common/CardResource';
import {SelectOption} from '../../../inputs/SelectOption';
import {SelectCard} from '../../../inputs/SelectCard';
import {OrOptions} from '../../../inputs/OrOptions';
import {LogHelper} from '../../../LogHelper';
import {Resource} from '../../../../common/Resource';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {digit} from '../../Options';

export class AstrodrillRebalance extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.ASTRODRILL_RB,
      tags: [Tag.SPACE],
      startingMegaCredits: 40,
      resourceType: CardResource.ASTEROID,

      behavior: {
        addResources: 4,
      },

      metadata: {
        cardNumber: 'R21',
        description: 'You start with 40 M€ and 4 asteroid resources.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(40).nbsp.resource(CardResource.ASTEROID, {amount: 4, digit});
          b.corpBox('action', (ce) => {
            ce.vSpace(Size.LARGE);
            ce.action(undefined, (eb) => {
              eb.empty().startAction.resource(CardResource.ASTEROID).asterix().slash().wild(1).or();
            });
            ce.vSpace();
            ce.action('Add an asteroid resource to ANY card OR gain any standard resource, OR remove an asteroid resource from this card to gain 3 titanium.', (eb) => {
              eb.resource(CardResource.ASTEROID).startAction.titanium(3, {digit});
            });
          });
        }),
      },
    });
  }

  public canAct(): boolean {
    return true;
  }

  public action(player: IPlayer) {
    const asteroidCards = player.getResourceCards(CardResource.ASTEROID);
    const opts = [];

    const gainStandardResource = new SelectOption('Gain a standard resource', 'Gain').andThen(() => {
      return new OrOptions(
        new SelectOption('Gain 1 titanium', 'Gain titanium').andThen(() => {
          player.stock.add(Resource.TITANIUM, 1, {log: true});
          return undefined;
        }),
        new SelectOption('Gain 1 steel', 'Gain steel').andThen(() => {
          player.stock.add(Resource.STEEL, 1, {log: true});
          return undefined;
        }),
        new SelectOption('Gain 1 plant', 'Gain plant').andThen(() => {
          player.stock.add(Resource.PLANTS, 1, {log: true});
          return undefined;
        }),
        new SelectOption('Gain 1 energy', 'Gain energy').andThen(() => {
          player.stock.add(Resource.ENERGY, 1, {log: true});
          return undefined;
        }),
        new SelectOption('Gain 1 heat', 'Gain heat').andThen(() => {
          player.stock.add(Resource.HEAT, 1, {log: true});
          return undefined;
        }),
        new SelectOption('Gain 1 M€', 'Gain M€').andThen(() => {
          player.stock.add(Resource.MEGACREDITS, 1, {log: true});
          return undefined;
        }),
      );
    });

    const addResourceToSelf = new SelectOption('Add 1 asteroid to this card', 'Add asteroid').andThen(() => {
      player.addResourceTo(this, {log: true});

      return undefined;
    });

    const addResource = new SelectCard(
      'Select card to add 1 asteroid',
      'Add asteroid',
      asteroidCards)
      .andThen(([card]) => {
        player.addResourceTo(card, {log: true});
        return undefined;
      });

    const spendResource = new SelectOption('Remove 1 asteroid on this card to gain 3 titanium', 'Remove asteroid').andThen(() => {
      this.resourceCount--;
      player.titanium += 3;
      LogHelper.logRemoveResource(player, this, 1, 'gain 3 titanium');

      return undefined;
    });

    if (this.resourceCount > 0) opts.push(spendResource);
    asteroidCards.length === 1 ? opts.push(addResourceToSelf) : opts.push(addResource);
    opts.push(gainStandardResource);

    return new OrOptions(...opts);
  }
}

================
File: cards/chemical/rebalance/Corp_CelesticRB.ts
================
import {IPlayer} from '../../../IPlayer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';
import {CorporationCard} from '../../corporation/CorporationCard';
import {IActionCard} from '../../ICard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {AltSecondaryTag} from '../../../../common/cards/render/AltSecondaryTag';
import {floaterCards} from '../../venusNext/floaterCards';
import {SelectCard} from '../../../inputs/SelectCard';


export class CelesticRebalance extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.CELESTIC_RB,
      tags: [Tag.VENUS],
      startingMegaCredits: 42,
      resourceType: CardResource.FLOATER,
      initialActionText: 'Draw 2 cards with a floater icon on it',
      victoryPoints: {resourcesHere: {}, per: 3},
      
      metadata: {
        cardNumber: 'R05',
        description: 'Start with 42 M€. First action: reveal cards from the deck until you have revealed 2 with a floater icon on it. Take them into hand and discard the rest.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(42).nbsp.cards(2, {secondaryTag: AltSecondaryTag.FLOATER});
          b.corpBox('action', (ce) => {
            ce.action('Add 1 floater to up to 2 DIFFERENT cards. 1 VP per 3 floaters on this card.', (eb) => {
              eb.empty().startAction.resource(CardResource.FLOATER).asterix().resource(CardResource.FLOATER).asterix();
            });
            ce.vSpace(); // to offset the description to the top a bit so it can be readable
          });
        }),
      },
    });
  }


  public initialAction(player: IPlayer) {
    player.drawCard(2, {
      include: (card) => floaterCards.has(card.name) || card.resourceType === CardResource.FLOATER,
    });
    return undefined;
  }

  public canAct(): boolean {
    return true;
  }

  public action(player: IPlayer) {
    const floaterCards = player.getResourceCards(CardResource.FLOATER);
    
    if (floaterCards.length === 0) {
      return undefined;
    }
  
    if (floaterCards.length === 1) {
      player.addResourceTo(floaterCards[0], {qty: 1, log: true});
      return undefined;
    }
  
    return new SelectCard(
      'Select up to 2 different cards to add 1 floater each',
      'Add floater(s)',
      floaterCards,
      {
        min: 1,
        max: 2,
      }
    ).andThen((selectedCards) => {
      selectedCards.forEach((card) => {
        player.addResourceTo(card, {qty: 1, log: true});
      });
      return undefined;
    });
  }
}

================
File: cards/chemical/rebalance/Corp_CheungShingMARSRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CorporationCard} from '../../corporation/CorporationCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IProjectCard} from '../../IProjectCard';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';

export class CheungShingMARSRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.CHEUNG_SHING_MARS_RB,
      tags: [Tag.BUILDING],
      startingMegaCredits: 44,

      behavior: {
        production: {megacredits: 3},
      },

      
      metadata: {
        cardNumber: 'R16',
        description: 'You start with 3M€ production and 44 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.production((pb) => pb.megacredits(3)).nbsp.megacredits(44);
          b.corpBox('effect', (ce) => {
            ce.effect('When you play a building tag, you gain 3M€.', (eb) => {
              eb.tag(Tag.BUILDING).startEffect.megacredits(3);
            });
          });
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.tags.includes(Tag.BUILDING)) {
      player.stock.add(Resource.MEGACREDITS, 3, {log: true, from: this});      
    }
  }
}

================
File: cards/chemical/rebalance/Corp_FactorumRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {IPlayer} from '../../../IPlayer';
import {Tag} from '../../../../common/cards/Tag';
import {IActionCard} from '../../ICard';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';


export class FactorumRebalanced extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.FACTORUM_RB,
      tags: [Tag.POWER, Tag.BUILDING],
      startingMegaCredits: 40,

      behavior: {
        production: {steel: 2},
      },

      metadata: {
        cardNumber: 'R22',
        description: 'You start with 40 M€. Increase your steel production 2 steps.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(40).nbsp.production((pb) => pb.steel(2));
          b.corpBox('action', (ce) => {
            ce.vSpace(Size.LARGE);
            ce.action('Increase your energy production 1 step IF YOU HAVE NO ENERGY RESOURCES, or spend 1 energy to draw a building card.', (eb) => {
              eb.empty().arrow().production((pb) => pb.energy(1)).asterix();
              eb.or().energy(1).startAction.cards(1, {secondaryTag: Tag.BUILDING});
            });
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.energy === 0 || player.canAfford(3);
  }


  public action(player: IPlayer) {
    if (player.energy > 0) {
      player.stock.deduct(Resource.ENERGY, 1);
      player.drawCard(1, {tag: Tag.BUILDING});
    } else {
      player.production.add(Resource.ENERGY, 1, {log: true});
    }
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Corp_HelionRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';
import {Size} from '../../../../common/cards/render/Size';


export class HelionRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.HELION_RB,
      tags: [Tag.SPACE],
      startingMegaCredits: 40,

      behavior: {
        production: {heat: 4},
        heatDiscount: 1,
      },

      metadata: {
        cardNumber: 'R18',  
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.production((pb) => pb.heat(4, {digit}).nbsp).megacredits(40);
          b.text('(You start with 4 heat production and 40 M€.)', Size.TINY, false, false);
          b.corpBox('effect', (ce) => {
            ce.vSpace(Size.LARGE);
            ce.effect('You may use heat as M€. You may not use M€ as heat.', (eb) => {
              eb.startEffect.text('x').heat(1).equals().megacredits(1, {text: 'x'})
            });
              ce.effect('Using the RAISE TEMPERATURE action costs 1 less heat.', (eb) => {

                eb.temperature(1).asterix().startEffect.minus().heat(1.).nbsp; 
              });
                             
            



          });


          
        }),
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    player.canUseHeatAsMegaCredits = true;
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Corp_InterplanetaryCinematicsRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {Tag} from '../../../../common/cards/Tag';
import {IProjectCard} from '../../IProjectCard';
import {IPlayer} from '../../../IPlayer';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';
import {Resource} from '../../../../common/Resource';

export class InterplanetaryCinematicsRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.INTERPLANETARY_CINEMATICS_RB,
      tags: [Tag.BUILDING],
      startingMegaCredits: 40,

      behavior: {
        stock: {steel: 12},
      },

      metadata: {
        cardNumber: 'R19',
        description: 'You start with 12 steel and 40 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(40).nbsp.steel(12, {digit});
          b.corpBox('effect', (ce) => {
            ce.effect('Each time you play an event, you gain 3 M€.', (eb) => {
              eb.tag(Tag.EVENT).startEffect.megacredits(3);
            });
          });
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (player.isCorporation(this.name) && card.type === CardType.EVENT) {
      player.stock.add(Resource.MEGACREDITS, 3, {log: true, from: this});
    }
  }
}

================
File: cards/chemical/rebalance/Corp_InventrixRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {IProjectCard} from '../../IProjectCard';
import {AltSecondaryTag} from '../../../../common/cards/render/AltSecondaryTag';
import {Size} from '../../../../common/cards/render/Size';

export class InventrixRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.INVENTRIX_RB,
      tags: [Tag.SCIENCE],
      startingMegaCredits: 45,
      globalParameterRequirementBonus: {steps: 3},

      firstAction: {
        text: 'Draw 3 cards',
        drawCard: 3,
      },

      metadata: {
        cardNumber: 'R43',
        description: 'As your first action in the game, draw 3 cards. Start with 45 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br;         
          b.megacredits(45).nbsp.cards(3);
          b.corpBox('effect', (ce) => {
            ce.vSpace(Size.LARGE);
            ce.effect('Your temperature, oxygen, ocean, and Venus requirements are +3 or -3 steps, your choice in each case.', (eb) => {
              eb.plate('Global requirements').startEffect.text('+/- 3');
            });
            ce.effect('Cards with req cost 1 M€ less.', (eb) => {
              eb.cards(1, {secondaryTag: AltSecondaryTag.REQ}).startEffect.megacredits(-1); 
            });
          });
        }),
      },
    });
  }

  public override getCardDiscount(_player: IPlayer, card: IProjectCard) {
    return card.requirements.length > 0 ? 1 : 0;
  }
}

================
File: cards/chemical/rebalance/Corp_MiningGuildRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {CorporationCard} from '../../corporation/CorporationCard';
import {Phase} from '../../../../common/Phase';
import {Space} from '../../../boards/Space';
import {SpaceBonus} from '../../../../common/boards/SpaceBonus';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {GainProduction} from '../../../deferredActions/GainProduction';
import {CardRenderer} from '../../render/CardRenderer';
import {BoardType} from '../../../boards/BoardType';
import {digit} from '../../Options';
import {AresHandler} from '../../../ares/AresHandler';
import {Size} from '../../../../common/cards/render/Size';

export class MiningGuildRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.MINING_GUILD_RB,
      tags: [Tag.BUILDING, Tag.BUILDING],
      startingMegaCredits: 36,

      behavior: {
        production: {steel: 1},
        stock: {steel: 2},
      },

      metadata: {
        cardNumber: 'R24',
        hasExternalHelp: true,
        description: 'You start with 36 M€, 2 steel and 1 steel production.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(36).nbsp.steel(2, {digit}).nbsp.production((pb) => pb.steel(1));
          b.corpBox('effect', (ce) => {
            ce.effect('Each time you get any steel as a placement bonus on the map, increase your steel production 1 step. Same for titanium', (eb) => {
              eb.steel(1).asterix().colon();
              eb.production((pb) => pb.steel(1)).or(Size.TINY);
              eb.titanium(1).asterix();
              eb.startEffect.production((pb) => pb.titanium(1));
            });
          });
        }),
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space, boardType: BoardType) {
    // Nerfing on The Moon.
    if (boardType !== BoardType.MARS) {
      return;
    }
    if (cardOwner.id !== activePlayer.id || cardOwner.game.phase === Phase.SOLAR) {
      return;
    }
    // Don't grant a bonus if the card is overplaced (like Ares Ocean City)
    if (space.tile?.covers !== undefined) {
      return;
    }
    const board = cardOwner.game.board;
    const grantSteel = space.bonus.some((bonus) => bonus === SpaceBonus.STEEL ||
      AresHandler.anyAdjacentSpaceGivesBonus(board, space, SpaceBonus.STEEL));
    const grantTitanium = space.bonus.some((bonus) => bonus === SpaceBonus.TITANIUM) ||      
      AresHandler.anyAdjacentSpaceGivesBonus(board, space, SpaceBonus.TITANIUM);
      
    if (grantSteel) {
      cardOwner.game.defer(new GainProduction(cardOwner, Resource.STEEL));  
    }  
    if (grantTitanium) {
      cardOwner.game.defer(new GainProduction(cardOwner, Resource.TITANIUM));
    }
    
  }
}

================
File: cards/chemical/rebalance/Corp_MorningStarIncRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {GlobalParameter} from '../../../../common/GlobalParameter';
import {Size} from '../../../../common/cards/render/Size';

export class MorningStarIncRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.MORNING_STAR_INC_RB,
      tags: [Tag.VENUS],
      startingMegaCredits: 50,
      globalParameterRequirementBonus: {steps: 3, parameter: GlobalParameter.VENUS},
      cardDiscount: {tag: Tag.VENUS, amount: 2},

      firstAction: {
        text: 'Draw 3 cards with a Venus tag',
        drawCard: {count: 3, tag: Tag.VENUS},        
      },

      metadata: {
        cardNumber: 'R06',
        description: 'You start with 50 M€. Draw 3 Venus cards.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(50).nbsp.cards(3, {secondaryTag: Tag.VENUS});
          b.corpBox('effect', (ce) => {
            ce.vSpace(Size.LARGE);
            ce.effect('Your Venus requirements are +/- 3 steps, your choice in each case.', (eb) => {
              eb.plate('Venus requirements').startEffect.text('+/- 3');
            });
            ce.effect('When you play a Venus tag, you pay 2 M€ less for it.', (eb)=> {
              eb.venus(1).startEffect.megacredits(-2);
            });
          });
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Corp_PhoboLogRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CorporationCard} from '../../corporation/CorporationCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {digit} from '../../Options';

export class PhoboLogRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.PHOBOLOG_RB,
      tags: [Tag.SPACE],
      startingMegaCredits: 30,

      behavior: {
        stock: {titanium: 8},
        titanumValue: 1,
      },

      firstAction: {
        text: 'Draw 2 cards with a space tag',
        drawCard: {count: 2, tag: Tag.SPACE},        
      },

      metadata: {
        cardNumber: 'R09',
        description: 'You start with 10 titanium and 23 M€. As your first action, draw 2 cards with a space tag.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(30).nbsp.titanium(8, {digit}).nbsp.cards(2, {secondaryTag: Tag.SPACE});;
          b.corpBox('effect', (ce) => {
            ce.effect('Your titanium resources are each worth 1 M€ extra.', (eb) => {
              eb.titanium(1).startEffect.plus(Size.SMALL).megacredits(1);
            });
          });
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Corp_PointLunaRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {ICorporationCard} from '../../corporation/ICorporationCard';
import {CorporationCard} from '../../corporation/CorporationCard';
import {ICard} from '../../ICard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

import {OrOptions} from '../../../inputs/OrOptions';
import {SelectCard} from '../../../inputs/SelectCard';
import {SelectOption} from '../../../inputs/SelectOption';
import {Priority} from '../../../deferredActions/Priority';

export class PointLunaRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.POINT_LUNA_RB,
      tags: [Tag.SPACE, Tag.EARTH],
      startingMegaCredits: 45,

      behavior: {
        production: {titanium: 1},
        drawCard: 1,   
      },

      metadata: {
        cardNumber: 'R10',
        description: 'You start with 1 titanium production and 45 M€. Draw a card',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.production((pb) => pb.titanium(1)).nbsp.megacredits(45).cards(1);
          b.corpBox('effect', (ce) => {
            ce.effect('When you play an Earth tag, including this, draw a card then discard a card.', (eb) => {
              eb.tag(Tag.EARTH).startEffect.plus().cards(1).minus().cards(1);
            });
          });
        }),
      },
    });
  }
  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    return this.onCardPlayed(player, card);
  }

  public onCardPlayed(player: IPlayer, card: ICard) {
    if (player.isCorporation(this.name)) {
      const earthTags = player.tags.cardTagCount(card, Tag.EARTH);
      this.onEarthTagAdded(player, earthTags);
    }
  }

  public onEarthTagAdded(player: IPlayer, count: number) {
    for (let i = 0; i < count; i++) {
      player.defer(() => {
        // No card to discard
        if (player.cardsInHand.length === 0) {
          return undefined;
        }
        return new OrOptions(
          new SelectCard('Select a card to discard', 'Discard', player.cardsInHand)
            .andThen(([card]) => {
              player.game.log('${0} is using their ${1} effect to draw a card by discarding a card.', (b) => b.player(player).card(this));
              player.discardCardFromHand(card, {log: true});
              player.drawCard();
              return undefined;
            }),
          new SelectOption('Do nothing'),
        );
      },
      Priority.DISCARD_AND_DRAW);
    }
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Corp_PolyphemosRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';
import {IPlayer} from '../../../IPlayer';
import {IProjectCard} from '../../IProjectCard';

export class PolyphemosRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.POLYPHEMOS_RB,
      startingMegaCredits: 55,
      cardCost: 5,

      behavior: {
        production: {megacredits: 5},
        stock: {titanium: 5},
      },

      metadata: {
        cardNumber: 'R11',
        description: 'You start with 55 M€. Increase your M€ production 5 steps. Gain 5 titanium.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(55).nbsp.production((pb) => pb.megacredits(5)).nbsp.titanium(5, {digit});
          b.corpBox('effect', (ce) => {
            ce.effect('When you buy a card to hand, pay 5M€ instead of 3, including starting hand.', (eb) => {
              eb.cards(1).asterix().startEffect.megacredits(5);
            });
            ce.effect('When playing a card with a basic cost of 20MC or more, draw a card.', (eb) => {
              eb.megacredits(20).asterix().startEffect.cards(1);
            });
          });
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (player.isCorporation(this.name) && card.cost >= 20) {
          player.drawCard();
    };
}
}

================
File: cards/chemical/rebalance/Corp_PoseidonRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';

export class PoseidonRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.POSEIDON_RB,
      startingMegaCredits: 40,

      firstAction: {
        text: 'Place a colony',
        // title: 'Poseidon first action - Select where to build colony
        colonies: {buildColony: {}},
      },
      metadata: {
        cardNumber: 'R02',
        description: 'You start with 40 M€. As your first action, place a colony.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(40).nbsp.colonies(1);
          b.corpBox('effect', (ce) => {
            ce.effect('When YOU place a colony, including this, raise your M€ production 2 step.', (eb) => {
              eb.colonies(1, {all}).startEffect.production((pb) => pb.megacredits(2));
            });
          });
        }),
      },
    });
  }

  public onColonyAdded(_player: IPlayer, cardOwner: IPlayer) {
    if (_player === cardOwner) {
      cardOwner.production.add(Resource.MEGACREDITS, 2, {log: true});
    }    
  }
}

================
File: cards/chemical/rebalance/Corp_PristarRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Turmoil} from '../../../turmoil/Turmoil';
import {Resource} from '../../../../common/Resource';


export class PristarRebalance extends CorporationCard {

  private hasTemporaryInfluence: boolean = false;

  constructor() {
    super({
      name: CardName.PRISTAR_RB,
      startingMegaCredits: 53,
      resourceType: CardResource.PRESERVATION,

      victoryPoints: {resourcesHere: {}},

      metadata: {
        cardNumber: 'R07',
        description: 'You start with 53 M€. Decrease your TR 2 steps. 1 VP per preservation resource here.',

        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(53).nbsp.nbsp.minus().tr(2, {size: Size.SMALL});
          b.corpBox('effect', (ce) => {
            ce.effect('During production phase, if you did not get TR so far this generation, add one preservation resource here and gain 6 M€.', (eb) => {
              eb.tr(1, {size: Size.SMALL, cancelled: true}).startEffect.resource(CardResource.PRESERVATION).megacredits(6).influence;
            });
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.decreaseTerraformRating(2);
    return undefined;
  }

  public onProductionPhase(player: IPlayer) {
    // Remove temporary influence from previous generation if it exists
    if (this.hasTemporaryInfluence) {
      Turmoil.ifTurmoil(player.game, (turmoil) => {
        turmoil.addInfluenceBonus(player, -1);
      });
      this.hasTemporaryInfluence = false;
    }

    if (!player.generationData.hasRaisedTR) {
      player.stock.add(Resource.MEGACREDITS, 6, {log: true, from: this});
      player.addResourceTo(this, 1);
      
      // Add temporary influence for this generation
      Turmoil.ifTurmoil(player.game, (turmoil) => {
        turmoil.addInfluenceBonus(player, 1);
      });
      this.hasTemporaryInfluence = true;

      player.game.log('${0} gained 1 temporary influence from ${1}', (b) => b.player(player).card(this));
    }

    return undefined;
  }
}

================
File: cards/chemical/rebalance/Corp_RobinsonIndustriesRB.ts
================
import {IActionCard} from '../../ICard';
import {IPlayer} from '../../../IPlayer';
import {CorporationCard} from '../../corporation/CorporationCard';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {ALL_RESOURCES} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';
import {TITLES} from '../../../inputs/titles';
import {Tag} from '../../../../common/cards/Tag';

export class RobinsonIndustriesRebalance extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.ROBINSON_INDUSTRIES_RB,
      tags: [Tag.WILD],
      startingMegaCredits: 40,

      metadata: {
        cardNumber: 'R27',
        description: 'You start with 40 M€ and 2 M€ production. When you perform an action the wild tag acts as any tag.',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(40).nbsp.production((pb) => pb.megacredits(2));
          b.corpBox('action', (ce) => {
            ce.action('Spend 4 M€ to increase (one of) your LOWEST production 1 step.', (eb) => {
              eb.megacredits(4).startAction.production((pb) => pb.wild(1).asterix());
            });
          });
        }),
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.canAfford(4);
  }

  public action(player: IPlayer) {
    let minimum = player.production.megacredits;
    let lowest: Array<SelectOption> = [];

    ALL_RESOURCES.forEach((resource) => {
      const option = new SelectOption('Increase ' + resource + ' production 1 step').andThen(() => {
        player.game.defer(new SelectPaymentDeferred(player, 4, {title: TITLES.payForCardAction(this.name)}))
          // Add production after payment, to prevent Manutech from being in the way.
          .andThen(() => player.production.add(resource, 1, {log: true}));
        return undefined;
      });

      if (player.production[resource] < minimum) {
        lowest = [];
        minimum = player.production[resource];
      }
      if (player.production[resource] === minimum) lowest.push(option);
    });

    const result = new OrOptions();
    result.options = lowest;
    return result;
  }
}

================
File: cards/chemical/rebalance/Corp_SpliceRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {ICorporationCard} from '../../corporation/ICorporationCard';
import {CorporationCard} from '../../corporation/CorporationCard';
import {SelectOption} from '../../../inputs/SelectOption';
import {OrOptions} from '../../../inputs/OrOptions';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Resource} from '../../../../common/Resource';
import {all} from '../../Options';
import {message} from '../../../logs/MessageBuilder';
import {ICard} from '../../ICard';
import {GainResources} from '../../../deferredActions/GainResources';

export class SpliceRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.SPLICE_RB,
      tags: [Tag.MICROBE],
      startingMegaCredits: 52, // 44 + 4 as card resolution when played

      firstAction: {
        text: 'Draw a card with a microbe tag',
        drawCard: {count: 1, tag: Tag.MICROBE},
      },

      metadata: {
        cardNumber: 'R28',
        description: 'You start with 48 M€. As your first action, reveal cards until you have revealed a microbe tag. Take it and discard the rest.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(48).nbsp.cards(1, {secondaryTag: Tag.MICROBE});
          b.corpBox('effect', (ce) => {
            ce.vSpace(Size.LARGE);
            ce.effect(undefined, (eb) => {
              eb.tag(Tag.MICROBE, {all}).startEffect;
              eb.megacredits(2, {all}).or().resource(CardResource.MICROBE, {all}).asterix();
            });
            ce.vSpace();
            ce.effect('when a microbe tag is played, incl. this, THAT PLAYER gains 2 M€, or adds a microbe to THAT card, and you gain 2 M€.', (eb) => {
              eb.tag(Tag.MICROBE, {all}).startEffect;
              eb.megacredits(2);
            });
          });
        }),
      },
    });
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    return this.onCardPlayed(player, card);
  }

  public onCardPlayed(player: IPlayer, card: ICard): undefined {
    const game = player.game;
    const microbeTags = player.tags.cardTagCount(card, Tag.MICROBE);
    if (microbeTags === 0) {
      return;
    }

    const gain = microbeTags * 2;

    const gainResource = new SelectOption('Add a microbe resource to this card', 'Add microbe').andThen(() => {
      player.addResourceTo(card);
      return undefined;
    });

    const gainMC = new SelectOption(
      message('Gain ${0} M€', (b) => b.number(gain)),
      'Gain M€')
      .andThen(() => {
        game.defer(new GainResources(player, Resource.MEGACREDITS, {count: gain, log: true, from: this}));
        return undefined;
      });

    // Splice owner gets 2M€ per microbe tag
    const cardPlayer = game.getCardPlayerOrThrow(this.name);
    game.defer(new GainResources(cardPlayer, Resource.MEGACREDITS, {count: gain, log: true, from: this}));

    if (card.resourceType === CardResource.MICROBE) {
      // Card player chooses between 2 M€ and a microbe on card, if possible
      player.defer(new OrOptions(gainResource, gainMC));
    } else {
      gainMC.cb(undefined);
    }
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Corp_StormCraftIncorporatedRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {IPlayer} from '../../../IPlayer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

import {Resource} from '../../../../common/Resource';

import {floaterCards} from '../../venusNext/floaterCards';
import {ICard} from '../../ICard';

import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {AltSecondaryTag} from '../../../../common/cards/render/AltSecondaryTag';
import {message} from '../../../logs/MessageBuilder';

export class StormCraftIncorporatedRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.STORMCRAFT_INCORPORATED_RB,
      tags: [Tag.JOVIAN],
      startingMegaCredits: 50,    

      metadata: {
        cardNumber: 'R29',
        description: 'You start with 50 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(50).nbsp.cards(1, {secondaryTag: AltSecondaryTag.FLOATER});
          b.corpBox('action', (ce) => {
            ce.effect('When you gain a floater to ANY CARD, also gain 1MC or 1 Energy.', (eb) => {
              eb.resource(CardResource.FLOATER).asterix().startEffect.megacredits(1).slash().energy(1);
            });
            ce.vSpace();
          });
        }),
      },
    });
  }

  public initialAction(player: IPlayer) {
    player.drawCard(1, {
      include: (card) => floaterCards.has(card.name) || card.resourceType === CardResource.FLOATER,
    });
    return undefined;
  }

  public onResourceAdded(player: IPlayer, card: ICard, count: number) {
  
      const gainMC = new SelectOption(
        message('Gain ${0} M€', (b) => b.number(count)),
        'Gain M€').andThen(() => {
        player.stock.add(Resource.MEGACREDITS, count, {log: true})
        return undefined;
      });

      const gainEnergy = new SelectOption(
        message('Gain ${0} energy', (b) => b.number(count)),
        'Gain M€').andThen(() => {
        player.stock.add(Resource.ENERGY, count, {log: true})
        return undefined;
      });

    if (card.resourceType === CardResource.FLOATER) {
      player.defer(new OrOptions(gainEnergy, gainMC));
    } 
    }        
}

================
File: cards/chemical/rebalance/Corp_TerralabsResearchRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {IPlayer} from '../../../IPlayer';
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class TerralabsResearchRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.TERRALABS_RESEARCH_RB,
      tags: [Tag.SCIENCE, Tag.EARTH],
      startingMegaCredits: 30,
      cardCost: 1,

      metadata: {
        cardNumber: 'R14',
        description: 'You start with 30 M€. Lower your TR 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(30).nbsp.minus().tr(1);
          b.corpBox('effect', (ce) => {
            ce.effect('Buying cards to hand costs 1 M€.', (eb) => {
              eb.cards(1).startEffect.megacredits(1);
            });
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.decreaseTerraformRating();
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Corp_TharsisRepublicRB.ts
================
import {CorporationCard} from '../../corporation/CorporationCard';
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {Space} from '../../../boards/Space';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {Priority} from '../../../deferredActions/Priority';
import {GainResources} from '../../../deferredActions/GainResources';
import {GainProduction} from '../../../deferredActions/GainProduction';
import {Board} from '../../../boards/Board';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {all} from '../../Options';

export class TharsisRepublicRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.THARSIS_REPUBLIC_RB,
      tags: [Tag.BUILDING, Tag.CITY],
      startingMegaCredits: 40,

      firstAction: {
        text: 'Place a city tile',
        city: {},
      },

      metadata: {
        cardNumber: 'R31',
        description: 'You start with 40 M€. As your first action in the game, place a city tile.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(40).nbsp.city();
          b.corpBox('effect', (ce) => {
            ce.effect('When any city tile is placed, increase your M€ production 1 step. When you place a city tile, gain 3 M€.', (eb) => {
              eb.city({size: Size.SMALL, all}).asterix().colon();
              eb.production((pb) => pb.megacredits(1)).nbsp;
              eb.city({size: Size.SMALL}).startEffect.megacredits(3);
            });
          });
        }),
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (Board.isCitySpace(space)) {
      if (cardOwner.id === activePlayer.id) {
        cardOwner.game.defer(new GainResources(cardOwner, Resource.MEGACREDITS, {count: 3}));
      }
      cardOwner.game.defer(
        new GainProduction(cardOwner, Resource.MEGACREDITS),
        cardOwner.id !== activePlayer.id ? Priority.OPPONENT_TRIGGER : undefined,
      );
    }
    return;
  }

  public override bespokePlay(player: IPlayer) {
    if (player.game.isSoloMode()) {
      // Get bonus for 2 neutral cities
      player.production.add(Resource.MEGACREDITS, 2);
    }
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Corp_ThorgateRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CorporationCard} from '../../corporation/CorporationCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ThorgateRebalance extends CorporationCard {
  constructor() {
    super({
      name: CardName.THORGATE_RB,
      tags: [Tag.POWER],
      startingMegaCredits: 40,

      behavior: {
        production: {energy: 1},
      },

      cardDiscount: {tag: Tag.POWER, amount: 3},
      metadata: {
        cardNumber: 'R13',
        description: 'You start with 1 energy production and 40 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.production((pb) => pb.energy(1)).nbsp.megacredits(48);
          b.corpBox('effect', (ce) => {
            ce.effect('When playing a power card OR THE STANDARD PROJECT POWER PLANT, you pay 3 M€ less for it.', (eb) => {
              eb.tag(Tag.POWER).asterix().startEffect.megacredits(-3);
            });
          });
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_ MoholeExcavationRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class MoholeExcavationRebalance extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.MOHOLE_EXCAVATION_RB,
      tags: [Tag.BUILDING],

      behavior: {
        production: {steel: 1, heat: 2},
        stock: {steel: 4},
      },

      metadata: {
        cardNumber: 'P23',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.steel(1).br;
            pb.heat(2);            
          }).br;
          b.steel(4);
        }),
        description: 'Increase your steel production 1 step and heat production 2 steps. Gain 4 steel.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_BiofuelsRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class BiofuelsRebalance extends PreludeCard {
  constructor() {
    super({
      name: CardName.BIOFUELS_RB,
      tags: [Tag.MICROBE],

      behavior: {
        production: {energy: 2, plants: 1},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'P03',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2).plants(1)).br;
          b.plants(2);
        }),
        description: 'Increase your energy by two steps and plant production 1 step. Gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_BiosphereSupportRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class BiosphereSupportRebalance extends PreludeCard {
  constructor() {
    super({
      name: CardName.BIOSPHERE_SUPPORT_RB,
      tags: [Tag.PLANT],

      behavior: {
        production: {plants: 2, megacredits: 1},
      },

      metadata: {
        cardNumber: 'P05',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).br;
            pb.plants(2);
          });
        }),
        description: 'Increase your plant production 2 steps and your M€ production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_DomeFarmingRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class DomeFarmingRebalance extends PreludeCard {
  constructor() {
    super({
      name: CardName.DOME_FARMING_RB,
      tags: [Tag.PLANT, Tag.BUILDING],

      behavior: {
        production: {megacredits: 3, plants: 1},
      },

      metadata: {
        cardNumber: 'P07',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(3).plants(1));
        }),
        description: 'Increase your M€ production 3 steps and plant production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_EarlySettlementRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class EarlySettlementRebalance extends PreludeCard {
  constructor() {
    super({
      name: CardName.EARLY_SETTLEMENT_RB,
      tags: [Tag.BUILDING, Tag.CITY],

      behavior: {
        production: {plants: 1},
        stock: {plants: 3},
        city: {},
      },

      metadata: {
        cardNumber: 'P09',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).city();
          b.plants(3);
        }),
        description: 'Increase your plant production 1 step. Gain three plants. Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_EccentricSponsorRB.ts
================
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {PreludeCard} from '../../prelude/PreludeCard';
import {PlayProjectCard} from '../../../deferredActions/PlayProjectCard';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {PreludesExpansion} from '../../../preludes/PreludesExpansion';

export class EccentricSponsorRebalance extends PreludeCard {
  constructor() {
    super({
      name: CardName.ECCENTRIC_SPONSOR_RB,

      metadata: {
        cardNumber: 'P11',
        renderData: CardRenderer.builder((b) => {
          b.text('Play a card from hand, reducing its cost by 27 M€', Size.SMALL, true);
        }),
      },
    });
  }

  // TODO(kberg): Make it possible to identify that the prelude will fizzle during canPlay, which
  // will present a warning to the player.

  public override getCardDiscount(player: IPlayer) {
    if (player.lastCardPlayed === this.name) {
      return 27;
    }
    return 0;
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new PlayProjectCard(player))
      .andThen((card) => {
        if (card === undefined) {
          PreludesExpansion.fizzle(player, this);
          // If this card fizzles, don't apply the discount to the next card.
          player.lastCardPlayed = undefined;
        }
      });
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Prelude_GalileanMiningRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class GalileanMiningRebalance extends PreludeCard {
  constructor() {
    super({
      name: CardName.GALILEAN_MINING_RB,
      tags: [Tag.JOVIAN],

      behavior: {
        production: {titanium: 2},
      },      

      metadata: {
        cardNumber: 'P13',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.titanium(2);
          }).br;          
        }),
        description: 'Increase your titanium production 2 steps.',
      },
    });
  }  
}

================
File: cards/chemical/rebalance/Prelude_HugeAsteroidRB.ts
================
import {IPlayer} from '../../../IPlayer';
import {PreludeCard} from '../../prelude/PreludeCard';
import {CardName} from '../../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../../render/CardRenderer';

export class HugeAsteroidRebalance extends PreludeCard {
  constructor() {
    super({
      name: CardName.HUGE_ASTEROID_RB,

      startingMegacredits: -2,

      behavior: {
        global: {temperature: 3},
      },

      metadata: {
        cardNumber: 'P15',
        renderData: CardRenderer.builder((b) => {
          b.temperature(3).br;
          b.megacredits(-2);
        }),
        description: 'Increase temperature 3 steps. Pay 2 M€.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer) {
    return player.canAfford(2);
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 2));
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Prelude_IoResearchOutpostRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class IoResearchOutpostRebalance extends PreludeCard {
  constructor() {
    super({
      name: CardName.IO_RESEARCH_OUTPOST_RB,
      tags: [Tag.JOVIAN, Tag.SCIENCE],

      behavior: {
        production: {titanium: 1},
        drawCard: 2,
      },

      metadata: {
        cardNumber: 'P16',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).br;
          b.cards(2);
        }),
        description: 'Increase your titanium production 1 step. Draw two cards.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_LoanRB.ts
================
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class LoanRebalance extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.LOAN_RB,

      behavior: {
        production: {megacredits: -2},
        stock: {megacredits: 32},
      },

      metadata: {
        cardNumber: 'P17',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().megacredits(2)).br;
          b.megacredits(32);
        }),
        description: 'Gain 32 M€. Decrease your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_MartianIndustriesRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class MartianIndustriesRebalance extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.MARTIAN_INDUSTRIES_RB,
      tags: [Tag.BUILDING, Tag.POWER],

      behavior: {
        production: {energy: 1, steel: 1},
        stock: {megacredits: 6},
      },

      metadata: {
        cardNumber: 'P18',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).steel(1)).br;
          b.megacredits(6);
        }),
        description: 'Increase your energy and steel production 1 step. Gain 6 M€.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_MetalsCompanyRB.ts
================
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class MetalsCompanyRebalance extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.METALS_COMPANY_RB,

      behavior: {
        production: {megacredits: 1, steel: 1, titanium: 1},
        stock: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'P20',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).steel(1).titanium(1).br);
          b.megacredits(2);
        }),
        description: 'Increase your M€, steel and titanium production 1 step. Gain 2M€',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_MoholeRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class MoholeRebalance extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.MOHOLE_RB,
      tags: [Tag.BUILDING],

      behavior: {
        production: {heat: 2, energy: 1},
        stock: {energy: 3, heat: 5},
      },

      metadata: {
        cardNumber: 'P22',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(2).energy(1)).br;
          b.heat(5).br;
          b.energy(3);
        }),
        description: 'Increase your heat production 2 steps and your energy production 1 step. Gain 5 heat and 3 energy.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_NitrogenShipmentRB.ts
================
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class NitrogenShipmentRebalance extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.NITROGEN_SHIPMENT_RB,
      tags: [Tag.EARTH],

      behavior: {        
        tr: 2,
        stock: {plants: 5},
      },

      metadata: {
        cardNumber: 'P24',
        renderData: CardRenderer.builder((b) => {
          b.tr(2).br;
          b.plants(5);
        }),
        description: 'Increase your TR 2 steps. Gain 5 plants.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_OrbitalConstructionYardRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class OrbitalConstructionYardRebalance extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.ORBITAL_CONSTRUCTION_YARD_RB,
      tags: [Tag.SPACE],

      behavior: {
        production: {titanium: 1},
        stock: {titanium: 5},
      },

      metadata: {
        cardNumber: 'P25',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).br;
          b.titanium(5);
        }),
        description: 'Increase your titanium production 1 step. Gain 5 titanium.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_PolarIndustriesRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class PolarIndustriesRebalance extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.POLAR_INDUSTRIES_RB,
      tags: [Tag.BUILDING],

      behavior: {
        production: {heat: 2},
        ocean: {},
        stock: {megacredits: 5},
      },

      metadata: {
        cardNumber: 'P26',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(2)).megacredits(5).br;
          b.oceans(1);
        }),
        description: 'Increase your heat production 2 steps. Gain 5 M€. Place an ocean tile.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_SelfSufficientSettlementRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class SelfSufficientSettlementRebalance extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.SELF_SUFFICIENT_SETTLEMENT_RB,
      tags: [Tag.BUILDING, Tag.CITY],

      behavior: {
        production: {megacredits: 2},
        city: {},
        stock: {megacredits: 3},
      },

      metadata: {
        cardNumber: 'P29',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).megacredits(3).br.city();
        }),
        description: 'Increase your M€ production 2 steps. Gain 3 M€. Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_SmeltingPlantRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {PreludeCard} from '../../prelude/PreludeCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class SmeltingPlantRebalance extends PreludeCard {
  constructor() {
    super({
      name: CardName.SMELTING_PLANT_RB,
      tags: [Tag.BUILDING],

      behavior: {
        stock: {steel: 4},
        global: {oxygen: 2},
        drawCard: {count: 1, tag: Tag.BUILDING},
      },

      metadata: {
        cardNumber: 'P30',
        renderData: CardRenderer.builder((b) => {
          b.oxygen(2).br;
          b.steel(4).br;
          b.cards(1, {secondaryTag: Tag.BUILDING});
        }),
        description: 'Raise oxygen 2 steps. Gain 5 steel. Draw a building card.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Prelude_SocietySupportRB.ts
================
import {PreludeCard} from '../../prelude/PreludeCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';
import {IPlayer} from '../../../IPlayer';

export class SocietySupportRebalance extends PreludeCard {
  constructor() {
    super({
      name: CardName.SOCIETY_SUPPORT_RB,
      tags: [Tag.WILD],

      startingMegacredits: -2,
      
      behavior: {
        production: {plants: 1, energy: 1, heat: 1},        
      },

      metadata: {
        cardNumber: 'P31',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.plants(1).energy(1).heat(1);}).br;
            b.megacredits(-3);
        }),
        description: 'Increase your plant, energy and heat production 1 step. Lose 3 M€.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer) {
    return player.canAfford(3);
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 3));
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Project_AdvancedAlloysRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';

export class AdvancedAlloysRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ADVANCED_ALLOYS_RB,      
      cost: 9,

      behavior: {
        steelValue: 1,
        titanumValue: 1,
      },

      metadata: {
        cardNumber: '071',
        renderData: CardRenderer.builder((b) => {
          b.effect('Each titanium you have is worth 1 M€ extra.', (be) => {
            be.titanium(1).startEffect.plus(Size.SMALL).megacredits(1);
          }).br;
          b.effect('Each steel you have is worth 1 M€ extra.', (be) => {
            be.steel(1).startEffect.plus(Size.SMALL).megacredits(1);
          });
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_AerobrakedAmmoniaAsteroidRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class AerobrakedAmmoniaAsteroidRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.AEROBRAKED_AMMONIA_ASTEROID_RB,
      tags: [Tag.SPACE],
      cost: 26,

      behavior: {
        production: {heat: 4, plants: 1},
        addResourcesToAnyCard: {count: 3, type: CardResource.MICROBE},
      },

      metadata: {
        description: 'Increase your heat production 4 steps and your plant production 1 step. Add 3 microbes to ANOTHER card.',
        cardNumber: '1701',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.heat(4).br;
            pb.plants(1);
          }).br;
          b.resource(CardResource.MICROBE, 3).asterix();
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_AsteroidHollowingRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {ActionCard} from '../../ActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';

export class AsteroidHollowingRebalance extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ASTEROID_HOLLOWING_RB,
      tags: [Tag.SPACE],
      cost: 16,
      resourceType: CardResource.ASTEROID,

      action: {
        spend: {titanium: 1},
        production: {megacredits: 1},
        addResources: 1,
      },

      victoryPoints: {resourcesHere: {}},

      metadata: {
        cardNumber: 'X151',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add 1 asteroid resource here and increase M€ production 1 step.', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.ASTEROID).production((pb) => pb.megacredits(1));
          }).br;
          b.vpText('1VP for each asteroid on this card.');
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_BactoviralResearchRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

export class BactoviralResearchRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BACTOVIRAL_RESEARCH_RB,
      tags: [Tag.MICROBE, Tag.SCIENCE],
      cost: 10,

      behavior: {
        drawCard: 1,
        addResourcesToAnyCard: {count: {tag: Tag.MICROBE}, type: CardResource.MICROBE},
      },

      metadata: {
        cardNumber: 'X351',
        renderData: CardRenderer.builder((b) => {
          b.cards(1).br.br; // double br is intentional for visual appeal
          b.resource(CardResource.MICROBE).asterix().slash().tag(Tag.MICROBE);
        }),
        description: 'Draw 1 card. Choose 1 of your played cards and add 1 microbe to it for each microbe tag you have, including this.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_BlackPolarDustRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class BlackPolarDustRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BLACK_POLAR_DUST_RB,
      cost: 13,

      behavior: {
        ocean: {},
        production: {megacredits: -2, heat: 3},
      },

      metadata: {
        cardNumber: '022',
        description: 'Place an ocean tile. Decrease your M€ production 2 steps and increase your heat production 3 steps.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().megacredits(2).br;
            pb.plus().heat(3);
          }).oceans(1);
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_BuildingIndustriesRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class BuildingIndustriesRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BUILDING_INDUSTRIES_RB,
      tags: [Tag.BUILDING],
      cost: 5,

      behavior: {
        production: {energy: -1, steel: 2},
      },

      metadata: {
        cardNumber: '0651',
        description: 'Decrease your energy production 1 step and increase your steel production 2 steps.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().steel(2);
          });
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_CartelRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class CartelRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CARTEL_RB,
      tags: [Tag.EARTH],
      cost: 10,

      behavior: {
        production: {megacredits: {tag: Tag.EARTH}},
      },

      metadata: {
        cardNumber: '1371',
        description: 'Increase your M€ production 1 step for each Earth tag you have, including this.',
        renderData: CardRenderer.builder((b) => b.production((pb) => {
          pb.megacredits(1).slash().tag(Tag.EARTH);
        })),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_CloudSeedingRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {Tag} from '../../../../common/cards/Tag';

export class CloudSeedingRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CLOUD_SEEDING_RB,
      tags: [Tag.PLANT],
      cost: 11,

      behavior: {
        production: {megacredits: -1, plants: 2},
        decreaseAnyProduction: {type: Resource.HEAT, count: 1},
      },

      requirements: {oceans: 3},
      metadata: {
        cardNumber: '0041',
        description: 'Requires 3 ocean tiles. Decrease your M€ production 1 step and any heat production 1 step. Increase your plant production 2 steps.',
        renderData: CardRenderer.builder((b) => b.production((pb) => {
          pb.minus().megacredits(1).heat(1, {all}).br;
          pb.plus().plants(2);
        })),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_CommunityServicesRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {Resource} from '../../../../common/Resource';
import {Card} from '../../Card';
import {CardRenderer} from '../../render/CardRenderer';

export class CommunityServicesRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 11,
      name: CardName.COMMUNITY_SERVICES_RB,
      type: CardType.AUTOMATED,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'C041',
        description: 'Increase your M€ production 1 step per CARD WITH NO TAGS, including this.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1);
          }).slash().noTags();
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.production.add(Resource.MEGACREDITS, player.tags.numberOfCardsWithNoTags() + 1, {log: true});
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Project_CorporateStrongholdRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class CorporateStrongholdRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CORPORATE_STRONGHOLD_RB,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 11,

      behavior: {
        production: {energy: -1, megacredits: 3},
        city: {},
      },
      victoryPoints: -1,

      metadata: {
        cardNumber: '1821',
        description: 'Decrease your energy production 1 step and increase your M€ production 3 steps. Place a city tile.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          }).nbsp.nbsp.city();
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_CuttingEdgeTechnologyRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {AltSecondaryTag} from '../../../../common/cards/render/AltSecondaryTag';

export class CuttingEdgeTechnologyRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CUTTING_EDGE_TECHNOLOGY_RB,
      tags: [Tag.SCIENCE],
      cost: 14,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'X181',
        renderData: CardRenderer.builder((b) => {
          b.effect('When playing a card with a requirement, you pay 2 M€ less for it.', (eb) => {
            eb.cards(1, {secondaryTag: AltSecondaryTag.REQ}).startEffect.megacredits(-2);
          });
        }),
      },
    });
  }

  public override getCardDiscount(_player: IPlayer, card: IProjectCard) {
    return card.requirements.length > 0 ? 2 : 0;
  }
}

================
File: cards/chemical/rebalance/Project_EarthCatapultRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class EarthCatapultRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.EARTH_CATAPULT_RB,
      tags: [Tag.EARTH],
      cost: 26,
      victoryPoints: 1,

      requirements: {tag: Tag.EARTH, count: 2},
      cardDiscount: {amount: 2},
      metadata: {
        cardNumber: '0701',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a card, you pay 2 M€ less for it.', (eb) => {
            eb.empty().startEffect.megacredits(-2);
          });
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_EarthOfficeRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class EarthOfficeRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.EARTH_OFFICE_RB,
      tags: [Tag.EARTH],
      cost: 4,

      cardDiscount: {tag: Tag.EARTH, amount: 3},
      metadata: {
        cardNumber: '1051',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an Earth tag, you pay 3 M€ less for it.', (eb) => {
            eb.tag(Tag.EARTH).startEffect.megacredits(-3);
          });
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_EnergyMarketRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';
import {SelectOption} from '../../../inputs/SelectOption';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectAmount} from '../../../inputs/SelectAmount';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../../render/CardRenderer';

export class EnergyMarketRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ENERGY_MARKET_RB,
      tags: [Tag.POWER],
      cost: 5,

      metadata: {
        cardNumber: 'X031',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2X M€ to gain X energy.', (eb) => {
            eb.megacredits(1, {text: '2x'}).startAction.text('x').energy(1);
          }).br;
          b.or().br;
          b.action('Decrease energy production 1 step to gain 8 M€.', (eb) => {
            eb.production((pb) => pb.energy(1)).startAction.megacredits(8);
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.canAfford(2) || player.production.energy >= 1;
  }

  private getEnergyOption(player: IPlayer, availableMC: number): SelectAmount {
    return new SelectAmount(
      'Select amount of energy to gain', 'Gain energy', 1, Math.floor(availableMC / 2))
      .andThen((amount) => {
        player.game.defer(new SelectPaymentDeferred(player, amount * 2))
          .andThen(() => player.stock.add(Resource.ENERGY, amount, {log: true}));
        return undefined;
      });
  }

  private getMegacreditsOption(player: IPlayer) {
    player.production.add(Resource.ENERGY, -1);
    player.stock.add(Resource.MEGACREDITS, 8);
    player.game.log('${0} decreased energy production 1 step to gain 8 M€', (b) => b.player(player));
    return undefined;
  }

  public action(player: IPlayer) {
    const availableMC = player.spendableMegacredits();
    if (availableMC >= 2 && player.production.energy >= 1) {
      return new OrOptions(
        new SelectOption('Spend 2X M€ to gain X energy', 'Spend M€').andThen(() => {
          return this.getEnergyOption(player, availableMC);
        }),
        new SelectOption('Decrease energy production 1 step to gain 8 M€', 'Decrease energy').andThen(() => {
          return this.getMegacreditsOption(player);
        }),
      );
    } else if (availableMC >= 2) {
      return this.getEnergyOption(player, availableMC);
    } else if (player.production.energy >= 1) {
      return this.getMegacreditsOption(player);
    }
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Project_EnergySavingRB.ts
================
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {Size} from '../../../../common/cards/render/Size';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';

export class EnergySavingRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ENERGY_SAVING_RB,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 16,

      behavior: {
        production: {energy: {cities: {}}},
      },

      metadata: {
        cardNumber: '1891',
        description: 'Increase your energy production 1 step for each city tile in play.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).slash().city({size: Size.SMALL, all}));
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_ExtractorBalloonsRB.ts
================
import {IActionCard} from '../../ICard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {CardName} from '../../../../common/cards/CardName';
import {MAX_VENUS_SCALE} from '../../../../common/constants';
import {LogHelper} from '../../../LogHelper';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Card} from '../../Card';

export class ExtractorBalloonsRebalance extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.EXTRACTOR_BALLOONS_RB,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 18,
      resourceType: CardResource.FLOATER,

      behavior: {
        addResources: 3,
      },

      // action: {
      //   or: {
      //     autoSelect: true,
      //     behaviors: [{
      //       title: 'Remove 2 floaters here to raise Venus 1 step.',
      //       spend: {resourcesHere: 2},
      //       global: {venus: 1},
      //       // Don't offer this if Venus isn't maximized?
      //       // // // LogHelper.logRemoveResource(player, this, 2, 'raise oxygen 1 step');
      //     },
      //     {
      //       title: 'Add 1 floater to this card.',
      //       addResources: 1,
      //     }],
      //   },
      // },

      metadata: {
        cardNumber: '2231',
        description: 'Add 3 floaters to this card',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER);
          }).br;
          b.action('Remove 2 floaters here to raise Venus 1 step.', (eb) => {
            eb.or(Size.SMALL).resource(CardResource.FLOATER, 2).startAction.venus(1);
          }).br.resource(CardResource.FLOATER, 3);
        }),
      },
    });
  }

  public canAct(): boolean {
    return true;
  }
  public action(player: IPlayer) {
    const venusMaxed = player.game.getVenusScaleLevel() === MAX_VENUS_SCALE;
    const canAffordReds = player.canAfford({cost: 0, tr: {venus: 1}});
    if (this.resourceCount < 2 || venusMaxed || !canAffordReds) {
      player.addResourceTo(this, {log: true});
      return undefined;
    }
    return new OrOptions(
      new SelectOption('Remove 2 floaters to raise Venus scale 1 step',
        'Remove floaters').andThen(() => {
        player.removeResourceFrom(this, 2);
        const actual = player.game.increaseVenusScaleLevel(player, 1);
        LogHelper.logVenusIncrease(player, actual);
        return undefined;
      }),
      new SelectOption('Add 1 floater to this card', 'Add floater').andThen(() => {
        player.addResourceTo(this, {log: true});
        return undefined;
      }),
    );
  }
}

================
File: cards/chemical/rebalance/Project_ForcedPrecipitationRB.ts
================
import {IActionCard} from '../../ICard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {MAX_VENUS_SCALE} from '../../../../common/constants';
import {CardName} from '../../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';
import {LogHelper} from '../../../LogHelper';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {TITLES} from '../../../inputs/titles';

export class ForcedPrecipitationRebalance extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.FORCED_PRECIPITATION_RB,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 4,
      resourceType: CardResource.FLOATER,

      metadata: {
        cardNumber: '2261',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 M€ to add 1 floater to THIS card.', (eb) => {
            eb.megacredits(2).startAction.resource(CardResource.FLOATER);
          }).br;
          b.or().br;
          b.action('Spend 2 floaters here to increase Venus 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.venus(1);
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    if (player.canAfford(2)) {
      return true;
    }
    if (this.resourceCount > 1 && player.canAfford({cost: 0, tr: {venus: 1}})) {
      if (player.game.getVenusScaleLevel() === MAX_VENUS_SCALE) {
        this.warnings.add('maxvenus');
      }
      return true;
    }
    return false;
  }

  public action(player: IPlayer) {
    const opts = [];

    const addResource = new SelectOption('Pay 2 M€ to add 1 floater to this card', 'Pay').andThen(() => this.addResource(player));
    const spendResource = new SelectOption('Remove 2 floaters to raise Venus 1 step', 'Remove floaters').andThen(() => this.spendResource(player));
    if (player.game.getVenusScaleLevel() === MAX_VENUS_SCALE) {
      spendResource.warnings = ['maxvenus'];
    }
    if (this.resourceCount > 1 && player.canAfford({cost: 0, tr: {venus: 1}})) {
      opts.push(spendResource);
    } else {
      return this.addResource(player);
    }

    if (player.canAfford(2)) {
      opts.push(addResource);
    } else {
      return this.spendResource(player);
    }

    return new OrOptions(...opts);
  }

  private addResource(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 2, {title: TITLES.payForCardAction(this.name)}))
      .andThen(() => player.addResourceTo(this, {log: true}));
    return undefined;
  }

  private spendResource(player: IPlayer) {
    player.removeResourceFrom(this, 2);
    const actual = player.game.increaseVenusScaleLevel(player, 1);
    LogHelper.logVenusIncrease(player, actual);
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Project_GHGImportFromVenusRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {IProjectCard} from '../../IProjectCard';

export class GHGImportFromVenusRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.GHG_IMPORT_FROM_VENUS_RB,
      type: CardType.EVENT,
      tags: [Tag.SPACE, Tag.VENUS],
      cost: 20,

      behavior: {
        production: {heat: 3},
        global: {venus: 1},
      },

      metadata: {
        description: 'Raise Venus 1 step. Increase your heat production 3 steps.',
        cardNumber: '2281',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).production((pb) => {
            pb.heat(3);
          });
        }),
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_GMOContractRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {Resource} from '../../../../common/Resource';
import {CardRenderer} from '../../render/CardRenderer';

export class GMOContractRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.GMO_CONTRACT_RB,
      tags: [Tag.MICROBE, Tag.SCIENCE],
      cost: 6,

      requirements: {party: PartyName.GREENS},
      metadata: {
        description: 'Requires that Greens are ruling or that you have 2 delegates there.',
        cardNumber: 'T06',
        renderData: CardRenderer.builder((b) => {
          b.effect('Each time you play a plant, animal or microbe tag, including this, gain 2 M€.', (be) => {
            be.tag(Tag.ANIMAL).slash().tag(Tag.PLANT).slash().tag(Tag.MICROBE);
            be.startEffect.megacredits(2);
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const amount = player.tags.cardTagCount(card, [Tag.ANIMAL, Tag.PLANT, Tag.MICROBE]);
    if (amount > 0) {
      player.defer(() => player.stock.add(Resource.MEGACREDITS, amount * 2, {log: true}));
    }
  }
}

================
File: cards/chemical/rebalance/Project_HackersRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {PlayerInput} from '../../../PlayerInput';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';

export class HackerRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HACKERS_RB,
      cost: 3,
      victoryPoints: -1,

      behavior: {
        production: {energy: -1, megacredits: 2},
      },

      metadata: {
        cardNumber: '1251',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).megacredits(1, {all}).br;
            pb.plus().megacredits(3);
          });
        }),
        description: 'Decrease your energy production 1 step and EACH OPPONENTS M€ 1 step. Increase your M€ production 3 steps.',
      },
    });
  }

  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    player.game.getPlayers().filter((p) => p.id !== player.id).forEach((opponent) => {
      opponent.production.add(Resource.MEGACREDITS, -1, {log: true});
    });
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Project_HeatTrappersRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';

export class HeatTrappersRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HEAT_TRAPPERS_RB,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 6,      
      victoryPoints: -1,

      behavior: {
        decreaseAnyProduction: {type: Resource.HEAT, count: 2},
        production: {energy: 1},
      },
      requirements: {temperature: -22},
      metadata: {
        cardNumber: '178',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().heat(2, {all}).br;
            pb.plus().energy(1);
          });
        }),
        description: 'Requires -22C or warmer. Decrease any heat production 2 steps and increase your energy production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_IndustrialCenterAresRB.ts
================
import {CardName} from '../../../../common/cards/CardName';
import {SpaceBonus} from '../../../../common/boards/SpaceBonus';
import {IndustrialCenter} from '../../base/IndustrialCenter';
import {TileType} from '../../../../common/TileType';
import {CardRenderer} from '../../render/CardRenderer';

export class IndustrialCenterRebalance extends IndustrialCenter {
  constructor() {
    super(
      CardName.INDUSTRIAL_CENTER_RB,
      {bonus: [SpaceBonus.STEEL]},
      {
        cardNumber: 'A101',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 6 M€ to increase your steel production 1 step.', (eb) => {
            eb.megacredits(6).startAction.production((pb) => pb.steel(1));
          }).br;
          b.tile(TileType.INDUSTRIAL_CENTER, false, true).asterix();
        }),
        description: 'Place this tile adjacent to a city tile. This tile grants an ADJACENCY BONUS of 1 steel.',
      });
  }
}

================
File: cards/chemical/rebalance/Project_InsectsRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class InsectsRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INSECTS_RB,
      tags: [Tag.MICROBE],
      cost: 11,

      behavior: {
        production: {plants: {tag: Tag.PLANT}},
      },

      requirements: {oxygen: 6},
      metadata: {
        cardNumber: '1481',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1).slash().tag(Tag.PLANT));
        }),
        description: 'Requires 6% oxygen. Increase your plant production 1 step for each plant tag you have.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_JetStreamMicroscrappersRB.ts
================
import {IActionCard} from '../../ICard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {MAX_VENUS_SCALE} from '../../../../common/constants';
import {CardName} from '../../../../common/cards/CardName';
import {LogHelper} from '../../../LogHelper';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {Payment} from '../../../../common/inputs/Payment';

export class JetStreamMicroscrappersRebalance extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.JET_STREAM_MICROSCRAPPERS_RB,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 7,
      resourceType: CardResource.FLOATER,

      metadata: {
        cardNumber: '2341',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add 2 floaters here', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.FLOATER, 2);
          }).br;
          b.or().br;
          b.action('Spend 2 floaters here to raise Venus 1 step', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.venus(1);
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    const venusMaxed = player.game.getVenusScaleLevel() === MAX_VENUS_SCALE;
    const canSpendResource = this.resourceCount > 1 && !venusMaxed;

    return player.titanium > 0 || (canSpendResource && player.canAfford({cost: 0, tr: {venus: 1}}));
  }

  public action(player: IPlayer) {
    const opts = [];

    const addResource = new SelectOption('Spend one titanium to add 2 floaters to this card', 'Spend titanium').andThen(() => this.addResource(player));
    const spendResource = new SelectOption('Remove 2 floaters to raise Venus 1 step', 'Remove floaters').andThen(() => this.spendResource(player));

    if (this.resourceCount > 1 && player.game.getVenusScaleLevel() < MAX_VENUS_SCALE) {
      opts.push(spendResource);
    } else {
      return this.addResource(player);
    }

    if (player.titanium > 0) {
      opts.push(addResource);
    } else {
      return this.spendResource(player);
    }

    return new OrOptions(...opts);
  }

  private addResource(player: IPlayer) {
    player.addResourceTo(this, {qty: 2, log: true});
    player.pay(Payment.of({titanium: 1}));
    return undefined;
  }

  private spendResource(player: IPlayer) {
    player.removeResourceFrom(this, 2);
    const actual = player.game.increaseVenusScaleLevel(player, 1);
    LogHelper.logVenusIncrease(player, actual);
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Project_MarsUniversityRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectCard} from '../../../inputs/SelectCard';
import {SelectOption} from '../../../inputs/SelectOption';
import {CardName} from '../../../../common/cards/CardName';
import {Priority} from '../../../deferredActions/Priority';
import {CardRenderer} from '../../render/CardRenderer';

export class MarsUniversityRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MARS_UNIVERSITY_RB,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 12,      

      metadata: {
        cardNumber: '0731',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a science tag, including this, you may discard a card from hand to draw a card.', (eb) => {
            eb.tag(Tag.SCIENCE).startEffect.minus().cards(1).nbsp.plus().cards(1);
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    const scienceTags = player.tags.cardTagCount(card, Tag.SCIENCE);
    this.onScienceTagAdded(player, scienceTags);
  }
  public onColonyAddedToLeavitt(player: IPlayer) {
    this.onScienceTagAdded(player, 1);
  }
  public onScienceTagAdded(player: IPlayer, count: number) {
    for (let i = 0; i < count; i++) {
      player.defer(() => {
        // No card to discard
        if (player.cardsInHand.length === 0) {
          return undefined;
        }
        return new OrOptions(
          new SelectCard('Select a card to discard', 'Discard', player.cardsInHand)
            .andThen(([card]) => {
              player.game.log('${0} is using their ${1} effect to draw a card by discarding a card.', (b) => b.player(player).card(this));
              player.discardCardFromHand(card, {log: true});
              player.drawCard();
              return undefined;
            }),
          new SelectOption('Do nothing'),
        );
      },
      Priority.DISCARD_AND_DRAW);
    }
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Project_MassConverterRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class MassConverterRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MASS_CONVERTER_RB,
      tags: [Tag.SCIENCE, Tag.POWER],
      cost: 8,

      behavior: {
        production: {energy: 6},
      },

      requirements: {tag: Tag.SCIENCE, count: 6},
      cardDiscount: {tag: Tag.SPACE, amount: 2, per: 'card'},
      metadata: {
        cardNumber: '0941',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => pb.energy(6));
        }),
        description: 'Requires 6 science tags. Increase your energy production 6 steps.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_MeatIndustryRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {ICard} from '../../ICard';
import {CardResource} from '../../../../common/CardResource';
import {Resource} from '../../../../common/Resource';

export class MeatIndustryRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MEAT_INDUSTRY_RB,
      tags: [Tag.BUILDING],
      cost: 10,

      metadata: {
        cardNumber: 'X251',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you gain an animal to ANY CARD, gain 2 M€.', (eb) => {
            eb.resource(CardResource.ANIMAL).asterix().startEffect.megacredits(2);
          });
        }),
      },
    });
  }

  public onResourceAdded(player: IPlayer, card: ICard, count: number) {
    if (card.resourceType === CardResource.ANIMAL) {
      player.stock.add(Resource.MEGACREDITS, count * 2, {log: true});
    }
  }
}

================
File: cards/chemical/rebalance/Project_MicroMillsRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class MicroMillsRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MICRO_MILLS_RB,
      cost: 2,

      behavior: {
        production: {heat: 1},
      },

      metadata: {
        cardNumber: '1641',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(1));
        }),
        description: 'Increase your heat production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_OrbitalCleanupRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {ActionCard} from '../../ActionCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';

export class OrbitalCleanupRebalance extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ORBITAL_CLEANUP_RB,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 14,
      victoryPoints: 2,    

      action: {
        stock: {megacredits: {tag: Tag.SCIENCE, per: 2}},
      },

      metadata: {
        cardNumber: 'X081',

        renderData: CardRenderer.builder((b) => {
          b.action('Gain 1 M€ per every two Science tag you have.', (eb) => {
            eb.empty().startAction.megacredits(1).slash().tag(Tag.SCIENCE, 2);
          }).br;     
        }), 
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_OutdoorSportsRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {all, nextTo} from '../../Options';
import {Board} from '../../../boards/Board';

export class OutdoorSportsRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.OUTDOOR_SPORTS_RB,
      cost: 8,
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 3},
      },

      requirements: [{cities: 1, all, nextTo}, {oceans: 1}],
      metadata: {
        cardNumber: 'X381',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(3);
          });
        }),
        description: 'Requires any city adjacent to an ocean. Increase your M€ production 3 steps.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    const board = player.game.board;
    const oceans = board.getOceanSpaces({upgradedOceans: true, wetlands: true});
    return oceans.some((ocean) => board.getAdjacentSpaces(ocean).some((space) => Board.isCitySpace(space)));
  }
}

================
File: cards/chemical/rebalance/Project_ReleaseOfInertGasesRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ReleaseOfInertGasesRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.RELEASE_OF_INERT_GASES_RB,
      cost: 13,

      behavior: {
        tr: 2,
      },

      metadata: {
        cardNumber: '0361',
        renderData: CardRenderer.builder((b) => {
          b.tr(2);
        }),
        description: 'Raise your terraforming rating 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_ResearchOutpostRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ResearchOutpostRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.RESEARCH_OUTPOST_RB,
      tags: [Tag.SCIENCE, Tag.CITY, Tag.BUILDING],
      cost: 18,
      victoryPoints: -1,

      behavior: {
        city: {on: 'isolated'},
      },

      cardDiscount: {amount: 1},
      metadata: {
        cardNumber: '020',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a card, you pay 1 M€ less for it.', (eb) => {
            eb.empty().startEffect.megacredits(-1);
          }).br;
          b.city();
        }),
        description: 'Place a city tile NEXT TO NO OTHER TILE.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_RotatorImpactsRB.ts
================
import {IActionCard} from '../../ICard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {CardName} from '../../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {max} from '../../Options';
import {TITLES} from '../../../inputs/titles';
import {SelectCard} from '../../../inputs/SelectCard';
import {ICard} from '../../ICard';


export class RotatorImpactsRebalance extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.ROTATOR_IMPACTS_RB,
      type: CardType.ACTIVE,
      tags: [Tag.SPACE],
      cost: 6,
      resourceType: CardResource.ASTEROID,

      requirements: {venus: 14, max},
      metadata: {
        cardNumber: '2431',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 6 M€ to add an asteroid resource to ANY card [TITANIUM MAY BE USED].', (eb) => {
            eb.megacredits(6).super((b) => b.titanium(1)).startAction.resource(CardResource.ASTEROID).asterix;
          }).br;
          b.action('Spend 1 resource from this card to increase Venus 1 step.', (eb) => {
            eb.or().resource(CardResource.ASTEROID).startAction.venus(1);
          });
        }),
        description: 'Venus must be 14% or lower',
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.canAfford({cost: 6, titanium: true}) || (this.resourceCount > 0 && player.canAfford({cost: 0, tr: {venus: 1}}));
  }

  public action(player: IPlayer) {
    const asteroidCards = player.getResourceCards(CardResource.ASTEROID);
    const opts: Array<SelectOption> = [];

    const addResource = new SelectOption('Pay 6 M€ to add 1 asteroid to any card', 'Pay').andThen( () => this.addResource(player, asteroidCards) );
    const spendResource = new SelectOption('Remove 1 asteroid to raise venus 1 step', 'Remove asteroid').andThen( () => this.spendResource(player) );

    if (this.resourceCount > 0) {
      opts.push(spendResource);
    } else {
      return this.addResource(player, asteroidCards);
    }

    if (player.canAfford({cost: 6, titanium: true})) {
      opts.push(addResource);
    } else {
      return this.spendResource(player);
    }

    return new OrOptions(...opts);
  }

  private addResource(player: IPlayer, asteroidCards: ICard[]) {
    player.game.defer(new SelectPaymentDeferred(player, 6, {canUseTitanium: true, title: TITLES.payForCardAction(this.name)}));

    if (asteroidCards.length === 1) {
      player.addResourceTo(this, {log: true});
      return undefined;
    }

    return new SelectCard(
      'Select card to add 1 asteroid',
      'Add asteroid',
      asteroidCards).andThen( ([card]) => {
      player.addResourceTo(card, {log: true});
      return undefined;
    },
    );
  }

  private spendResource(player: IPlayer) {
    player.removeResourceFrom(this);
    player.game.increaseVenusScaleLevel(player, 1);
    player.game.log('${0} removed an asteroid resource to increase Venus 1 step', (b) => b.player(player));
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Project_SkyDocksRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';

export class SkyDocksRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 18,
      tags: [Tag.SPACE, Tag.EARTH],
      name: CardName.SKY_DOCKS_RB,
      type: CardType.ACTIVE,
      victoryPoints: 1,

      behavior: {
        colonies: {addTradeFleet: 1},
      },

      requirements: {tag: Tag.EARTH, count: 2},
      cardDiscount: {amount: 1},
      metadata: {
        cardNumber: 'C36',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a card, you pay 1 M€ less for it.', (eb) => {
            eb.empty().startEffect.megacredits(-1);
          }).br;
          b.tradeFleet();
        }),
        description: 'Requires 2 Earth tags. Gain 1 Trade Fleet.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_SnowAlgaeRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {Tag} from '../../../../common/cards/Tag';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';

export class SnowAlgaeRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SNOW_ALGAE_RB,
      cost: 11,
      tags: [Tag.PLANT],

      behavior: {
        production: {plants: 1, heat: 1},
      },

      requirements: {oceans: 2},
      metadata: {
        cardNumber: '211',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.plants(1).heat(1);
          });
        }),
        description: 'Requires 2 oceans. Increase your plant production and your heat production 1 step each.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_SoilFactoryRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class SoilFactoryRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SOIL_FACTORY_RB,
      tags: [Tag.BUILDING],
      cost: 12,

      behavior: {
        production: {energy: -1, plants: 2},
      },
      victoryPoints: 1,

      metadata: {
        cardNumber: '1791',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().plants(2);
          });
        }),
        description: 'Decrease your energy production 1 step and increase your plant production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_SolarPowerRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class SolarPowerRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SOLAR_POWER_RB,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 10,

      behavior: {
        production: {energy: 1},
      },
      victoryPoints: 1,

      metadata: {
        cardNumber: '113',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1));
        }),
        description: 'Increase your energy production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_SpinoffDepartmentRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';

export class SpinoffDepartmentRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 13,
      tags: [Tag.BUILDING],
      name: CardName.SPINOFF_DEPARTMENT_RB,
      type: CardType.ACTIVE,

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'C41',
        renderData: CardRenderer.builder((b) => {
          b.effect('WHEN PLAYING A CARD WITH A BASIC COST OF 20M€ OR MORE, draw a card.', (eb) => {
            eb.megacredits(20).asterix().startEffect.cards(1);
          }).br;
          b.production((pb) => pb.megacredits(2));
        }),
        description: 'Increase your M€ production 2 steps.',
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.cost >= 20) {
      player.drawCard();
    }
  }
}

================
File: cards/chemical/rebalance/Project_StratopolisRB.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {SpaceName} from '../../../SpaceName';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class StratopolisRebalance extends ActionCard {
  constructor() {
    super({
      name: CardName.STRATOPOLIS_RB,
      type: CardType.ACTIVE,
      tags: [Tag.CITY, Tag.VENUS],
      cost: 20,

      resourceType: CardResource.FLOATER,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {tag: Tag.SCIENCE, count: 2},

      behavior: {
        production: {megacredits: 2},
        city: {space: SpaceName.STRATOPOLIS},
      },

      action: {
        addResourcesToAnyCard: {
          count: 2,
          tag: Tag.VENUS,
          type: CardResource.FLOATER,
          autoSelect: true,
        },
      },

      metadata: {
        cardNumber: '248',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 2 floaters to ANY VENUS CARD.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.VENUS});
          }).br;
          b.production((pb) => pb.megacredits(2)).city().asterix();
          b.vpText('1 VP for every 2nd Floater on this card.');
        }),
        description: {
          text: 'Requires 2 science tags. Increase your M€ production 2 steps. Place a city tile ON THE RESERVED AREA',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_StripMineRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class StripMineRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.STRIP_MINE_RB,
      tags: [Tag.BUILDING],
      cost: 23,

      behavior: {
        production: {energy: -2, steel: 2, titanium: 1},
        global: {oxygen: 2},
      },

      metadata: {
        cardNumber: '138',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().steel(2).titanium(1);
          }).br;
          b.oxygen(2);
        }),
        description: 'Decrease your energy production 2 steps. Increase your steel production 2 steps and your titanium production 1 step. Raise oxygen 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_TitanAirScrappingRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardResource} from '../../../../common/CardResource';
import {SelectOption} from '../../../inputs/SelectOption';
import {OrOptions} from '../../../inputs/OrOptions';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {Payment} from '../../../../common/inputs/Payment';

export class TitanAirScrappingRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 21,
      tags: [Tag.JOVIAN],
      name: CardName.TITAN_AIRSCRAPPING_RB,
      type: CardType.ACTIVE,
      resourceType: CardResource.FLOATER,
      victoryPoints: 2,

      metadata: {
        cardNumber: 'C431',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add 4 floaters here.', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.FLOATER, 4);
          }).br;
          b.or().br;
          b.action('Spend 2 floaters here to increase your TR 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.tr(1);
          });
        }),
      },
    });
  }


  public canAct(player: IPlayer): boolean {
    if (player.titanium > 0) {
      return true;
    }
    if (this.resourceCount >= 2) {
      return player.canAfford({cost: 0, tr: {tr: 1}});
    }
    return false;
  }

  public action(player: IPlayer) {
    const opts = [];

    const addResource = new SelectOption('Spend 1 titanium to add 4 floaters on this card', 'Spend titanium').andThen(() => this.addResource(player));
    const spendResource = new SelectOption('Remove 2 floaters on this card to increase your TR 1 step', 'Remove floaters').andThen(() => this.spendResource(player));

    if (this.resourceCount >= 2 && player.canAfford({cost: 0, tr: {tr: 1}})) {
      opts.push(spendResource);
    }


    if (player.titanium > 0) {
      opts.push(addResource);
    }

    if (opts.length === 1) {
      return opts[0].cb(undefined);
    }

    return new OrOptions(...opts);
  }

  private addResource(player: IPlayer) {
    player.pay(Payment.of({titanium: 1}));
    player.addResourceTo(this, {qty: 4, log: true});
    return undefined;
  }

  private spendResource(player: IPlayer) {
    player.removeResourceFrom(this, 2);
    player.increaseTerraformRating();
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Project_TollStationRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';

export class TollStationRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TOLL_STATION_RB,
      tags: [Tag.SPACE],
      cost: 14,

      behavior: {
        production: {megacredits: {tag: Tag.SPACE, others: true}},
      },

      metadata: {
        cardNumber: '099',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).slash().tag(Tag.SPACE, {all}).asterix();
          });
        }),
        description: 'Increase your M€ production 1 step for each space tag your OPPONENTS have.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_TopsoilContractRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardName} from '../../../../common/cards/CardName';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardRenderer} from '../../render/CardRenderer';
import {ICard} from '../../ICard';
import {CardResource} from '../../../../common/CardResource';
import {Resource} from '../../../../common/Resource';

export class TopsoilContractRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TOPSOIL_CONTRACT_RB,
      tags: [Tag.MICROBE, Tag.EARTH],
      cost: 10,

      behavior: {
        stock: {plants: 3},
      },

      metadata: {
        cardNumber: 'X30',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you gain a microbe to ANY CARD, also gain 1 M€.', (eb) => {
            eb.resource(CardResource.MICROBE).asterix().startEffect.megacredits(1);
          }).br;
          b.plants(3);
        }),
        description: 'Gain 3 plants.',
      },
    });
  }

  public onResourceAdded(player: IPlayer, card: ICard, count: number) {
    if (card.resourceType === CardResource.MICROBE) {
      player.stock.add(Resource.MEGACREDITS, count, {log: true});
    }
  }
}

================
File: cards/chemical/rebalance/Project_TropicalResortRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class TropicalResortRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TROPICAL_RESORT_RB,
      tags: [Tag.BUILDING],
      cost: 11,

      behavior: {
        production: {megacredits: 3, heat: -2},
      },
      victoryPoints: 2,

      metadata: {
        cardNumber: '098',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) =>{
            pb.minus().heat(2).br;
            pb.plus().megacredits(3);
          });
        }),
        description: 'Reduce your heat production 2 steps and increase your M€ production 3 steps.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_UndergroundCityRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class UndergroundCityRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.UNDERGROUND_CITY_RB,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 18,

      behavior: {
        production: {energy: -1, steel: 2},
        city: {},
      },

      metadata: {
        cardNumber: '032',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().steel(2);
          }).nbsp.city();
        }),
        description: 'Place a city tile. Decrease your energy production 1 step and increase your steel production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_UndergroundDetonationsRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';
import {SelectPaymentDeferred} from '../../../deferredActions/SelectPaymentDeferred';
import {TITLES} from '../../../inputs/titles';
import { Card } from '../../Card';


export class UndergroundDetonationsRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.UNDERGROUND_DETONATIONS_RB,
      tags: [Tag.BUILDING],
      cost: 2,    

      metadata: {
        cardNumber: '202',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 8M€ to increase your heat production 2 steps. STEEL MAY BE USED', (eb) => {
            eb.megacredits(8).super((b) => b.steel(1)).startAction.production((pb)=>pb.heat(2));
          });
        }),
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.canAfford({cost: 8, steel: true});
  }
  public action(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 8, {canUseSteel: true, title: TITLES.payForCardAction(this.name)}))
      .andThen(() => player.production.add(Resource.HEAT, 2));
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Project_ViralEnhancersRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';

import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {CardName} from '../../../../common/cards/CardName';
import {CardResource} from '../../../../common/CardResource';
import {CardRenderer} from '../../render/CardRenderer';
import {message} from '../../../logs/MessageBuilder';

export class ViralEnhancersRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.VIRAL_ENHANCERS_RB,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      cost: 10,

      metadata: {
        cardNumber: '0741',
        renderData: CardRenderer.builder((b) => {
          b.tag(Tag.PLANT).slash().tag(Tag.MICROBE).slash().tag(Tag.ANIMAL).br;
          b.effect('When you play a plant, microbe, or an animal tag, including this, gain 1 plant or add 1 resource to THAT CARD.', (eb) => {
            eb.empty().startEffect;
            eb.plants(1).slash().resource(CardResource.MICROBE).asterix().slash().resource(CardResource.ANIMAL).asterix();
          });
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    const resourceCount = player.tags.cardTagCount(card, [Tag.ANIMAL, Tag.PLANT, Tag.MICROBE]);
    if (resourceCount === 0) {
      return undefined;
    }

    if (card.resourceType !== CardResource.ANIMAL && card.resourceType !== CardResource.MICROBE) {
      player.plants += resourceCount;
      return undefined;
    }

    for (let i = 0; i < resourceCount; i++) {
      player.defer(
        () => new OrOptions(
          new SelectOption(message('Add resource to card ${0}', (b) => b.card(card)), 'Add resource').andThen(() => {
            player.addResourceTo(card);
            return undefined;
          }),
          new SelectOption('Gain plant').andThen(() => {
            player.plants++;
            return undefined;
          }),
        ),
      );
    }
    return undefined;
  }
}

================
File: cards/chemical/rebalance/Project_WarpDriveRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';

export class WarpDriveRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 16,
      tags: [Tag.SCIENCE],
      name: CardName.WARP_DRIVE_RB,
      type: CardType.ACTIVE,
      victoryPoints: 2,

      requirements: {tag: Tag.SCIENCE, count: 5},
      cardDiscount: {tag: Tag.SPACE, amount: 4},
      metadata: {
        cardNumber: 'C49',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 4 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-4);
          });
        }),
        description: 'Requires 5 science tags.',
      },
    });
  }
}

================
File: cards/chemical/rebalance/Project_ZeppelinsRB.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {all} from '../../Options';

export class ZeppelinsRebalance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ZEPPELINS_RB,
      cost: 11,
      victoryPoints: 1,

      behavior: {
        production: {megacredits: {cities: {where: 'onmars'}}},
      },

      requirements: {oxygen: 5},
      metadata: {
        cardNumber: '129',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).slash();
            pb.city({size: Size.SMALL, all}).asterix();
          });
        }),
        description: 'Requires 5% oxygen. Increase your M€ production 1 step for each city tile ON MARS.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/AcquiredBioengineeringFirm.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {PartyName} from '../../../../common/turmoil/PartyName';

export class AcquiredBioengineeringFirm extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ACQUIRED_BIOENGINEERING_FIRM,
      cost: 8,
      tags: [Tag.PLANT, Tag.EARTH],
      requirements: {party: PartyName.GREENS},

      behavior: {
        production: {plants: 1},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'x413',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.plants(1);
          }).plants(2);
        }),
        description: 'Requires that Greens are in power or that you have 2 delegates there. Increase your plant production 1 step and gain 2 plants.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/AcquiredConsultingFirm.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {all} from '../../Options';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {Resource} from '../../../../common/Resource';
import {Turmoil} from '../../../turmoil/Turmoil';

export class AcquiredConsultingFirm extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ACQUIRED_CONSULTING_FIRM,
      cost: 8,
      tags: [Tag.EARTH],

      metadata: {
        cardNumber: 'x420',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(1).slash().delegates(1, {all});
        }),
        description: 'Gain 1 M€ for each active delegate.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    let delegates = 0;
    Turmoil.getTurmoil(player.game).parties.forEach((party) => delegates += party.delegates.size);
    player.stock.add(Resource.MEGACREDITS, delegates, {log: true});
    return undefined;
  }
}

================
File: cards/chemical/turmoil/AuthoritarianState.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {all} from '../../Options';
import {Size} from '../../../../common/cards/render/Size';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {Resource} from '../../../../common/Resource';

export class AuthoritarianState extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.AUTHORITARIAN_STATE,
      cost: 14,
      tags: [Tag.CITY, Tag.BUILDING],
      victoryPoints: -2,

      behavior: {
        production: {megacredits: 3, energy: -1},
        city: {},
      },

      metadata: {
        cardNumber: 'x411',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          });
          b.city().asterix().br;
          b.text('Steal').nbsp.megacredits(3, {all}).slash().emptyTile('normal', {size: Size.SMALL, all}).asterix();
        }),
        description: 'Decrease your energy production 1 step and increase your M€ production 3 steps. Place a city tile, then, for each adjacent tile, steal 3 M€ from the owner of that tile.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const usedSpace = player.game.board.getSpaceByTileCard(this.name);
    if (usedSpace !== undefined) {
      player.game.board.getAdjacentSpaces(usedSpace).forEach((space) => {
        space.player?.stock.deduct(Resource.MEGACREDITS, 3, {log: true, from: player, stealing: true});
        return undefined;
      });
    }
    return undefined;
  }
}

================
File: cards/chemical/turmoil/CommitteeCoalition.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class CommitteeCoalition extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.COMMITTEE_COALITION,
      cost: 4,

      metadata: {
        cardNumber: 'x401',
        renderData: CardRenderer.builder((b) => {
          b.effect('If you have a party leader in a NON-DOMINANT PARTY, you have +1 influence.',
            (eb) => eb.partyLeaders(1).asterix().nbsp.startEffect.nbsp.plus().influence());
        }),
      },
    });
  }
  // effect handled in Turmoil.ts
}

================
File: cards/chemical/turmoil/CorporateCitadel.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {PartyName} from '../../../../common/turmoil/PartyName';

export class CorporateCitadel extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CORPORATE_CITADEL,
      cost: 11,
      tags: [Tag.SPACE],
      requirements: {party: PartyName.UNITY},
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 4, energy: -1},
      },

      metadata: {
        cardNumber: 'x409',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(4);
          });
        }),
        description: 'Requires that Unity are in power or that you have 2 delegates there. Decrease your energy production 1 step and increase your M€ production 4 steps.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/DemocraticReform.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {all} from '../../Options';
/* import {IPlayer} from '../../IPlayer';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectDelegate} from '../../inputs/SelectDelegate';
import {Turmoil} from '../../turmoil/Turmoil';
import {NeutralPlayer} from '../../turmoil/Turmoil';
import {Delegate} from '../../turmoil/Turmoil';
import {MultiSet} from 'mnemonist';
import {SimpleDeferredAction} from '../../deferredActions/DeferredAction';
import {SelectParty} from '../../inputs/SelectParty';
import {IParty} from '../../turmoil/parties/IParty';*/

export class DemocraticReform extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.DEMOCRATIC_REFORM,
      cost: 7,
      requirements: {party: PartyName.MARS},

      metadata: {
        cardNumber: 'x387',
        renderData: CardRenderer.builder((b) => {
          b.minus().delegates(2, {all}).nbsp.plus().delegates(2).asterix();
        }),
        description: 'Requires that Mars First are in power or that you have 2 delegates there. Remove any 2 non-leader delegates and add 2 NEUTRAL delegates to any parties.',
      },
    });
  }
  /* public override bespokeCanPlay(player: IPlayer): boolean {
    const turmoil = Turmoil.getTurmoil(player.game);
    var nonLeaderDelegates = 0;
    for (const party of turmoil.parties) {
      if (party.delegates.size > 1) {
        nonLeaderDelegates += party.delegates.size - 1;
      }
    }
    return nonLeaderDelegates >= 2;
  }
  public override bespokePlay(player: IPlayer): undefined {
    player.game.defer(new SimpleDeferredAction(player, () => this.removeDelegate(player))).andThen(() => {
      return this.removeDelegate(player)?.andThen(() => {
        const turmoil = Turmoil.getTurmoil(player.game);
        return new SelectParty('Select a party to add a neutral delegate','add delegate', turmoil.parties.map((party) => party.name)).andThen((party) => {
          turmoil.sendDelegateToParty('NEUTRAL', party, player.game);
          return new SelectParty('Select a party to add a neutral delegate','add delegate', turmoil.parties.map((party) => party.name)).andThen((party) => {
            turmoil.sendDelegateToParty('NEUTRAL', party, player.game);
            return undefined;
          });
        });
        })
      });
      return undefined
  }

  private log(player: IPlayer, party: IParty, selectedPlayer: IPlayer | NeutralPlayer) {
    if (selectedPlayer === 'NEUTRAL') {
      player.game.log('${0} removed neutral delegate from ${1}', (b) => b.player(player).party(party));
    } else {
      player.game.log('${0} removed ${1}\'s delegate from ${2}', (b) => b.player(player).player(selectedPlayer).party(party));
    }
  }

  private removeDelegate(player: IPlayer): OrOptions | SelectDelegate | undefined {
    const turmoil = Turmoil.getTurmoil(player.game);
    const orOptions: Array<SelectDelegate> = [];
    // Take each party having more than just the party leader in the area
    for (const party of turmoil.parties) {
      if (party.delegates.size > 1) {
        // Remove the party leader from available choices
        const copy = MultiSet.from(party.delegates);
        if (party.partyLeader !== undefined) {
          copy.remove(party.partyLeader);
        } else {
          // This wouldn't happen normally.
          throw new Error(`partyLeader not defined for ${player.game.id}`);
        }
        const players: Array<IPlayer | NeutralPlayer> = [];
        for (const entry of copy.multiplicities()) {
          if (entry[0] === 'NEUTRAL') {
            players.push('NEUTRAL');
          } else {
            players.push(player.game.getPlayerById(entry[0]));
          }
        }

        if (players.length > 0) {
          const selectDelegate = new SelectDelegate(players, 'Select player delegate to remove from ' + party.name + ' party')
            .andThen((selectedPlayer) => {
              let playerToRemove: Delegate;
              if (selectedPlayer === 'NEUTRAL') {
                playerToRemove = 'NEUTRAL';
              } else {
                playerToRemove = selectedPlayer.id;
              }
              turmoil.removeDelegateFromParty(playerToRemove, party.name, player.game);
              this.log(player, party, selectedPlayer);
              return undefined;
            });
          selectDelegate.buttonLabel = 'Remove delegate';
          orOptions.push(selectDelegate);
        }
      }
    }
    if (orOptions.length === 0) {
      return undefined;
    } else if (orOptions.length === 1) {
      return orOptions[0];
    } else {
      const options = new OrOptions(...orOptions);
      return options;
    }
  }*/
}

================
File: cards/chemical/turmoil/DesignedOrganisms.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {Resource} from '../../../../common/Resource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {IPlayer} from '../../../IPlayer';
import {GlobalParameter} from '../../../../common/GlobalParameter';
import {Card} from '../../Card';
import {MAX_OXYGEN_LEVEL} from '../../../../common/constants';

export class DesignedOrganisms extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.DESIGNED_ORGANISMS_CHEMICAL,
      tags: [Tag.SCIENCE, Tag.ANIMAL],
      cost: 11,

      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 1},
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: 1},
      requirements: {tag: Tag.SCIENCE, count: 4},

      metadata: {
        cardNumber: 'x268',
        renderData: CardRenderer.builder((b) => {
          b.action('Draw a card and add an animal to this card ONLY IF you\'ve raised the oxygen this generation (or if the parameter is maxed).', (eb) => {
            eb.plus().oxygen(1).asterix().nbsp.colon().nbsp.startAction.cards(1).resource(CardResource.ANIMAL);
          }).br;
          b.production((pb) => pb.minus().plants(1, {all})).br;
          b.vpText('1 VP for every animal on this card.');
        }),
        description: {
          text: 'Requires 4 science tags. Decease any plant production 1 step.',
          align: 'left',
        },
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.generationData.hasRaisedGlobalParameter[GlobalParameter.OXYGEN] || player.game.getOxygenLevel() === MAX_OXYGEN_LEVEL;
  }
  public action(player: IPlayer) {
    player.addResourceTo(this, 1);
    player.drawCard(1);
  }
}

================
File: cards/chemical/turmoil/DirectedSabotageImpact.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {Tag} from '../../../../common/cards/Tag';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectPlayer} from '../../../inputs/SelectPlayer';
import {SelectOption} from '../../../inputs/SelectOption';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';

export class DirectedSabotageImpact extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.DIRECTED_SABOTAGE_IMPACT,
      tags: [Tag.SPACE],
      cost: 18,
      victoryPoints: -1,

      behavior: {
        global: {temperature: 1},
        ocean: {},
      },

      metadata: {
        cardNumber: 'x385',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1);
          b.oceans(1).br;
          b.minus().megacredits(8, {all}).plants(3, {all});
        }),
        description: 'Raise the temperature 1 step and place an ocean tile. Remove up to 8 M€ and up to 3 plants from any player.',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    const Players = player.game.getPlayers().filter((otherPlayer) => otherPlayer.id !== player.id);

    if (player.game.isSoloMode()) {
      return undefined;
    }
    return new OrOptions(
      new SelectPlayer(
        Array.from(Players),
        'Select player to remove up to 8 M€ and 3 plants from',
        'Remove resources')
        .andThen((selectedPlayer) => {
          selectedPlayer.stock.deduct(Resource.MEGACREDITS, 8, {log: true, from: player});
          selectedPlayer.stock.deduct(Resource.PLANTS, 3, {log: true, from: player});
          return undefined;
        }),
      new SelectOption(
        'Do not remove resources',
        'Confirm'),
    );
  }
}

================
File: cards/chemical/turmoil/EnergyLab.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class EnergyLab extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ENERGY_LAB,
      tags: [Tag.SCIENCE, Tag.POWER],
      cost: 6,

      behavior: {
        stock: {energy: 3},
      },

      metadata: {
        cardNumber: 'x399',
        renderData: CardRenderer.builder((b) => {
          b.effect('When playing a power tag, energy may be used as 2 M€ each.',
            (eb) => eb.tag(Tag.POWER).startEffect.energy(1).equals().megacredits(2)).br;
          b.energy(3);
        }),
        description: 'Gain 3 energy',
      },
    });
  }
}

================
File: cards/chemical/turmoil/ExoplanetLanding.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {Tag} from '../../../../common/cards/Tag';

export class ExoplanetLanding extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.EXOPLANET_LANDING,
      cost: 15,
      tags: [Tag.SCIENCE, Tag.SPACE],
      requirements: {party: PartyName.SCIENTISTS},
      victoryPoints: 2,

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: 'x417',
        renderData: CardRenderer.builder((b) => {
          b.cards(2);
        }),
        description: 'Requires that Scientists are in power or that you have 2 delegates there. Draw 2 cards.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/FirstMartianMemorial.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class FirstMaritanMemorial extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FIRST_MARTIAN_MEMORIAL,
      cost: 5,
      tags: [Tag.BUILDING],
      requirements: {chairman: {}},
      victoryPoints: 1,

      behavior: {
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'x418',
        renderData: CardRenderer.builder((b) => {
          b.cards(1);
        }),
        description: 'Requires that you are chairman. Draw a card.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/FusionBombing.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PartyName} from '../../../../common/turmoil/PartyName';

export class FusionBombing extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.FUSION_BOMBING,
      cost: 12,
      requirements: {party: PartyName.KELVINISTS},

      behavior: {
        global: {temperature: 2},
      },

      metadata: {
        cardNumber: 'x386',
        renderData: CardRenderer.builder((b) => {
          b.temperature(2);
        }),
        description: 'Requires that Kelvinists are in power or that you have 2 delegates there. Raise the temperature 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/HybridVessels.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class HybridVessels extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.HYBRID_VESSELS,
      tags: [Tag.SPACE],
      cost: 11,
      victoryPoints: 1,

      behavior: {
        production: {energy: -1, megacredits: 2},
      },

      requirements: {tag: Tag.SCIENCE, count: 2},
      cardDiscount: {tag: Tag.SPACE, amount: 2},
      metadata: {
        cardNumber: 'x396',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => {
            pb.minus().energy(1).nbsp;
            pb.plus().megacredits(2);
          });
        }),
        description: {
          text: 'Requires 2 science tags. Decrease your energy production 1 step and increase your M€ production 2 steps.',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/chemical/turmoil/InaugurationCeremony.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {Size} from '../../../../common/cards/render/Size';

export class InaugurationCeremony extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.INAUGURATION_CEREMONY,
      cost: 5,
      requirements: {chairman: {}},
      victoryPoints: 1,

      behavior: {
        stock: {megacredits: {cities: {where: 'everywhere'}, all: true, per: 2}},
      },

      metadata: {
        cardNumber: 'x389',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(1).slash().city({all, size: Size.SMALL}).city({all, size: Size.SMALL});
        }),
        description: 'Requires you are chairman. Gain 1 M€ for every 2 cities in play.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/IndustryDevelopment.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {PartyName} from '../../../../common/turmoil/PartyName';

export class IndustryDevelopment extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INDUSTRY_DEVELOPMENT,
      cost: 8,
      tags: [Tag.BUILDING],
      requirements: {party: PartyName.MARS},

      behavior: {
        production: {steel: 1, energy: 1},
      },

      metadata: {
        cardNumber: 'x412',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.steel(1).energy(1);
          });
        }),
        description: 'Requires that Mars First are in power or that you have 2 delegates there. Increase your steel production 1 step and your energy production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/InterplanetaryDiplomacy.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class InterplanetaryDiplomacy extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.INTERPLANETARY_DIPLOMACY,
      tags: [Tag.EARTH],
      cost: 6,

      resourceType: CardResource.DIPLOMACY,
      victoryPoints: {resourcesHere: {}, per: 3},
      requirements: {tr: 25},

      metadata: {
        cardNumber: 'x394',
        description: 'Requires 25 TR.',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a Venus, Earth, or Jovian tag, including this, add a diplomacy resource to this card.', (be) => {
            be.tag(Tag.VENUS).slash();
            be.tag(Tag.EARTH).slash();
            be.tag(Tag.JOVIAN);
            be.startEffect.resource(CardResource.DIPLOMACY);
          }).br;
          b.vpText('1 VP per 3 diplomacy resources on this card.');
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const qty = player.tags.cardTagCount(card, [Tag.VENUS, Tag.EARTH, Tag.JOVIAN]);
    player.addResourceTo(this, {qty, log: true});
  }
}

================
File: cards/chemical/turmoil/IonizingRadiationBeam.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {digit, all} from '../../Options';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {CardResource} from '../../../../common/CardResource';
import {RemoveResourcesFromCard} from '../../../deferredActions/RemoveResourcesFromCard';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';

export class IonizingRadiationBeam extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.IONIZING_RADIATION_BEAM,
      cost: 18,
      tags: [Tag.POWER],
      requirements: {party: PartyName.KELVINISTS},
      victoryPoints: -2,

      behavior: {
        production: {energy: 3, heat: 3},
        removeAnyPlants: 4,
      },

      metadata: {
        cardNumber: 'x413',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.energy(3).br;
            pb.heat(3);
          }).br;
          b.minus().resource(CardResource.ANIMAL, {all}).nbsp.minus().plants(4, {digit, all});
        }),
        description: 'Requires that Kelvinists are in power or that you have 2 delegates there. Increase your energy production 3 steps and your heat production 3 steps. Remove up to 4 plants from any player and remove up to 1 animal from any player.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    if (player.game.isSoloMode()) {
      return undefined;
    }
    const orOptionsAnimals = new RemoveResourcesFromCard(player, CardResource.ANIMAL, 1).execute() as OrOptions;

    const orOptions = new OrOptions();
    if (orOptionsAnimals !== undefined) {
      orOptions.options.push(orOptionsAnimals);
    } else {
      player.game.log('There was nobody to remove animals from.');
      return undefined;
    }
    orOptions.options.push(new SelectOption('Skip removal', 'Confirm').andThen(() => {
      return undefined;
    }));

    return orOptionsAnimals;
  }
}

================
File: cards/chemical/turmoil/Kickbacks.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class Kickbacks extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.KICKBACKS,
      cost: 1,
      requirements: {chairman: {}},
      victoryPoints: -1,

      behavior: {
        stock: {megacredits: 3},
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'x403',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).megacredits(3);
        }),
        description: 'Requires you are chairman. Increase your M€ production 2 steps and gain 3 M€.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/LegalFirm.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {all} from '../../Options';

export class LegalFirm extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.LEGAL_FIRM,
      cost: 5,
      tags: [Tag.EARTH],

      metadata: {
        cardNumber: 'x402',
        renderData: CardRenderer.builder((b) => {
          b.effect('When ANOTHER PLAYER removes your resources or lowers your production, steal 3 M€ from THAT PLAYER.',
            (eb) => eb.minus().wild(1).slash().production((pb) => pb.wild(1)).startEffect.text('Steal ').megacredits(3, {all}).asterix());
        }),
      },
    });
  }
  // effect handled in Player.ts, Production.ts, and Stock.ts
}

================
File: cards/chemical/turmoil/MartianResearchNetwork.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {Tag} from '../../../../common/cards/Tag';

export class MartianResearchNetwork extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MARTIAN_RESEARCH_NETWORK,
      tags: [Tag.WILD],
      cost: 12,
      requirements: {party: PartyName.SCIENTISTS},

      cardDiscount: {amount: 1},

      metadata: {
        cardNumber: 'x398',
        renderData: CardRenderer.builder((b) => {
          b.effect('Whenever you play a card, you pay 1 M€ less for it.', (eb) => {
            eb.empty().startEffect.megacredits(-1);
          }).br;
        }),
        description: 'Requires that Scienctists are in power or that you have 2 delegates there.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/MediaManipulation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {Turmoil} from '../../../turmoil/Turmoil';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {SelectParty} from '../../../inputs/SelectParty';

export class MediaManipulation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.MEDIA_MANIPULATION,
      cost: 5,

      metadata: {
        cardNumber: 'x388',
        renderData: CardRenderer.builder((b) => {
          b.delegates(2).asterix();
        }),
        description: 'Add 2 delegates to SEPARATE parties.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer): boolean {
    const turmoil = Turmoil.getTurmoil(player.game);
    return turmoil.getAvailableDelegateCount(player) >= 2;
  }
  public override bespokePlay(player: IPlayer): undefined {
    const turmoil = Turmoil.getTurmoil(player.game);
    player.game.defer(new SimpleDeferredAction(player, () => new SelectParty('Select first party to add a delegate', 'add delegate', turmoil.parties.map((party) => party.name)).andThen((firstParty) => {
      turmoil.sendDelegateToParty(player, firstParty, player.game);
      return new SelectParty('Select second party to add a delegate', 'add delegate', turmoil.parties.map((party) => party.name).filter((party) => party !== firstParty)).andThen((secondParty) => {
        turmoil.sendDelegateToParty(player, secondParty, player.game);
        return undefined;
      });
    })));
    return undefined;
  }
}

================
File: cards/chemical/turmoil/MedicalInstitute.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {PartyName} from '../../../../common/turmoil/PartyName';

export class MedicalInstitute extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MEDICAL_INSTITUTE,
      cost: 12,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      requirements: {party: PartyName.SCIENTISTS},
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 3},
      },

      metadata: {
        cardNumber: 'x405',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(3));
        }),
        description: 'Requires that Scientists are in power or that you have 2 delegates there. Increase your M€ production 3 steps.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/MicrobialSupport.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {PartyName} from '../../../../common/turmoil/PartyName';

export class MicrobialSupport extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MICROBIAL_SUPPORT,
      cost: 8,
      tags: [Tag.MICROBE],
      requirements: {party: PartyName.GREENS},

      behavior: {
        production: {megacredits: {tag: Tag.MICROBE}},
      },

      metadata: {
        cardNumber: 'x406',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).slash().tag(Tag.MICROBE));
        }),
        description: 'Requires that Greens are in power or that you have 2 delegates there. Increase your M€ production 1 step for each microbe tag you have, including this.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/PoliticalDonations.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {Resource} from '../../../../common/Resource';
import {Turmoil} from '../../../turmoil/Turmoil';

export class PoliticalDonations extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.POLITICAL_DONATIONS,
      cost: 0,
      tags: [Tag.EARTH],

      metadata: {
        cardNumber: 'x390',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(3).slash().partyLeaders(1);
        }),
        description: 'Gain 3 M€ for each party leader you have.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const turmoil = Turmoil.getTurmoil(player.game);
    let partyLeaders = 0;
    turmoil.parties.forEach((party) => {
      if (party.partyLeader === player) {
        partyLeaders++;
      }
    });
    player.stock.add(Resource.MEGACREDITS, partyLeaders * 3, {log: true});
    return undefined;
  }
}

================
File: cards/chemical/turmoil/Preservationism.ts
================
import {IProjectCard} from '../../IProjectCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {Card} from '../../Card';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {Size} from '../../../../common/cards/render/Size';

export class Preservationism extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PRESERVATIONISM,
      cost: 8,

      resourceType: CardResource.PRESERVATION,
      victoryPoints: {resourcesHere: 1},
      requirements: {party: PartyName.REDS},

      metadata: {
        cardNumber: 'x268',
        renderData: CardRenderer.builder((b) => {
          b.action('During the production phase, if you did not raise your TR this generation, add a preservation resource to this card.', (eb) => {
            eb.tr(1, {size: Size.SMALL, cancelled: true}).startEffect.resource(CardResource.PRESERVATION);
          }).br;
          b.vpText('1 VP for every preservation resource on this card.');
        }),
        description: 'Requires that Reds are in power or that you have 2 delegates there.',
      },
    });
  }
  public onProductionPhase(player: IPlayer): void {
    if (!player.generationData.hasRaisedTR) {
      this.resourceCount += 1;
    }
  }
}

================
File: cards/chemical/turmoil/PreservationistSettlement.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {PartyName} from '../../../../common/turmoil/PartyName';

export class PreservationistSettlement extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PRESERVATIONIST_SETTLEMENT,
      cost: 17,
      tags: [Tag.CITY, Tag.BUILDING],
      requirements: {party: PartyName.REDS},
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 3, energy: -1},
        city: {on: 'isolated'},
      },

      metadata: {
        cardNumber: 'x410',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          });
          b.city().asterix();
        }),
        description: 'Requires that Reds are in power or that you have 2 delegates there. Decrease your energy production 1 step, increase your M€ production 3 steps, and place a city tile NEXT TO NO OTHER TILE.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/PrimalNationalPark.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {TileType} from '../../../../common/TileType';
import {AdjacencyBonus} from '../../../ares/AdjacencyBonus';
import {IPlayer, CanAffordOptions} from '../../../IPlayer';

export class PrimalNationalPark extends Card implements IProjectCard {
  constructor(
    name = CardName.MASSIVE_SOLAR_FARM,
    cost = 8,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: 'x408',
      renderData: CardRenderer.builder((b) => {
        b.production((pb) => pb.energy(3)).nbsp.tile(TileType.MASSIVE_SOLAR_FARM, false);
      }),
      description: 'Raise your energy production 3 steps and place this tile.',
    },
  ) {
    super({
      type: CardType.AUTOMATED,
      name,
      cost,
      tags: [Tag.BUILDING],
      victoryPoints: 1,
      adjacencyBonus,
      behavior: {
        production: {megacredits: 2},
        tile: {
          type: TileType.PRIMAL_NATIONAL_PARK,
          on: 'isolated',
          title: 'Select space for special tile',
          adjacencyBonus: adjacencyBonus,
        },
      },
      metadata,
    });
  }
  /* private getTRPenalty(player: IPlayer): number {
    return Math.floor((player.getTerraformRating() - 15) / 5)
  }*/
  public override bespokeCanPlay(player: IPlayer, _canAffordOptions?: CanAffordOptions | undefined): boolean {
    return player.canAfford({cost: 8});
  }
}

================
File: cards/chemical/turmoil/ReducedSnowCoverage.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ReducedSnowCoverage extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.REDUCED_SNOW_COVERAGE,
      cost: 1,
      requirements: {oceans: 2},

      behavior: {
        production: {heat: 1},
      },

      metadata: {
        cardNumber: 'x415',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(1));
        }),
        description: 'Requires 2 ocean tiles. Increase your heat production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/RemoteAreaSuppliers.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {Size} from '../../../../common/cards/render/Size';
import {IPlayer} from '../../../IPlayer';
import {PlayerInput} from '../../../PlayerInput';
import {SpaceType} from '../../../../common/boards/SpaceType';
import {Resource} from '../../../../common/Resource';
import {all} from '../../Options';

export class RemoteAreaSuppliers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.REMOTE_AREA_SUPPLIERS,
      cost: 11,
      tags: [Tag.BUILDING],
      victoryPoints: 1,

      metadata: {
        cardNumber: 'x404',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).slash().emptyTile('normal', {size: Size.SMALL, all}).asterix());
        }),
        description: 'Increase your M€ production 1 step for each tile ON MARS, AND NEXT TO NO OTHER TILE.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const spacesOnMars = player.game.board.spaces.filter((space) => space.spaceType !== SpaceType.COLONY);
    const remoteSpaces = spacesOnMars.filter((space) => space.tile !== undefined && player.game.board.getAdjacentSpaces(space).every((space) => space.tile === undefined));
    player.production.add(Resource.MEGACREDITS, remoteSpaces.length);
    return undefined;
  }
}

================
File: cards/chemical/turmoil/ShortTermBonuses.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';

export class ShortTermBonuses extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SHORT_TERM_BONUSES,
      cost: 12,
      requirements: {party: PartyName.KELVINISTS},

      metadata: {
        cardNumber: 'x397',
        renderData: CardRenderer.builder((b) => {
          b.effect('For every step you raise your TR, gain 2 M€.', (eb) => {
            eb.tr(1).startEffect.megacredits(2);
          }).br;
        }),
        description: 'Requires that Kelvinists are in power or that you have 2 delegates there.',
      },
    });
  }
  public onIncreaseTerraformRating(player: IPlayer, cardOwner: IPlayer, steps: number): void {
    if (player.id === cardOwner.id) {
      cardOwner.stock.add(Resource.MEGACREDITS, steps * 2, {log: true});
    }
  }
}

================
File: cards/chemical/turmoil/SocialWelfare.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {PartyName} from '../../../../common/turmoil/PartyName';
import {all} from '../../Options';
import {Size} from '../../../../common/cards/render/Size';

export class SocialWelfare extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SOCIAL_WELFARE,
      cost: 6,
      requirements: {party: PartyName.MARS},
      victoryPoints: 1,

      behavior: {
        stock: {megacredits: {cities: {where: 'everywhere'}}},
      },

      metadata: {
        cardNumber: 'x416',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(1).slash().city({all, size: Size.SMALL});
        }),
        description: 'Requires that Mars First are in power or that you have 2 delegates there. Gain 1 M€ for each city tile.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/TellurianEcosystems.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {PartyName} from '../../../../common/turmoil/PartyName';

export class TellurianEcosystems extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TELLURIAN_ECOSYSTEMS,
      tags: [Tag.EARTH, Tag.ANIMAL],
      cost: 10,

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {party: PartyName.GREENS},

      metadata: {
        cardNumber: 'x392',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an Earth tag, including this, add an animal to this card', (eb) => {
            eb.tag(Tag.EARTH).startEffect.resource(CardResource.ANIMAL);
          }).br;
          b.vpText('1 VP for every 2 animals on this card.');
        }),
        description: 'Requires that Greens are in power or that you have 2 delegates there.',
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const qty = player.tags.cardTagCount(card, Tag.EARTH);
    player.addResourceTo(this, {qty, log: true});
  }
}

================
File: cards/chemical/turmoil/TerraformingUnion.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {all} from '../../Options';
import {IPlayer} from '../../../IPlayer';

export class TerraformingUnion extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TERRAFORMING_UNION,
      cost: 9,
      tags: [Tag.WILD],
      requirements: {tr: 25},

      behavior: {
        tr: 2,
      },

      metadata: {
        cardNumber: 'x419',
        renderData: CardRenderer.builder((b) => {
          b.tr(2).nbsp.plus().tr(1, {all}).asterix();
        }),
        description: 'Requires 25 TR. Raise your TR 2 steps. ALL OPPONENTS raise their TR 1 step.',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    const otherPlayers = player.game.getPlayers().filter((p) => p.id !== player.id);
    for (const p of otherPlayers) {
      p.increaseTerraformRating(1);
    }
    return undefined;
  }
}

================
File: cards/chemical/turmoil/VenusSocietySupport.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {PartyName} from '../../../../common/turmoil/PartyName';

export class VenusSocietySupport extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.VENUS_SOCIETY_SUPPORT,
      cost: 8,
      tags: [Tag.VENUS],
      requirements: {party: PartyName.UNITY},

      behavior: {
        production: {megacredits: {tag: Tag.VENUS}},
      },

      metadata: {
        cardNumber: 'x407',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).slash().tag(Tag.VENUS));
        }),
        description: 'Requires that Unity are in power or that you have 2 delegates there. Increase your M€ production 1 step for each Venus tag you have, including this.',
      },
    });
  }
}

================
File: cards/chemical/turmoil/WorldGovernmentDiplomats.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {SelectOption} from '../../../inputs/SelectOption';
import {Turmoil} from '../../../turmoil/Turmoil';
import {SelectParty} from '../../../inputs/SelectParty';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {OrOptions} from '../../../inputs/OrOptions';

export class WorldGovernmentDiplomats extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.WORLD_GOVERNMENT_DIPLOMATS,
      tags: [Tag.EARTH],
      cost: 15,

      resourceType: CardResource.DIPLOMACY,

      behavior: {
        tr: 1,
      },

      metadata: {
        cardNumber: 'x395',
        description: 'Raise your TR 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an Earth tag, including this, either add a diplomacy resource to this card or remove a diplomacy resource from this card to place a delegate.', (eb) => {
            eb.tag(Tag.EARTH).startEffect.resource(CardResource.DIPLOMACY).or(Size.SMALL).minus().resource(CardResource.DIPLOMACY).plus().delegates(1);
          }).br;
          b.tr(1);
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.tags.includes(Tag.EARTH) === false) {
      return undefined;
    }
    if (this.resourceCount === 0) {
      player.addResourceTo(this);
      return undefined;
    }

    const addResource = new SelectOption('Add a diplomacy resource to World Government Diplomats', 'Add diplomacy resource').andThen( () => {
      player.addResourceTo(this);
      return undefined;
    });

    const spendResource = new SelectOption('Remove 1 diplomacy resource from World Government Diplomats and place a delegate', 'Remove diplomacy resource').andThen( () => {
      player.removeResourceFrom(this, 1);
      const turmoil = Turmoil.getTurmoil(player.game);
      return new SelectParty('Select first party to add a delegate', 'add delegate', turmoil.parties.map((party) => party.name)).andThen((party) => {
        turmoil.sendDelegateToParty(player, party, player.game);
        return undefined;
      });
    });

    player.game.defer(new SimpleDeferredAction(player, () => new OrOptions(spendResource, addResource)));
    return undefined;
  }
}

================
File: cards/chemical/UNMISponsorship.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class UNMISponsorship extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.UNMI_SPONSORSHIP,
      cost: 11,
      tags: [Tag.EARTH],
      requirements: {raisedTR: true},

      metadata: {
        cardNumber: 'x342',
        renderData: CardRenderer.builder((b) => {
          b.tr(2);
        }),
        description: 'Requires you\'ve raised your TR this generation. Raise your TR 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/venus/AerialMassDrivers.ts
================
import {IActionCard} from '../../ICard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class AerialMassDrivers extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.AERIAL_MASS_DRIVERS,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 15,
      victoryPoints: 1,

      resourceType: CardResource.FLOATER,

      action: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 1, autoSelect: true},
      },

      metadata: {
        cardNumber: 'x331',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to any card', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER);
          }).br;
          b.effect('Floaters on this card mey be used as 4 M€ when paying for standard projects.', (eb) => {
            eb.plate('Standard projects').startEffect.resource(CardResource.FLOATER).equals().megacredits(4);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/venus/AirborneMicrobes.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class AirborneMicrobes extends ActionCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.AIRBORNE_MICROBES,
      type: CardType.ACTIVE,
      tags: [Tag.MICROBE, Tag.VENUS],
      cost: 7,
      resourceType: CardResource.MICROBE,
      requirements: {venus: 4},
      victoryPoints: {resourcesHere: {}, per: 3},

      behavior: {
        addResourcesToAnyCard: {type: CardResource.MICROBE, tag: Tag.VENUS, count: 2},
      },

      action: {
        addResourcesToAnyCard: {type: CardResource.MICROBE, tag: Tag.VENUS, count: 1},
      },

      metadata: {
        cardNumber: 'x265',
        renderData: CardRenderer.builder((b) => {
          b.action('Add a microbe to any Venus card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE, {secondaryTag: Tag.VENUS});
          }).br;
          b.vpText('1 VP per 3 microbes on this card.').br;
          b.resource(CardResource.MICROBE, {amount: 2, secondaryTag: Tag.VENUS});
        }),
        description: 'Requires Venus 4%. Add 2 microbes to any Venus card.',
      },
    });
  }
}

================
File: cards/chemical/venus/AtenGroupMining.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class AtenGroupMining extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ATEN_GROUP_MINING,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 25,
      requirements: [{tag: Tag.VENUS}, {tag: Tag.EARTH}],
      victoryPoints: 2,

      behavior: {
        production: {titanium: 2},
      },

      metadata: {
        cardNumber: 'x301',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(2));
        }),
        description: 'Requires that you have an Earth tag and a Venus tag. Increase your titanium production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/venus/AtmoshpericSolarCollectors.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class AtmosphericSolarCollectors extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ATMOSPHERIC_SOLAR_COLLECTORS,
      tags: [Tag.POWER, Tag.VENUS],
      cost: 14,

      behavior: {
        global: {venus: 1},
        production: {energy: 1},
      },

      metadata: {
        cardNumber: 'x282',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1)).nbsp.venus(1).br;
        }),
        description: 'Increase your energy production 1 step and raise Venus 1 step.',
      },
    });
  }
}

================
File: cards/chemical/venus/AtmosphereLiftingDetonations.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {max} from '../../Options';

export class AtmosphereLiftingDetonations extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ATMOSPHERE_LIFTING_DETONATIONS,
      tags: [Tag.VENUS],
      cost: 4,
      requirements: {venus: 10, max},

      behavior: {
        global: {venus: 1},
      },

      metadata: {
        cardNumber: 'x248',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).nbsp.minus().energy(2);
        }),
        description: 'Venus must be 10% or lower. Raise Venus 1 step. Lose 2 energy.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.energy >= 2;
  }
  public override bespokePlay(player: IPlayer) {
    player.energy -= 2;
    return undefined;
  }
}

================
File: cards/chemical/venus/BasaltMining.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class BasaltMining extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BASALT_MINING,
      tags: [Tag.VENUS],
      cost: 20,
      requirements: {venus: 8},

      behavior: {
        global: {venus: 2},
        production: {energy: -1, steel: 1, megacredits: 2},
      },

      metadata: {
        cardNumber: 'x288',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().steel(1).megacredits(2);
          }).br;
          b.venus(2).br;
        }),
        description: 'Requires Venus 8% or higher. Decrease your energy production 1 step. Increase your steel production 1 step and your M€ production 2 steps. Raise Venus 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/venus/BioengineeringStudies.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {IPlayer} from '../../../IPlayer';

export class BioengineeringStudies extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.BIOENGINEERING_STUDIES,
      type: CardType.ACTIVE,
      tags: [Tag.ANIMAL, Tag.VENUS, Tag.EARTH],
      cost: 5,
      resourceType: CardResource.ANIMAL,

      metadata: {
        cardNumber: 'x271',
        renderData: CardRenderer.builder((b) => {
          b.effect('For every Venus tag you play, add an animal resource to this card.', (eb) => {
            eb.tag(Tag.VENUS).startEffect.resource(CardResource.ANIMAL);
          }).br;
          b.effect('Animals on this card may be used as 3 M€ when paying for cards with animal tags.', (eb) => {
            eb.tag(Tag.ANIMAL).startEffect.resource(CardResource.ANIMAL).equals().megacredits(3);
          }).br;
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const qty = player.tags.cardTagCount(card, Tag.VENUS);
    player.addResourceTo(this, {qty, log: true});
  }
  // heed my warning, do not try to impement an effect like this

  // effect functionality handled elsewhere
}

================
File: cards/chemical/venus/BiomechanicalFoliage.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {digit} from '../../Options';

export class BiomechanicalFoliage extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BIOMECHANICAL_FOLIAGE,
      tags: [Tag.SCIENCE],
      cost: 12,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'x311',
        renderData: CardRenderer.builder((b) => {
          b.cards(1).nbsp.or().nbsp.tag(Tag.PLANT).colon().cards(3, {digit});
        }),
        description: 'Draw a card or draw 3 cards if you have 3 plant tags',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    if (player.tags.count(Tag.PLANT) < 3) {
      player.drawCard(1);
    } else {
      player.drawCard(3);
    }
    return undefined;
  }
}

================
File: cards/chemical/venus/CapitalOfVenus.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {SpaceName} from '../../../SpaceName';

export class CapitalOfVenus extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CAPITAL_OF_VENUS,
      tags: [Tag.CITY, Tag.VENUS],
      cost: 23,
      requirements: {venus: 22},
      victoryPoints: {tag: Tag.VENUS, per: 2},

      behavior: {
        production: {megacredits: 5, energy: -2},
        addResourcesToAnyCard: {
          tag: Tag.VENUS,
          count: 2,
          autoSelect: true,
          mustHaveCard: false,
        },
        city: {space: SpaceName.CAPITAL_OF_VENUS},
      },

      metadata: {
        cardNumber: 'x281',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().megacredits(5);
          });
          b.city().asterix().br.wild(2, {secondaryTag: Tag.VENUS}).br;
          b.vpText('1 VP for every 2 Venus tags you have.').br;
        }),
        description: 'Requires Venus 22%. Decrease your energy production 2 steps and increase your M€ production 5 steps. Place a city tile ON THE RESERVED AREA. Add any 2 resources to any Venus card.',
      },
    });
  }
}

================
File: cards/chemical/venus/CarbonFixingMicrobes.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class CarbonFixingMicrobes extends ActionCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.CARBON_FIXING_MICROBES,
      type: CardType.ACTIVE,
      tags: [Tag.MICROBE, Tag.VENUS],
      cost: 4,
      resourceType: CardResource.MICROBE,
      requirements: {venus: 10},

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 microbes to raise Venus 1 step',
            spend: {resourcesHere: 2},
            global: {venus: 1},
          },
          {
            title: 'Spend 1 M€ to add 1 microbe to this card',
            spend: {megacredits: 1},
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: 'x267',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 M€ to add 1 microbe to this card.', (eb) => {
            eb.megacredits(1).startAction.resource(CardResource.MICROBE);
          }).br;
          b.or().br;
          b.action('Remove 2 microbes From this card to raise Venus 1 step.', (eb) => {
            eb.resource(CardResource.MICROBE, 2).startAction.venus(1);
          }).br;
        }),
        description: 'Requires Venus 10%.',
      },
    });
  }
}

================
File: cards/chemical/venus/CarbonSolidifcation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class CarbonSolidification extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CARBON_SOLIDIFICATION,
      tags: [Tag.VENUS],
      cost: 9,
      resourceType: CardResource.FLOATER,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 floaters to raise Venus 1 step',
            spend: {resourcesHere: 2},
            global: {venus: 1},
          },
          {
            title: 'Spend 2 energy to add 2 floaters to this card',
            spend: {energy: 2},
            addResources: 2,
          }],
        },
      },

      metadata: {
        cardNumber: 'x260',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 energy to add 2 floaters to this card.', (eb) => {
            eb.energy(2).startAction.resource(CardResource.FLOATER, 2);
          }).br;
          b.or().br;
          b.action('Remove 2 floaters from this card to raise Venus 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.venus(1);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/venus/CollaborationProject.ts
================
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {IProjectCard} from '../../IProjectCard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Size} from '../../../../common/cards/render/Size';
import {Tag} from '../../../../common/cards/Tag';

export class CollaborationProject extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.COLLABORATION_PROJECT,
      tags: [Tag.EARTH],
      cost: 5,
      requirements: [{tag: Tag.VENUS}, {tag: Tag.EARTH}, {tag: Tag.JOVIAN}],

      metadata: {
        cardNumber: 'x252',
        renderData: CardRenderer.builder((b) => {
          b.text('next card', Size.SMALL, true).colon().megacredits(-12);
        }),
        description: 'Requires that you have an Earth tag, a Venus tag, and a Jovian tag. The next card you play this generation costs 12 M€ less.',
      },
    });
  }

  public override getCardDiscount(player: IPlayer) {
    if (player.lastCardPlayed === this.name) {
      return 12;
    }
    return 0;
  }
}

================
File: cards/chemical/venus/CondenstationCatalysts.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class CondenstationCatalysts extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CONDENSATION_CATALYSTS,
      tags: [Tag.VENUS],
      cost: 8,
      requirements: {venus: 4},

      behavior: {
        global: {venus: 1},
      },

      metadata: {
        cardNumber: 'x287',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).br;
        }),
        description: 'Requires Venus 4%. Raise Venus 1 step.',
      },
    });
  }
}

================
File: cards/chemical/venus/ConsistentBombardment.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class ConsistentBombardment extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CONSISTENT_BOMBARDMENT,
      tags: [Tag.SPACE],
      cost: 12,
      resourceType: CardResource.ASTEROID,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 1 asteroid to raise the temperature.',
            spend: {resourcesHere: 1},
            global: {temperature: 1},
          },
          {
            title: 'Spend 1 asteroid to raise Venus.',
            spend: {resourcesHere: 1},
            global: {venus: 1},
          },
          {
            title: 'Spend 1 titanium to add 1 asteroid to ANY card',
            spend: {titanium: 1},
            addResourcesToAnyCard: {type: CardResource.ASTEROID, count: 1},
          }],
        },
      },

      metadata: {
        cardNumber: 'x253',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add 1 asteroid to ANY card.', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.ASTEROID).asterix();
          }).br;
          b.or().br;
          b.action('Remove 1 asteroid from this card to raise the temperature or Venus 1 step.', (eb) => {
            eb.resource(CardResource.ASTEROID).startAction.temperature(1).slash().venus(1);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/venus/ConvoyToVenus.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class ConvoyToVenus extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.CONVOY_TO_VENUS,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 23,
      victoryPoints: 1,

      behavior: {
        global: {venus: 1},
        drawCard: 1,
        addResourcesToAnyCard: {
          tag: Tag.VENUS,
          count: 2,
          autoSelect: true,
          mustHaveCard: false,
        },
      },

      metadata: {
        cardNumber: 'x244',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).wild(2, {secondaryTag: Tag.VENUS}).cards(1);
        }),
        description: 'Raise Venus 1 step, add 2 of any resource to a Venus card, and draw a card.',
      },
    });
  }
}

================
File: cards/chemical/venus/DanuMontesRover.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {max} from '../../Options';

export class DanuMontesRover extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.DANU_MONTES_ROVER,
      tags: [Tag.SCIENCE, Tag.VENUS],
      cost: 2,
      requirements: {venus: 6, max},
      victoryPoints: 1,

      metadata: {
        cardNumber: 'x251',
        description: 'Venus must be 6% or lower.',
      },
    });
  }
}

================
File: cards/chemical/venus/DesignedFlyers.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {GlobalParameter} from '../../../../common/GlobalParameter';
import {Card} from '../../Card';
import {MAX_VENUS_SCALE} from '../../../../common/constants';

export class DesignedFlyers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.DESIGNED_FLYERS,
      tags: [Tag.SCIENCE, Tag.ANIMAL, Tag.VENUS],
      cost: 14,

      behavior: {
        addResources: 1,
      },

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: 1},
      requirements: {tag: Tag.SCIENCE, count: 5},

      metadata: {
        cardNumber: 'x268',
        renderData: CardRenderer.builder((b) => {
          b.action('Draw a card and add an animal to this card ONLY IF you\'ve raised Venus this generation (or if the parameter is maxed).', (eb) => {
            eb.plus().venus(1).asterix().nbsp.colon().nbsp.startAction.cards(1).resource(CardResource.ANIMAL);
          }).br;
          b.vpText('1 VP for every animal on this card.').br;
          b.resource(CardResource.ANIMAL);
        }),
        description: 'Requires 5 science tags. Add an animal to this card.',
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.generationData.hasRaisedGlobalParameter[GlobalParameter.VENUS] || player.game.getVenusScaleLevel() === MAX_VENUS_SCALE;
  }
  public action(player: IPlayer) {
    player.addResourceTo(this, 1);
    player.drawCard();
  }
}

================
File: cards/chemical/venus/DeuteriumFusion.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class DeuteriumFusion extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DEUTERIUM_FUSION,
      tags: [Tag.SCIENCE, Tag.POWER],
      cost: 9,
      requirements: [{tag: Tag.VENUS}, {tag: Tag.EARTH}, {tag: Tag.JOVIAN}],

      behavior: {
        production: {energy: 2},
      },

      metadata: {
        cardNumber: 'x304',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2));
        }),
        description: 'Requires an Earth tag, a Venus tag, and a Jovian tag. Increase your energy production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/venus/DistirbutionCenter.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class DistributionCenter extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DISTRIBUTION_CENTER,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 18,
      requirements: {uniqueTags: {}, count: 9},

      behavior: {
        production: {megacredits: 5, energy: -2},
        city: {},
      },

      metadata: {
        cardNumber: 'x295',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().megacredits(5);
          }).nbsp;
          b.city();
        }),
        description: 'Requires that you have 9 unique tags in play. Decrease your energy production 2 steps and increase your M€ production 5 steps. Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/venus/DryIceRings.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class DryIceRings extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DRY_ICE_RINGS,
      tags: [Tag.VENUS, Tag.SPACE],
      cost: 30,
      victoryPoints: {tag: Tag.VENUS, per: 2},

      behavior: {
        global: {venus: 2},
      },

      metadata: {
        cardNumber: 'x277',
        renderData: CardRenderer.builder((b) => {
          b.venus(2).br;
          b.vpText('1 VP for every 2 Venus tags you have.').br;
        }),
        description: 'Raise Venus 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/venus/DwarfPlanetCollision.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';
import {max, all} from '../../Options';
import {IPlayer} from '../../../IPlayer';
import {Resource} from '../../../../common/Resource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectPlayer} from '../../../inputs/SelectPlayer';
import {SelectOption} from '../../../inputs/SelectOption';
import {RemoveResourcesFromCard} from '../../../deferredActions/RemoveResourcesFromCard';
import {SelectCard} from '../../../inputs/SelectCard';

export class DwarfPlanetCollision extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.DWARF_PLANET_COLLISION,
      tags: [Tag.SPACE],
      cost: 33,
      requirements: {venus: 6, max},

      behavior: {
        global: {venus: 3},
      },

      metadata: {
        cardNumber: 'x243',
        renderData: CardRenderer.builder((b) => {
          b.venus(3).br.minus().megacredits(8, {all, secondaryTag: Tag.VENUS}).resource(CardResource.FLOATER, {amount: 2, all, secondaryTag: Tag.VENUS});
        }),
        description: 'Requires Venus 6% or lower. Raise Venus 3 steps, Remove up to 8 M€ from any player with a Venus tag, and remove up to 2 floaters from any Venus card.',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    const venusTagPlayers = player.game.getPlayers().filter((otherPlayer) => otherPlayer.id !== player.id && otherPlayer.tags.count(Tag.VENUS, 'raw') > 0);

    if (player.game.isSoloMode()|| venusTagPlayers.length === 0) {
      return undefined;
    }

    if (venusTagPlayers.length > 0) {
      return new OrOptions(
        new SelectPlayer(
          Array.from(venusTagPlayers),
          'Select player to remove up to 8 M€ from',
          'Remove M€')
          .andThen((selectedPlayer) => {
            selectedPlayer.stock.deduct(Resource.MEGACREDITS, 8, {log: true, from: player});
            return undefined;
          }),
        new SelectOption(
          'Do not remove M€',
          'Confirm'),
      ).andThen(() => {
        const resourceCards = RemoveResourcesFromCard.getAvailableTargetCards(player, CardResource.FLOATER).filter((card) => card.tags.includes(Tag.VENUS));

        if (resourceCards.length === 0) {
          return undefined;
        }
        const selectCard = new SelectCard(
          'Select card to remove 2 floaters from',
          'Remove resource(s)',
          resourceCards,
          {showOwner: true})
          .andThen(([card]) => {
            const owner = player.game.getCardPlayerOrThrow(card.name);
            owner.removeResourceFrom(card, 2, {removingPlayer: player});
            return undefined;
          });
        return new OrOptions(
          selectCard,
          new SelectOption('Do not remove'));
      });
    }
    return undefined;
  }
}

================
File: cards/chemical/venus/EclipseStation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class EclipseStation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ECLIPSE_STATION,
      cost: 17,
      tags: [Tag.SPACE],
      victoryPoints: 1,

      behavior: {
        stock: {megacredits: {tag: Tag.SPACE, each: 2}},
      },

      metadata: {
        cardNumber: 'x307',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(2).slash().tag(Tag.SPACE);
        }),
        description: 'Gain 2 M€ for each space tag you have, including this.',
      },
    });
  }
}

================
File: cards/chemical/venus/EndemicVenusianArchaea.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {GlobalParameter} from '../../../../common/GlobalParameter';

export class EndemicVenusianArchaea extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.ENDEMIC_VENUSIAN_ARCHAEA,
      type: CardType.ACTIVE,
      tags: [Tag.MICROBE, Tag.VENUS],
      cost: 11,
      resourceType: CardResource.MICROBE,
      requirements: {tag: Tag.SCIENCE, count: 2},
      victoryPoints: {resourcesHere: {}, per: 2},

      metadata: {
        cardNumber: 'x264',
        renderData: CardRenderer.builder((b) => {
          b.effect('For every step you raise Venus, add a microbe to this card.', (eb) => {
            eb.venus(1).startEffect.resource(CardResource.MICROBE);
          }).br;
          b.vpText('1 VP per 2 microbes on this card.').br;
        }),
        description: 'Requires 2 science tags.',
      },
    });
  }
  onGlobalParameterIncrease?(player: IPlayer, parameter: GlobalParameter, steps: number) {
    if (parameter === GlobalParameter.VENUS) {
      const qty = steps;
      player.addResourceTo(this, {qty, log: true});
    }
  }
}

================
File: cards/chemical/venus/FloaterAcquisition.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CanAffordOptions, IPlayer} from '../../../IPlayer';
import {CardName} from '../../../../common/cards/CardName';
import {CardResource} from '../../../../common/CardResource';
import {RemoveResourcesFromCard} from '../../../deferredActions/RemoveResourcesFromCard';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {AddResourcesToCard} from '../../../deferredActions/AddResourcesToCard';

export class FloaterAcquisition extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.FLOATER_ACQUISITION,
      cost: 6,

      metadata: {
        cardNumber: 'x241',
        renderData: CardRenderer.builder((b) => {
          b.text('Steal').nbsp.resource(CardResource.FLOATER, {amount: 2, all});
        }),
        description: 'Steal 2 floaters from another player.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer, _canAffordOptions?: CanAffordOptions | undefined): boolean {
    if (player.game.isSoloMode()) {
      return true;
    }
    return RemoveResourcesFromCard.getAvailableTargetCards(player, CardResource.FLOATER).filter( (card) => card.resourceCount >= 2).length >= 1;
  }
  public override bespokePlay(player: IPlayer) {
    if (player.game.isSoloMode()) {
      return undefined;
    }
    player.game.defer(new RemoveResourcesFromCard(player, CardResource.FLOATER, 2, {mandatory: true})).andThen(() => {
      player.game.defer(new AddResourcesToCard(player, CardResource.FLOATER, {count: 2}));
      return undefined;
    });
    return undefined;
  }
}

================
File: cards/chemical/venus/FloaterDocks.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';
import {SimpleDeferredAction} from '../../../deferredActions/DeferredAction';
import {SelectCard} from '../../../inputs/SelectCard';

export class FloaterDocks extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.FLOATER_DOCKS,
      tags: [Tag.VENUS, Tag.JOVIAN],
      cost: 17,
      victoryPoints: {resourcesHere: {}, per: 3},
      resourceType: CardResource.FLOATER,

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'x257',
        renderData: CardRenderer.builder((b) => {
          b.effect('For every Venus or Jovian tag you play, add a floater to ANY card.', (eb) => {
            eb.tag(Tag.VENUS).slash().tag(Tag.JOVIAN).startEffect.resource(CardResource.FLOATER).asterix();
          }).br;
          b.vpText('1 VP per 3 floaters on this card.').br;
          b.production((pb) => pb.megacredits(2));
        }),
        description: 'Increase your M€ production 2 steps.',
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    const resourceCount = player.tags.cardTagCount(card, [Tag.VENUS, Tag.JOVIAN]);
    const floaterCards = player.getResourceCards(CardResource.FLOATER);

    if (resourceCount === 0) {
      return undefined;
    }
    if (floaterCards.length === 1) {
      player.addResourceTo(this, resourceCount);
      return undefined;
    }
    for (let i = 0; i < resourceCount; i++) {
      player.game.defer(new SimpleDeferredAction(player, () => new SelectCard(
        'Select card to add 1 floater from Floater Docks (' + String(i + 1) + '/' + String(resourceCount) + ')',
        'Add floater',
        floaterCards).andThen(
        ([card]) => {
          player.addResourceTo(card, {log: true});
          return undefined;
        },
      )));
    }
    return undefined;
  }
}

================
File: cards/chemical/venus/FloatingArchitechture.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {CardResource} from '../../../../common/CardResource';

export class FloatingArchitechture extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FLOATING_ARCHITECHTURE,
      tags: [Tag.BUILDING],
      cost: 15,
      requirements: {floaters: 5},
      victoryPoints: {cities: {}, all: true, per: 3},

      behavior: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2},
      },

      metadata: {
        cardNumber: 'x310',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.FLOATER).asterix().br;
          b.vpText('1 VP for every 3rd City in play.');
        }),
        description: 'Requires 5 floaters. Add 2 floaters to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/venus/FloatingBiodomes.ts
================
import {IActionCard} from '../../ICard';
import {PlayerInput} from '../../../PlayerInput';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {OrOptions} from '../../../inputs/OrOptions';
import {SelectOption} from '../../../inputs/SelectOption';
import {SelectAmount} from '../../../inputs/SelectAmount';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';

export class FloatingBiodomes extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.FLOATING_BIODOMES,
      type: CardType.ACTIVE,
      tags: [Tag.PLANT, Tag.VENUS, Tag.JOVIAN],
      cost: 12,
      resourceType: CardResource.FLOATER,
      requirements: {tag: Tag.SCIENCE, count: 2},
      victoryPoints: 1,

      metadata: {
        cardNumber: 'x263',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER);
          }).br;
          b.or().br;
          b.action('Spend any number of floater here to gain that amount of plants.', (eb) => {
            eb.text('X').resource(CardResource.FLOATER).startAction.text('X').plants(1);
          });
        }),
        description: 'Requires 2 science tags.',
      },
    });
  }
  public canAct(): boolean {
    return true;
  }
  public action(player: IPlayer) {
    const opts: Array<PlayerInput> = [];

    const addResource = new SelectOption('Add 1 floater to this card', 'Add floater').andThen( () => {
      player.addResourceTo(this, {log: true});
      return undefined;
    });
    const spendResource = new SelectAmount('Remove any number of floaters to gain 1 plant per floater removed', 'Remove floaters', 1, this.resourceCount, true)
      .andThen((amount) => this.spendResource(player, amount));

    opts.push(addResource);

    if (this.resourceCount > 0) {
      opts.push(spendResource);
    } else {
      player.addResourceTo(this, {log: true});
      return undefined;
    }

    return new OrOptions(...opts);
  }

  private spendResource(player: IPlayer, amount: number) {
    player.removeResourceFrom(this, amount, {log: false});

    player.plants += amount;

    player.game.log('${0} removed ${1} floaters from ${2} to gain ${3} plants', (b) =>
      b.player(player).number(amount).card(this).number(amount));

    return undefined;
  }
}

================
File: cards/chemical/venus/FloatingPowerStation.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

export class FloatingPowerStation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FLOATING_POWER_STATION,
      tags: [Tag.POWER, Tag.VENUS],
      cost: 12,
      victoryPoints: 1,

      behavior: {
        production: {energy: 1},
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2, tag: Tag.VENUS},
      },

      metadata: {
        cardNumber: 'x303',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1)).resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.VENUS}).br;
        }),
        description: 'Increase your energy production 1 step and add 2 floaters to any Venus card.',
      },
    });
  }
}

================
File: cards/chemical/venus/FloatingResearchBase.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class FloatingResearchBase extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.FLOATING_RESEARCH_BASE,
      tags: [Tag.SCIENCE, Tag.VENUS],
      cost: 11,
      victoryPoints: {resourcesHere: {}, per: 3},
      requirements: {tag: Tag.SCIENCE, count: 2},
      resourceType: CardResource.FLOATER,

      behavior: {
        drawCard: 2,
      },

      action: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 1},
      },

      metadata: {
        cardNumber: 'x256',
        renderData: CardRenderer.builder((b) => {
          b.action('Add a floater to ANY card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER).asterix();
          }).br;
          b.vpText('1 VP per 3 floaters on this card.').br;
          b.cards(2);
        }),
        description: 'Requires 2 science tags. Draw 2 cards.',
      },
    });
  }
}

================
File: cards/chemical/venus/HugeWaterShipments.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class HugeWaterShipments extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.HUGE_WATER_SHIPMENTS,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 36,

      behavior: {
        global: {venus: 2},
        ocean: {count: 2},
      },

      metadata: {
        cardNumber: 'x245',
        renderData: CardRenderer.builder((b) => {
          b.venus(2).oceans(2);
        }),
        description: 'Raise Venus 2 steps and place 2 ocean tiles.',
      },
    });
  }
}

================
File: cards/chemical/venus/HydrogenInjection.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class HydrogenInjection extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HYDROGEN_INJECTION,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 18,

      behavior: {
        global: {venus: 1},
        production: {titanium: 1},
      },

      metadata: {
        cardNumber: 'x282',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).nbsp.venus(1).br;
        }),
        description: 'Increase your titanium production 1 step and raise Venus 1 step.',
      },
    });
  }
}

================
File: cards/chemical/venus/IonicGasSequestration.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class IonicGasSequestration extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.IONIC_GAS_SEQUESTRATION,
      tags: [Tag.SCIENCE, Tag.SPACE],
      cost: 13,

      behavior: {
        global: {venus: 1},
        stock: {titanium: 2},
      },

      metadata: {
        cardNumber: 'x242',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).nbsp.titanium(2);
        }),
        description: 'Raise Venus 1 step and gain 2 titanium.',
      },
    });
  }
}

================
File: cards/chemical/venus/IshtarComplex.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {IPlayer} from '../../../IPlayer';

export class IshtarComplex extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ISHTAR_COMPLEX,
      tags: [Tag.VENUS],
      cost: 5,
      requirements: {venus: 8},

      behavior: {
        production: {megacredits: 2, energy: -1},
      },

      metadata: {
        cardNumber: 'x298',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(2);
          });
          b.wild(1, {secondaryTag: Tag.VENUS}).slash().tag(Tag.VENUS).asterix();
        }),
        description: 'Requires Venus 8%. Decrease your energy production 1 step and raise your M€ production 2 steps. Add a resource to every Venus card that can contain resources.',
      },
    });
  }
  public override bespokePlay(player: IPlayer): undefined {
    for (const card of player.getResourceCards().filter((card) => card.tags.includes(Tag.VENUS))) {
      player.addResourceTo(card, {qty: 1, log: false});
    }
    return undefined;
  }
}

================
File: cards/chemical/venus/LakeOfAphrodite.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class LakeOfAphrodite extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LAKE_OF_APHRODITE,
      tags: [Tag.VENUS],
      cost: 13,
      requirements: {venus: 20},
      victoryPoints: 2,

      behavior: {
        global: {venus: 1},
      },

      metadata: {
        cardNumber: 'x291',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).br;
        }),
        description: 'Requires Venus 20%. Raise Venus 1 step.',
      },
    });
  }
}

================
File: cards/chemical/venus/LocalDecompression.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {GlobalParameter} from '../../../../common/GlobalParameter';
import {Tag} from '../../../../common/cards/Tag';

export class LocalDecompression extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.LOCAL_DECOMPRESSION,
      tags: [Tag.VENUS],
      cost: 13,
      globalParameterRequirementBonus: {parameter: GlobalParameter.VENUS, steps: 2},

      behavior: {
        global: {venus: 1},
      },

      metadata: {
        cardNumber: 'x273',
        renderData: CardRenderer.builder((b) => {
          b.effect('Your Venus requirements are +/- 2 steps, your choice in each case.', (eb) => {
            eb.plate('Venus requirements').startEffect.text('+/- 2');
          }).br;
          b.venus(1);
        }),
        description: 'Raise Venus 1 step.',
      },
    });
  }
}

================
File: cards/chemical/venus/LocalMagneticShielding.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class LocalMagneticShielding extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.LOCAL_MAGNETIC_SHIELDING,
      tags: [Tag.VENUS],
      cost: 10,
      resourceType: CardResource.FLOATER,

      behavior: {
        addResources: 2,
      },

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 floaters to raise your TR 1 step',
            spend: {resourcesHere: 2},
            tr: 1,
          },
          {
            title: 'Spend 2 M€ to add 1 floater to ANY card',
            spend: {megacredits: 2},
            addResourcesToAnyCard: {type: CardResource.FLOATER, count: 1},
          }],
        },
      },

      metadata: {
        cardNumber: 'x261',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 M€ to add 1 floater to ANY card.', (eb) => {
            eb.megacredits(2).startAction.resource(CardResource.FLOATER).asterix();
          }).br;
          b.or().br;
          b.action('Remove 2 floaters from this card to raise your TR 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.tr(1);
          }).br;
          b.resource(CardResource.FLOATER, 2);
        }),
        description: 'Add 2 floaters to this card.',
      },
    });
  }
}

================
File: cards/chemical/venus/LowLevelScrappers.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class LowLevelScrappers extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.LOW_LEVEL_SCRAPPERS,
      tags: [Tag.VENUS],
      cost: 4,
      resourceType: CardResource.FLOATER,
      requirements: {venus: 10},

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 floaters to raise Venus 1 step',
            spend: {resourcesHere: 2},
            global: {venus: 1},
          },
          {
            title: 'Spend 2 energy to add 2 floaters to this card',
            spend: {energy: 2},
            addResources: 2,
          }],
        },
      },

      metadata: {
        cardNumber: 'x259',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 energy to add 2 floaters to this card.', (eb) => {
            eb.energy(2).startAction.resource(CardResource.FLOATER, 2);
          }).br;
          b.or().br;
          b.action('Remove 2 floaters from this card to raise Venus 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.venus(1);
          }).br;
        }),
        description: 'Requires Venus 10%.',
      },
    });
  }
}

================
File: cards/chemical/venus/MesosphereShades.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class MesosphereShades extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MESOSPHERE_SHADES,
      tags: [Tag.VENUS],
      cost: 10,
      resourceType: CardResource.FLOATER,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 floaters to raise Venus 1 step',
            spend: {resourcesHere: 2},
            global: {venus: 1},
          },
          {
            title: 'Add 1 floater to ANY card',
            addResourcesToAnyCard: {type: CardResource.FLOATER, count: 1},
          }],
        },
      },

      metadata: {
        cardNumber: 'x258',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to ANY card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER).asterix();
          }).br;
          b.or().br;
          b.action('Remove 2 floaters from this card to raise Venus 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.venus(1);
          }).br;
        }),
      },
    });
  }
}

================
File: cards/chemical/venus/NearMissRotaryAsteroid.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

export class NearMissRotaryAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.NEAR_MISS_ROTARY_ASTEROID,
      tags: [Tag.SPACE],
      cost: 14,
      victoryPoints: 1,

      behavior: {
        global: {venus: 1},
        addResourcesToAnyCard: {type: CardResource.ASTEROID, count: 1},
      },

      metadata: {
        cardNumber: 'x242',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).nbsp.resource(CardResource.ASTEROID).asterix();
        }),
        description: 'Raise Venus 1 step and add an asteroid to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/venus/NeutralizerDrones.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class NeutralizerDrones extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.NEUTRALIZER_DRONES,
      tags: [Tag.VENUS],
      cost: 6,
      requirements: {floaters: 3},

      behavior: {
        global: {venus: 1},
      },

      metadata: {
        cardNumber: 'x286',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).br;
        }),
        description: 'Requires 3 floaters. Raise Venus 1 step.',
      },
    });
  }
}

================
File: cards/chemical/venus/NitrogenFromVenus.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

export class NitrogenFromVenus extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.NITROGEN_FROM_VENUS,
      tags: [Tag.VENUS, Tag.SPACE],
      cost: 18,
      victoryPoints: 1,

      behavior: {
        tr: 1,
        addResourcesToAnyCard: [{type: CardResource.MICROBE, count: 2, autoSelect: true}, {type: CardResource.FLOATER, count: 2, autoSelect: true}],
      },

      metadata: {
        cardNumber: 'x247',
        renderData: CardRenderer.builder((b) => {
          b.tr(1).br.resource(CardResource.MICROBE, 2).asterix().resource(CardResource.FLOATER, 2).asterix();
        }),
        description: 'Raise your TR 1 step, add 2 microbes to ANOTHER card, and 2 floaters to ANOTHER card.',
      },
    });
  }
}

================
File: cards/chemical/venus/OvdaCity.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {SpaceName} from '../../../SpaceName';

export class OvdaCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.OVDA_CITY,
      tags: [Tag.CITY, Tag.VENUS],
      cost: 14,
      requirements: {venus: 18},
      victoryPoints: {tag: Tag.VENUS, per: 2},

      behavior: {
        production: {megacredits: 3, energy: -1},
        city: {space: SpaceName.OVDA_CITY},
      },

      metadata: {
        cardNumber: 'x280',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          });
          b.city().asterix().br;
          b.vpText('1 VP for every 2 Venus tags you have.').br;
        }),
        description: 'Requires Venus 18%. Decrease your energy production 1 step and increase your M€ production 3 steps. Place a city tile ON THE RESERVED AREA.',
      },
    });
  }
}

================
File: cards/chemical/venus/PanSolarMining.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {ActionCard} from '../../ActionCard';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class PanSolarMining extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PAN_SOLAR_MINING,
      tags: [Tag.JOVIAN, Tag.SPACE],
      cost: 36,
      requirements: [{tag: Tag.VENUS}, {tag: Tag.EARTH}, {tag: Tag.JOVIAN}],
      resourceType: CardResource.ASTEROID,
      victoryPoints: 3,

      behavior: {
        addResources: 1,
      },

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 1 asteroid to raise your titanium production 1 step.',
            spend: {resourcesHere: 1},
            production: {titanium: 1},
          },
          {
            title: 'Add 1 asteroid to ANY card',
            addResourcesToAnyCard: {type: CardResource.ASTEROID, count: 1},
          }],
        },
      },

      metadata: {
        cardNumber: 'x254',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 asteroid to ANY card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ASTEROID).asterix();
          }).br;
          b.or().br;
          b.action('Remove 1 asteroid from this card to raise your titanium production 1 step.', (eb) => {
            eb.resource(CardResource.ASTEROID).startAction.production((pb) => pb.titanium(1));
          }).br;
          b.resource(CardResource.ASTEROID);
        }),
        description: 'Requires an Earth tag, a Venus tag, and a Jovian tag. Add an asteroid to this card.',
      },
    });
  }
}

================
File: cards/chemical/venus/PHNeutralizers.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class PHNeutralizers extends ActionCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.PH_NEUTRALIZERS,
      type: CardType.ACTIVE,
      tags: [Tag.SCIENCE, Tag.MICROBE, Tag.VENUS],
      cost: 8,
      resourceType: CardResource.MICROBE,
      requirements: {venus: 6},

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 microbes to raise your TR 1 step',
            spend: {resourcesHere: 2},
            tr: 1,
          },
          {
            title: 'Add 1 microbe to this card',
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: 'x266',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.or().br;
          b.action('Remove 2 microbes from this card to raise your TR 1 step.', (eb) => {
            eb.resource(CardResource.MICROBE, 2).startAction.tr(1);
          }).br;
        }),
        description: 'Requires Venus 6%.',
      },
    });
  }
}

================
File: cards/chemical/venus/PhontoicMetamaterials.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

export class PhotonicMetamaterials extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PHOTONIC_METAMATERIALS,
      tags: [Tag.SCIENCE, Tag.VENUS],
      cost: 11,
      requirements: {tag: Tag.SCIENCE, count: 2},

      behavior: {
        global: {venus: 1},
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2, tag: Tag.VENUS},
      },

      metadata: {
        cardNumber: 'x285',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.VENUS}).br;
        }),
        description: 'Requires 2 science tags. Raise Venus 1 step and add 2 floaters to any Venus card.',
      },
    });
  }
}

================
File: cards/chemical/venus/RhizobiomeResearch.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {CardResource} from '../../../../common/CardResource';

export class RhizobiomeResearch extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.RHIZOBIOME_RESEARCH,
      tags: [Tag.SCIENCE, Tag.MICROBE],
      cost: 12,

      behavior: {
        production: {plants: {tag: Tag.MICROBE, per: 2}},
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 2},
      },

      metadata: {
        cardNumber: 'x302',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1).slash().tag(Tag.MICROBE, 2)).resource(CardResource.MICROBE).asterix();
        }),
        description: 'Increase your plant production 1 step for every 2 microbe tags you have, including this. Add 2 microbes to another card.',
      },
    });
  }
}

================
File: cards/chemical/venus/SkyCommunications.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {all} from '../../Options';
import {IPlayer} from '../../../IPlayer';
import {Space} from '../../../boards/Space';
import {Board} from '../../../boards/Board';
import {Resource} from '../../../../common/Resource';
import {Size} from '../../../../common/cards/render/Size';

export class SkyCommunications extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SKY_COMMUNICATIONS,
      tags: [Tag.VENUS],
      cost: 11,
      resourceType: CardResource.FLOATER,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'x262',
        renderData: CardRenderer.builder((b) => {
          b.effect('When any city tile is placed, add a floater here.', (eb) => {
            eb.city({all}).startEffect.resource(CardResource.FLOATER);
          }).br;
          b.action('Gain 1 M€ for each floater here (max 4).', (eb) => {
            eb.empty().startAction.megacredits(1).slash().resource(CardResource.FLOATER).text('[max 4]', Size.SMALL);
          }).br;
        }),
      },
    });
  }
  public onTilePlaced(_cardOwner: IPlayer, _activePlayer: IPlayer, space: Space) {
    if (Board.isCitySpace(space)) {
      this.resourceCount += 1;
    }
    return undefined;
  }
  public canAct(): boolean {
    return true;
  }
  public action(player: IPlayer): undefined {
    player.stock.add(Resource.MEGACREDITS, Math.min(this.resourceCount, 4), {log: true});
    return undefined;
  }
}

================
File: cards/chemical/venus/StellarCruisers.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class StellarCruisers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.STELLAR_CRUISERS,
      tags: [Tag.SPACE],
      cost: 10,
      victoryPoints: 1,
      requirements: {uniqueTags: {}, count: 9},

      behavior: {
        production: {megacredits: {tag: Tag.EARTH}},
      },

      metadata: {
        cardNumber: 'x294',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).slash().tag(Tag.EARTH);
          });
        }),
        description: 'Requires that you have 9 unique tags in play. Increase your M€ production 1 step for each Earth tag you have.',
      },
    });
  }
}

================
File: cards/chemical/venus/SulphurProcessing.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {all} from '../../Options';

export class SulphurProcessing extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SULPHUR_PROCESSING,
      tags: [Tag.BUILDING],
      cost: 10,

      behavior: {
        production: {megacredits: 2},
        stock: {megacredits: {tag: Tag.VENUS, all: true}},
      },

      metadata: {
        cardNumber: 'x293',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).nbsp.megacredits(1).slash().tag(Tag.VENUS, {all}).br;
        }),
        description: 'Increase your M€ production 2 steps and gain 1 M€ for every Venus tag in play.',
      },
    });
  }
}

================
File: cards/chemical/venus/SuperCarbonCollectors.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class SuperCarbonCollectors extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SUPER_CARBON_COLLECTORS,
      tags: [Tag.PLANT, Tag.VENUS],
      cost: 20,
      requirements: {venus: 20},
      victoryPoints: 1,

      behavior: {
        production: {plants: 2},
        global: {venus: 2},
      },

      metadata: {
        cardNumber: 'x292',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(2)).venus(2).br;
        }),
        description: 'Requires Venus 20%. Increase your plant production 2 steps and raise Venus 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/venus/SurfaceHabs.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class SurfaceHabs extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SURFACE_HABS,
      tags: [Tag.VENUS],
      cost: 12,
      requirements: {venus: 12},
      victoryPoints: 2,

      behavior: {
        production: {megacredits: 1},
        drawCard: {count: 2, tag: Tag.VENUS},
      },

      metadata: {
        cardNumber: 'x299',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(3)).nbsp;
          b.wild(1, {secondaryTag: Tag.VENUS});
        }),
        description: 'Requires Venus 12%. Increase your M€ production 1 step and draw 2 cards with Venus tags.',
      },
    });
  }
}

================
File: cards/chemical/venus/SwarmShaders.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class SwarmShaders extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SWARM_SHADERS,
      tags: [Tag.VENUS, Tag.SPACE],
      cost: 18,

      behavior: {
        global: {venus: 2},
      },

      metadata: {
        cardNumber: 'x283',
        renderData: CardRenderer.builder((b) => {
          b.venus(2).br;
        }),
        description: 'Raise Venus 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/venus/TerrestrialAlliance.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class TerrestrialAlliance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TERRESTRIAL_ALLIANCE,
      cost: 3,
      requirements: [{tag: Tag.VENUS}, {tag: Tag.EARTH}],

      behavior: {
        tr: 1,
      },

      metadata: {
        cardNumber: 'x306',
        renderData: CardRenderer.builder((b) => {
          b.tr(1);
        }),
        description: 'Requires an Earth tag and a Venus tag. Raise your TR 1 step.',
      },
    });
  }
}

================
File: cards/chemical/venus/TheBehemoth.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

export class TheBehemoth extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.THE_BEHEMOTH,
      tags: [Tag.VENUS],
      cost: 20,
      requirements: {tag: Tag.SCIENCE, count: 4},
      victoryPoints: {tag: Tag.VENUS, per: 2},

      behavior: {
        production: {megacredits: 2},
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 3, tag: Tag.VENUS},
      },

      metadata: {
        cardNumber: 'x278',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).resource(CardResource.FLOATER, {amount: 3, secondaryTag: Tag.VENUS}).br;
          b.vpText('1 VP for every 2 Venus tags you have.').br;
        }),
        description: 'Requires 4 science tags. Increase your M€ production 2 steps and add 3 floaters to any Venus card.',
      },
    });
  }
}

================
File: cards/chemical/venus/ThemisBiodomes.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {SelectCard} from '../../../inputs/SelectCard';
import {ICard} from '../../ICard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {IProjectCard} from '../../IProjectCard';

export class ThemisBiodomes extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.THEMIS_BIODOMES,
      type: CardType.AUTOMATED,
      tags: [Tag.PLANT, Tag.VENUS],
      cost: 9,

      requirements: {venus: 16},
      victoryPoints: 1,

      behavior: {
        production: {energy: -1, megacredits: 2},
      },

      metadata: {
        cardNumber: 'x300',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.MICROBE, {amount: 2, secondaryTag: Tag.VENUS}).or().resource(CardResource.ANIMAL, {amount: 2, secondaryTag: Tag.VENUS}).br;
          b.production((pb) => pb.minus().energy(1).nbsp.plus().megacredits(2));
        }),
        description: {
          text: 'Requires Venus 16%. Add 2 microbes or 2 animals to a Venus card. Decrease your energy production 1 step and increase your M€ production 2 steps.',
          align: 'left',
        },
      },
    });
  }
  public getResCards(player: IPlayer): ICard[] {
    let resourceCards = player.getResourceCards(CardResource.ANIMAL);
    resourceCards = resourceCards.concat(player.getResourceCards(CardResource.MICROBE));
    return resourceCards.filter((card) => card.tags.includes(Tag.VENUS));
  }

  public override bespokePlay(player: IPlayer) {
    const cards = this.getResCards(player);

    if (cards.length > 1) {
      return new SelectCard(
        'Select card to add 2 resources',
        'Add resources',
        cards)
        .andThen(([card]) => {
          player.addResourceTo(card, {qty: 2, log: true});
          return undefined;
        });
    }

    if (cards.length === 1) {
      player.addResourceTo(cards[0], {qty: 2, log: true});
    }
    return undefined;
  }
}

================
File: cards/chemical/venus/TowersOfFreyja.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {SpaceName} from '../../../SpaceName';

export class TowersOfFreyja extends Card {
  constructor() {
    super({
      name: CardName.TOWERS_OF_FREYJA,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 18,
      requirements: {venus: 10},
      victoryPoints: 3,

      behavior: {
        city: {space: SpaceName.TOWERS_OF_FREYJA},
      },

      cardDiscount: {tag: Tag.VENUS, amount: 2},
      metadata: {
        cardNumber: 'x275',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a Venus card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.VENUS).startEffect.megacredits(-2);
          }).br;
          b.city().asterix();
        }),
        description: 'Requires 10% Venus or higher. Place a city tile ON THE RESERVED AREA',
      },
    });
  }
}

================
File: cards/chemical/venus/UltralightFloaters.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {CardResource} from '../../../../common/CardResource';

export class UltralightFloaters extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ULTRALIGHT_FLOATERS,
      tags: [Tag.VENUS],
      cost: 3,
      requirements: {venus: 6},

      behavior: {
        production: {megacredits: 1},
        addResourcesToAnyCard: {type: CardResource.FLOATER, tag: Tag.VENUS, count: 2, autoSelect: true},
      },

      metadata: {
        cardNumber: 'x250',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1)).resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.VENUS});
        }),
        description: 'Requires Venus 6%. Increase your M€ production 1 step and add 2 floaters to any Venus card.',
      },
    });
  }
}

================
File: cards/chemical/venus/UndergroundVenusBase.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';

export class UndergroundVenusBase extends Card {
  constructor() {
    super({
      name: CardName.UNDERGROUND_VENUS_BASE,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 13,
      requirements: {venus: 6},
      victoryPoints: 2,

      behavior: {
        production: {steel: 1},
      },

      metadata: {
        cardNumber: 'x274',
        renderData: CardRenderer.builder((b) => {
          b.effect('When playing a Venus tag, steel may be used as 2 M€ each.',
            (eb) => eb.tag(Tag.VENUS).startEffect.steel(1).equals().megacredits(2)).br;
          b.production((pb) => pb.steel(1));
        }),
        description: 'Requires 6% Venus or higher. Increase your steel production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/venus/VeneraOutpost.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';

export class VeneraOutpost extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.VENERA_OUTPOST,
      type: CardType.ACTIVE,
      tags: [Tag.SCIENCE, Tag.VENUS],
      cost: 18,
      requirements: {venus: 14},
      victoryPoints: 2,
      cardDiscount: {amount: 1},

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: 'x270',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a card, you pay 1 M€ less for it.', (eb) => {
            eb.empty().startEffect.megacredits(-1);
          }).br;
          b.cards(2);
        }),
        description: 'Requires 14% Venus or higher. Draw 2 cards.',
      },
    });
  }
}

================
File: cards/chemical/venus/VenusBiolab.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {ActionCard} from '../../ActionCard';

export class VenusBiolab extends ActionCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.VENUS_BIOLAB,
      type: CardType.ACTIVE,
      tags: [Tag.MICROBE, Tag.ANIMAL, Tag.VENUS],
      cost: 10,
      requirements: {venus: 10},
      victoryPoints: 1,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 M€ to add 2 microbes to ANY card',
            spend: {megacredits: 2},
            addResourcesToAnyCard: {type: CardResource.MICROBE, count: 2},
          },
          {
            title: 'Spend 2 M€ to add 1 animal to ANY card',
            spend: {megacredits: 2},
            addResourcesToAnyCard: {type: CardResource.ANIMAL, count: 1},
          }],
        },
      },

      metadata: {
        cardNumber: 'x272',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 M€ to add 2 microbes or 1 animal to ANY card.', (eb) => {
            eb.megacredits(2).startAction.resource(CardResource.MICROBE, 2).asterix().slash().resource(CardResource.ANIMAL).asterix();
          }).br;
        }),
        description: 'Requires Venus 10%.',
      },
    });
  }
}

================
File: cards/chemical/venus/VenusGeologicalSurvey.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class VenusGeologicalSurvey extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.VENUS_GEOLOGICAL_SURVEY,
      tags: [Tag.SCIENCE, Tag.VENUS],
      cost: 11,
      requirements: {tag: Tag.VENUS, count: 1},
      victoryPoints: 1,

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: 'x312',
        renderData: CardRenderer.builder((b) => {
          b.cards(2);
        }),
        description: 'Requires 1 Venus tag. Draw 2 cards',
      },
    });
  }
}

================
File: cards/chemical/venus/VenusianFungi.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';
import {CardResource} from '../../../../common/CardResource';

export class VenusianFungi extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.VENUSIAN_FUNGI,
      tags: [Tag.MICROBE, Tag.VENUS],
      cost: 14,
      requirements: {venus: 10},
      victoryPoints: 1,

      behavior: {
        global: {venus: 1},
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 3, tag: Tag.VENUS},
      },

      metadata: {
        cardNumber: 'x289',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).resource(CardResource.MICROBE, {amount: 3, secondaryTag: Tag.VENUS}).br;
        }),
        description: 'Requires Venus 10%. Raise Venus 1 step and add 3 microbes to any Venus card.',
      },
    });
  }
}

================
File: cards/chemical/venus/VenusMiningExpedition.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {digit} from '../../Options';

export class VenusMiningExpedition extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.VENUS_MINING_EXPEDITION,
      tags: [Tag.VENUS],
      cost: 8,
      requirements: {venus: 8},

      behavior: {
        stock: {steel: 5, titanium: 2},
      },

      metadata: {
        cardNumber: 'x249',
        renderData: CardRenderer.builder((b) => {
          b.steel(5, {digit}).nbsp.titanium(2, {digit});
        }),
        description: 'Requires Venus 8%. Gain 5 steel and 2 titanium.',
      },
    });
  }
}

================
File: cards/chemical/venus/VenusMiningIndustries.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class VenusMiningIndustries extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.VENUS_MINING_INDUSTIRES,
      tags: [Tag.VENUS],
      cost: 32,
      requirements: {venus: 8},
      victoryPoints: {tag: Tag.VENUS, per: 2},

      behavior: {
        production: {steel: 1, titanium: 2},
      },

      metadata: {
        cardNumber: 'x279',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.steel(1).br;
            pb.titanium(2);
          }).br;
          b.vpText('1 VP for every 2 Venus tags you have.').br;
        }),
        description: 'Requires Venus 8%. Increase your steel production 1 step and your titanium production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/venus/VenusPlantation.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {IPlayer} from '../../../IPlayer';
import {CardResource} from '../../../../common/CardResource';
import {SelectCard} from '../../../inputs/SelectCard';
import {ICard} from '../../ICard';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {IProjectCard} from '../../IProjectCard';

export class VenusPlantation extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.VENUS_PLANTATION,
      type: CardType.AUTOMATED,
      tags: [Tag.PLANT, Tag.VENUS],
      cost: 15,

      requirements: {venus: 24},
      victoryPoints: 3,

      behavior: {
        drawCard: {tag: Tag.VENUS, count: 2},
      },

      metadata: {
        cardNumber: 'x308',
        renderData: CardRenderer.builder((b) => {
          b.cards(2, {secondaryTag: Tag.VENUS}).br;
          b.resource(CardResource.MICROBE, {secondaryTag: Tag.VENUS}).or().resource(CardResource.ANIMAL, {secondaryTag: Tag.VENUS}).br;
        }),
        description: 'Requires Venus 24%. Draw 2 cards with Venus tags. Add 1 microbe or 1 animal to a Venus card.',
      },
    });
  }
  public getResCards(player: IPlayer): ICard[] {
    let resourceCards = player.getResourceCards(CardResource.ANIMAL);
    resourceCards = resourceCards.concat(player.getResourceCards(CardResource.MICROBE));
    return resourceCards.filter((card) => card.tags.includes(Tag.VENUS));
  }

  public override bespokePlay(player: IPlayer) {
    const cards = this.getResCards(player);

    if (cards.length > 1) {
      return new SelectCard(
        'Select card to add 1 resource',
        'Add resources',
        cards)
        .andThen(([card]) => {
          player.addResourceTo(card, {qty: 1, log: true});
          return undefined;
        });
    }

    if (cards.length === 1) {
      player.addResourceTo(cards[0], {qty: 1, log: true});
    }
    return undefined;
  }
}

================
File: cards/chemical/venus/VenusPowerPlant.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class VenusPowerPlant extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.VENUS_POWER_PLANT,
      tags: [Tag.POWER, Tag.VENUS],
      cost: 5,
      requirements: {venus: 10},

      behavior: {
        production: {energy: 2},
      },

      metadata: {
        cardNumber: 'x305',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2));
        }),
        description: 'Requires Venus 10%. Increase your energy production 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/venus/VenusSolarWaystation.ts
================
import {Tag} from '../../../../common/cards/Tag';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';

export class VenusSolarWaystation extends Card {
  constructor() {
    super({
      name: CardName.VENUS_SOLAR_WAYSTATION,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS, Tag.SPACE],
      cost: 18,
      requirements: {tag: Tag.VENUS, count: 2},
      victoryPoints: 2,

      behavior: {
        production: {titanium: 1},
      },

      cardDiscount: {tag: Tag.SPACE, amount: 2},
      metadata: {
        cardNumber: 'x276',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-2);
          }).br;
          b.production((pb) => pb.titanium(1));
        }),
        description: 'Requires that you have 2 Venus tags. Increase your titanium production 1 step.',
      },
    });
  }
}

================
File: cards/chemical/venus/VenusSurfaceDwellers.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {CardType} from '../../../../common/cards/CardType';
import {CardResource} from '../../../../common/CardResource';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Card} from '../../Card';
import {IPlayer} from '../../../IPlayer';
import {ICard} from '../../ICard';
import {SelectCard} from '../../../inputs/SelectCard';

export class VenusSurfaceDwellers extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.VENUS_SURFACE_DWELLERS,
      type: CardType.ACTIVE,
      tags: [Tag.ANIMAL, Tag.VENUS],
      cost: 25,
      resourceType: CardResource.ANIMAL,
      requirements: {venus: 24},
      victoryPoints: {resourcesHere: {}, each: 2},

      metadata: {
        cardNumber: 'x269',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend any resource from another one of your Venus cards to add an animal to this card.', (eb) => {
            eb.wild(1, {secondaryTag: Tag.VENUS}).startAction.resource(CardResource.ANIMAL);
          }).br;
          b.vpText('2 VP per animal on this card.').br;
        }),
        description: 'Requires 24% Venus or higher.',
      },
    });
  }
  public getOtherVenusResourceCards(player: IPlayer): Array<ICard> {
    return player.getResourceCards().filter((card) => card.tags.includes(Tag.VENUS) && card !== this && card.resourceCount > 0);
  }
  public canAct(player: IPlayer): boolean {
    return this.getOtherVenusResourceCards(player).length > 0;
  }
  public action(player: IPlayer): SelectCard<ICard> | undefined {
    return new SelectCard(
      'Select card to remove a resource from',
      'Remove resource',
      this.getOtherVenusResourceCards(player))
      .andThen(([card]) => {
        player.removeResourceFrom(card, 1, {log: true});
        player.addResourceTo(this, {qty: 1, log: true});
        return undefined;
      });
  }
}

================
File: cards/chemical/venus/VenusTourism.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class VenusTourism extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.VENUS_TOURISM,
      tags: [Tag.EARTH, Tag.VENUS],
      cost: 5,
      requirements: {venus: 8},

      behavior: {
        production: {megacredits: {tag: Tag.VENUS}},
      },

      metadata: {
        cardNumber: 'x297',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).slash().tag(Tag.VENUS);
          });
        }),
        description: 'Requires Venus 8%. Increase your M€ production 1 step for each Venus tag you have.',
      },
    });
  }
}

================
File: cards/chemical/venus/VortexEngine.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';
import {Tag} from '../../../../common/cards/Tag';

export class VortexEngine extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.VORTEX_ENGINE,
      tags: [Tag.VENUS],
      cost: 12,

      behavior: {
        global: {venus: 2},
        production: {megacredits: -1},
      },

      metadata: {
        cardNumber: 'x284',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(-1)).venus(2).br;
        }),
        description: 'Decrease your M€ production 1 step and raise Venus 2 steps.',
      },
    });
  }
}

================
File: cards/chemical/venus/WorkerDrones.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class WorkerDrones extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.WORKER_DRONES,
      tags: [Tag.SCIENCE, Tag.VENUS],
      cost: 8,

      behavior: {
        addResourcesToAnyCard: {
          tag: Tag.VENUS,
          count: 2,
          autoSelect: true,
          mustHaveCard: false,
        },
      },

      metadata: {
        cardNumber: 'x309',
        renderData: CardRenderer.builder((b) => {
          b.wild(2, {secondaryTag: Tag.VENUS});
        }),
        description: 'Add any 2 resources to a Venus card.',
      },
    });
  }
}

================
File: cards/chemical/venus/WorldGovernmentOffices.ts
================
import {IProjectCard} from '../../IProjectCard';
import {Tag} from '../../../../common/cards/Tag';
import {Card} from '../../Card';
import {CardType} from '../../../../common/cards/CardType';
import {CardName} from '../../../../common/cards/CardName';
import {CardRenderer} from '../../render/CardRenderer';

export class WorldGovernmentOffices extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.WORLD_GOVERNMENT_OFFICES,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 22,
      requirements: [{tag: Tag.VENUS}, {tag: Tag.EARTH}, {tag: Tag.JOVIAN}],
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 4, energy: -1},
        city: {},
      },

      metadata: {
        cardNumber: 'x296',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(4);
          }).nbsp;
          b.city();
        }),
        description: 'Requires an Earth tag, a Venus tag, and a Jovian tag. Decrease your energy production 1 step and increase your M€ production 4 steps. Place a city tile.',
      },
    });
  }
}

================
File: cards/chemical/VenusTradeStation.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';

export class VenusTradeStation extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 13,
      tags: [Tag.VENUS],
      name: CardName.VENUS_TRADE_STATION,
      type: CardType.ACTIVE,

      metadata: {
        cardNumber: 'x348',
        renderData: CardRenderer.builder((b) => {
          b.action('Move one of your trade fleets from the Trade Fleets Tile to this card to increase your energy production 1 step. Fleets on this card may no longer trade, and return to the Trade Fleets Tile during the Solar Phase.', (eb) => {
            eb.tradeFleet().asterix().startAction.production((pb) => pb.energy(1));
          }).br;
        }),
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.colonies.getFleetSize() > player.colonies.tradesThisGeneration;
  }
  public action(player: IPlayer) {
    player.colonies.tradesThisGeneration++;
    player.production.add(Resource.ENERGY, 1, {log: true});
    return undefined;
  }
}

================
File: cards/colonies/Airliners.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';

export class Airliners extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 11,
      name: CardName.AIRLINERS,
      type: CardType.AUTOMATED,
      requirements: {floaters: 3},
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 2},
        addResourcesToAnyCard: {count: 2, type: CardResource.FLOATER},
      },

      metadata: {
        cardNumber: 'C01',
        description: 'Requires that you have 3 floaters. Increase your M€ production 2 steps. Add 2 floaters to ANY card.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).br;
          b.resource(CardResource.FLOATER, 2).asterix();
        }),
      },
    });
  }
}

================
File: cards/colonies/AirRaid.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardResource} from '../../../common/CardResource';
import {RemoveResourcesFromCard} from '../../deferredActions/RemoveResourcesFromCard';
import {StealResources} from '../../deferredActions/StealResources';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class AirRaid extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 0,
      name: CardName.AIR_RAID,
      type: CardType.EVENT,

      metadata: {
        cardNumber: 'C02',
        description: 'Requires that you lose 1 floater. Steal 5 M€ from any player.',
        renderData: CardRenderer.builder((b) => {
          b.minus().resource(CardResource.FLOATER);
          b.text('steal', Size.MEDIUM, true).megacredits(5, {all});
        }),
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.getResourceCount(CardResource.FLOATER) > 0;
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new StealResources(player, Resource.MEGACREDITS, 5));
    player.game.defer(new RemoveResourcesFromCard(player, CardResource.FLOATER, 1, {source: 'self', blockable: false}));
    return undefined;
  }
}

================
File: cards/colonies/Aridor.ts
================
import {ICorporationCard} from '../corporation/ICorporationCard';
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ColoniesHandler} from '../../colonies/ColoniesHandler';
import {SerializedCard} from '../../SerializedCard';
import {ICard} from '../ICard';

export class Aridor extends CorporationCard {
  constructor() {
    super({
      name: CardName.ARIDOR,
      startingMegaCredits: 40,
      initialActionText: 'Add a colony tile',

      metadata: {
        cardNumber: 'R20',
        description: 'You start with 40 M€. As your first action, put an additional Colony Tile of your choice into play',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(40).nbsp.colonyTile();
          b.corpBox('effect', (ce) => {
            ce.effect('When you get a new type of tag in play [event cards do not count], increase your M€ production 1 step.', (eb) => {
              eb.diverseTag().startEffect.production((pb) => pb.megacredits(1));
            });
          });
        }),
      },
    });
  }
  public allTags = new Set<Tag>();

  private tagsForCard(card: ICard): Array<Tag> {
    if (card.type === CardType.EVENT) {
      return [];
    }
    return card.tags.filter((tag) => tag !== Tag.WILD);
  }

  public override bespokePlay(player: IPlayer) {
    for (const card of player.tableau) {
      for (const tag of this.tagsForCard(card)) {
        this.allTags.add(tag);
      }
    }
    return undefined;
  }

  public initialAction(player: IPlayer) {
    ColoniesHandler.addColonyTile(
      player,
      {title: 'Aridor first action - Select colony tile to add'},
    );
    return undefined;
  }

  private processTags(player: IPlayer, tags: ReadonlyArray<Tag>) {
    for (const tag of tags) {
      const currentSize = this.allTags.size;
      this.allTags.add(tag);
      if (this.allTags.size > currentSize) {
        player.game.log('${0} gained 1 M€ production from ${1} for ${2}', (b) => b.player(player).card(this).string(tag));
        player.production.add(Resource.MEGACREDITS, 1, {log: true});
      }
    }
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    return this.onCardPlayed(player, card);
  }

  public onColonyAddedToLeavitt(player: IPlayer) {
    this.processTags(player, [Tag.SCIENCE]);
  }

  public onCardPlayed(player: IPlayer, card: ICard) {
    if (!player.isCorporation(this.name)) {
      return;
    }
    this.processTags(player, this.tagsForCard(card));
  }

  public serialize(serialized: SerializedCard) {
    serialized.allTags = Array.from(this.allTags);
  }

  public deserialize(serialized: SerializedCard) {
    this.allTags = new Set(serialized.allTags);
  }
}

================
File: cards/colonies/Arklight.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Arklight extends CorporationCard {
  constructor() {
    super({
      name: CardName.ARKLIGHT,
      tags: [Tag.ANIMAL],
      startingMegaCredits: 45,
      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},

      behavior: {
        production: {megacredits: 2},
        addResources: 1,
      },

      metadata: {
        cardNumber: 'R04',
        description: 'You start with 45 M€. Increase your M€ production 2 steps. 1 VP per 2 animals on this card.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(45).nbsp.production((pb) => pb.megacredits(2));
          b.corpBox('effect', (ce) => {
            ce.effect('When you play an animal or plant tag, including this, add 1 animal to this card.', (eb) => {
              eb.tag(Tag.ANIMAL).slash().tag(Tag.PLANT).startEffect.resource(CardResource.ANIMAL);
            });
            ce.vSpace(); // to offset the description to the top a bit so it can be readable
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    if (player.isCorporation(CardName.ARKLIGHT)) {
      player.addResourceTo(this, {qty: card.tags.filter((cardTag) => cardTag === Tag.ANIMAL || cardTag === Tag.PLANT).length, log: true});
    }
  }
}

================
File: cards/colonies/AtmoCollectors.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {Size} from '../../../common/cards/render/Size';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {ActionCard} from '../ActionCard';

export class AtmoCollectors extends ActionCard implements IProjectCard {
  constructor() {
    super({
      cost: 15,
      name: CardName.ATMO_COLLECTORS,
      type: CardType.ACTIVE,
      resourceType: CardResource.FLOATER,

      behavior: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2},
      },

      action: {
        or: {
          behaviors: [
            {
              title: 'Remove 1 floater to gain 2 titanium',
              spend: {resourcesHere: 1},
              stock: {titanium: 2},
            },
            {
              title: 'Remove 1 floater to gain 3 energy',
              spend: {resourcesHere: 1},
              stock: {energy: 3},
            },
            {
              title: 'Remove 1 floater to gain 4 heat',
              spend: {resourcesHere: 1},
              stock: {heat: 4},
            },
            {
              title: 'Add 1 floater to this card',
              addResources: 1,
            },
          ],
          autoSelect: true,
        },
      },

      metadata: {
        description: 'Add 2 floaters to ANY card.',
        cardNumber: 'C03',
        renderData: CardRenderer.builder((b) => {
          b.action('Add one floater here.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER).or(Size.SMALL);
          }).br;
          b.action('Spend 1 floater here to gain 2 titanium, or 3 energy, or 4 heat.', (eb) => {
            eb.resource(CardResource.FLOATER).startAction.titanium(2, {digit}).slash(Size.SMALL).energy(3, {digit}).slash(Size.SMALL).heat(4, {digit});
          }).br;
          b.resource(CardResource.FLOATER, 2).asterix();
        }),
      },
    });
  }
}

================
File: cards/colonies/BuildColonyStandardProject.ts
================
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {StandardProjectCard} from '../StandardProjectCard';
import {ColonyName} from '../../../common/colonies/ColonyName';
import {BuildColony} from '../../deferredActions/BuildColony';

export class BuildColonyStandardProject extends StandardProjectCard {
  constructor() {
    super({
      name: CardName.BUILD_COLONY_STANDARD_PROJECT,
      cost: 17,
      metadata: {
        cardNumber: 'SP5',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 17 M€ to place a colony.', (eb) => {
            eb.megacredits(17).startAction.colonies();
          }),
        ),
      },
    });
  }

  protected override discount(player: IPlayer): number {
    const adhaiDiscount = Math.floor(player.resourcesOnCard(CardName.ADHAI_HIGH_ORBIT_CONSTRUCTIONS) / 2);
    return adhaiDiscount + super.discount(player);
  }

  private getOpenColonies(player: IPlayer) {
    let openColonies = player.game.colonies.filter((colony) => !colony.isFull() &&
      colony.colonies.includes(player.id) === false &&
      colony.isActive);

    // TODO(kberg): Europa sometimes costs additional 3.
    const canAffordVenus = player.canAfford({cost: this.cost, tr: {venus: 1}});
    if (!canAffordVenus) {
      openColonies = openColonies.filter((colony) => colony.name !== ColonyName.VENUS);
    }

    return openColonies;
  }

  public override canAct(player: IPlayer): boolean {
    return super.canAct(player) && this.getOpenColonies(player).length > 0;
  }

  actionEssence(player: IPlayer): void {
    player.game.defer(new BuildColony(player));
  }
}

================
File: cards/colonies/ColoniesCardManifest.ts
================
import {CardName} from '../../../common/cards/CardName';
import {ModuleManifest} from '../ModuleManifest';
import {Airliners} from './Airliners';
import {AirRaid} from './AirRaid';
import {Aridor} from './Aridor';
import {Arklight} from './Arklight';
import {AtmoCollectors} from './AtmoCollectors';
import {CommunityServices} from './CommunityServices';
import {Conscription} from './Conscription';
import {CoronaExtractor} from './CoronaExtractor';
import {CryoSleep} from './CryoSleep';
import {EarthElevator} from './EarthElevator';
import {EcologyResearch} from './EcologyResearch';
import {FloaterLeasing} from './FloaterLeasing';
import {FloaterPrototypes} from './FloaterPrototypes';
import {FloaterTechnology} from './FloaterTechnology';
import {GalileanWaystation} from './GalileanWaystation';
import {HeavyTaxation} from './HeavyTaxation';
import {IceMoonColony} from './IceMoonColony';
import {ImpactorSwarm} from './ImpactorSwarm';
import {InterplanetaryColonyShip} from './InterplanetaryColonyShip';
import {JovianLanterns} from './JovianLanterns';
import {JupiterFloatingStation} from './JupiterFloatingStation';
import {LunaGovernor} from './LunaGovernor';
import {LunarExports} from './LunarExports';
import {LunarMining} from './LunarMining';
import {MarketManipulation} from './MarketManipulation';
import {MartianZoo} from './MartianZoo';
import {MiningColony} from './MiningColony';
import {MinorityRefuge} from './MinorityRefuge';
import {MolecularPrinting} from './MolecularPrinting';
import {NitrogenFromTitan} from './NitrogenFromTitan';
import {PioneerSettlement} from './PioneerSettlement';
import {Polyphemos} from './Polyphemos';
import {Poseidon} from './Poseidon';
import {ProductiveOutpost} from './ProductiveOutpost';
import {QuantumCommunications} from './QuantumCommunications';
import {RedSpotObservatory} from './RedSpotObservatory';
import {RefugeeCamps} from './RefugeeCamps';
import {ResearchColony} from './ResearchColony';
import {RimFreighters} from './RimFreighters';
import {SkyDocks} from './SkyDocks';
import {SolarProbe} from './SolarProbe';
import {SolarReflectors} from './SolarReflectors';
import {SpacePort} from './SpacePort';
import {SpacePortColony} from './SpacePortColony';
import {SpinoffDepartment} from './SpinoffDepartment';
import {StormCraftIncorporated} from './StormCraftIncorporated';
import {SubZeroSaltFish} from './SubZeroSaltFish';
import {TitanAirScrapping} from './TitanAirScrapping';
import {TitanFloatingLaunchPad} from './TitanFloatingLaunchPad';
import {TitanShuttles} from './TitanShuttles';
import {TradeEnvoys} from './TradeEnvoys';
import {TradingColony} from './TradingColony';
import {UrbanDecomposers} from './UrbanDecomposers';
import {WarpDrive} from './WarpDrive';
import {BuildColonyStandardProject} from './BuildColonyStandardProject';

export const COLONIES_CARD_MANIFEST = new ModuleManifest({
  module: 'colonies',

  projectCards: {
    [CardName.AIRLINERS]: {Factory: Airliners},
    [CardName.AIR_RAID]: {Factory: AirRaid},
    [CardName.ATMO_COLLECTORS]: {Factory: AtmoCollectors},
    [CardName.COMMUNITY_SERVICES]: {Factory: CommunityServices},
    [CardName.CONSCRIPTION]: {Factory: Conscription},
    [CardName.CORONA_EXTRACTOR]: {Factory: CoronaExtractor},
    [CardName.CRYO_SLEEP]: {Factory: CryoSleep},
    [CardName.EARTH_ELEVATOR]: {Factory: EarthElevator},
    [CardName.ECOLOGY_RESEARCH]: {Factory: EcologyResearch},
    [CardName.FLOATER_LEASING]: {Factory: FloaterLeasing},
    [CardName.FLOATER_PROTOTYPES]: {Factory: FloaterPrototypes},
    [CardName.FLOATER_TECHNOLOGY]: {Factory: FloaterTechnology},
    [CardName.GALILEAN_WAYSTATION]: {Factory: GalileanWaystation},
    [CardName.HEAVY_TAXATION]: {Factory: HeavyTaxation},
    [CardName.ICE_MOON_COLONY]: {Factory: IceMoonColony},
    [CardName.IMPACTOR_SWARM]: {Factory: ImpactorSwarm},
    [CardName.INTERPLANETARY_COLONY_SHIP]: {Factory: InterplanetaryColonyShip},
    [CardName.JOVIAN_LANTERNS]: {Factory: JovianLanterns},
    [CardName.JUPITER_FLOATING_STATION]: {Factory: JupiterFloatingStation},
    [CardName.LUNA_GOVERNOR]: {Factory: LunaGovernor},
    [CardName.LUNAR_EXPORTS]: {Factory: LunarExports},
    [CardName.LUNAR_MINING]: {Factory: LunarMining},
    [CardName.MARTIAN_ZOO]: {Factory: MartianZoo},
    [CardName.MARKET_MANIPULATION]: {Factory: MarketManipulation},
    [CardName.MINING_COLONY]: {Factory: MiningColony},
    [CardName.MINORITY_REFUGE]: {Factory: MinorityRefuge},
    [CardName.MOLECULAR_PRINTING]: {Factory: MolecularPrinting},
    [CardName.NITROGEN_FROM_TITAN]: {Factory: NitrogenFromTitan},
    [CardName.PIONEER_SETTLEMENT]: {Factory: PioneerSettlement},
    [CardName.PRODUCTIVE_OUTPOST]: {Factory: ProductiveOutpost},
    [CardName.QUANTUM_COMMUNICATIONS]: {Factory: QuantumCommunications},
    [CardName.RED_SPOT_OBSERVATORY]: {Factory: RedSpotObservatory},
    [CardName.RESEARCH_COLONY]: {Factory: ResearchColony},
    [CardName.RIM_FREIGHTERS]: {Factory: RimFreighters},
    [CardName.REFUGEE_CAMPS]: {Factory: RefugeeCamps},
    [CardName.SOLAR_PROBE]: {Factory: SolarProbe},
    [CardName.SOLAR_REFLECTORS]: {Factory: SolarReflectors},
    [CardName.SKY_DOCKS]: {Factory: SkyDocks},
    [CardName.SPACE_PORT]: {Factory: SpacePort},
    [CardName.SPACE_PORT_COLONY]: {Factory: SpacePortColony},
    [CardName.SPINOFF_DEPARTMENT]: {Factory: SpinoffDepartment},
    [CardName.SUBZERO_SALT_FISH]: {Factory: SubZeroSaltFish},
    [CardName.TITAN_AIRSCRAPPING]: {Factory: TitanAirScrapping},
    [CardName.TITAN_FLOATING_LAUNCHPAD]: {Factory: TitanFloatingLaunchPad},
    [CardName.TITAN_SHUTTLES]: {Factory: TitanShuttles},
    [CardName.TRADING_COLONY]: {Factory: TradingColony},
    [CardName.TRADE_ENVOYS]: {Factory: TradeEnvoys},
    [CardName.URBAN_DECOMPOSERS]: {Factory: UrbanDecomposers},
    [CardName.WARP_DRIVE]: {Factory: WarpDrive},
  },
  standardProjects: {
    [CardName.BUILD_COLONY_STANDARD_PROJECT]: {Factory: BuildColonyStandardProject},
  },
  corporationCards: {
    [CardName.ARIDOR]: {Factory: Aridor, compatibility: 'colonies'},
    [CardName.ARKLIGHT]: {Factory: Arklight},
    [CardName.POLYPHEMOS]: {Factory: Polyphemos},
    [CardName.POSEIDON]: {Factory: Poseidon, compatibility: 'colonies'},
    [CardName.STORMCRAFT_INCORPORATED]: {Factory: StormCraftIncorporated},
  },
});

================
File: cards/colonies/CommunityServices.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';

export class CommunityServices extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 13,
      name: CardName.COMMUNITY_SERVICES,
      type: CardType.AUTOMATED,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'C04',
        description: 'Increase your M€ production 1 step per CARD WITH NO TAGS, including this.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1);
          }).slash().noTags();
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.production.add(Resource.MEGACREDITS, player.tags.numberOfCardsWithNoTags() + 1, {log: true});
    return undefined;
  }
}

================
File: cards/colonies/Conscription.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class Conscription extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      cost: 5,
      tags: [Tag.EARTH],
      name: CardName.CONSCRIPTION,
      victoryPoints: -1,

      requirements: {tag: Tag.EARTH, count: 2},
      metadata: {
        cardNumber: 'C05',
        renderData: CardRenderer.builder((b) => {
          b.text('next card', Size.SMALL, true).colon().megacredits(-16);
        }),
        description: 'Requires 2 Earth tags. The next card you play this generation costs 16 M€ less.',
      },
    });
  }

  public override getCardDiscount(player: IPlayer) {
    if (player.lastCardPlayed === this.name) {
      return 16;
    }
    return 0;
  }
}

================
File: cards/colonies/CoronaExtractor.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {digit} from '../Options';

export class CoronaExtractor extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CORONA_EXTRACTOR,
      cost: 10,
      tags: [Tag.SPACE, Tag.POWER],

      behavior: {
        production: {energy: 4},
      },

      requirements: {tag: Tag.SCIENCE, count: 4},
      metadata: {
        cardNumber: 'C06',
        description: 'Requires 4 science tags. Increase your energy production 4 steps.',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.energy(4, {digit}))),
      },
    });
  }
}

================
File: cards/colonies/CryoSleep.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';

export class CryoSleep extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 10,
      tags: [Tag.SCIENCE],
      name: CardName.CRYO_SLEEP,
      type: CardType.ACTIVE,
      victoryPoints: 1,

      behavior: {
        colonies: {tradeDiscount: 1},
      },

      metadata: {
        cardNumber: 'C07',
        renderData: CardRenderer.builder((b) => b.effect('When you trade, you pay 1 less resource for it.', (be) => {
          be.trade().startEffect.tradeDiscount(1);
        })),
      },
    });
  }
}

================
File: cards/colonies/EarthElevator.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';

export class EarthElevator extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 43,
      tags: [Tag.SPACE, Tag.EARTH],
      name: CardName.EARTH_ELEVATOR,
      type: CardType.AUTOMATED,
      victoryPoints: 4,

      behavior: {
        production: {titanium: 3},
      },

      metadata: {
        description: 'Increase your titanium production 3 steps.',
        cardNumber: 'C08',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(3));
        }),
      },
    });
  }
}

================
File: cards/colonies/EcologyResearch.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardResource} from '../../../common/CardResource';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {Size} from '../../../common/cards/render/Size';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';

export class EcologyResearch extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 21,
      tags: [Tag.SCIENCE, Tag.PLANT, Tag.ANIMAL, Tag.MICROBE],
      name: CardName.ECOLOGY_RESEARCH,
      type: CardType.AUTOMATED,
      victoryPoints: 1,

      metadata: {
        description: 'Increase your plant production 1 step for each colony you own. Add 1 animal to ANOTHER card and 2 microbes to ANOTHER card.',
        cardNumber: 'C09',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1).slash().colonies(1, {size: Size.SMALL})).br;
          b.resource(CardResource.ANIMAL).asterix().nbsp.nbsp.resource(CardResource.MICROBE, 2).asterix();
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const coloniesCount = player.getColoniesCount();
    player.production.add(Resource.PLANTS, coloniesCount, {log: true});

    const animalCards = player.getResourceCards(CardResource.ANIMAL);
    if (animalCards.length) {
      player.game.defer(new AddResourcesToCard(player, CardResource.ANIMAL, {count: 1}));
    }

    const microbeCards = player.getResourceCards(CardResource.MICROBE);
    if (microbeCards.length) {
      player.game.defer(new AddResourcesToCard(player, CardResource.MICROBE, {count: 2}));
    }

    return undefined;
  }
}

================
File: cards/colonies/FloaterLeasing.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {CardResource} from '../../../common/CardResource';

export class FloaterLeasing extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 3,
      name: CardName.FLOATER_LEASING,
      type: CardType.AUTOMATED,

      behavior: {
        production: {megacredits: {floaters: {}, per: 3}},
      },

      metadata: {
        cardNumber: 'C10',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1)).slash().resource(CardResource.FLOATER, {amount: 3, digit});
        }),
        description: 'Increase your M€ production 1 step PER 3 floaters you have.',
      },
    });
  }
}

================
File: cards/colonies/FloaterPrototypes.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';

export class FloaterPrototypes extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 2,
      tags: [Tag.SCIENCE],
      name: CardName.FLOATER_PROTOTYPES,
      type: CardType.EVENT,

      behavior: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2},
      },

      metadata: {
        cardNumber: 'C11',
        renderData: CardRenderer.builder((b) => b.resource(CardResource.FLOATER, 2).asterix()),
        description: 'Add two floaters to ANOTHER card.',
      },
    });
  }
}

================
File: cards/colonies/FloaterTechnology.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {ActionCard} from '../ActionCard';
import {CardRenderer} from '../render/CardRenderer';

export class FloaterTechnology extends ActionCard implements IProjectCard {
  constructor() {
    super({
      cost: 7,
      tags: [Tag.SCIENCE],
      name: CardName.FLOATER_TECHNOLOGY,
      type: CardType.ACTIVE,

      action: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 1 /* , mustHaveCard: true */},
      },

      metadata: {
        cardNumber: 'C12',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to ANOTHER card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER).asterix();
          });
        }),
      },
    });
  }
}

================
File: cards/colonies/GalileanWaystation.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class GalileanWaystation extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 15,
      tags: [Tag.SPACE],
      name: CardName.GALILEAN_WAYSTATION,
      type: CardType.AUTOMATED,
      victoryPoints: 1,

      behavior: {
        production: {megacredits: {tag: Tag.JOVIAN, all: true}},
      },

      metadata: {
        description: 'Increase your M€ production 1 step for every Jovian tag in play.',
        cardNumber: 'C13',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).slash().tag(Tag.JOVIAN, {all}));
        }),
      },
    });
  }
}

================
File: cards/colonies/HeavyTaxation.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';

export class HeavyTaxation extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 3,
      tags: [Tag.EARTH],
      name: CardName.HEAVY_TAXATION,
      type: CardType.AUTOMATED,
      victoryPoints: -1,

      behavior: {
        production: {megacredits: 2},
        stock: {megacredits: 4},
      },

      requirements: {tag: Tag.EARTH, count: 2},
      metadata: {
        cardNumber: 'C14',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).nbsp.megacredits(4);
        }),
        description: 'Requires 2 Earth tags. Increase your M€ production 2 steps, and gain 4 M€.',
      },
    });
  }
}

================
File: cards/colonies/IceMoonColony.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';

export class IceMoonColony extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 23,
      tags: [Tag.SPACE],
      name: CardName.ICE_MOON_COLONY,
      type: CardType.AUTOMATED,

      behavior: {
        colonies: {buildColony: {}},
        ocean: {},
      },

      metadata: {
        cardNumber: 'C15',
        renderData: CardRenderer.builder((b) => b.colonies(1).oceans(1)),
        description: 'Place 1 colony and 1 ocean tile.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.colonies.getPlayableColonies().length > 0;
  }
}

================
File: cards/colonies/ImpactorSwarm.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';
import {all, digit} from '../Options';

export class ImpactorSwarm extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 11,
      tags: [Tag.SPACE],
      name: CardName.IMPACTOR_SWARM,
      type: CardType.EVENT,

      behavior: {
        stock: {heat: 12},
        removeAnyPlants: 2,
      },

      requirements: {tag: Tag.JOVIAN, count: 2},
      metadata: {
        cardNumber: 'C16',
        renderData: CardRenderer.builder((b) => {
          b.heat(12, {digit}).br;
          b.minus().plants(2, {all});
        }),
        description: 'Requires 2 Jovian tags. Gain 12 heat. Remove up to 2 plants from any player.',
      },
    });
  }
}

================
File: cards/colonies/InterplanetaryColonyShip.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';

export class InterplanetaryColonyShip extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 12,
      tags: [Tag.SPACE, Tag.EARTH],
      name: CardName.INTERPLANETARY_COLONY_SHIP,
      type: CardType.EVENT,

      behavior: {
        colonies: {buildColony: {}},
      },

      metadata: {
        cardNumber: 'C17',
        renderData: CardRenderer.builder((b) => b.colonies(1)),
        description: 'Place a colony.',
      },
    });
  }
}

================
File: cards/colonies/JovianLanterns.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';
import {Payment} from '../../../common/inputs/Payment';

export class JovianLanterns extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 20,
      tags: [Tag.JOVIAN],
      name: CardName.JOVIAN_LANTERNS,
      type: CardType.ACTIVE,

      resourceType: CardResource.FLOATER,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {tag: Tag.JOVIAN},

      behavior: {
        tr: 1,
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2},
      },

      metadata: {
        cardNumber: 'C18',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add 2 floaters here.', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.FLOATER, 2);
          }).br;
          b.tr(1).resource(CardResource.FLOATER, 2).asterix().br;
          b.vpText('1 VP per 2 floaters here.');
        }),
        description: {
          text: 'Requires 1 Jovian tag. Increase your TR 1 step. Add 2 floaters to ANY card.',
          align: 'left',
        },
      },
    });
  }


  public canAct(player: IPlayer): boolean {
    return player.titanium > 0;
  }

  public action(player: IPlayer) {
    player.pay(Payment.of({titanium: 1}));
    player.addResourceTo(this, {qty: 2, log: true});
    return undefined;
  }
}

================
File: cards/colonies/JupiterFloatingStation.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {Resource} from '../../../common/Resource';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class JupiterFloatingStation extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 9,
      tags: [Tag.JOVIAN],
      name: CardName.JUPITER_FLOATING_STATION,
      type: CardType.ACTIVE,
      resourceType: CardResource.FLOATER,
      requirements: {tag: Tag.SCIENCE, count: 3},
      victoryPoints: 1,

      metadata: {
        cardNumber: 'C19',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to a JOVIAN CARD.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER, {secondaryTag: Tag.JOVIAN});
          }).br;
          b.or().br;
          b.action('Gain 1 M€ for every floater here [MAX 4].', (eb) => {
            eb.empty().startAction;
            eb.megacredits(1).slash().resource(CardResource.FLOATER).text('[max 4]', Size.SMALL);
          });
        }),
        description: {
          text: 'Requires 3 science tags.',
          align: 'left',
        },
      },
    });
  }


  public canAct(): boolean {
    return true;
  }

  public action(player: IPlayer) {
    return new OrOptions(
      new SelectOption('Add 1 floater to a Jovian card', 'Add floater').andThen(() => {
        player.game.defer(new AddResourcesToCard(player, CardResource.FLOATER, {
          restrictedTag: Tag.JOVIAN, title: 'Add 1 floater to a Jovian card',
        }));
        return undefined;
      }),
      new SelectOption('Gain 1 M€ per floater here (max 4)', 'Gain M€').andThen(() => {
        player.stock.add(Resource.MEGACREDITS, Math.min(this.resourceCount, 4), {log: true});
        return undefined;
      }),
    );
  }
}

================
File: cards/colonies/LunaGovernor.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';

export class LunaGovernor extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 4,
      tags: [Tag.EARTH, Tag.EARTH],
      name: CardName.LUNA_GOVERNOR,
      type: CardType.AUTOMATED,

      behavior: {
        production: {megacredits: 2},
      },

      requirements: {tag: Tag.EARTH, count: 3},
      metadata: {
        cardNumber: 'C20',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2));
        }),
        description: 'Requires 3 Earth tags. Increase your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/colonies/LunarExports.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class LunarExports extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 19,
      tags: [Tag.EARTH, Tag.SPACE],
      name: CardName.LUNAR_EXPORTS,
      type: CardType.AUTOMATED,

      behavior: {
        or: {
          behaviors: [{
            title: 'Increase your M€ production 5 steps',
            production: {megacredits: 5},
          },
          {
            title: 'Increase your plant production 2 steps',
            production: {plants: 2},
          }],
        },
      },

      metadata: {
        cardNumber: 'C21',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.plants(2).or(Size.SMALL).megacredits(5);
          });
        }),
        description: 'Increase your plant production 2 steps, or your M€ production 5 steps.',
      },
    });
  }
}

================
File: cards/colonies/LunarMining.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';

export class LunarMining extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 11,
      tags: [Tag.EARTH],
      name: CardName.LUNAR_MINING,
      type: CardType.AUTOMATED,

      behavior: {
        production: {titanium: {tag: Tag.EARTH, per: 2}},
      },

      metadata: {
        cardNumber: 'C22',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.titanium(1).slash().tag(Tag.EARTH, 2);
          });
        }),
        description: 'Increase your titanium production 1 step for every 2 Earth tags you have in play, including this.',
      },
    });
  }
}

================
File: cards/colonies/MarketManipulation.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {IGame} from '../../IGame';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';
import {CardRenderer} from '../render/CardRenderer';
import {SelectColony} from '../../inputs/SelectColony';
import {LogHelper} from '../../LogHelper';

export class MarketManipulation extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 1,
      tags: [Tag.EARTH],
      name: CardName.MARKET_MANIPULATION,
      type: CardType.EVENT,

      metadata: {
        cardNumber: 'C23',
        renderData: CardRenderer.builder((b) => {
          b.text(
            'Increase one colony tile track 1 step. Decrease another colony tile track 1 step.',
            Size.SMALL,
            true,
          );
        }),
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    const increasableColonies = this.getIncreasableColonies(player.game);
    const decreasableColonies = this.getDecreasableColonies(player.game);

    if (increasableColonies.length === 0) return false;
    if (decreasableColonies.length === 0) return false;
    if (
      increasableColonies.length === 1 &&
      decreasableColonies.length === 1 &&
      increasableColonies[0] === decreasableColonies[0]
    ) {
      return false;
    }

    return true;
  }

  private getIncreasableColonies(game: IGame) {
    return game.colonies.filter(
      (colony) => colony.trackPosition < 6 && colony.isActive,
    );
  }

  private getDecreasableColonies(game: IGame) {
    return game.colonies.filter(
      (colony) =>
        colony.trackPosition > colony.colonies.length && colony.isActive,
    );
  }

  public override bespokePlay(player: IPlayer) {
    let increasableColonies = this.getIncreasableColonies(player.game);
    const decreasableColonies = this.getDecreasableColonies(player.game);
    // if there is only one decreaseable colony and it is an increaseable colony, don't allow increase of that colony.
    if (decreasableColonies.length === 1 && increasableColonies.some((colony) => colony.name === decreasableColonies[0].name)) {
      increasableColonies = increasableColonies.filter((colony) => colony.name !== decreasableColonies[0].name);
    }
    const increaseColonyTrack = new SelectColony(
      'Select which colony tile track to increase',
      'Increase',
      increasableColonies)
      .andThen(
        (increasedColony) => {
          increasedColony.increaseTrack();
          LogHelper.logColonyTrackIncrease(player, increasedColony, 1);
          const decreaseColonyTrack = new SelectColony(
            'Select which colony tile track to decrease',
            'Decrease',
            decreasableColonies.filter((decreaseableColony) => decreaseableColony.name !== increasedColony.name))
            .andThen((decreasedColony) => {
              decreasedColony.decreaseTrack();
              LogHelper.logColonyTrackDecrease(player, decreasedColony);
              return undefined;
            });
          player.defer(decreaseColonyTrack);
          return undefined;
        },
      );

    player.defer(increaseColonyTrack);
    return undefined;
  }
}

================
File: cards/colonies/MartianZoo.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {all} from '../Options';

export class MartianZoo extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 12,
      tags: [Tag.ANIMAL, Tag.BUILDING],
      name: CardName.MARTIAN_ZOO,
      type: CardType.ACTIVE,
      resourceType: CardResource.ANIMAL,
      requirements: {cities: 2, all},
      victoryPoints: 1,

      metadata: {
        cardNumber: 'C24',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an Earth tag, place an animal here.', (eb) => {
            eb.tag(Tag.EARTH).startEffect.resource(CardResource.ANIMAL);
          }).br;
          b.action('Gain 1M€ per animal here.', (eb) => {
            eb.empty().startAction.megacredits(1).slash().resource(CardResource.ANIMAL);
          });
        }),
        description: {
          text: 'Requires 2 city tiles in play.',
          align: 'left',
        },
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    const count = player.tags.cardTagCount(card, Tag.EARTH);
    if (count > 0) {
      player.addResourceTo(this, count);
    }
  }

  public canAct(): boolean {
    return this.resourceCount > 0;
  }

  public action(player: IPlayer) {
    player.stock.add(Resource.MEGACREDITS, this.resourceCount, {log: true});
    return undefined;
  }
}

================
File: cards/colonies/MiningColony.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';

export class MiningColony extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 20,
      tags: [Tag.SPACE],
      name: CardName.MINING_COLONY,
      type: CardType.AUTOMATED,

      behavior: {
        production: {titanium: 1},
        colonies: {buildColony: {}},
      },

      metadata: {
        cardNumber: 'C25',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).colonies(1);
        }),
        description: 'Increase your titanium production 1 step. Place a colony.',
      },
    });
  }
}

================
File: cards/colonies/MinorityRefuge.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {ColonyName} from '../../../common/colonies/ColonyName';
import {BuildColony} from '../../deferredActions/BuildColony';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class MinorityRefuge extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 5,
      tags: [Tag.SPACE],
      name: CardName.MINORITY_REFUGE,
      type: CardType.AUTOMATED,

      metadata: {
        cardNumber: 'C26',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(-2)).colonies(1);
        }),
        description: 'Decrease your M€ production 2 steps. Place a colony.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    if (player.colonies.getPlayableColonies().length === 0) {
      return false;
    }

    const megaCreditsProduction = player.production.megacredits;
    if (megaCreditsProduction === -4 && player.isCorporation(CardName.POSEIDON)) {
      return true;
    } else if (megaCreditsProduction <= -4) {
      const lunaIsAvailable = player.game.colonies.some((colony) =>
        colony.name === ColonyName.LUNA &&
        colony.isFull() === false &&
        colony.colonies.includes(player.id) === false);

      if (lunaIsAvailable === false) {
        return false;
      }
      this.warnings.add('buildOnLuna');
    }

    return true;
  }

  public override bespokePlay(player: IPlayer) {
    const openColonies = player.production.megacredits <= -4 ?
      player.game.colonies.filter((colony) => colony.name === ColonyName.LUNA) :
      undefined;
    player.game.defer(
      new BuildColony(
        player, {
          title: 'Select colony for Minority Refuge',
          colonies: openColonies,
        }))
      .andThen(() => player.production.add(Resource.MEGACREDITS, -2));
    return undefined;
  }
}

================
File: cards/colonies/MolecularPrinting.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class MolecularPrinting extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 11,
      tags: [Tag.SCIENCE],
      name: CardName.MOLECULAR_PRINTING,
      type: CardType.AUTOMATED,
      victoryPoints: 1,

      behavior: {
        stock: {megacredits: {cities: {}, colonies: {colonies: {}}, all}},
      },

      metadata: {
        cardNumber: 'C27',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(1).slash().city({size: Size.SMALL, all}).br;
          b.megacredits(1).slash().colonies(1, {size: Size.SMALL, all});
        }),
        description: 'Gain 1 M€ for each city tile in play. Gain 1 M€ for each colony in play.',
      },
    });
  }
}

================
File: cards/colonies/NitrogenFromTitan.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class NitrogenFromTitan extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 25,
      tags: [Tag.JOVIAN, Tag.SPACE],
      name: CardName.NITROGEN_FROM_TITAN,
      type: CardType.AUTOMATED,
      victoryPoints: 1,

      behavior: {
        tr: 2,
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2, tag: Tag.JOVIAN},
      },

      metadata: {
        cardNumber: 'C28',
        renderData: CardRenderer.builder((b) => {
          b.tr(2).resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.JOVIAN});
        }),
        description: 'Raise your TR 2 steps. Add 2 floaters to a JOVIAN CARD.',
      },
    });
  }
}

================
File: cards/colonies/PioneerSettlement.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {ColonyName} from '../../../common/colonies/ColonyName';
import {BuildColony} from '../../deferredActions/BuildColony';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {max} from '../Options';

export class PioneerSettlement extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 13,
      tags: [Tag.SPACE],
      name: CardName.PIONEER_SETTLEMENT,
      type: CardType.AUTOMATED,
      requirements: {colonies: 1, max},
      victoryPoints: 2,

      metadata: {
        cardNumber: 'C29',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(-2));
          b.nbsp.colonies(1);
        }),
        description: 'Requires that you have no more than 1 colony. Decrease your M€ production 2 steps. Place a colony.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    if (player.colonies.getPlayableColonies().length === 0) {
      return false;
    }

    let lunaIsAvailable = false;
    let coloniesCount = 0;
    const hasOneColonyMax = player.game.colonies.every((colony) => {
      if (colony.name === ColonyName.LUNA &&
          colony.isFull() === false &&
          colony.colonies.includes(player.id) === false) {
        lunaIsAvailable = true;
      }
      coloniesCount += colony.colonies.filter((owner) => owner === player.id).length;
      if (coloniesCount > 1) {
        return false;
      }
      return true;
    });

    if (hasOneColonyMax === false) {
      return false;
    }

    const megaCreditsProduction = player.production.megacredits;
    if (megaCreditsProduction === -4 && player.isCorporation(CardName.POSEIDON)) {
      return true;
    } else if (megaCreditsProduction <= -4) {
      if (lunaIsAvailable === false) {
        return false;
      }
      this.warnings.add('buildOnLuna');
    }

    return true;
  }

  public override bespokePlay(player: IPlayer) {
    const openColonies = player.production.megacredits <= -4 ?
      player.game.colonies.filter((colony) => colony.name === ColonyName.LUNA) :
      undefined;
    player.game.defer(new BuildColony(player, {title: 'Select colony for Pioneer Settlement', colonies: openColonies}));
    player.production.add(Resource.MEGACREDITS, -2);
    return undefined;
  }
}

================
File: cards/colonies/Polyphemos.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class Polyphemos extends CorporationCard {
  constructor() {
    super({
      name: CardName.POLYPHEMOS,
      startingMegaCredits: 50,
      cardCost: 5,

      behavior: {
        production: {megacredits: 5},
        stock: {titanium: 5},
      },

      metadata: {
        cardNumber: 'R11',
        description: 'You start with 50 M€. Increase your M€ production 5 steps. Gain 5 titanium.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(50).nbsp.production((pb) => pb.megacredits(5)).nbsp.titanium(5, {digit});
          b.corpBox('effect', (ce) => {
            ce.effect('When you buy a card to hand, pay 5M€ instead of 3, including the starting hand.', (eb) => {
              eb.cards(1).asterix().startEffect.megacredits(5);
            });
          });
        }),
      },
    });
  }
}

================
File: cards/colonies/Poseidon.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';

export class Poseidon extends CorporationCard {
  constructor() {
    super({
      name: CardName.POSEIDON,
      startingMegaCredits: 45,

      firstAction: {
        text: 'Place a colony',
        // title: 'Poseidon first action - Select where to build colony
        colonies: {buildColony: {}},
      },
      metadata: {
        cardNumber: 'R02',
        description: 'You start with 45 M€. As your first action, place a colony.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(45).nbsp.colonies(1);
          b.corpBox('effect', (ce) => {
            ce.effect('When any colony is placed, including this, raise your M€ production 1 step.', (eb) => {
              eb.colonies(1, {all}).startEffect.production((pb) => pb.megacredits(1));
            });
          });
        }),
      },
    });
  }

  public onColonyAdded(_player: IPlayer, cardOwner: IPlayer) {
    cardOwner.production.add(Resource.MEGACREDITS, 1, {log: true});
  }
}

================
File: cards/colonies/ProductiveOutpost.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';

export class ProductiveOutpost extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 0,
      name: CardName.PRODUCTIVE_OUTPOST,
      type: CardType.AUTOMATED,

      metadata: {
        cardNumber: 'C30',
        renderData: CardRenderer.builder((b) => {
          b.text('Gain all your colony bonuses.', Size.SMALL, true);
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.game.colonies.forEach((colony) => {
      colony.colonies.filter((owner) => owner === player.id).forEach((owner) => {
        // Not using GiveColonyBonus deferred action because it's only for the active player
        player.defer(() => colony.giveColonyBonus(player.game.getPlayerById(owner)));
      });
    });
    return undefined;
  }
}

================
File: cards/colonies/QuantumCommunications.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class QuantumCommunications extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 8,
      name: CardName.QUANTUM_COMMUNICATIONS,
      type: CardType.AUTOMATED,
      requirements: {tag: Tag.SCIENCE, count: 4},
      victoryPoints: 1,

      metadata: {
        cardNumber: '079',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).slash().colonies(1, {size: Size.SMALL, all});
          });
        }),
        description: 'Requires 4 science tags. Increase your M€ production 1 step for each colony in play.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    let coloniesCount = 0;
    player.game.colonies.forEach((colony) => {
      coloniesCount += colony.colonies.length;
    });
    player.production.add(Resource.MEGACREDITS, coloniesCount, {log: true});
    return undefined;
  }
}

================
File: cards/colonies/RedSpotObservatory.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class RedSpotObservatory extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 17,
      tags: [Tag.JOVIAN, Tag.SCIENCE],
      name: CardName.RED_SPOT_OBSERVATORY,
      type: CardType.ACTIVE,
      resourceType: CardResource.FLOATER,
      victoryPoints: 2,

      behavior: {
        drawCard: 2,
      },

      requirements: {tag: Tag.SCIENCE, count: 3},
      metadata: {
        cardNumber: 'C32',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to this card, or spend 1 floater here to draw a card.', (eb) => {
            eb.empty().arrow().resource(CardResource.FLOATER).or();
            eb.resource(CardResource.FLOATER).startAction.cards(1);
          }).br;
          b.cards(2);
        }),
        description: {
          text: 'Requires 3 science tags. Draw 2 cards.',
          align: 'left',
        },
      },
    });
  }


  public canAct(): boolean {
    return true;
  }

  public action(player: IPlayer) {
    if (this.resourceCount < 1) {
      player.addResourceTo(this, 1);
      return undefined;
    }

    const opts = [];

    const addResource = new SelectOption('Add 1 floater on this card', 'Add floater').andThen(() => this.addResource(player));
    const spendResource = new SelectOption('Remove 1 floater on this card to draw a card', 'Remove floater').andThen(() => this.spendResource(player));

    opts.push(spendResource);
    opts.push(addResource);

    return new OrOptions(...opts);
  }

  private addResource(player: IPlayer) {
    player.addResourceTo(this, 1);
    return undefined;
  }

  private spendResource(player: IPlayer) {
    this.resourceCount--;
    player.drawCard();
    return undefined;
  }
}

================
File: cards/colonies/RefugeeCamps.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class RefugeeCamps extends ActionCard implements IProjectCard {
  constructor() {
    super({
      cost: 10,
      tags: [Tag.EARTH],
      name: CardName.REFUGEE_CAMPS,
      type: CardType.ACTIVE,
      resourceType: CardResource.CAMP,
      victoryPoints: {resourcesHere: {}},

      action: {
        production: {megacredits: -1},
        addResources: 1,
      },

      metadata: {
        cardNumber: 'C33',
        renderData: CardRenderer.builder((b) => {
          b.action('Decrease your M€ production 1 step to add a camp resource to this card.', (eb) => {
            eb.production((pb) => pb.megacredits(1));
            eb.startAction.resource(CardResource.CAMP);
          }).br;
          b.vpText('1 VP for each camp resource on this card.');
        }),
      },
    });
  }
}

================
File: cards/colonies/ResearchColony.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class ResearchColony extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 20,
      tags: [Tag.SPACE, Tag.SCIENCE],
      name: CardName.RESEARCH_COLONY,
      type: CardType.AUTOMATED,

      behavior: {
        drawCard: 2,
        colonies: {buildColony: {allowDuplicates: true}},
      },

      metadata: {
        cardNumber: 'C34',
        renderData: CardRenderer.builder((b) => {
          b.colonies(1).asterix().nbsp.cards(2);
        }),
        description: 'Place a colony. MAY BE PLACED WHERE YOU ALREADY HAVE A COLONY. Draw 2 cards.',
      },
    });
  }
}

================
File: cards/colonies/RimFreighters.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class RimFreighters extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 4,
      tags: [Tag.SPACE],
      name: CardName.RIM_FREIGHTERS,
      type: CardType.ACTIVE,

      behavior: {
        colonies: {tradeDiscount: 1},
      },

      metadata: {
        cardNumber: 'C35',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you trade, you pay 1 less resource for it.', (eb) => {
            eb.trade().startEffect.tradeDiscount(1);
          });
        }),
      },
    });
  }
}

================
File: cards/colonies/SkyDocks.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class SkyDocks extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 18,
      tags: [Tag.SPACE, Tag.EARTH],
      name: CardName.SKY_DOCKS,
      type: CardType.ACTIVE,
      victoryPoints: 2,

      behavior: {
        colonies: {addTradeFleet: 1},
      },

      requirements: {tag: Tag.EARTH, count: 2},
      cardDiscount: {amount: 1},
      metadata: {
        cardNumber: 'C36',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a card, you pay 1 M€ less for it.', (eb) => {
            eb.empty().startEffect.megacredits(-1);
          }).br;
          b.tradeFleet();
        }),
        description: 'Requires 2 Earth tags. Gain 1 Trade Fleet.',
      },
    });
  }
}

================
File: cards/colonies/SolarProbe.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {digit} from '../Options';

export class SolarProbe extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 9,
      tags: [Tag.SPACE, Tag.SCIENCE],
      name: CardName.SOLAR_PROBE,
      type: CardType.EVENT,
      victoryPoints: 1,

      behavior: {
        drawCard: {count: {tag: Tag.SCIENCE, per: 3}},
      },

      metadata: {
        cardNumber: 'C37',
        renderData: CardRenderer.builder((b) => {
          b.cards(1).slash().tag(Tag.SCIENCE, {amount: 3, digit});
        }),
        description: 'Draw 1 card for every 3 science tags you have, including this.',
      },
    });
  }
}

================
File: cards/colonies/SolarReflectors.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {digit} from '../Options';

export class SolarReflectors extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 23,
      tags: [Tag.SPACE],
      name: CardName.SOLAR_REFLECTORS,
      type: CardType.AUTOMATED,

      behavior: {
        production: {heat: 5},
      },

      metadata: {
        cardNumber: 'C38',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(5, {digit}));
        }),
        description: 'Increase your heat production 5 steps.',
      },
    });
  }
}

================
File: cards/colonies/SpacePort.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class SpacePort extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 22,
      tags: [Tag.CITY, Tag.BUILDING],
      name: CardName.SPACE_PORT,
      type: CardType.AUTOMATED,

      behavior: {
        production: {energy: -1, megacredits: 4},
        colonies: {addTradeFleet: 1},
        city: {},
      },

      requirements: {colonies: 1},
      metadata: {
        cardNumber: 'C39',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(4);
          }).nbsp.city().br;
          b.tradeFleet();
        }),
        description: 'Requires 1 colony. Decrease your energy production 1 step and increase your M€ production 4 steps. Place a city tile. Gain 1 Trade Fleet.',
      },
    });
  }
}

================
File: cards/colonies/SpacePortColony.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all} from '../Options';

export class SpacePortColony extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 27,
      tags: [Tag.SPACE],
      name: CardName.SPACE_PORT_COLONY,
      type: CardType.AUTOMATED,

      requirements: {colonies: 1},
      victoryPoints: {colonies: {colonies: {}}, all, per: 2},

      behavior: {
        colonies: {
          buildColony: {allowDuplicates: true},
          addTradeFleet: 1,
        },
      },

      metadata: {
        cardNumber: 'C39',
        renderData: CardRenderer.builder((b) => {
          b.colonies(1).asterix().nbsp.tradeFleet().br;
          b.vpText('1VP per 2 colonies in play.');
        }),
        description: 'Requires a colony. Place a colony. MAY BE PLACED ON A COLONY TILE WHERE YOU ALREADY HAVE A COLONY. Gain 1 Trade Fleet.',
      },
    });
  }

  public override getVictoryPoints(player: IPlayer) {
    let coloniesCount = 0;
    player.game.colonies.forEach((colony) => {
      coloniesCount += colony.colonies.length;
    });
    return Math.floor(coloniesCount / 2);
  }
}

================
File: cards/colonies/SpinoffDepartment.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class SpinoffDepartment extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 10,
      tags: [Tag.BUILDING],
      name: CardName.SPINOFF_DEPARTMENT,
      type: CardType.ACTIVE,

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'C41',
        renderData: CardRenderer.builder((b) => {
          b.effect('WHEN PLAYING A CARD WITH A BASIC COST OF 20M€ OR MORE, draw a card.', (eb) => {
            eb.megacredits(20).asterix().startEffect.cards(1);
          }).br;
          b.production((pb) => pb.megacredits(2));
        }),
        description: 'Increase your M€ production 2 steps.',
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.cost >= 20) {
      player.drawCard();
    }
  }
}

================
File: cards/colonies/StormCraftIncorporated.ts
================
import {ActiveCorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {AndOptions} from '../../inputs/AndOptions';
import {SelectAmount} from '../../inputs/SelectAmount';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {PlayerInput} from '../../PlayerInput';
import {Resource} from '../../../common/Resource';
import {message} from '../../logs/MessageBuilder';

export class StormCraftIncorporated extends ActiveCorporationCard {
  constructor() {
    super({
      name: CardName.STORMCRAFT_INCORPORATED,
      tags: [Tag.JOVIAN],
      startingMegaCredits: 48,
      resourceType: CardResource.FLOATER,

      action: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 1, autoSelect: true},
      },

      metadata: {
        cardNumber: 'R29',
        description: 'You start with 48 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(48);
          b.corpBox('action', (ce) => {
            ce.vSpace(Size.LARGE);
            ce.action('Add a floater to ANY card.', (eb) => {
              eb.empty().startAction.resource(CardResource.FLOATER).asterix();
            });
            ce.vSpace();
            ce.effect('Floaters on this card may be used as 2 heat each.', (eb) => {
              eb.startEffect.resource(CardResource.FLOATER).equals().heat(2);
            });
          });
        }),
      },
    });
  }

  public spendHeat(player: IPlayer, targetAmount: number,
    cb: () => (undefined | PlayerInput) = () => undefined): AndOptions {
    let heatAmount: number;
    let floaterAmount: number;

    const options = new AndOptions(
      new SelectAmount('Heat', 'Spend heat', 0, Math.min(player.heat, targetAmount))
        .andThen((amount) => {
          heatAmount = amount;
          return undefined;
        }),
      new SelectAmount('Stormcraft Incorporated Floaters (2 heat each)', 'Spend floaters',
        0, Math.min(this.resourceCount, Math.ceil(targetAmount / 2)))
        .andThen((amount) => {
          floaterAmount = amount;
          return undefined;
        })).andThen(() => {
      if (heatAmount + (floaterAmount * 2) < targetAmount) {
        throw new Error(`Need to pay ${targetAmount} heat`);
      }
      if (heatAmount > 0 && heatAmount - 1 + (floaterAmount * 2) >= targetAmount) {
        throw new Error('You cannot overspend heat');
      }
      if (floaterAmount > 0 && heatAmount + ((floaterAmount - 1) * 2) >= targetAmount) {
        throw new Error('You cannot overspend floaters');
      }
      player.removeResourceFrom(this, floaterAmount);
      player.stock.deduct(Resource.HEAT, heatAmount);
      return cb();
    });
    options.title = message('Select how to spend ${0} heat', (b) => b.number(targetAmount));
    return options;
  }
}

================
File: cards/colonies/SubZeroSaltFish.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';
import {all} from '../Options';

export class SubZeroSaltFish extends ActionCard implements IProjectCard {
  constructor() {
    super({
      cost: 5,
      tags: [Tag.ANIMAL],
      name: CardName.SUBZERO_SALT_FISH,
      type: CardType.ACTIVE,

      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},
      requirements: {temperature: -6},

      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 1},
      },

      action: {
        addResources: 1,
      },

      metadata: {
        cardNumber: 'C42',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.production((pb) => pb.minus().plants(1, {all})).br;
          b.vpText('1 VP per 2 animals on this card.');
        }),
        description: {
          text: 'Requires -6 C. Decrease any plant production 1 step.',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/colonies/TitanAirScrapping.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Payment} from '../../../common/inputs/Payment';

export class TitanAirScrapping extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 21,
      tags: [Tag.JOVIAN],
      name: CardName.TITAN_AIRSCRAPPING,
      type: CardType.ACTIVE,
      resourceType: CardResource.FLOATER,
      victoryPoints: 2,

      metadata: {
        cardNumber: 'C43',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add 2 floaters here.', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.FLOATER, 2);
          }).br;
          b.or().br;
          b.action('Spend 2 floaters here to increase your TR 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.tr(1);
          });
        }),
      },
    });
  }


  public canAct(player: IPlayer): boolean {
    if (player.titanium > 0) {
      return true;
    }
    if (this.resourceCount >= 2) {
      return player.canAfford({cost: 0, tr: {tr: 1}});
    }
    return false;
  }

  public action(player: IPlayer) {
    const opts = [];

    const addResource = new SelectOption('Spend 1 titanium to add 2 floaters on this card', 'Spend titanium').andThen(() => this.addResource(player));
    const spendResource = new SelectOption('Remove 2 floaters on this card to increase your TR 1 step', 'Remove floaters').andThen(() => this.spendResource(player));

    if (this.resourceCount >= 2 && player.canAfford({cost: 0, tr: {tr: 1}})) {
      opts.push(spendResource);
    }


    if (player.titanium > 0) {
      opts.push(addResource);
    }

    if (opts.length === 1) {
      return opts[0].cb(undefined);
    }

    return new OrOptions(...opts);
  }

  private addResource(player: IPlayer) {
    player.pay(Payment.of({titanium: 1}));
    player.addResourceTo(this, {qty: 2, log: true});
    return undefined;
  }

  private spendResource(player: IPlayer) {
    player.removeResourceFrom(this, 2);
    player.increaseTerraformRating();
    return undefined;
  }
}

================
File: cards/colonies/TitanFloatingLaunchPad.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {IColony} from '../../colonies/IColony';
import {SelectColony} from '../../inputs/SelectColony';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IColonyTrader} from '../../colonies/IColonyTrader';
import {ColoniesHandler} from '../../colonies/ColoniesHandler';
import {message} from '../../logs/MessageBuilder';

export class TitanFloatingLaunchPad extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 18,
      tags: [Tag.JOVIAN],
      name: CardName.TITAN_FLOATING_LAUNCHPAD,
      type: CardType.ACTIVE,
      resourceType: CardResource.FLOATER,
      victoryPoints: 1,

      behavior: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 2, tag: Tag.JOVIAN},
      },

      metadata: {
        cardNumber: 'C44',
        renderData: CardRenderer.builder((b) => {
          b.action(undefined, (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER, {secondaryTag: Tag.JOVIAN}).nbsp.or();
          }).br;
          b.action('Add 1 floater to ANY JOVIAN CARD or spend 1 floater here to trade for free.', (eb) => {
            eb.resource(CardResource.FLOATER).startAction.trade();
          }).br.br;
          b.resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.JOVIAN});
        }),
        description: {
          text: 'Add two floaters to ANY JOVIAN CARD.',
          align: 'left',
        },
      },
    });
  }

  public canAct(): boolean {
    return true;
  }

  public action(player: IPlayer) {
    const orOptions = new OrOptions(
      new SelectOption('Remove 1 floater on this card to trade for free', 'Remove floater').andThen(() => {
        player.defer(
          new SelectColony('Select colony tile to trade with for free', 'Select', ColoniesHandler.tradeableColonies(player.game))
            .andThen((colony) => {
              this.resourceCount--;
              player.game.log('${0} spent 1 floater to trade with ${1}', (b) => b.player(player).colony(colony));
              colony.trade(player);
              return undefined;
            }));
        return undefined;
      }),
      new SelectOption('Add 1 floater to a Jovian card', 'Add floater').andThen(() => {
        player.game.defer(new AddResourcesToCard(player, CardResource.FLOATER, {restrictedTag: Tag.JOVIAN, title: 'Add 1 floater to a Jovian card'}));
        return undefined;
      }),
    );
    if (this.resourceCount === 0 || !player.colonies.canTrade()) {
      return orOptions.options[1].cb();
    }
    return orOptions;
  }
}

export class TradeWithTitanFloatingLaunchPad implements IColonyTrader {
  private titanFloatingLaunchPad: TitanFloatingLaunchPad | undefined;

  constructor(private player: IPlayer) {
    const card = player.playedCards.find((card) => card.name === CardName.TITAN_FLOATING_LAUNCHPAD);
    this.titanFloatingLaunchPad = card === undefined ? undefined : (card as TitanFloatingLaunchPad);
  }

  public canUse() {
    return (this.titanFloatingLaunchPad?.resourceCount ?? 0) > 0 &&
      !this.player.getActionsThisGeneration().has(CardName.TITAN_FLOATING_LAUNCHPAD);
  }

  public optionText() {
    return message('Pay 1 floater (use ${0} action)', (b) => b.cardName(CardName.TITAN_FLOATING_LAUNCHPAD));
  }

  public trade(colony: IColony) {
    // grr I wish there was a simpler syntax.
    if (this.titanFloatingLaunchPad !== undefined) {
      this.titanFloatingLaunchPad.resourceCount--;
    }
    this.player.addActionThisGeneration(CardName.TITAN_FLOATING_LAUNCHPAD);
    this.player.game.log('${0} spent 1 floater to trade with ${1}', (b) => b.player(this.player).colony(colony));
    colony.trade(this.player);
  }
}

================
File: cards/colonies/TitanShuttles.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectAmount} from '../../inputs/SelectAmount';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class TitanShuttles extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 23,
      tags: [Tag.JOVIAN, Tag.SPACE],
      name: CardName.TITAN_SHUTTLES,
      type: CardType.ACTIVE,
      resourceType: CardResource.FLOATER,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'C45',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 2 floaters to ANY JOVIAN CARD.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.JOVIAN});
          }).br;
          b.or().br;
          b.action('Spend any number of floaters here to gain the same number of titanium.', (eb) => {
            eb.text('x').resource(CardResource.FLOATER).startAction.text('x').titanium(1);
          }).br;
        }),
      },
    });
  }


  public canAct(): boolean {
    return true;
  }

  public action(player: IPlayer) {
    if (this.resourceCount === 0) {
      player.game.defer(new AddResourcesToCard(player, CardResource.FLOATER, {count: 2, restrictedTag: Tag.JOVIAN, title: 'Add 2 floaters to a Jovian card'}));
      return undefined;
    }

    return new OrOptions(
      new SelectOption('Add 2 floaters to a Jovian card', 'Add floaters').andThen(() => {
        player.game.defer(new AddResourcesToCard(player, CardResource.FLOATER, {count: 2, restrictedTag: Tag.JOVIAN}));
        return undefined;
      }),
      new SelectAmount(
        'Remove X floaters on this card to gain X titanium', 'Remove floaters',
        1, this.resourceCount, true,
      ).andThen((amount) => {
        player.removeResourceFrom(this, amount);
        player.titanium += amount;
        player.game.log('${0} removed ${1} floaters to gain ${2} titanium', (b) => b.player(player).number(amount).number(amount));
        return undefined;
      }),
    );
  }
}

================
File: cards/colonies/TradeEnvoys.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';

export class TradeEnvoys extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 6,
      name: CardName.TRADE_ENVOYS,
      type: CardType.ACTIVE,

      behavior: {
        colonies: {tradeOffset: 1},
      },

      metadata: {
        cardNumber: 'C46',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you trade, you may first increase that Colony Tile track 1 step.', (eb) => {
            eb.trade().startEffect.text('+1', Size.LARGE);
          });
        }),
      },
    });
  }
}

================
File: cards/colonies/TradingColony.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';

export class TradingColony extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 18,
      tags: [Tag.SPACE],
      name: CardName.TRADING_COLONY,
      type: CardType.ACTIVE,

      behavior: {
        colonies: {
          buildColony: {},
          tradeOffset: 1,
        },
      },

      metadata: {
        cardNumber: 'C47',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you trade, you may first increase that Colony Tile track 1 step.', (eb) => {
            eb.trade().startEffect.text('+1', Size.LARGE);
          }).br;
          b.colonies(1);
        }),
        description: 'Place a colony.',
      },
    });
  }
}

================
File: cards/colonies/UrbanDecomposers.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class UrbanDecomposers extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 6,
      tags: [Tag.MICROBE],
      name: CardName.URBAN_DECOMPOSERS,
      type: CardType.AUTOMATED,

      behavior: {
        production: {plants: 1},
        addResourcesToAnyCard: {count: 2, type: CardResource.MICROBE},
      },

      requirements: [{colonies: 1}, {cities: 1}],
      metadata: {
        cardNumber: 'C48',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).resource(CardResource.MICROBE, 2).asterix();
        }),
        description: 'Requires that you have 1 city tile and 1 colony in play. Increase your plant production 1 step, and add 2 microbes to ANOTHER card.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    let coloniesCount = 0;
    player.game.colonies.forEach((colony) => {
      coloniesCount += colony.colonies.filter((owner) => owner === player.id).length;
    });
    return coloniesCount > 0 && player.game.board.getCities(player).length > 0;
  }
}

================
File: cards/colonies/WarpDrive.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class WarpDrive extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 14,
      tags: [Tag.SCIENCE],
      name: CardName.WARP_DRIVE,
      type: CardType.ACTIVE,
      victoryPoints: 2,

      requirements: {tag: Tag.SCIENCE, count: 5},
      cardDiscount: {tag: Tag.SPACE, amount: 4},
      metadata: {
        cardNumber: 'C49',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a space card, you pay 4 M€ less for it.', (eb) => {
            eb.tag(Tag.SPACE).startEffect.megacredits(-4);
          });
        }),
        description: 'Requires 5 science tags.',
      },
    });
  }
}

================
File: cards/community/AerospaceMission.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {BuildColony} from '../../deferredActions/BuildColony';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';

export class AerospaceMission extends PreludeCard {
  constructor() {
    super({
      name: CardName.AEROSPACE_MISSION,
      tags: [Tag.SPACE],
      startingMegacredits: -14,

      metadata: {
        cardNumber: 'Y01',
        renderData: CardRenderer.builder((b) => {
          b.colonies(1).nbsp.colonies(1).br;
          b.minus().megacredits(14);
        }),
        description: 'Place 2 colonies. Pay 14 M€.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    return player.canAfford(14);
  }

  public override bespokePlay(player: IPlayer) {
    player.stock.deduct(Resource.MEGACREDITS, 14);
    player.game.defer(new BuildColony(player, {title: 'Select where to build the first colony'}));
    player.game.defer(new BuildColony(player, {title: 'Select where to build the second colony'}));
    return undefined;
  }
}

================
File: cards/community/AgricolaInc.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {TagCount} from '../../../common/cards/TagCount';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';
import {inplaceRemove} from '../../../common/utils/utils';

export class AgricolaInc extends CorporationCard {
  constructor() {
    super({
      name: CardName.AGRICOLA_INC,
      tags: [Tag.PLANT],
      startingMegaCredits: 40,

      victoryPoints: 'special',
      behavior: {
        production: {megacredits: 1, plants: 1, heat: 1},
      },

      metadata: {
        cardNumber: 'R36',
        description: 'You start with 1 plant production, 1 M€ production, 1 heat production and 40 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.production((pb) => pb.megacredits(1).plants(1).heat(1)).nbsp.megacredits(40);
          b.corpBox('effect', (ce) => {
            ce.text('Effect: At game end, score -2 / 0 / 1 / 2 VP PER TAG TYPE for 0 / 1-2 / 3-4 / 5+ tags.', Size.SMALL, true);
          });
        }),
        victoryPoints: CardRenderDynamicVictoryPoints.questionmark(),
      },
    });
  }

  public override getVictoryPoints(player: IPlayer): number {
    const scorableTags = [...player.game.tags];
    inplaceRemove(scorableTags, Tag.WILD);
    inplaceRemove(scorableTags, Tag.EVENT);
    inplaceRemove(scorableTags, Tag.CLONE);

    const playerTags : TagCount[] = player.tags.countAllTags();
    let points = 0;

    scorableTags.forEach((tag) => {
      const tagData = playerTags.find((data) => data.tag === tag);

      if (tagData === undefined) {
        points -= 2;
      } else if (tagData.count === 3 || tagData.count === 4) {
        points += 1;
      } else if (tagData.count > 4) {
        points += 2;
      }
    });

    return points;
  }
}

================
File: cards/community/Athena.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {PlaceHazardTile} from '../../deferredActions/PlaceHazardTile';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {TileType} from '../../../common/TileType';

export class Athena extends CorporationCard {
  constructor() {
    super({
      name: CardName.ATHENA,
      tags: [Tag.EARTH],
      initialActionText: 'Place 2 hazard tiles adjacent to no other tiles.',
      startingMegaCredits: 62,

      metadata: {
        cardNumber: 'R52',
        description: 'You start with 62 M€. As your first action, place 2 hazard tiles adjacent to no other tiles.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(62).hazardTile(1, {size: Size.LARGE}).hazardTile(1, {size: Size.LARGE});
          b.corpBox('effect', (ce) => {
            ce.vSpace(Size.SMALL);
            ce.effect('You do not lose production when placing adjacent to hazard tiles.', (eb) => {
              eb.startEffect.hazardTile(1, {size: Size.LARGE}).nbsp.asterix();
            });
          });
        }),
      },
    });
  }

  public initialAction(player: IPlayer) {
    const game = player.game;
    const title = 'Select space next to no other tile for hazard';

    if (game.gameOptions.aresExtension) {
      game.defer(new PlaceHazardTile(
        player, TileType.EROSION_MILD, {title, spaces: this.getAvailableSpaces(player)}))
        .andThen(() => {
          game.defer(new PlaceHazardTile(
            player, TileType.EROSION_MILD, {title, spaces: this.getAvailableSpaces(player)}));
        });
    }

    return undefined;
  }

  private getAvailableSpaces(player: IPlayer) {
    const board = player.game.board;
    return board.getAvailableSpacesOnLand(player)
      .filter(((space) => space.tile === undefined))
      .filter((space) => {
        const adjacentSpaces = board.getAdjacentSpaces(space);
        return adjacentSpaces.filter((space) => space.tile !== undefined).length === 0;
      });
  }
}

================
File: cards/community/ByElection.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {Turmoil} from '../../turmoil/Turmoil';
import {ChooseRulingPartyDeferred} from '../../turmoil/ChooseRulingPartyDeferred';
import {CardRenderer} from '../render/CardRenderer';

export class ByElection extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.BY_ELECTION,
      tags: [Tag.WILD],

      metadata: {
        cardNumber: 'Y02',
        renderData: CardRenderer.builder((b) => {
          b.rulingParty().plus().influence();
        }),
        description: 'Set the ruling party to one of your choice. Gain 1 influence.',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    Turmoil.ifTurmoil((player.game), (turmoil) => {
      turmoil.addInfluenceBonus(player);
      player.game.defer(new ChooseRulingPartyDeferred(player, turmoil));
    });

    return undefined;
  }
}

================
File: cards/community/CommunityCardManifest.ts
================
import {AerospaceMission} from './AerospaceMission';
import {AgricolaInc} from './AgricolaInc';
import {Athena} from './Athena';
import {ByElection} from './ByElection';
import {CardName} from '../../../common/cards/CardName';
import {CuriosityII} from './CuriosityII';
import {Eris} from './Eris';
import {ExecutiveOrder} from './ExecutiveOrder';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {Incite} from './Incite';
import {JunkVentures} from './JunkVentures';
import {LeadershipSummit} from './LeadershipSummit';
import {Midas} from './Midas';
import {ModuleManifest} from '../ModuleManifest';
import {Playwrights} from './Playwrights';
import {PoliticalUprising} from './PoliticalUprising';
import {ProjectWorkshop} from './ProjectWorkshop';
import {ResearchGrant} from './ResearchGrant';
import {SpecialDesignProxy} from './SpecialDesignProxy';
import {TradeAdvance} from './TradeAdvance';
import {UnitedNationsMissionOne} from './UnitedNationsMissionOne';
import {ValuableGases} from './ValuableGases';

export const COMMUNITY_CARD_MANIFEST = new ModuleManifest({
  module: 'community',
  corporationCards: {
    [CardName.AGRICOLA_INC]: {Factory: AgricolaInc},
    [CardName.PROJECT_WORKSHOP]: {Factory: ProjectWorkshop},
    [CardName.INCITE]: {Factory: Incite, compatibility: 'turmoil'},
    [CardName.PLAYWRIGHTS]: {Factory: Playwrights},
    [CardName.CURIOSITY_II]: {Factory: CuriosityII},
    [CardName.MIDAS]: {Factory: Midas},
    [CardName.UNITED_NATIONS_MISSION_ONE]: {Factory: UnitedNationsMissionOne},
    [CardName.JUNK_VENTURES]: {Factory: JunkVentures},
    [CardName.ERIS]: {Factory: Eris, compatibility: 'ares'},
    [CardName.ATHENA]: {Factory: Athena, compatibility: 'ares'},
  },
  preludeCards: {
    [CardName.RESEARCH_GRANT]: {Factory: ResearchGrant},
    [CardName.VALUABLE_GASES]: {Factory: ValuableGases, compatibility: 'venus'},
    [CardName.AEROSPACE_MISSION]: {Factory: AerospaceMission, compatibility: 'colonies'},
    [CardName.TRADE_ADVANCE]: {Factory: TradeAdvance, compatibility: 'colonies'},
    [CardName.POLITICAL_UPRISING]: {Factory: PoliticalUprising, compatibility: 'turmoil'},
    [CardName.BY_ELECTION]: {Factory: ByElection, compatibility: 'turmoil'},
    [CardName.EXECUTIVE_ORDER]: {Factory: ExecutiveOrder, compatibility: 'turmoil'},
  },
  projectCards: {
    [CardName.SPECIAL_DESIGN_PROXY]: {Factory: SpecialDesignProxy, instantiate: false},
  },
  globalEvents: {
    [GlobalEventName.LEADERSHIP_SUMMIT]: {Factory: LeadershipSummit},
  },
});

================
File: cards/community/CuriosityII.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {DrawCards} from '../../deferredActions/DrawCards';
import {SpaceType} from '../../../common/boards/SpaceType';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {Phase} from '../../../common/Phase';
import {TITLES} from '../../inputs/titles';

export class CuriosityII extends CorporationCard {
  constructor() {
    super({
      name: CardName.CURIOSITY_II,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      startingMegaCredits: 40,

      behavior: {
        production: {steel: 2},
      },

      metadata: {
        cardNumber: '',
        description: 'You start with 40 M€ and 2 steel production.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(40).nbsp.production((pb) => pb.steel(2));
          b.corpBox('effect', (ce) => {
            ce.vSpace();
            ce.effect(
              'When you place a tile on an area that has a RESOURCE placement bonus, ' +
              'or on top of another tile, you may pay 2 M€ to draw a card.',
              (eb) => {
                eb.emptyTile('normal', {size: Size.SMALL}).nbsp.asterix().startEffect.megacredits(-2).cards(1);
              });
          });
        }),
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    const eligibleBonuses = [SpaceBonus.STEEL, SpaceBonus.TITANIUM, SpaceBonus.HEAT, SpaceBonus.PLANT, SpaceBonus.MEGACREDITS, SpaceBonus.ANIMAL, SpaceBonus.MICROBE, SpaceBonus.ENERGY];

    if (cardOwner.id !== activePlayer.id) return;
    if (cardOwner.game.phase === Phase.SOLAR) return;
    if (space.spaceType === SpaceType.COLONY) return;

    if (space.bonus.some((bonus) => eligibleBonuses.includes(bonus)) || space.tile?.covers !== undefined) {
      cardOwner.defer(() => this.corpAction(cardOwner));
    }
  }

  private corpAction(player: IPlayer) {
    if (!player.canAfford(2)) return undefined;

    return new OrOptions(
      new SelectOption('Pay 2 M€ to draw a card').andThen(() => {
        player.game.defer(new SelectPaymentDeferred(player, 2, {title: TITLES.payForCardAction(this.name)}))
          .andThen(() => player.game.defer(DrawCards.keepAll(player)));
        return undefined;
      }),
      new SelectOption('Do nothing'),
    );
  }
}

================
File: cards/community/Eris.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {IGame} from '../../IGame';
import {CardName} from '../../../common//cards/CardName';
import {PlaceHazardTile} from '../../deferredActions/PlaceHazardTile';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectSpace} from '../../inputs/SelectSpace';
import {CardRenderer} from '../render/CardRenderer';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {Size} from '../../../common/cards/render/Size';
import {TileType, tileTypeToString} from '../../../common/TileType';
import {LogHelper} from '../../LogHelper';

const ARES_CARDS = [
  CardName.BIOENGINEERING_ENCLOSURE,
  CardName.BIOFERTILIZER_FACILITY,
  CardName.BUTTERFLY_EFFECT,
  CardName.CAPITAL_ARES,
  CardName.COMMERCIAL_DISTRICT_ARES,
  CardName.DEIMOS_DOWN_ARES,
  CardName.DESPERATE_MEASURES,
  CardName.ECOLOGICAL_SURVEY,
  CardName.ECOLOGICAL_ZONE_ARES,
  CardName.GEOLOGICAL_SURVEY,
  CardName.GREAT_DAM_ARES,
  CardName.INDUSTRIAL_CENTER_ARES,
  CardName.LAVA_FLOWS_ARES,
  CardName.MAGNETIC_FIELD_GENERATORS_ARES,
  CardName.MARKETING_EXPERTS,
  CardName.METALLIC_ASTEROID,
  CardName.MINING_AREA_ARES,
  CardName.MINING_RIGHTS_ARES,
  CardName.MOHOLE_AREA_ARES,
  CardName.NATURAL_PRESERVE_ARES,
  CardName.NUCLEAR_ZONE_ARES,
  CardName.OCEAN_CITY,
  CardName.OCEAN_FARM,
  CardName.OCEAN_SANCTUARY,
  CardName.RESTRICTED_AREA_ARES,
  CardName.SOLAR_FARM,
];

export class Eris extends CorporationCard {
  constructor() {
    super({
      name: CardName.ERIS,
      tags: [Tag.BUILDING],
      initialActionText: 'Draw an Ares card',
      startingMegaCredits: 46,

      metadata: {
        cardNumber: 'R47',
        description: 'You start with 46 M€. As your first action, draw an Ares card.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(46).nbsp.cards(1, {secondaryTag: AltSecondaryTag.ARES});
          b.corpBox('action', (ce) => {
            ce.action('Place a new hazard tile adjacent to NO OTHER TILE, OR remove a hazard tile to gain 1 TR.', (eb) => {
              eb.empty().startAction.plus().hazardTile().slash().minus().hazardTile().colon().tr(1, {size: Size.SMALL});
            });
          });
        }),
      },
    });
  }

  public initialAction(player: IPlayer) {
    this.drawAresCard(player);
    return undefined;
  }

  public canAct(player: IPlayer): boolean {
    const game = player.game;
    const availableSpaces = this.getAvailableSpaces(player);
    const hazardSpaces = Eris.getAllUnprotectedHazardSpaces(game);

    if (availableSpaces.length === 0 && hazardSpaces.length === 0) return false;
    return true;
  }

  public action(player: IPlayer) {
    const game = player.game;
    const orOptions = new OrOptions();
    const availableSpaces = this.getAvailableSpaces(player);
    const hazardSpaces = Eris.getAllUnprotectedHazardSpaces(game);

    if (availableSpaces.length > 0) {
      orOptions.options.push(new SelectOption('Place a hazard tile adjacent to no other tile', 'Select').andThen(() => {
        const title = 'Select space next to no other tile for hazard';
        game.defer(new PlaceHazardTile(player, TileType.EROSION_MILD, {title, spaces: availableSpaces}));
        return undefined;
      }));
    }

    if (hazardSpaces.length > 0 && player.canAfford({cost: 0, tr: {tr: 1}})) {
      orOptions.options.push(new SelectOption('Remove a hazard tile to gain 1 TR', 'Select').andThen(() => {
        return new SelectSpace(
          'Select hazard tile to remove',
          Eris.getAllUnprotectedHazardSpaces(game)).andThen(
          (space) => {
            const tileType = space.tile?.tileType;
            space.tile = undefined;
            player.increaseTerraformRating(1, {log: true});
            if (tileType === undefined) {
              return;
            }
            LogHelper.logBoardTileAction(player, space, tileTypeToString[tileType], 'removed');
            return undefined;
          },
        );
      }));
    }

    if (orOptions.options.length === 1) return orOptions.options[0].cb();
    return orOptions;
  }

  private drawAresCard(player: IPlayer) {
    player.drawCard(1, {include: (card) => ARES_CARDS.includes(card.name)});

    return undefined;
  }

  private getAvailableSpaces(player: IPlayer) {
    const board = player.game.board;
    return board.getAvailableSpacesOnLand(player)
      .filter(((space) => space.tile === undefined))
      .filter((space) => {
        const adjacentSpaces = board.getAdjacentSpaces(space);
        return adjacentSpaces.filter((space) => space.tile !== undefined).length === 0;
      });
  }

  public static getAllUnprotectedHazardSpaces(game: IGame) {
    return game.board.getHazards().filter((space) => space.tile?.protectedHazard !== true);
  }
}

================
File: cards/community/ExecutiveOrder.ts
================
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {SendDelegateToArea} from '../../deferredActions/SendDelegateToArea';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../../turmoil/Turmoil';
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {SelectGlobalEvent} from '../../inputs/SelectGlobalEvent';

export class ExecutiveOrder extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.EXECUTIVE_ORDER,

      metadata: {
        cardNumber: 'Y31',
        renderData: CardRenderer.builder((b) => {
          b.text('PLAY').globalEvent().asterix();
          b.br.br.br;
          b.delegates(2).megacredits(10).br.br;
        }),
        description: 'Draw 4 global events. Play 1 as the CURRENT GLOBAL EVENT and discard the rest. Place 2 delegates in any party. Gain 10 M€.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.stock.add(Resource.MEGACREDITS, 10, {log: true});
    const turmoil = Turmoil.getTurmoil(player.game);
    const globalEvents: IGlobalEvent[] = [];

    for (let i = 0; i < 4; i++) {
      const event = turmoil.globalEventDealer.draw();
      if (event !== undefined) {
        globalEvents.push(event);
      }
    }

    return new SelectGlobalEvent(globalEvents)
      .andThen((event) => {
        player.game.log('${0} selected Global Event ${1} for the current gflobal event', (b) => b.player(player).globalEvent(event));
        turmoil.currentGlobalEvent = event;
        turmoil.sendDelegateToParty('NEUTRAL', event.currentDelegate, player.game);
        player.game.log('Neutral delegate added to ${0}', (b) => b.partyName(event.currentDelegate));

        globalEvents.forEach((ge) => {
          if (ge.name !== event.name) {
            turmoil.globalEventDealer.discard(ge);
          }
        });

        player.game.defer(new SendDelegateToArea(player, 'Select where to send 2 delegates', {count: 2}));
        return undefined;
      });
  }
}

================
File: cards/community/Hygiea.ts
================
import {Colony} from '../../colonies/Colony';
import {ColonyName} from '../../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../../common/colonies/ColonyBenefit';
import {Resource} from '../../../common/Resource';

export class Hygiea extends Colony {
  constructor() {
    super({
      name: ColonyName.HYGIEA,
      description: [
        'Choose opponent to discard 1 card',
        'Steal 3 units of the listed type',
        'Gain 3 M€',
      ],
      buildType: ColonyBenefit.OPPONENT_DISCARD,
      tradeType: ColonyBenefit.STEAL_RESOURCES,
      tradeQuantity: [3, 3, 3, 3, 3, 3, 3],
      tradeResource: [
        Resource.MEGACREDITS,
        Resource.MEGACREDITS,
        Resource.HEAT,
        Resource.ENERGY,
        Resource.PLANTS,
        Resource.STEEL,
        Resource.TITANIUM,
      ],
      colonyBonusType: ColonyBenefit.GAIN_RESOURCES,
      colonyBonusQuantity: 3,
      colonyBonusResource: Resource.MEGACREDITS,
      shouldIncreaseTrack: 'ask',
    });
  }
}

================
File: cards/community/Iapetus.ts
================
import {Colony} from '../../colonies/Colony';
import {ColonyName} from '../../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../../common/colonies/ColonyBenefit';

export class Iapetus extends Colony {
  constructor() {
    super({
      name: ColonyName.IAPETUS,
      description: [
        'Gain 1 TR',
        'Gain n TR',
        'Pay 1 M€ less for cards this generation',
      ],

      buildType: ColonyBenefit.GAIN_TR,
      tradeType: ColonyBenefit.GAIN_TR,
      tradeQuantity: [0, 0, 0, 1, 1, 1, 2],
      colonyBonusType: ColonyBenefit.GAIN_CARD_DISCOUNT,
    });
  }
}

================
File: cards/community/Incite.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class Incite extends CorporationCard {
  constructor() {
    super({
      name: CardName.INCITE,
      tags: [Tag.SCIENCE],
      startingMegaCredits: 32,

      behavior: {
        turmoil: {influenceBonus: 1},
      },
      firstAction: {
        text: 'Place 2 delegates in one party',
        turmoil: {sendDelegates: {count: 2}},
      },

      metadata: {
        cardNumber: 'R37',
        description: 'You start with 32 M€. As your first action, place two delegates in one party.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(32).nbsp.delegates(2);
          b.corpBox('effect', (ce) => {
            ce.vSpace(Size.LARGE);
            ce.effect(undefined, (eb) => {
              eb.empty().startEffect.influence();
            });
            ce.vSpace(Size.SMALL);
            ce.effect('You have +1 influence. When you send a delegate using the lobbying action, you pay 2 M€ less for it.', (eb) => {
              eb.delegates(1).startEffect.megacredits(-2);
            });
          });
        }),
      },
    });
  }
}

================
File: cards/community/JunkVentures.ts
================
import {CardName} from '../../../common/cards/CardName';
import {Size} from '../../../common/cards/render/Size';
import {CorporationCard} from '../corporation/CorporationCard';
import {CardRenderer} from '../render/CardRenderer';
import {ChooseCards} from '../../deferredActions/ChooseCards';
import {IPlayer} from '../../IPlayer';

export class JunkVentures extends CorporationCard {
  constructor() {
    super({
      name: CardName.JUNK_VENTURES,
      initialActionText: 'Discard the top 3 cards of the deck',
      startingMegaCredits: 43,

      metadata: {
        cardNumber: 'R49',
        description: 'You start with 43 M€. As your first action, discard the top 3 cards of the deck.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(43).text('DECK: ').minus().cards(3);
          b.corpBox('action', (cb) => {
            cb.text('ACTION: SHUFFLE THE DISCARD PILE, THEN DRAW 3 CARDS FROM IT. KEEP 1 AND DISCARD THE OTHER 2.', Size.SMALL, true);
          });
        }),
      },
    });
  }

  public initialAction(player: IPlayer) {
    const cards = player.game.projectDeck.drawN(player.game, 3);
    for (const card of cards) {
      player.game.projectDeck.discard(card);
    }
    return undefined;
  }

  public canAct(player: IPlayer): boolean {
    return player.game.projectDeck.discardPile.length >= 3;
  }

  public action(player: IPlayer) {
    const game = player.game;
    game.projectDeck.shuffleDiscardPile();

    const cards = [];
    for (let idx = 0; idx < 3; idx++) {
      const card = player.game.projectDeck.discardPile.pop();
      if (card === undefined) {
        break;
      }
      cards.push(card);
    }

    player.game.defer(new ChooseCards(player, cards, {keepMax: 1}));
    return undefined;
  }
}

================
File: cards/community/LeadershipSummit.ts
================
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../../turmoil/Turmoil';
import {CardRenderer} from '../render/CardRenderer';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.cards(1).slash().partyLeaders(1).plus().influence();
});

export class LeadershipSummit extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.LEADERSHIP_SUMMIT,
      description: 'Draw 1 card for each party leader (max 5) and influence.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const partyLeaderCount = turmoil.parties.filter((party) => party.partyLeader === player).length;
      player.drawCard(Math.min(5, partyLeaderCount) + turmoil.getPlayerInfluence(player));
    });
  }
}

================
File: cards/community/Leavitt.ts
================
import {Colony} from '../../colonies/Colony';
import {ColonyName} from '../../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../../common/colonies/ColonyBenefit';

export class Leavitt extends Colony {
  constructor() {
    super({
      description: [
        'Gain 1 science tag',
        'Draw n cards, keep 1',
        'Draw 1 card which you may pay to keep',
      ],

      name: ColonyName.LEAVITT,
      buildType: ColonyBenefit.GAIN_SCIENCE_TAG,
      tradeType: ColonyBenefit.DRAW_CARDS_AND_KEEP_ONE,
      tradeQuantity: [1, 2, 3, 4, 5, 6, 7],
      colonyBonusType: ColonyBenefit.DRAW_CARDS_AND_BUY_ONE,
    });
  }
}

================
File: cards/community/Mercury.ts
================
import {Colony} from '../../colonies/Colony';
import {ColonyName} from '../../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../../common/colonies/ColonyBenefit';
import {Resource} from '../../../common/Resource';

export class Mercury extends Colony {
  constructor() {
    super({
      name: ColonyName.MERCURY,
      description: [
        'Gain the trade bonus of any colony tile. (This does not move the markers.)',
        'Gain 1 unit of production of the type below the track marker',
        'Gain 2 M€',
      ],

      buildType: ColonyBenefit.COPY_TRADE,
      tradeType: ColonyBenefit.GAIN_PRODUCTION,
      tradeResource: [
        Resource.HEAT, Resource.HEAT, Resource.HEAT,
        Resource.STEEL, Resource.STEEL,
        Resource.TITANIUM, Resource.TITANIUM,
      ],
      colonyBonusType: ColonyBenefit.GAIN_RESOURCES,
      colonyBonusResource: Resource.MEGACREDITS,
      colonyBonusQuantity: 2,
      shouldIncreaseTrack: 'ask',
    });
  }
}

================
File: cards/community/Midas.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class Midas extends CorporationCard {
  constructor() {
    super({
      name: CardName.MIDAS,
      startingMegaCredits: 120,

      metadata: {
        cardNumber: 'R41',
        description: 'You start with 120 M€. Lower your TR 7 steps.',
        renderData: CardRenderer.builder((b) => {
          b.vSpace(Size.LARGE).br;
          b.megacredits(120, {size: Size.LARGE}).nbsp.nbsp.nbsp;
          b.minus().tr(7);
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.decreaseTerraformRating(7);
    return undefined;
  }
}

================
File: cards/community/Pallas.ts
================
import {Colony} from '../../colonies/Colony';
import {ColonyName} from '../../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../../common/colonies/ColonyBenefit';

export class Pallas extends Colony {
  constructor() {
    super({
      name: ColonyName.PALLAS,
      description: [
        'Gain +1 influence',
        'Place n delegates',
        'Gain 1 M€ for each delegate in any party',
      ],

      buildType: ColonyBenefit.GAIN_INFLUENCE,
      tradeType: ColonyBenefit.PLACE_DELEGATES,
      tradeQuantity: [1, 1, 1, 2, 2, 2, 3],
      colonyBonusType: ColonyBenefit.GIVE_MC_PER_DELEGATE,
    });
  }
}

================
File: cards/community/Playwrights.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {SelectCard} from '../../inputs/SelectCard';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {all} from '../Options';
import {SpecialDesignProxy} from './SpecialDesignProxy';

export class Playwrights extends CorporationCard {
  constructor() {
    super({
      name: CardName.PLAYWRIGHTS,
      tags: [Tag.POWER],
      startingMegaCredits: 38,

      behavior: {
        production: {energy: 1},
      },

      metadata: {
        cardNumber: 'R40',
        description: 'You start with 38 M€ and 1 energy production.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(38).production((pb) => pb.energy(1));
          b.corpBox('action', (cb) => {
            cb.action('Replay a played event from any player (INCLUDING events that place special tiles) by paying its cost ONLY in M€ (discounts and rebates apply), then REMOVE IT FROM PLAY.', (eb) => {
              eb.megacredits(1, {text: '?'}).startAction;
              eb.text('replay', Size.SMALL, true);
              eb.nbsp.cards(1, {all, secondaryTag: Tag.EVENT});
            });
          });
        }),
      },
    });
  }

  // For Project Inspection
  private checkLoops = 0;

  public canAct(player: IPlayer): boolean {
    const replayableEvents = this.getReplayableEvents(player);
    return replayableEvents.length > 0;
  }

  public action(player: IPlayer): SelectCard<IProjectCard> | undefined {
    const players = player.game.getPlayers();
    const replayableEvents = this.getReplayableEvents(player);

    return new SelectCard<IProjectCard>(
      'Select event card to replay at cost in M€ and remove from play', 'Select', replayableEvents, {played: false})
      .andThen(
        ([card]) => {
          const selectedCard: IProjectCard = card;

          players.forEach((p) => {
            const cardIndex = p.playedCards.findIndex((c) => c.name === selectedCard.name);
            if (cardIndex !== -1) {
              p.playedCards.splice(cardIndex, 1);
            }
          });

          const cost = player.getCardCost(selectedCard);
          player.game.defer(new SelectPaymentDeferred(player, cost, {title: 'Select how to pay to replay the event'}))
            .andThen(() => {
              player.playCard(selectedCard, undefined, 'nothing'); // Play the card but don't add it to played cards
              player.removedFromPlayCards.push(selectedCard); // Remove card from the game
              if (selectedCard.name === CardName.SPECIAL_DESIGN) {
                player.playedCards.push(new SpecialDesignProxy());
              } else if (selectedCard.name === CardName.LAW_SUIT) {
              /*
               * If the card played is Law Suit we need to remove it from the newly sued player's played cards.
               * Needs to be deferred to happen after Law Suit's `play()` method.
               */
                player.defer(() => {
                  player.game.getPlayers().some((p) => {
                    const card = p.playedCards[p.playedCards.length - 1];
                    if (card?.name === selectedCard.name) {
                      p.playedCards.pop();
                      return true;
                    }
                    return false;
                  });
                  return undefined;
                });
              }
            });
          return undefined;
        },
      );
  }

  public getCheckLoops(): number {
    return this.checkLoops;
  }

  private getReplayableEvents(player: IPlayer): Array<IProjectCard> {
    const playedEvents : IProjectCard[] = [];

    this.checkLoops++;
    try {
      player.game.getPlayers().forEach((p) => {
        playedEvents.push(...p.playedCards.filter((card) => {
          // Special case Price Wars, which is not easy to work with.
          if (card.name === CardName.PRICE_WARS) {
            return false;
          }
          const canAffordOptions = {
            cost: player.getCardCost(card),
            reserveUnits: MoonExpansion.adjustedReserveCosts(player, card),
          };
          return card.type === CardType.EVENT &&
          // Can player.canPlay(card) replace this?
          player.canAfford(canAffordOptions) && card.canPlay(player, canAffordOptions);
        }));
      });
    } finally {
      this.checkLoops--;
    }

    return playedEvents;
  }
}

================
File: cards/community/PoliticalUprising.ts
================
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {TURMOIL_CARD_MANIFEST} from '../turmoil/TurmoilCardManifest';
import {CardRenderer} from '../render/CardRenderer';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {CardManifest} from '../ModuleManifest';

export class PoliticalUprising extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.POLITICAL_UPRISING,

      behavior: {
        turmoil: {sendDelegates: {count: 4, manyParties: true}},
      },

      metadata: {
        cardNumber: 'Y03',
        renderData: CardRenderer.builder((b) => {
          b.delegates(4).br.br;
          b.cards(1, {secondaryTag: AltSecondaryTag.TURMOIL});
        }),
        description: 'Place 4 delegates in any parties. Draw a Turmoil card.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    this.drawTurmoilCard(player);
    return undefined;
  }

  // TODO(kberg): it is possible, though unlikely, that the draw deck won't have another Turmoil card, but this
  // app ought to check the discard pile, or something.
  private drawTurmoilCard(player: IPlayer) {
    // Rather than draw and discard potentially dozens of cards, find one card in the deck that's a Turmoil card.

    // First get all the card names for Turmoil Project cards by indexing the manifest.
    const turmoilCardNames = CardManifest.keys(TURMOIL_CARD_MANIFEST.projectCards);

    // Then find the first card in the deck that matches one of those names.
    const drawnCard = player.game.projectDeck.drawPile.find((card) => turmoilCardNames.includes(card.name));

    if (drawnCard === undefined) {
      player.game.log('${0} played ${1} to find a Turmoil card but none were in the draw deck.', (b) => b.player(player).card(this));
    } else {
      const cardIndex = player.game.projectDeck.drawPile.findIndex((c) => c.name === drawnCard.name);
      player.game.projectDeck.drawPile.splice(cardIndex, 1);

      player.cardsInHand.push(drawnCard);
      player.game.log('${0} drew ${1}', (b) => b.player(player).card(drawnCard));
    }

    return undefined;
  }
}

================
File: cards/community/ProjectWorkshop.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {SelectCard} from '../../inputs/SelectCard';
import {ICard} from '../ICard';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {digit} from '../Options';
import {PartyHooks} from '../../turmoil/parties/PartyHooks';
import {PartyName} from '../../../common/turmoil/PartyName';
import {REDS_RULING_POLICY_COST} from '../../../common/constants';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {TITLES} from '../../inputs/titles';

export class ProjectWorkshop extends CorporationCard {
  constructor() {
    super({
      name: CardName.PROJECT_WORKSHOP,
      tags: [Tag.EARTH],
      startingMegaCredits: 39,

      behavior: {
        stock: {steel: 1, titanium: 1},
      },

      firstAction: {
        text: 'Draw a blue card',
        drawCard: {count: 1, type: CardType.ACTIVE},
      },

      metadata: {
        cardNumber: 'R45',
        description: 'You start with 39 M€, 1 steel and 1 titanium. As your first action, draw a blue card.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(39).steel(1).titanium(1).cards(1, {secondaryTag: AltSecondaryTag.BLUE});
          b.corpBox('action', (cb) => {
            cb.vSpace(Size.LARGE);
            cb.action(undefined, (eb) => {
              eb.text('flip', Size.SMALL, true).cards(1, {secondaryTag: AltSecondaryTag.BLUE});
              eb.startAction.text('?', Size.MEDIUM, true).tr(1, {size: Size.SMALL});
              eb.cards(2, {digit});
            });
            cb.vSpace(Size.SMALL);
            cb.action('Flip and discard a played blue card to convert any VP on it into TR and draw 2 cards, or spend 3 M€ to draw a blue card.', (eb) => {
              eb.or().megacredits(3).startAction.cards(1, {secondaryTag: AltSecondaryTag.BLUE});
            });
          });
        }),
      },
    });
  }

  private getEligibleCards(player: IPlayer) {
    const cards = player.playedCards.filter((card) => card.type === CardType.ACTIVE);
    if (!PartyHooks.shouldApplyPolicy(player, PartyName.REDS, 'rp01')) {
      return cards;
    }
    return cards.filter((card) => {
      const vp = card.getVictoryPoints(player);
      if (vp <= 0) {
        return true;
      }
      return player.canAfford(REDS_RULING_POLICY_COST * vp);
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.canAfford(3) || this.getEligibleCards(player).length > 0;
  }

  public action(player: IPlayer) {
    const activeCards = this.getEligibleCards(player);

    const flipBlueCard = new SelectOption(
      'Flip and discard a played blue card',
      'Select')
      .andThen(() => {
        if (activeCards.length === 1) {
          this.convertCardPointsToTR(player, activeCards[0]);
          player.discardPlayedCard(activeCards[0]);
          player.drawCard(2);
          return undefined;
        }

        return new SelectCard<IProjectCard>(
          'Select active card to discard',
          'Discard',
          activeCards)
          .andThen(
            ([card]) => {
              this.convertCardPointsToTR(player, card);
              player.discardPlayedCard(card);
              player.drawCard(2);
              return undefined;
            },
          );
      });

    const drawBlueCard = new SelectOption('Spend 3 M€ to draw a blue card', 'Draw card').andThen(() => {
      player.game.defer(new SelectPaymentDeferred(player, 3,
        {title: TITLES.payForCardAction(this.name)}))
        .andThen(() => player.drawCard(1, {cardType: CardType.ACTIVE}));
      return undefined;
    });

    if (activeCards.length === 0) return drawBlueCard;
    if (!player.canAfford(3)) return flipBlueCard;

    return new OrOptions(drawBlueCard, flipBlueCard);
  }

  private convertCardPointsToTR(player: IPlayer, card: ICard) {
    const steps = card.getVictoryPoints(player);
    // TODO(kberg): this doesn't reduce VPs below 0. What to do?
    if (steps > 0) {
      player.increaseTerraformRating(steps, {log: true});
    } else if (steps < 0) {
      player.decreaseTerraformRating(-steps, {log: true});
    }
  }
}

================
File: cards/community/ResearchGrant.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from '../prelude/PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class ResearchGrant extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.RESEARCH_GRANT,
      tags: [Tag.SCIENCE, Tag.SCIENCE],
      behavior: {
        stock: {megacredits: 8},
      },

      metadata: {
        cardNumber: 'Y04',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(8);
        }),
        description: 'Gain 8 M€.',
      },
    });
  }
}

================
File: cards/community/ScienceTagCard.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {ProxyCard} from '../ProxyCard';

export class ScienceTagCard extends ProxyCard {
  constructor() {
    super(CardName.SCIENCE_TAG_BLANK_CARD);
  }
  public override get tags() {
    return [Tag.SCIENCE];
  }
}

================
File: cards/community/SpecialDesignProxy.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {ProxyCard} from '../ProxyCard';

/**
 * A special use card that stands in when Playwrights reactivates Special Design.
 *
 * Since Special Design can't sit in the game, this proxy card takes care of it.
 */
export class SpecialDesignProxy extends ProxyCard {
  constructor() {
    super(CardName.SPECIAL_DESIGN_PROXY);
  }
  public override getGlobalParameterRequirementBonus(player: IPlayer) {
    // NOTE: normally code looks like 'if player.lastCardPlayed === this.name` but
    // not in this case.
    if (player.lastCardPlayed === CardName.SPECIAL_DESIGN) {
      return 2;
    }
    return 0;
  }
}

================
File: cards/community/Titania.ts
================
import {Colony} from '../../colonies/Colony';
import {Resource} from '../../../common/Resource';
import {ColonyName} from '../../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../../common/colonies/ColonyBenefit';

export class Titania extends Colony {
  constructor() {
    super({
      name: ColonyName.TITANIA,
      description: [
        'Gain 5, 3, or 2 VP',
        'Gain n VP',
        'Lose 3 M€',
      ],


      buildType: ColonyBenefit.GAIN_VP,
      buildQuantity: [5, 3, 2],
      tradeType: ColonyBenefit.GAIN_VP,
      tradeQuantity: [2, 2, 2, 1, 1, 0, 0],
      colonyBonusType: ColonyBenefit.LOSE_RESOURCES,
      colonyBonusQuantity: 3,
      colonyBonusResource: Resource.MEGACREDITS,
      shouldIncreaseTrack: 'no',
    });
  }
}

================
File: cards/community/TradeAdvance.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class TradeAdvance extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.TRADE_ADVANCE,
      tags: [Tag.EARTH],
      behavior: {
        stock: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'Y05',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(2).text('[ solo').colon().megacredits(10).text(']').br;
          b.text('Trade all colonies with').br;
          b.trade().colon().text('+1');
        }),
        description: 'Gain 2 M€ [SOLO: Gain 10 M€]. Immediately trade with all active colonies. You may increase the Colony Tile track 1 step before each of these trades.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.defer(() => {
      const activeColonies = player.game.colonies.filter((colony) => colony.isActive);
      activeColonies.forEach((colony) => {
        colony.trade(player, {usesTradeFleet: false}, 1);
      });
      return undefined;
    });

    if (player.game.isSoloMode()) {
      player.megaCredits += 8;
    }

    return undefined;
  }
}

================
File: cards/community/UnitedNationsMissionOne.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';
import {all} from '../Options';
import {Phase} from '../../../common/Phase';
import {Resource} from '../../../common/Resource';

export class UnitedNationsMissionOne extends CorporationCard {
  constructor() {
    super({
      name: CardName.UNITED_NATIONS_MISSION_ONE,
      tags: [Tag.EARTH],
      startingMegaCredits: 40, // +1 for the initial change in TR.

      metadata: {
        cardNumber: 'R50',
        description: 'You start with 39 M€. Increase your TR 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(39).nbsp.tr(1);
          b.corpBox('effect', (ce) => {
            ce.vSpace();
            ce.effect('When any player takes an action or plays a card that increases TR, including this, gain 1 M€ for each step.', (eb) => {
              eb.tr(1, {all}).startEffect.megacredits(1);
            });
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer): undefined {
    player.increaseTerraformRating();
    return undefined;
  }

  // TODO(kberg): Since UNMO can generate MC for raising TR, that MC can offset reds costs, can't it?
  public onIncreaseTerraformRating(player: IPlayer, cardOwner: IPlayer, steps: number) {
    const game = player.game;

    if (game.phase === Phase.ACTION || game.phase === Phase.PRELUDES) {
      cardOwner.stock.add(Resource.MEGACREDITS, steps, {log: true});
    }
  }
}

================
File: cards/community/ValuableGases.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {SelectProjectCardToPlay} from '../../inputs/SelectProjectCardToPlay';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {digit} from '../Options';

export class ValuableGases extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.VALUABLE_GASES,
      tags: [Tag.JOVIAN, Tag.VENUS],
      behavior: {
        stock: {megacredits: 6},
      },

      metadata: {
        cardNumber: 'Y06',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(6).br.br;
          b.text('play', Size.MEDIUM, true).cards(1, {secondaryTag: Tag.VENUS}).colon();
          b.resource(CardResource.FLOATER, {amount: 4, digit});
        }),
        description: 'Gain 6 M€. Play a Venus card from your hand and add 4 floaters to it.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const playableCards = player.getPlayableCards().filter((card) => card.card.tags.includes(Tag.VENUS));

    if (playableCards.length > 0) {
      return new SelectProjectCardToPlay(player, playableCards)
        .andThen((card) => {
          if (card.resourceType === CardResource.FLOATER) {
            player.addResourceTo(card, 4);
          }
          return undefined;
        });
    }

    return undefined;
  }
}

================
File: cards/community/Venus.ts
================
import {Colony} from '../../colonies/Colony';
import {ColonyName} from '../../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../../common/colonies/ColonyBenefit';

export class Venus extends Colony {
  public override isActive = false;
  constructor() {
    super({
      name: ColonyName.VENUS,
      description: [
        'Increase Venus 1 step',
        'Add n resources to ANY Venus card',
        'Add 1 resource to ANY Venus card',
      ],

      buildType: ColonyBenefit.INCREASE_VENUS_SCALE,
      tradeType: ColonyBenefit.ADD_RESOURCES_TO_VENUS_CARD,
      tradeQuantity: [0, 0, 0, 1, 2, 3, 4],
      colonyBonusType: ColonyBenefit.ADD_RESOURCES_TO_VENUS_CARD,
    });
  }
}

================
File: cards/corporation/BeginnerCorporation.ts
================
import {CorporationCard} from './CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class BeginnerCorporation extends CorporationCard {
  constructor() {
    super({
      name: CardName.BEGINNER_CORPORATION,

      behavior: {
        drawCard: 10,
      },

      metadata: {
        cardNumber: 'R00',
        description: 'You start with 42 M€. Instead of choosing from 10 cards during setup, you get 10 cards for free.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(42).nbsp.cards(10, {digit});
        }),
      },
      startingMegaCredits: 42,
    });
  }
}

================
File: cards/corporation/CorporationCard.ts
================
import {CardType} from '../../../common/cards/CardType';
import {ICorporationCard} from './ICorporationCard';
import {Card, StaticCardProperties} from '../Card';
import {IPlayer} from '../../IPlayer';
import {getBehaviorExecutor} from '../../behavior/BehaviorExecutor';
import {IActionCard} from '../ICard';

export abstract class CorporationCard extends Card implements ICorporationCard {
  constructor(external: Omit<StaticCardProperties, 'type'>) {
    // Corporation cards don't need a type defined for them.
    super({...external, type: CardType.CORPORATION});
  }
  public override get type(): CardType.CORPORATION {
    return CardType.CORPORATION;
  }
}

/**
 * A corporation card that can parse an `action: {}` stanza.
 */
export abstract class ActiveCorporationCard extends CorporationCard implements IActionCard {
  public canAct(player: IPlayer) {
    if (this.properties.action === undefined) {
      throw new Error('action not defined');
    }
    if (!getBehaviorExecutor().canExecute(this.properties.action, player, this)) {
      return false;
    }
    return this.bespokeCanAct(player);
  }

  public action(player: IPlayer) {
    if (this.properties.action === undefined) {
      throw new Error('action not defined');
    }
    getBehaviorExecutor().execute(this.properties.action, player, this);
    return this.bespokeAction(player);
  }

  public bespokeCanAct(_player: IPlayer): boolean {
    return true;
  }

  public bespokeAction(_player: IPlayer) {
    return undefined;
  }
}

================
File: cards/corporation/CrediCor.ts
================
import {CorporationCard} from './CorporationCard';
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IStandardProjectCard} from '../IStandardProjectCard';
import {Resource} from '../../../common/Resource';

export class CrediCor extends CorporationCard {
  constructor() {
    super({
      name: CardName.CREDICOR,
      startingMegaCredits: 57,

      metadata: {
        cardNumber: 'R08',
        description: 'You start with 57 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(57);
          b.corpBox('effect', (ce) => {
            ce.effect('After you pay for a card or standard project with a basic cost of 20M€ or more, you gain 4 M€.', (eb) => {
              eb.minus().megacredits(20).startEffect.megacredits(4);
            });
          });
        }),
      },
    });
  }
  private effect(player: IPlayer, card: IProjectCard | IStandardProjectCard): void {
    if (player.isCorporation(this.name) && card.cost >= 20) {
      player.stock.add(Resource.MEGACREDITS, 4, {log: true});
    }
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    this.effect(player, card);
  }
  public onStandardProject(player: IPlayer, project: IStandardProjectCard) {
    this.effect(player, project);
  }
}

================
File: cards/corporation/EcoLine.ts
================
import {CorporationCard} from './CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class EcoLine extends CorporationCard {
  constructor() {
    super({
      name: CardName.ECOLINE,
      tags: [Tag.PLANT],
      startingMegaCredits: 36,

      behavior: {
        production: {plants: 2},
        stock: {plants: 3},
        greeneryDiscount: 1,
      },

      metadata: {
        cardNumber: 'R17',
        description: 'You start with 2 plant production, 3 plants, and 36 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.production((pb) => pb.plants(2)).nbsp.megacredits(36).plants(3, {digit});
          b.corpBox('effect', (ce) => {
            ce.effect('You may always pay 7 plants, instead of 8, to place greenery.', (eb) => {
              eb.plants(7, {digit}).startAction.greenery();
            });
          });
        }),
      },
    });
  }
}

================
File: cards/corporation/Helion.ts
================
import {CorporationCard} from './CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Helion extends CorporationCard {
  constructor() {
    super({
      name: CardName.HELION,
      tags: [Tag.SPACE],
      startingMegaCredits: 42,

      behavior: {
        production: {heat: 3},        
      },

      metadata: {
        cardNumber: 'R18',
        description: 'You start with 3 heat production and 42 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.production((pb) => pb.heat(3)).nbsp.megacredits(42);
          b.corpBox('effect', (ce) => {
            ce.effect('You may use heat as M€. You may not use M€ as heat.', (eb) => {
              eb.startEffect.text('x').heat(1).equals().megacredits(1, {text: 'x'});
            });
          });
        }),
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    player.canUseHeatAsMegaCredits = true;
    return undefined;
  }
}

================
File: cards/corporation/ICorporationCard.ts
================
import {ICard} from '../ICard';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {CardType} from '../../../common/cards/CardType';
import {SerializedCard} from '../../SerializedCard';
import {Behavior} from '../../behavior/Behavior';

export interface ICorporationCard extends ICard {
  type: CardType.CORPORATION;
  initialActionText?: string;
  initialAction?(player: IPlayer): PlayerInput | undefined;
  firstAction?: Behavior,
  startingMegaCredits: number;
  cardCost?: number;
  onCorpCardPlayed?(player: IPlayer, card: ICorporationCard, cardOwner: IPlayer): PlayerInput | undefined | void;

  serialize?(serialized: SerializedCard): void;
  deserialize?(serialized: SerializedCard): void;
}

export function isICorporationCard(card: ICard): card is ICorporationCard {
  return card.type === CardType.CORPORATION;
}

================
File: cards/corporation/InterplanetaryCinematics.ts
================
import {CorporationCard} from './CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {Resource} from '../../../common/Resource';

export class InterplanetaryCinematics extends CorporationCard {
  constructor() {
    super({
      name: CardName.INTERPLANETARY_CINEMATICS,
      tags: [Tag.BUILDING],
      startingMegaCredits: 30,

      behavior: {
        stock: {steel: 20},
      },

      metadata: {
        cardNumber: 'R19',
        description: 'You start with 20 steel and 30 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(30).nbsp.steel(20, {digit});
          b.corpBox('effect', (ce) => {
            ce.effect('Each time you play an event, you gain 2 M€.', (eb) => {
              eb.tag(Tag.EVENT).startEffect.megacredits(2);
            });
          });
        }),
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (player.isCorporation(this.name) && card.type === CardType.EVENT) {
      player.stock.add(Resource.MEGACREDITS, 2, {log: true, from: this});
    }
  }
}

================
File: cards/corporation/Inventrix.ts
================
import {CorporationCard} from './CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Inventrix extends CorporationCard {
  constructor() {
    super({
      name: CardName.INVENTRIX,
      tags: [Tag.SCIENCE],
      startingMegaCredits: 45,
      globalParameterRequirementBonus: {steps: 2},

      firstAction: {
        text: 'Draw 3 cards',
        drawCard: 3,
      },

      metadata: {
        cardNumber: 'R43',
        description: 'As your first action in the game, draw 3 cards. Start with 45 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(45).nbsp.cards(3);
          b.corpBox('effect', (ce) => {
            ce.effect('Your temperature, oxygen, ocean, and Venus requirements are +2 or -2 steps, your choice in each case.', (eb) => {
              eb.plate('Global requirements').startEffect.text('+/- 2');
            });
          });
        }),
      },
    });
  }
}

================
File: cards/corporation/MiningGuild.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CorporationCard} from './CorporationCard';
import {Phase} from '../../../common/Phase';
import {Space} from '../../boards/Space';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {GainProduction} from '../../deferredActions/GainProduction';
import {CardRenderer} from '../render/CardRenderer';
import {BoardType} from '../../boards/BoardType';
import {digit} from '../Options';
import {AresHandler} from '../../ares/AresHandler';

export class MiningGuild extends CorporationCard {
  constructor() {
    super({
      name: CardName.MINING_GUILD,
      tags: [Tag.BUILDING, Tag.BUILDING],
      startingMegaCredits: 30,

      behavior: {
        production: {steel: 1},
        stock: {steel: 5},
      },

      metadata: {
        cardNumber: 'R24',
        hasExternalHelp: true,
        description: 'You start with 30 M€, 5 steel and 1 steel production.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(30).nbsp.steel(5, {digit}).nbsp.production((pb) => pb.steel(1));
          b.corpBox('effect', (ce) => {
            ce.effect('Each time you place a tile on an area with a steel or titanium placement bonus, increase your steel production 1 step', (eb) => {
              eb.steel(1).asterix().slash().titanium(1).asterix();
              eb.startEffect.production((pb) => pb.steel(1));
            });
          });
        }),
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space, boardType: BoardType) {
    // Nerfing on The Moon.
    if (boardType !== BoardType.MARS) {
      return;
    }
    if (cardOwner.id !== activePlayer.id || cardOwner.game.phase === Phase.SOLAR) {
      return;
    }
    // Don't grant a bonus if the card is overplaced (like Ares Ocean City)
    if (space.tile?.covers !== undefined) {
      return;
    }
    const board = cardOwner.game.board;
    const grant = space.bonus.some((bonus) => bonus === SpaceBonus.STEEL || bonus === SpaceBonus.TITANIUM) ||
      AresHandler.anyAdjacentSpaceGivesBonus(board, space, SpaceBonus.STEEL) ||
      AresHandler.anyAdjacentSpaceGivesBonus(board, space, SpaceBonus.TITANIUM);
    if (grant) {
      cardOwner.game.defer(new GainProduction(cardOwner, Resource.STEEL));
    }
  }
}

================
File: cards/corporation/PhoboLog.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CorporationCard} from './CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {digit} from '../Options';

export class PhoboLog extends CorporationCard {
  constructor() {
    super({
      name: CardName.PHOBOLOG,
      tags: [Tag.SPACE],
      startingMegaCredits: 23,

      behavior: {
        stock: {titanium: 10},
        titanumValue: 1,
      },

      metadata: {
        cardNumber: 'R09',
        description: 'You start with 10 titanium and 23 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(23).nbsp.titanium(10, {digit});
          b.corpBox('effect', (ce) => {
            ce.effect('Your titanium resources are each worth 1 M€ extra.', (eb) => {
              eb.titanium(1).startEffect.plus(Size.SMALL).megacredits(1);
            });
          });
        }),
      },
    });
  }
}

================
File: cards/corporation/SaturnSystems.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {ICorporationCard} from './ICorporationCard';
import {CorporationCard} from './CorporationCard';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {ICard} from '../ICard';

export class SaturnSystems extends CorporationCard {
  constructor() {
    super({
      name: CardName.SATURN_SYSTEMS,
      tags: [Tag.JOVIAN],
      startingMegaCredits: 42,

      behavior: {
        // The 1MC is for the card effect related to itself.
        production: {titanium: 1, megacredits: 1},
      },

      metadata: {
        cardNumber: 'R03',
        description: 'You start with 1 titanium production and 42 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.production((pb) => pb.titanium(1)).nbsp.megacredits(42);
          b.corpBox('effect', (ce) => {
            ce.effect('Each time any Jovian tag is put into play, including this, increase your M€ production 1 step.', (eb) => {
              eb.tag(Tag.JOVIAN, {all}).startEffect.production((pb) => pb.megacredits(1));
            });
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: ICard) {
    for (const tag of card.tags) {
      if (tag === Tag.JOVIAN) {
        player.game.getCardPlayerOrThrow(this.name).production.add(Resource.MEGACREDITS, 1, {log: true});
      }
    }
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    this.onCardPlayed(player, card);
  }
}

================
File: cards/corporation/Teractor.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CorporationCard} from './CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Teractor extends CorporationCard {
  constructor() {
    super({
      name: CardName.TERACTOR,
      tags: [Tag.EARTH],
      startingMegaCredits: 60,

      cardDiscount: {tag: Tag.EARTH, amount: 3},
      metadata: {
        cardNumber: 'R30',
        description: 'You start with 60 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(60);
          b.corpBox('effect', (ce) => {
            ce.effect('When you play an Earth tag, you pay 3 M€ less for it.', (eb) => {
              eb.tag(Tag.EARTH).startEffect.megacredits(-3);
            });
          });
        }),
      },
    });
  }
}

================
File: cards/corporation/TharsisRepublic.ts
================
import {CorporationCard} from './CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {SpaceType} from '../../../common/boards/SpaceType';
import {Space} from '../../boards/Space';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {Priority} from '../../deferredActions/Priority';
import {GainResources} from '../../deferredActions/GainResources';
import {GainProduction} from '../../deferredActions/GainProduction';
import {Board} from '../../boards/Board';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class TharsisRepublic extends CorporationCard {
  constructor() {
    super({
      name: CardName.THARSIS_REPUBLIC,
      tags: [Tag.BUILDING],
      startingMegaCredits: 40,

      firstAction: {
        text: 'Place a city tile',
        city: {},
      },

      metadata: {
        cardNumber: 'R31',
        description: 'You start with 40 M€. As your first action in the game, place a city tile.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(40).nbsp.city();
          b.corpBox('effect', (ce) => {
            ce.effect('When any city tile is placed ON MARS, increase your M€ production 1 step. When you place a city tile, gain 3 M€.', (eb) => {
              eb.city({size: Size.SMALL, all}).asterix().colon();
              eb.production((pb) => pb.megacredits(1)).nbsp;
              eb.city({size: Size.SMALL}).startEffect.megacredits(3);
            });
          });
        }),
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (Board.isCitySpace(space)) {
      if (cardOwner.id === activePlayer.id) {
        cardOwner.game.defer(new GainResources(cardOwner, Resource.MEGACREDITS, {count: 3}));
      }
      if (space.spaceType !== SpaceType.COLONY) {
        cardOwner.game.defer(
          new GainProduction(cardOwner, Resource.MEGACREDITS),
          cardOwner.id !== activePlayer.id ? Priority.OPPONENT_TRIGGER : undefined,
        );
      }
    }
    return;
  }

  public override bespokePlay(player: IPlayer) {
    if (player.game.isSoloMode()) {
      // Get bonus for 2 neutral cities
      player.production.add(Resource.MEGACREDITS, 2);
    }
    return undefined;
  }
}

================
File: cards/corporation/Thorgate.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CorporationCard} from './CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Thorgate extends CorporationCard {
  constructor() {
    super({
      name: CardName.THORGATE,
      tags: [Tag.POWER],
      startingMegaCredits: 48,

      behavior: {
        production: {energy: 1},
      },

      cardDiscount: {tag: Tag.POWER, amount: 3},
      metadata: {
        cardNumber: 'R13',
        description: 'You start with 1 energy production and 48 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.production((pb) => pb.energy(1)).nbsp.megacredits(48);
          b.corpBox('effect', (ce) => {
            ce.effect('When playing a power card OR THE STANDARD PROJECT POWER PLANT, you pay 3 M€ less for it.', (eb) => {
              eb.tag(Tag.POWER).asterix().startEffect.megacredits(-3);
            });
          });
        }),
      },
    });
  }
}

================
File: cards/corporation/UnitedNationsMarsInitiative.ts
================
import {CorporationCard} from './CorporationCard';
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {ICorporationCard} from './ICorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {TITLES} from '../../inputs/titles';
export const ACTION_COST = 3;
export class UnitedNationsMarsInitiative extends CorporationCard implements IActionCard, ICorporationCard {
  constructor() {
    super({
      name: CardName.UNITED_NATIONS_MARS_INITIATIVE,
      tags: [Tag.EARTH],
      startingMegaCredits: 40,

      metadata: {
        cardNumber: 'R32',
        description: 'You start with 40 M€.',
        renderData: CardRenderer.builder((b) => {
          // TODO(chosta): find a not so hacky solutions to spacing
          b.br.br.br;
          b.empty().nbsp.nbsp.nbsp.nbsp.megacredits(40);
          b.corpBox('action', (ce) => {
            ce.action('If your Terraform Rating was raised this generation, you may pay 3 M€ to raise it 1 step more.', (eb) => {
              eb.megacredits(3).startAction.tr(1).asterix();
            });
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.generationData.hasRaisedTR && player.canAfford({cost: ACTION_COST, tr: {tr: 1}});
  }

  public action(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 3, {title: TITLES.payForCardAction(this.name)}))
      .andThen(() => player.increaseTerraformRating());
    return undefined;
  }
}

================
File: cards/Deck.ts
================
import {SerializedDeck} from './SerializedDeck';
import {cardsFromJSON, ceosFromJSON, corporationCardsFromJSON, preludesFromJSON} from '../createCard';
import {CardName} from '../../common/cards/CardName';
import {LogHelper} from '../LogHelper';
import {Random} from '../../common/utils/Random';
import {ICard} from './ICard';
import {ICorporationCard} from './corporation/ICorporationCard';
import {IProjectCard} from './IProjectCard';
import {inplaceShuffle} from '../utils/shuffle';
import {Logger} from '../logs/Logger';
import {IPreludeCard} from './prelude/IPreludeCard';
import {ICeoCard} from './ceos/ICeoCard';

/**
 * A deck of cards to draw from, and also its discard pile.
 */
export class Deck<T extends ICard> {
  private readonly type;
  public drawPile: Array<T>;
  public discardPile: Array<T>;
  private readonly random: Random;

  // Exposing shuffle so it can be replaced in tests.
  public static shuffle(array: Array<any>, random: Random) {
    inplaceShuffle(array, random);
  }

  protected constructor(type: string, drawPile: Array<T>, discards: Array<T>, random: Random) {
    this.type = type;
    this.drawPile = drawPile;
    this.discardPile = discards;
    this.random = random;
  }

  public shuffle(cardsOnTop: Array<CardName> = []) {
    const copy = [...this.drawPile, ...this.discardPile];
    this.drawPile.splice(0, this.drawPile.length);
    this.discardPile.splice(0, this.discardPile.length);

    if (cardsOnTop.length === 0) {
      Deck.shuffle(copy, this.random);
      this.drawPile.push(...copy);
    } else {
      const set = new Set(cardsOnTop);
      const top: Array<T> = [];
      const rest: Array<T> = [];
      copy.forEach((card) => {
        if (set.has(card.name)) {
          top.push(card);
        } else {
          rest.push(card);
        }
      });
      inplaceShuffle(top, this.random);
      inplaceShuffle(rest, this.random);
      this.drawPile.push(...rest, ...top);
    }
  }

  /**
   * @deprecated use draw or drawOrThrow
   */
  public drawLegacy(logger: Logger, source: 'top' | 'bottom' = 'top'): T {
    return this.drawOrThrow(logger, source);
  }

  public draw(logger: Logger, source: 'top' | 'bottom' = 'top'): T | undefined {
    this.shuffleIfNecessary(logger);
    const card = source === 'top' ? this.drawPile.pop() : this.drawPile.shift();
    this.shuffleIfNecessary(logger);
    return card;
  }

  public drawN(logger: Logger, count: number, source: 'top' | 'bottom' = 'top'): Array<T> {
    const cards: Array<T> = [];
    for (let idx = 0; idx < count; idx++) {
      const card = this.draw(logger, source);
      if (card === undefined) {
        break;
      }
      cards.push(card);
    }
    return cards;
  }

  drawNOrThrow(logger: Logger, count: number): Array<T> {
    const cards: Array<T> = [];
    for (let idx = 0; idx < count; idx++) {
      cards.push(this.drawOrThrow(logger));
    }
    return cards;
  }

  public size(): number {
    return this.drawPile.length + this.discardPile.length;
  }

  public canDraw(count: number): boolean {
    return this.size() >= count;
  }

  private shuffleIfNecessary(logger: Logger) {
    if (this.drawPile.length === 0 && this.discardPile.length !== 0) {
      logger.log(`The ${this.type} discard pile has been shuffled to form a new deck.`);
      this.shuffle();
    }
  }

  public drawOrThrow(logger: Logger, source: 'top' | 'bottom' = 'top'): T {
    const card = this.draw(logger, source);
    if (card === undefined) {
      throw new Error(`Unexpected empty ${this.type} deck`);
    }
    return card;
  }

  public drawByCondition(logger: Logger, total: number, include: (card: T) => boolean) {
    const result: Array<T> = [];
    const discardedCards = new Set<CardName>();

    while (result.length < total) {
      if (discardedCards.size >= this.drawPile.length + this.discardPile.length) {
        logger.log(`discarded every ${this.type} card without a match`);
        break;
      }
      const projectCard = this.drawLegacy(logger);
      if (include(projectCard)) {
        result.push(projectCard);
      } else {
        discardedCards.add(projectCard.name);
        this.discard(projectCard);
      }
    }
    if (discardedCards.size > 0) {
      LogHelper.logDiscardedCards(logger, Array.from(discardedCards));
    }

    return result;
  }

  public discard(...cards: Array<T>): void {
    this.discardPile.push(...cards);
  }

  // For Junk Ventures
  public shuffleDiscardPile(): void {
    Deck.shuffle(this.discardPile, this.random);
  }

  public serialize(): SerializedDeck {
    return {
      drawPile: this.drawPile.map((c) => c.name),
      discardPile: this.discardPile.map((c) => c.name),
    };
  }
}

export class CorporationDeck extends Deck<ICorporationCard> {
  public constructor(deck: Array<ICorporationCard>, discarded: Array<ICorporationCard>, random: Random) {
    super('corporation', deck, discarded, random);
  }

  public static deserialize(d: SerializedDeck, random: Random): Deck<ICorporationCard> {
    const deck = corporationCardsFromJSON(d.drawPile);
    const discarded = corporationCardsFromJSON(d.discardPile);
    return new CorporationDeck(deck, discarded, random);
  }
}

export class ProjectDeck extends Deck<IProjectCard> {
  public constructor(deck: Array<IProjectCard>, discarded: Array<IProjectCard>, random: Random) {
    super('project', deck, discarded, random);
  }

  public static deserialize(d: SerializedDeck, random: Random): Deck<IProjectCard> {
    const deck = cardsFromJSON(d.drawPile);
    const discarded = cardsFromJSON(d.discardPile);
    return new ProjectDeck(deck, discarded, random);
  }
}

const INCOMPATIBLE_PRELUDES = [CardName.BY_ELECTION, CardName.THE_NEW_SPACE_RACE] as const;
export class PreludeDeck extends Deck<IPreludeCard> {
  public constructor(deck: Array<IPreludeCard>, discarded: Array<IPreludeCard>, random: Random) {
    const copy = [...deck];
    const indexes = INCOMPATIBLE_PRELUDES.map((name) => deck.findIndex((c) => c.name === name));
    if (indexes[0] >= 0 && indexes[1] >= 0) {
      // Remove one from the game, randomly
      const target = random.nextInt(2);
      const indexToRemove = indexes[target];
      copy.splice(indexToRemove, 1);
    }

    super('prelude', copy, discarded, random);
  }

  public static deserialize(d: SerializedDeck, random: Random): Deck<IPreludeCard> {
    const deck = preludesFromJSON(d.drawPile);
    const discarded = preludesFromJSON(d.discardPile);
    return new PreludeDeck(deck, discarded, random);
  }
}

export class CeoDeck extends Deck<ICeoCard> {
  public constructor(deck: Array<ICeoCard>, discarded: Array<ICeoCard>, random: Random) {
    super('ceo', deck, discarded, random);
  }

  public static deserialize(d: SerializedDeck, random: Random): Deck<ICeoCard> {
    const deck = ceosFromJSON(d.drawPile);
    const discarded = ceosFromJSON(d.discardPile);
    return new CeoDeck(deck, discarded, random);
  }
}

================
File: cards/ICard.ts
================
import {CardType} from '../../common/cards/CardType';
import {IProjectCard} from './IProjectCard';
import {Space} from '../boards/Space';
import {PlayerInput} from '../PlayerInput';
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';
import {CardResource} from '../../common/CardResource';
import {CardName} from '../../common/cards/CardName';
import {CardMetadata} from '../../common/cards/CardMetadata';
import {GlobalParameter} from '../../common/GlobalParameter';
import {BoardType} from '../boards/BoardType';
import {CardDiscount} from '../../common/cards/Types';
import {IVictoryPoints} from '../../common/cards/IVictoryPoints';
import {TileType} from '../../common/TileType';
import {Behavior} from '../behavior/Behavior';
import {TRSource} from '../../common/cards/TRSource';
import {CardRequirementDescriptor} from '../../common/cards/CardRequirementDescriptor';
import {OneOrArray} from '../../common/utils/types';
import {JSONValue} from '../../common/Types';
import {IStandardProjectCard} from './IStandardProjectCard';
import {Warning} from '../../common/cards/Warning';
import {Resource} from '../../common/Resource';
import {Units} from '../../common/Units';
import {IColony} from '../colonies/IColony';

/*
 * Represents a card which has an action that itself allows a player
 * to replay a card. Those cards can evaluate card playability recursively.
 * which consumes the entire call stack.
 *
 * Cards like that keep track of the number of times they're called as a
 * loop check.
 */
export interface IHasCheckLoops {
  getCheckLoops(): number;
}

export function isIHasCheckLoops(object: any): object is IHasCheckLoops {
  return object.getCheckLoops !== undefined;
}

export interface ICard {
  name: CardName;
  tags: Array<Tag>;
  play(player: IPlayer): PlayerInput | undefined;
  /**
   * Describes the M€ discount `player` could apply to playing `card`.
   *
   * If the discount code is simple, consider using `cardDiscount` instead.
   */
  getCardDiscount?(player: IPlayer, card: IProjectCard): number;
  /**
   * Describes type of discount this card applies to other cards.
   *
   * Achieves the same thing as `getCardDiscount` but for the simplest, most common use cases.
   *
   * Having descriptions this simple also makes it easier to render its discount in the UI.
   */
  cardDiscount?: OneOrArray<CardDiscount>;
  /**
   * Describes the M€ discount `player` could apply to playing `card`.
   */
  getStandardProjectDiscount?(player: IPlayer, card: IStandardProjectCard): number;

  /**
   * The +/- bonus applied to global parameter requirements, e.g. Adaptation Technology.
   *
   * `parameter` describes which global parameter is being tested.
   *
   * NB: Instances of `Card` allow using a JSON object to describe the global parameter bonus,
   * see `globalParameterRequirementBonus` for more information.
   */
  getGlobalParameterRequirementBonus(player: IPlayer, parameter: GlobalParameter): number;
  victoryPoints?: number | 'special' | IVictoryPoints,
  getVictoryPoints(player: IPlayer): number;
  /** Returns any dynamic influence value */
  getInfluenceBonus?: (player: IPlayer) => number;
  /** Called when cards are played. However, if this is a corp, it'll be called when opponents play cards, too. */
  onCardPlayed?(player: IPlayer, card: ICard): PlayerInput | undefined | void;
  onCardPlayedFromAnyPlayer?(thisCardOwner: IPlayer, playedCardOwner: IPlayer, card: IProjectCard): PlayerInput | undefined;
  onStandardProject?(player: IPlayer, project: IStandardProjectCard): void;
  onTilePlaced?(cardOwner: IPlayer, activePlayer: IPlayer, space: Space, boardType: BoardType): void;
  onDiscard?(player: IPlayer): void;
  /**
   * Called when anybody gains TR
   *
   * @param player the player gaining TR
   * @param cardOwner the owner of this card
   * @param steps the number of steps gained
   */
  onIncreaseTerraformRating?(player: IPlayer, cardOwner: IPlayer, steps: number): void;
  onGlobalParameterIncrease?(player: IPlayer, parameter: GlobalParameter, steps: number): void;

  /**
   * Optional callback when a resource is added to this card.
   *
   * @param player the player whose turn it is. Expected to be the player that owns this card.
   * @param playedCard the card that received resources. Can be itself, but
   * for cards like Meat Industry, `playedCard` is the destination card.
   * @param count the number of resources added to `card`
   */
  onResourceAdded?(player: IPlayer, playedCard: ICard, count: number): void;

  /**
   * Optional callback when any player identifies a space.
   *
   * @param identifyingPlayer the player performing the identification action
   *   or undefined if added by a neutral player.
   * @param cardOwner the player who owns THIS CARD.
   * @param space the space that was just identified.
   * @param fromExcavate when true, this identifacation came from excavating an unidentified space.
   */
  onIdentification?(identifyingPlayer: IPlayer | undefined, cardOwner: IPlayer, space: Space, fromExcavate: boolean): void;

  /**
   * Optional callback when any player excavates a space.
   *
   * @param player the player performing the excavation action
   * @param space the space that was just excavated.
   */
  onExcavation?(player: IPlayer, space: Space): void;

  onProductionGain?(player: IPlayer, resource: Resource, amount: number): void;
  onProductionPhase?(player: IPlayer): void;

  /** Optional callback when ANY player adds a colony. */
  onColonyAdded?(player: IPlayer, cardOwner: IPlayer): void;
  /** Optional callback when `player` adds a colony to Leavitt. */
  onColonyAddedToLeavitt?(player: IPlayer): void;

  onTrade?(cardOwner: IPlayer, activePlayer: IPlayer, colony: IColony): void;
  onColonyBuilt?(cardOwner: IPlayer, activePlayer: IPlayer, colony: IColony): void;

  cost?: number; /** Used with IProjectCard and PreludeCard. */
  type: CardType;
  requirements: Array<CardRequirementDescriptor>;
  metadata: CardMetadata;

  /**
   * Per-instance state-specific warnings about this card's action.
   */
  warnings: Set<Warning>;

  behavior?: Behavior,

  /**
   * Returns the contents of the card's production box.
   *
   * Use with Robotic Workforce and Cyberia Systems.
   *
   * Prefer this to `produce` and prefer `behavior` to this.
   */
  productionBox?(player: IPlayer): Units;

  /**
   * Applies the production change for the card's production box.
   *
   * Use with Robotic Workforce and Cyberia Systems.
   * (Special case for Small Open Pit Mine.)
   *
   * Prefer both `productionBox` and `behavior` over this.
   */
  produce?(player: IPlayer): void;

  /** Terraform Rating predicted when this card is played */
  tr?: TRSource;
  /** Terraform Rating predicted when this card is played */
  computeTr?(player: IPlayer): TRSource;

  resourceCount: number;
  resourceType?: CardResource;
  protectedResources?: boolean;
  /** Currently used for The Moon, but can be expanded to encompass other tile-placing cards. */
  tilesBuilt: ReadonlyArray<TileType>;
  isDisabled?: boolean; // For Pharmacy Union and CEO cards.
  /**
   * Extra data that the game will serialize and deserialize along with the card.
   *
   * ONLY store plain JSON data. Classes, objects, functions, will all be incorrectly serialized.
   */
  data?: JSONValue;

  /** The generation the card was activated. Used for Duncan and Underworld cards. */
  // TODO(kberg): move to json?
  generationUsed?: number;
}

export interface IActionCard {
  action(player: IPlayer): PlayerInput | undefined;
  canAct(player: IPlayer): boolean;
}

export function isIActionCard(object: any): object is IActionCard {
  return object !== undefined && object.canAct !== undefined && object.action !== undefined;
}

================
File: cards/ICardFactory.ts
================
import {GameModule} from '../../common/cards/GameModule';
import {OneOrArray} from '../../common/utils/types';
import {asArray} from '../../common/utils/utils';
import {GameOptions} from '../game/GameOptions';

/**
 * Defines conditions for creating a card in a game, including conditions
 * when it will be included in a game.
 */
export type CardFactorySpec<T> = {
  // Creates a new instance of this card.
  Factory: new () => T;
  // Returns the required modules for this card.
  compatibility?: OneOrArray<GameModule>;
  // False when the card should not be instantiated. It's reserved for fake and proxy cards.
  instantiate?: boolean;
  // Used for Turmoil's global events. When true, classifeid as a "negative" global event.
  negative?: boolean;
}

export function isCompatibleWith(cf: CardFactorySpec<any>, gameOptions: GameOptions): boolean {
  if (cf.compatibility === undefined) {
    return true;
  }
  const expansions: Array<GameModule> = asArray(cf.compatibility);
  return expansions.every((expansion) => {
    switch (expansion) {
    case 'corpera':
      return gameOptions.corporateEra;
    case 'venus':
      return gameOptions.venusNextExtension;
    case 'colonies':
      return gameOptions.coloniesExtension;
    case 'turmoil':
      return gameOptions.turmoilExtension;
    case 'prelude':
      return gameOptions.preludeExtension;
    case 'prelude2':
      return gameOptions.prelude2Expansion;
    case 'moon':
      return gameOptions.moonExpansion;
    case 'pathfinders':
      return gameOptions.pathfindersExpansion;
    case 'ares':
      return gameOptions.aresExtension;
    case 'ceo':
      return gameOptions.ceoExtension;
    case 'starwars':
      return gameOptions.starWarsExpansion;
    case 'underworld':
      return gameOptions.underworldExpansion;
    case 'promo':
      return gameOptions.promoCardsOption;
    }
    throw new Error(`Unhandled expansion type ${expansion}`);
  });
}

================
File: cards/IProjectCard.ts
================
import {ICard} from './ICard';
import {CanAffordOptions, IPlayer} from '../IPlayer';
import {Resource} from '../../common/Resource';
import {Units} from '../../common/Units';
import {CardType} from '../../common/cards/CardType';
import {YesAnd} from './requirements/CardRequirement';

export type CanPlayResponse = boolean | YesAnd;

export type PlayableCard = {
  card: IProjectCard,
  details?: CanPlayResponse,
};

export interface IProjectCard extends ICard {
  canPlay(player: IPlayer, canAffordOptions?: CanAffordOptions): CanPlayResponse;
  cost: number;

  /**
   * The bonus resource gained when playing this card. This value is a serialized value.
   *
   * This field serves two purposes.
   * It's used by Robotic Workforce to track production bonuses that are game-specific
   * (Mining Rights, Mining Area, their Ares equivalents, and Pathfinders' Specialized Settlement all apply.)
   *
   * It's also used when rendering the card to indicate which production bonus it might have received, as
   * a visual cue for someone playing Robotic Workforce.
   */
  bonusResource?: Array<Resource>;

  /**
   * Resources held in reserve when paying for a card.
   *
   * Cards that require a unit of steel while playing, for instance.
   * Added for the expansion The Moon, but now used with Local Heat Trapping,
   * the Convert Heat standard action, and other cards.
   */
  reserveUnits?: Units;
}

export function isIProjectCard(card: ICard): card is IProjectCard {
  return card.type === CardType.AUTOMATED ||
    card.type === CardType.ACTIVE ||
    card.type === CardType.EVENT;
}

================
File: cards/IStandardActionCard.ts
================
import {IActionCard, ICard} from './ICard';
import {CardType} from '../../common/cards/CardType';

export interface IStandardActionCard extends ICard, IActionCard {
  type: CardType.STANDARD_ACTION;
}

================
File: cards/IStandardProjectCard.ts
================
import {IActionCard, ICard} from './ICard';
import {CardType} from '../../common/cards/CardType';

export interface IStandardProjectCard extends ICard, IActionCard {
  type: CardType.STANDARD_PROJECT;
  cost: number;
}

================
File: cards/ModuleManifest.ts
================
import {CardName} from '../../common/cards/CardName';
import {GameModule} from '../../common/cards/GameModule';
import {GlobalEventName} from '../../common/turmoil/globalEvents/GlobalEventName';
import {ICorporationCard} from './corporation/ICorporationCard';
import {CardFactorySpec} from './ICardFactory';
import {IProjectCard} from './IProjectCard';
import {ICard} from './ICard';
import {IStandardProjectCard} from './IStandardProjectCard';
import {IStandardActionCard} from './IStandardActionCard';
import {IPreludeCard} from './prelude/IPreludeCard';
import {ICeoCard} from './ceos/ICeoCard';
import {IGlobalEvent} from '../turmoil/globalEvents/IGlobalEvent';

export type CardManifest<T extends ICard> = Partial<Record<CardName, CardFactorySpec<T>>>;
export type GlobalEventManifest = Partial<Record<GlobalEventName, CardFactorySpec<IGlobalEvent>>>;

export namespace CardManifest {
  export function keys<T extends ICard>(manifest: CardManifest<T>): Array<CardName> {
    return Object.keys(manifest) as Array<CardName>;
  }
  export function values<T extends ICard>(manifest: CardManifest<T>): Array<CardFactorySpec<T>> {
    return Object.values(manifest) as Array<CardFactorySpec<T>>;
  }
  export function entries<T extends ICard>(manifest: CardManifest<T>): Array<[CardName, CardFactorySpec<T>]> {
    return keys(manifest).map((key) => {
      const value = manifest[key];
      if (value === undefined) {
        throw new Error(`Manifest has key ${key} but no entry.`);
      }
      return [key, value];
    });
  }
}

export namespace GlobalEventManifest {
  export function keys(manifest: GlobalEventManifest): Array<GlobalEventName> {
    return Object.keys(manifest) as Array<GlobalEventName>;
  }
  export function values(manifest: GlobalEventManifest): Array<CardFactorySpec<IGlobalEvent>> {
    return Object.values(manifest) as Array<CardFactorySpec<IGlobalEvent>>;
  }
  export function entries(manifest: GlobalEventManifest): Array<[GlobalEventName, CardFactorySpec<IGlobalEvent>]> {
    return keys(manifest).map((key) => {
      const value = manifest[key];
      if (value === undefined) {
        throw new Error(`Manifest has key ${key} but no entry.`);
      }
      return [key, value];
    });
  }
}

export class ModuleManifest {
  module: GameModule;
  projectCards : CardManifest<IProjectCard>;
  cardsToRemove: Set<CardName>;
  corporationCards : CardManifest<ICorporationCard>;
  preludeCards : CardManifest<IPreludeCard>;
  ceoCards: CardManifest<ICeoCard>;
  standardProjects : CardManifest<IStandardProjectCard>;
  standardActions : CardManifest<IStandardActionCard>;
  globalEvents: GlobalEventManifest;
  constructor(arg: {
    module: GameModule,
    projectCards?: CardManifest<IProjectCard>,
    cardsToRemove?: Array<CardName>,
    corporationCards?: CardManifest<ICorporationCard>,
    ceoCards?: CardManifest<ICeoCard>,
    preludeCards?: CardManifest<IPreludeCard>,
    standardProjects?: CardManifest<IStandardProjectCard>,
    standardActions?: CardManifest<IStandardActionCard>,
    globalEvents?: GlobalEventManifest,
  }) {
    this.module = arg.module;
    this.projectCards = arg.projectCards || {};
    this.cardsToRemove = new Set(arg.cardsToRemove || []);
    this.corporationCards = arg.corporationCards || {};
    this.preludeCards = arg.preludeCards || {};
    this.ceoCards = arg.ceoCards || {};
    this.standardProjects = arg.standardProjects || {};
    this.standardActions = arg.standardActions || {};
    this.globalEvents = arg.globalEvents || {};
  }
}

================
File: cards/moon/AIControlledMineNetwork.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class AIControlledMineNetwork extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.AI_CONTROLLED_MINE_NETWORK,
      type: CardType.AUTOMATED,
      tags: [Tag.SCIENCE],
      cost: 6,

      behavior: {
        moon: {logisticsRate: 1},
      },

      requirements: {logisticRate: 2},
      metadata: {
        description: 'Requires the logistic rate to be 2 or higher. Raise the logistic rate 1 step',
        cardNumber: 'M32',
        renderData: CardRenderer.builder((b) => {
          b.moonLogisticsRate();
        }),
      },
    });
  }
}

================
File: cards/moon/AlgaeBioreactors.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class AlgaeBioreactors extends Card {
  constructor() {
    super({
      name: CardName.ALGAE_BIOREACTORS,
      type: CardType.AUTOMATED,
      tags: [Tag.PLANT],
      cost: 9,

      behavior: {
        production: {plants: -1},
        global: {oxygen: 1},
        moon: {habitatRate: 1},
      },

      metadata: {
        description: 'Decrease your plant production 1 step. Raise the habitat rate 1 step and oxygen 1%.',
        cardNumber: 'M47',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().plants(1)).moonHabitatRate().oxygen(1);
        }),
      },
    });
  }
}

================
File: cards/moon/AncientShipyards.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all} from '../Options';

export class AncientShipyards extends Card {
  constructor() {
    super({
      name: CardName.ANCIENT_SHIPYARDS,
      type: CardType.ACTIVE,
      tags: [Tag.MOON, Tag.SPACE],
      cost: 6,

      resourceType: CardResource.RESOURCE_CUBE,
      victoryPoints: {resourcesHere: {}, each: -1},
      reserveUnits: {titanium: 3},

      metadata: {
        description: 'Spend 3 titanium. -1 VP for every resource here.',
        cardNumber: 'M19',
        renderData: CardRenderer.builder((b) => {
          b.action('Steal 2 M€ from each player and add a resource cube here.', (eb) => {
            eb.empty().startAction.text('Steal').nbsp.megacredits(2, {all}).asterix().colon().resource(CardResource.RESOURCE_CUBE);
          }).br.br;
          b.minus().titanium(3);
        }),
      },
    });
  }

  public canAct(): boolean {
    return true;
  }

  public action(player: IPlayer) {
    const game = player.game;
    for (const target of player.getOpponents()) {
      target.maybeBlockAttack(player, (proceed) => {
        if (proceed) {
          target.stock.steal(Resource.MEGACREDITS, 2, player);
        }
        return undefined;
      });
    }
    if (game.isSoloMode()) {
      player.stock.add(Resource.MEGACREDITS, 2);
    }
    player.addResourceTo(this, 1);
    return undefined;
  }
}

================
File: cards/moon/AnOfferYouCantRefuse.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Delegate, Turmoil} from '../../turmoil/Turmoil';
import {PartyName} from '../../../common/turmoil/PartyName';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {IGame} from '../../IGame';
import {IParty} from '../../turmoil/parties/IParty';
import {all} from '../Options';
import {message} from '../../logs/MessageBuilder';

export class AnOfferYouCantRefuse extends Card {
  constructor() {
    super({
      name: CardName.AN_OFFER_YOU_CANT_REFUSE,
      type: CardType.EVENT,
      cost: 5,

      metadata: {
        description: 'Exchange a NON-NEUTRAL opponent delegate with one of your own from the reserve. This exchange may not change the party leader. You may then move your delegate to another party.',
        cardNumber: 'M62',
        renderData: CardRenderer.builder((b) => {
          b.minus().delegates(1, {all}).asterix().nbsp.plus().delegates(1);
        }),
      },
    });
  }

  private isReplaceableDelegate(delegate: Delegate, player: IPlayer, party: IParty): delegate is IPlayer {
    if (delegate === player || delegate === 'NEUTRAL') {
      return false;
    }

    // This can't happen. It just appeases the compiler.
    if (party.partyLeader === undefined) {
      return false;
    }

    // If you're the party leader and the delegate isn't neutral, the exchange is OK.
    if (party.partyLeader === player) {
      return true;
    }

    const partyLeaderDelegateCount = party.delegates.get(party.partyLeader);
    const yourDelegateCount = party.delegates.get(player);

    if (delegate !== party.partyLeader) {
      // The only reason you might not replace a non-party leader delegate is if you don't start with
      // the same number of delegates as the party leader.
      return yourDelegateCount < partyLeaderDelegateCount;
    } else {
      // You can't replace a party leader's delegate the party leader doesn't have at least two more delegates. Otherwise
      // you can take the lead.
      if (partyLeaderDelegateCount - yourDelegateCount <= 1) {
        return false;
      }
      // You also can't replace a party leader's delegate if another non-party leader has the same number of delegates as the
      // current party leader. Otherwise that other player's delegate would take the lead.
      for (const m of party.delegates.multiplicities()) {
        if (m[0] === party.partyLeader || m[0] === player) {
          continue;
        }
        if (m[1] === partyLeaderDelegateCount) {
          return false;
        }
      }
      return true;
    }
  }

  // You can play this if you have an available delegate, and if you can swap with a non-neutral delegate without changing the party leader
  public override bespokeCanPlay(player: IPlayer) {
    const turmoil = Turmoil.getTurmoil(player.game);
    if (!turmoil.hasDelegatesInReserve(player)) {
      return false;
    }

    for (const party of turmoil.parties) {
      for (const delegate of party.delegates.keys()) {
        if (this.isReplaceableDelegate(delegate, player, party)) {
          return true;
        }
      }
    }
    return false;
  }

  private moveToAnotherParty(game: IGame, from: PartyName, delegate: IPlayer): OrOptions {
    const orOptions = new OrOptions();
    const turmoil = Turmoil.getTurmoil(game);

    turmoil.parties.forEach((party) => {
      if (party.name === from) {
        orOptions.options.push(new SelectOption('Do not move'));
      } else {
        orOptions.options.push(new SelectOption(party.name).andThen(() => {
          turmoil.removeDelegateFromParty(delegate, from, game);
          turmoil.sendDelegateToParty(delegate, party.name, game);
          return undefined;
        }));
      }
    });

    return orOptions;
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    const turmoil = Turmoil.getTurmoil(game);
    const orOptions = new OrOptions();

    for (const party of turmoil.parties) {
      for (const delegate of party.delegates.keys()) {
        if (!this.isReplaceableDelegate(delegate, player, party)) {
          continue;
        }

        const color = delegate.color;
        const option = new SelectOption(message('${0} / ${1}', (b) => b.party(party).playerColor(color))).andThen(() => {
          turmoil.replaceDelegateFromParty(delegate, player, party.name, game);
          turmoil.checkDominantParty(); // Check dominance right after replacement (replace doesn't check dominance.)
          return this.moveToAnotherParty(game, party.name, player);
        });
        orOptions.options.push(option);
      }
    }
    return orOptions;
  }
}

================
File: cards/moon/ArchimedesHydroponicsStation.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class ArchimedesHydroponicsStation extends Card {
  constructor() {
    super({
      name: CardName.ARCHIMEDES_HYDROPONICS_STATION,
      type: CardType.AUTOMATED,
      tags: [Tag.PLANT],
      cost: 12,

      behavior: {
        production: {energy: -1, megacredits: -1, plants: 2},
      },

      metadata: {
        description: 'Decrease your energy production 1 step and your M€ production 1 step. Increase your plant production 2 steps.',
        cardNumber: 'M27',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().energy(1).megacredits(1).nbsp.plus().plants(2));
        }),
      },
    });
  }
}

================
File: cards/moon/AristarchusRoadNetwork.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class AristarchusRoadNetwork extends Card {
  constructor() {
    super({
      name: CardName.ARISTARCHUS_ROAD_NETWORK,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON],
      cost: 15,
      reserveUnits: {steel: 2},

      behavior: {
        production: {megacredits: 2},
        moon: {
          roadTile: {},
        },
      },

      metadata: {
        description: 'Spend 2 steel. Increase your M€ production 2 steps. ' +
        'Place a road tile on The Moon and raise the Logistics Rate 1 step.',
        cardNumber: 'M10',
        renderData: CardRenderer.builder((b) => {
          b.minus().steel(2).nbsp.production((eb) => eb.megacredits(2)).br;
          b.moonRoad({secondaryTag: AltSecondaryTag.MOON_LOGISTICS_RATE});
        }),
      },
    });
  }
}

================
File: cards/moon/BasicInfrastructure.ts
================
import {CardName} from '../../../common/cards/CardName';
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from '../prelude/PreludeCard';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';

export class BasicInfrastructure extends PreludeCard {
  constructor() {
    super({
      name: CardName.BASIC_INFRASTRUCTURE,
      tags: [Tag.MOON],

      behavior: {
        moon: {roadTile: {}},
        colonies: {addTradeFleet: 1},
      },

      metadata: {
        description: 'Place a road tile on The Moon and raise the Logistics Rate 1 step. Gain 1 trade fleet.',
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.tile(TileType.MOON_ROAD, false).tradeFleet();
        }),
      },
    });
  }
}

================
File: cards/moon/ColonistShuttles.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class ColonistShuttles extends Card {
  constructor() {
    super({
      name: CardName.COLONIST_SHUTTLES,
      type: CardType.AUTOMATED,
      tags: [Tag.SPACE],
      cost: 12,
      reserveUnits: {titanium: 1},

      behavior: {
        moon: {habitatRate: 1},
        stock: {megacredits: {moon: {habitat: {}}, each: 2}},
      },

      metadata: {
        description: 'Spend 1 titanium. Raise the habitat rate 1 step. Gain 2M€ for each habitat tile on The Moon.',
        cardNumber: 'M16',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1).moonHabitatRate().br;
          b.megacredits(2).slash().moonHabitat({size: Size.SMALL, all});
        }),
      },
    });
  }
}

================
File: cards/moon/CopernicusSolarArrays.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class CopernicusSolarArrays extends Card {
  constructor() {
    super({
      name: CardName.COPERNICUS_SOLAR_ARRAYS,
      type: CardType.AUTOMATED,
      tags: [Tag.POWER, Tag.SPACE],
      cost: 8,
      reserveUnits: {titanium: 1},

      behavior: {
        production: {energy: 1},
        stock: {heat: 2},
      },

      metadata: {
        description: 'Spend 1 titanium. Gain 2 heat. Incease your energy production 1 step.',
        cardNumber: 'M44',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1);
          b.br;
          b.heat(2);
          b.br;
          b.production((pb) => pb.energy(1));
        }),
      },
    });
  }
}

================
File: cards/moon/CopernicusTower.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {ActionCard} from '../ActionCard';

export class CopernicusTower extends ActionCard {
  constructor() {
    super({
      name: CardName.COPERNICUS_TOWER,
      type: CardType.ACTIVE,
      tags: [Tag.SCIENCE, Tag.MOON],
      cost: 36,

      resourceType: CardResource.SCIENCE,
      requirements: {production: Resource.TITANIUM, count: 2},
      victoryPoints: {tag: Tag.MOON},

      action: {
        or: {
          autoSelect: true,
          behaviors: [
            {
              spend: {resourcesHere: 1},
              tr: 1,
              title: 'Remove 1 science resource to increase TR 1 step',
            },
            {
              addResources: 1,
              title: 'Add 1 science resource to this card',
            },
          ],
        },
      },

      metadata: {
        cardNumber: 'M72',
        renderData: CardRenderer.builder((b) => {
          b.text('Requires you have 2 titanium production.', Size.TINY, false, false).br;
          b.action('Add 1 science resource here, or spend 1 science resource here to raise your TR 1 step.', (eb) => {
            eb.empty().startAction.resource(CardResource.SCIENCE).nbsp.slash().nbsp.resource(CardResource.SCIENCE).arrow().tr(1);
          });
          b.br;
          b.vpText('1 VP PER MOON TAG YOU HAVE.');
        }),
      },
    });
  }
}

================
File: cards/moon/CoreMine.ts
================
import {CardName} from '../../../common/cards/CardName';
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardRenderer} from '../render/CardRenderer';
import {IProjectCard} from '../IProjectCard';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class CoreMine extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.CORE_MINE,
      tags: [Tag.MOON],

      behavior: {
        production: {titanium: 1},
        moon: {mineTile: {}},
      },

      metadata: {
        description: 'Place a mine tile on The Moon and raise the mining rate 1 step. Increase your titanium production 1 step.',
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).moonMine({secondaryTag: AltSecondaryTag.MOON_MINING_RATE});
        }),
      },
    });
  }
}

================
File: cards/moon/CosmicRadiation.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {message} from '../../logs/MessageBuilder';

export class CosmicRadiation extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.COSMIC_RADIATION,
      type: CardType.EVENT,
      tags: [Tag.MOON],
      cost: 3,

      requirements: {miningRate: 4},
      metadata: {
        description: 'Requires 4 mining rate. All players pay 4M€ for each mining tile they own.',
        cardNumber: 'M52',
        renderData: CardRenderer.builder((b) => {
          b.minus().megacredits(4, {all}).slash().moonMine({size: Size.SMALL, all});
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    const mines = MoonExpansion.spaces(game, TileType.MOON_MINE);
    game.getPlayersInGenerationOrder().forEach((mineTileOwner) => {
      const owned = mines.filter((mine) => mine.player?.id === mineTileOwner.id).length;
      if (owned > 0) {
        const bill = owned * 4;
        const owes = Math.min(bill, mineTileOwner.spendableMegacredits());

        game.defer(new SelectPaymentDeferred(mineTileOwner, owes, {
          title: message('You must spend ${0} M€ for ${1} mining tiles', (b) => b.number(owes).number(owned))}))
          .andThen(() =>
            game.log(
              '${0} spends ${1} M€ for the ${2} mining tiles they own.',
              (b) => b.player(mineTileOwner).number(owes).number(owned)));
      }
    });
    return undefined;
  }
}

================
File: cards/moon/CrescentResearchAssociation.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CorporationCard} from '../corporation/CorporationCard';
import {IProjectCard} from '../IProjectCard';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class CrescentResearchAssociation extends CorporationCard {
  constructor() {
    super({
      name: CardName.CRESCENT_RESEARCH_ASSOCIATION,
      tags: [Tag.SCIENCE, Tag.MOON],
      startingMegaCredits: 50,

      victoryPoints: {tag: Tag.MOON, per: 3},

      metadata: {
        description: 'You start with 50 M€. 1 VP for every 3 Moon tags you have.',
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(50).br;
          b.effect('When you play a Moon tag, you pay 1 M€ less for each Moon tag you have.', (eb) => {
            eb.tag(Tag.MOON).startEffect.megacredits(1).slash().tag(Tag.MOON);
          });
        }),
      },
    });
  }

  public override getCardDiscount(player: IPlayer, card: IProjectCard) {
    if (card.tags.indexOf(Tag.MOON) === -1) {
      return 0;
    }
    return player.tags.count(Tag.MOON);
  }
}

================
File: cards/moon/DarksideIncubationPlant.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {IActionCard} from '../ICard';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {LogHelper} from '../../LogHelper';

export class DarksideIncubationPlant extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      name: CardName.DARKSIDE_INCUBATION_PLANT,
      type: CardType.ACTIVE,
      tags: [Tag.MICROBE, Tag.MOON],
      cost: 11,

      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 2},
      reserveUnits: {titanium: 1},

      metadata: {
        description: {
          text: 'Spend 1 titanium. 1 VP for every 2 microbes here.',
          align: 'left',
        },
        cardNumber: 'M45',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe here.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.action('Spend 2 microbes to raise the habitat rate 1 step.', (eb) => {
            eb.resource(CardResource.MICROBE, 2).startAction.moonHabitatRate();
          });

          b.br;
          b.minus().titanium(1);
        }),
      },
    });
  }

  public canAct() {
    return true;
  }

  private canRaiseHabitatRate(player: IPlayer) {
    return this.resourceCount >= 2 && player.canAfford({cost: 0, tr: {moonHabitat: 1}});
  }

  public action(player: IPlayer) {
    const options = [];
    MoonExpansion.ifMoon(player.game, (moonData) => {
      if (this.canRaiseHabitatRate(player) && moonData.habitatRate < 8) {
        options.push(new SelectOption('Spend 2 microbes to raise the habitat rate 1 step.').andThen(() => {
          player.removeResourceFrom(this, 2);
          LogHelper.logRemoveResource(player, this, 2, 'raise the habitat rate');
          MoonExpansion.raiseHabitatRate(player);
          return undefined;
        }));
      }
    });
    options.push(new SelectOption('Add 1 microbe to this card').andThen(() => {
      player.addResourceTo(this, 1);
      return undefined;
    }));
    if (options.length === 1) {
      return options[0].cb(undefined);
    } else {
      return new OrOptions(...options);
    }
  }
}

================
File: cards/moon/DarksideMeteorBombardment.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class DarksideMeteorBombardment extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.DARKSIDE_METEOR_BOMBARDMENT,
      type: CardType.EVENT,
      tags: [Tag.SPACE],
      cost: 20,

      behavior: {
        stock: {steel: 2, titanium: 2},
        moon: {miningRate: 2},
      },

      metadata: {
        description: 'Gain 2 steel and 2 titanium. Raise the mining rate 2 steps.',
        cardNumber: 'M33',
        renderData: CardRenderer.builder((b) => {
          b.steel(2).titanium(2);
          b.br;
          b.moonMiningRate({amount: 2});
        }),
      },
    });
  }
}

================
File: cards/moon/DarksideMiningSyndicate.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {Resource} from '../../../common/Resource';
import {Card} from '../Card';

export class DarksideMiningSyndicate extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.DARKSIDE_MINING_SYNDICATE,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON, Tag.SPACE],
      cost: 18,
      tr: {moonMining: 1},

      metadata: {
        description: 'Increase your titanium production 2 steps, or ' +
        '1 step if the mining rate is at least 2. And then raise the mining rate 1 step.',
        cardNumber: 'M66',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(2)).or().br;
          b.moonMiningRate({amount: 2}).colon().production((pb) => pb.titanium(1)).br;
          b.moonMiningRate().br;
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const productionBonus = (MoonExpansion.moonData(player.game).miningRate >= 2) ? 1 : 2;
    player.production.add(Resource.TITANIUM, productionBonus, {log: true});
    MoonExpansion.raiseMiningRate(player);
    return undefined;
  }
}

================
File: cards/moon/DarksideObservatory.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {MoonCards} from '../../moon/MoonCards';
import {IActionCard, ICard} from '../ICard';
import {Card} from '../Card';
import {SelectCard} from '../../inputs/SelectCard';

export class DarksideObservatory extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      name: CardName.DARKSIDE_OBSERVATORY,
      type: CardType.ACTIVE,
      tags: [Tag.SCIENCE],
      cost: 12,

      metadata: {
        cardNumber: 'M75',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 science to ANY card [EXCEPT those giving 2 VP or more per science resource.]', (ab) => {
            ab.empty().startAction.resource(CardResource.SCIENCE).asterix();
          }).br;
          b.or().br;
          b.action('Add 2 data to ANY card.', (ab) => {
            ab.empty().startAction.resource(CardResource.DATA, 2).asterix();
          });
        }),
      },
    });
  }

  private include(card: ICard) {
    return card.resourceType === CardResource.DATA || MoonCards.scienceCardsWithLessThan2VP.has(card.name);
  }

  public canAct(player: IPlayer) {
    return player.playedCards.some(this.include) || player.corporations.some(this.include);
  }

  private addResource(card: ICard, player: IPlayer): void {
    if (card.resourceType === CardResource.DATA) {
      player.addResourceTo(card, {qty: 2, log: true});
    }
    if (card.resourceType === CardResource.SCIENCE) {
      player.addResourceTo(card, {qty: 1, log: true});
    }
  }

  public action(player: IPlayer) {
    const playableCards = [
      ...player.playedCards.filter((c) => this.include(c)),
      ...player.corporations.filter((c) => this.include(c)),
    ];

    return new SelectCard(
      'Select card to add EITHER 1 science resource OR 2 Data resources',
      'Add',
      playableCards)
      .andThen(([card]) => {
        this.addResource(card, player);
        return undefined;
      });
  }
}

================
File: cards/moon/DarksideSmugglersUnion.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';
import {IActionCard} from '../ICard';
import {IPlayer} from '../../IPlayer';
import {IColonyTrader} from '../../colonies/IColonyTrader';
import {IColony} from '../../colonies/IColony';
import {ColoniesHandler} from '../../colonies/ColoniesHandler';
import {SelectColony} from '../../inputs/SelectColony';
import {message} from '../../logs/MessageBuilder';

export class DarksideSmugglersUnion extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      name: CardName.DARKSIDE_SMUGGLERS_UNION,
      type: CardType.ACTIVE,
      tags: [Tag.SPACE],
      cost: 17,

      behavior: {
        moon: {logisticsRate: 1},
      },

      metadata: {
        description: 'Raise the logistics rate 1 step.',
        cardNumber: 'M80',
        renderData: CardRenderer.builder((b) => {
          b.action('Perform a trade action.', (ab) => ab.empty().startAction.trade());
          b.br;
          b.moonLogisticsRate();
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.colonies.canTrade();
  }

  public action(player: IPlayer) {
    const tradeableColonies = ColoniesHandler.tradeableColonies(player.game);
    return new SelectColony('Select colony tile to trade with for free', 'Select', tradeableColonies)
      .andThen((colony: IColony) => {
        player.game.log('${0} traded with ${1}', (b) => b.player(player).colony(colony));
        colony.trade(player);
        return undefined;
      });
  }
}

export class TradeWithDarksideSmugglersUnion implements IColonyTrader {
  constructor(private player: IPlayer) {}

  public canUse() {
    return this.player.playedCards.find((card) => card.name === CardName.DARKSIDE_SMUGGLERS_UNION) !== undefined &&
      !this.player.getActionsThisGeneration().has(CardName.DARKSIDE_SMUGGLERS_UNION);
  }

  public optionText() {
    return message('Trade for free (use ${0} action)', (b) => b.cardName(CardName.DARKSIDE_SMUGGLERS_UNION));
  }

  public trade(colony: IColony) {
    this.player.addActionThisGeneration(CardName.DARKSIDE_SMUGGLERS_UNION);
    this.player.game.log('${0} used ${1} action to trade with ${2}', (b) => b.player(this.player).cardName(CardName.DARKSIDE_SMUGGLERS_UNION).colony(colony));
    colony.trade(this.player);
  }
}

================
File: cards/moon/DeepLunarMining.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class DeepLunarMining extends Card {
  constructor() {
    super({
      name: CardName.DEEP_LUNAR_MINING,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON],
      cost: 18,
      reserveUnits: {titanium: 1},

      behavior: {
        production: {titanium: 2},
        moon: {miningRate: 1},
      },

      metadata: {
        description: 'Spend 1 titanium. Increase your titanium production 2 steps. Raise the mining rate 1 step.',
        cardNumber: 'M18',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1).production((pb) => {
            pb.titanium(2);
          }).br;
          b.moonMiningRate();
        }),
      },
    });
  }
}

================
File: cards/moon/EarthEmbassy.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class EarthEmbassy extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.EARTH_EMBASSY,
      type: CardType.ACTIVE,
      tags: [Tag.MOON, Tag.EARTH],
      cost: 16,

      metadata: {
        cardNumber: 'M77',
        renderData: CardRenderer.builder((b) => {
          b.effect('After being played, when you perform an action, your Moon tags count as Earth tags, but not vice versa.', (eb) => {
            eb.empty().startEffect.tag(Tag.MOON).equals().tag(Tag.EARTH);
          });
        }),
      },
    });
  }
}

================
File: cards/moon/FirstLunarSettlement.ts
================
import {CardName} from '../../../common/cards/CardName';
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardRenderer} from '../render/CardRenderer';
import {IProjectCard} from '../IProjectCard';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class FirstLunarSettlement extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.FIRST_LUNAR_SETTLEMENT,
      tags: [Tag.CITY, Tag.MOON],

      behavior: {
        production: {megacredits: 1},
        moon: {habitatTile: {}},
      },

      metadata: {
        description: 'Place a habitat tile on The Moon and raise the habitat rate 1 step. Increase your M€ production 1 step.',
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1)).moonHabitat({secondaryTag: AltSecondaryTag.MOON_HABITAT_RATE});
        }),
      },
    });
  }
}

================
File: cards/moon/GeodesicTents.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class GeodesicTents extends Card {
  constructor() {
    super({
      name: CardName.GEODESIC_TENTS,
      type: CardType.AUTOMATED,
      tags: [Tag.PLANT, Tag.CITY, Tag.MOON],
      cost: 13,
      reserveUnits: {titanium: 1},

      behavior: {
        production: {energy: -1, plants: 1},
        moon: {habitatTile: {}},
      },

      metadata: {
        description: 'Decrease your energy production 1 step and increase your plant production 1 step. ' +
        'Spend 1 titanium. Place a habitat tile on The Moon and raise the habitat rate 1 step.',
        cardNumber: 'M06',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).nbsp.plus().plants(1);
          }).br;
          b.minus().titanium(1).br;
          b.moonHabitat({secondaryTag: AltSecondaryTag.MOON_HABITAT_RATE});
        }),
      },
    });
  }
}

================
File: cards/moon/GrandLunaAcademy.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {digit} from '../Options';

export class GrandLunaAcademy extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.GRAND_LUNA_ACADEMY,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON],
      cost: 13,

      behavior: {
        drawCard: {count: {tag: Tag.MOON, per: 2}},
      },

      metadata: {
        description: 'Draw 1 card per 2 Moon tags you have, including this.',
        cardNumber: 'M83',
        renderData: CardRenderer.builder((b) => {
          b.cards(1).slash().tag(Tag.MOON, {amount: 2, digit});
        }),
      },
    });
  }
}

================
File: cards/moon/Habitat14.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';


export class Habitat14 extends Card {
  constructor() {
    super({
      name: CardName.HABITAT_14,
      type: CardType.AUTOMATED,
      tags: [Tag.CITY, Tag.MOON],
      cost: 5,

      behavior: {
        production: {energy: -1, megacredits: -1},
        moon: {habitatTile: {}},
      },
      reserveUnits: {titanium: 1},

      metadata: {
        description: 'Decrease your energy production 1 step and your M€ production 1 step. Spend 1 titanium. Place a habitat tile on The Moon and raise the habitat rate 1 step.',
        cardNumber: 'M05',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).minus().megacredits(1);
          }).br;
          b.minus().titanium(1).br;
          b.moonHabitat();
        }),
      },
    });
  }
}

================
File: cards/moon/HE3FusionPlant.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all} from '../Options';

export class HE3FusionPlant extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.HE3_FUSION_PLANT,
      type: CardType.AUTOMATED,
      tags: [Tag.POWER, Tag.POWER, Tag.MOON],
      cost: 12,

      behavior: {
        production: {energy: {moon: {mine: {}}}},
      },

      requirements: {miningRate: 2},
      metadata: {
        description: 'Requires the mining rate of 2 or higher. ' +
            'Increase your energy production 1 step for each mining tile on The Moon.',
        cardNumber: 'M48',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1)).slash().moonMine({all});
        }),
      },
    });
  }
}

================
File: cards/moon/HE3Lobbyists.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class HE3Lobbyists extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.HE3_LOBBYISTS,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON],
      cost: 7,

      behavior: {
        production: {megacredits: {tag: Tag.MOON}},
      },

      metadata: {
        description: 'Increase your M€ production 1 step for each Moon tag you have (including this).',
        cardNumber: 'M50',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1)).slash().tag(Tag.MOON);
        }),
      },
    });
  }
}

================
File: cards/moon/HE3ProductionQuotas.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {PartyName} from '../../../common/turmoil/PartyName';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {TileType} from '../../../common/TileType';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';
import {Resource} from '../../../common/Resource';

export class HE3ProductionQuotas extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.HE3_PRODUCTION_QUOTAS,
      type: CardType.EVENT,
      tags: [Tag.MOON],
      cost: 10,

      behavior: {
        moon: {miningRate: 1},
      },

      requirements: [{party: PartyName.KELVINISTS}, {miningTiles: 1, all}],
      metadata: {
        description: 'Requires that Kelvinists are ruling or that you have 2 delegates there, and 1 mine tile on The Moon. ' +
        'Pay 1 steel per mine tile on The Moon to gain 4 heat per mine tile on The Moon. Raise the mining rate 1 step.',
        cardNumber: 'M57',
        renderData: CardRenderer.builder((b) => {
          b.minus().steel(1).slash().moonMine({size: Size.SMALL, all})
            .colon().text('4').heat(1).slash().moonMine({size: Size.SMALL, all}).br;
          b.moonMiningRate();
        }),
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    const moonTiles = MoonExpansion.spaces(player.game, TileType.MOON_MINE, {surfaceOnly: true});
    if (player.steel < moonTiles.length) {
      return false;
    }
    return true;
  }

  public override bespokePlay(player: IPlayer) {
    const moonTiles = MoonExpansion.spaces(player.game, TileType.MOON_MINE, {surfaceOnly: true});
    const steelSpent = moonTiles.length;
    const heatGained = moonTiles.length * 4;
    player.stock.deduct(Resource.STEEL, steelSpent);
    player.heat += heatGained;
    player.game.log('Player spent ${0} steel and gained ${1} heat', (b) => b.number(steelSpent).number(heatGained));
    return undefined;
  }
}

================
File: cards/moon/HE3Refinery.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class HE3Refinery extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.HE3_REFINERY,
      cost: 8,
      tags: [Tag.MOON],

      action: {
        stock: {megacredits: {moon: {miningRate: {}}}},
      },

      metadata: {
        cardNumber: 'M49',
        renderData: CardRenderer.builder((b) => {
          b.action('Gain 1 M€ for each level of mining rate.', (eb) => {
            eb.empty().startAction;
            eb.megacredits(1).slash().moonMiningRate();
          });
        }),
      },
    });
  }
}

================
File: cards/moon/HeavyDutyRovers.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {Card} from '../Card';
import {Resource} from '../../../common/Resource';
import {all} from '../Options';

export class HeavyDutyRovers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HEAVY_DUTY_ROVERS,
      cost: 12,

      behavior: {
        moon: {logisticsRate: 1},
      },

      metadata: {
        description: 'Gain 4 M€ for each mining tile adjacent to a road tile. Raise the logistic rate 1 step.',
        cardNumber: 'M39',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(4).slash().moonRoad({size: Size.SMALL, all})
            .moonMine({size: Size.SMALL, all});
          b.br;
          b.moonLogisticsRate({size: Size.SMALL});
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    MoonExpansion.ifMoon(player.game, (moonData) => {
      const mines = MoonExpansion.spaces(player.game, TileType.MOON_MINE);
      const minesNextToRoads = mines.filter((mine) => {
        const spacesNextToMine = moonData.moon.getAdjacentSpaces(mine);
        const firstRoad = spacesNextToMine.find((s) => MoonExpansion.spaceHasType(s, TileType.MOON_ROAD));
        return firstRoad !== undefined;
      });
      const count = minesNextToRoads.length;
      player.stock.add(Resource.MEGACREDITS, count * 4, {log: true});
    });
    return undefined;
  }
}

================
File: cards/moon/HeliostatMirrorArray.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class HeliostatMirrorArray extends Card {
  constructor() {
    super({
      cost: 10,
      tags: [Tag.POWER],
      type: CardType.AUTOMATED,
      name: CardName.HELIOSTAT_MIRROR_ARRAY,

      behavior: {
        production: {energy: 2},
        stock: {heat: 1},
      },
      reserveUnits: {titanium: 1},

      metadata: {
        description: 'Spend 1 titanium. Gain 1 heat. Increase your energy production 2 steps.',
        cardNumber: 'M41',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1).heat(1);
          b.br;
          b.production((pb) => pb.energy(2));
        }),
      },
    });
  }
}

================
File: cards/moon/HostileTakeover.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {TileType} from '../../../common/TileType';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Space} from '../../boards/Space';

export class HostileTakeover extends Card {
  constructor() {
    super({
      name: CardName.HOSTILE_TAKEOVER,
      type: CardType.EVENT,
      tags: [Tag.CITY, Tag.MOON],
      cost: 26,
      requirements: [{habitatRate: 2}, {miningRate: 4}],

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'M64',
        renderData: CardRenderer.builder((b) => {
          b.moonHabitat().asterix().moonMine().asterix().production((pb) => pb.megacredits(2));
        }),
        description: 'Requires a habitat rate of 2 or higher, and a mining rate of 4 or higher. ' +
          'Add your player marker to a habitat tile and a mining tile owned by any opponent. ' +
          'Those now also count as yours. Increase your M€ production 2 steps.',
      },
    });
  }

  private availableSpaces(player: IPlayer, type: TileType) {
    return MoonExpansion.spaces(player.game, type, {upgradedTiles: false})
      .filter((space) => space.player !== player && space.coOwner === undefined);
  }
  public override bespokeCanPlay(player: IPlayer) {
    const habitatSpaces = this.availableSpaces(player, TileType.MOON_HABITAT);
    const mineSpaces = this.availableSpaces(player, TileType.MOON_MINE);
    const lunarMineUrbanizationSpaces = this.availableSpaces(player, TileType.LUNAR_MINE_URBANIZATION);
    // TODO(kberg): warn if Lunar Mine Urbanization is one of the few eligibile cards.
    if (habitatSpaces.length > 0 && mineSpaces.length > 0) {
      return true;
    }
    if (habitatSpaces.length + mineSpaces.length > 0 && lunarMineUrbanizationSpaces.length > 0) {
      return true;
    }
    return false;
  }

  public override bespokePlay(player: IPlayer) {
    const habitatSpaces = this.availableSpaces(player, TileType.MOON_HABITAT);
    const mineSpaces = this.availableSpaces(player, TileType.MOON_MINE);

    // It is expected that Lunar Mine Urbanization cannot be played twice.
    let lunarMineUrbanizationSpace: Space | undefined = this.availableSpaces(player, TileType.LUNAR_MINE_URBANIZATION)[0];

    if (lunarMineUrbanizationSpace !== undefined) {
      if (mineSpaces.length === 0) {
        mineSpaces.push(lunarMineUrbanizationSpace);
        lunarMineUrbanizationSpace = undefined;
      } else {
        habitatSpaces.push(lunarMineUrbanizationSpace);
      }
    }

    return new SelectSpace('Select a habitat space to co-own', habitatSpaces).andThen((space) => {
      space.coOwner = player;
      if (space.id === lunarMineUrbanizationSpace?.id) {
        lunarMineUrbanizationSpace = undefined;
      } else {
        if (lunarMineUrbanizationSpace !== undefined) {
          mineSpaces.push(lunarMineUrbanizationSpace);
        }
      }
      return new SelectSpace('Select a mining space to co-own', mineSpaces).andThen((space) => {
        space.coOwner = player;
        return undefined;
      });
    });
  }
}

================
File: cards/moon/HypersensitiveSiliconChipFactory.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all} from '../Options';

export class HypersensitiveSiliconChipFactory extends Card {
  constructor() {
    super({
      name: CardName.HYPERSENSITIVE_SILICON_CHIP_FACTORY,
      type: CardType.AUTOMATED,
      tags: [Tag.BUILDING],
      cost: 11,

      behavior: {
        production: {megacredits: 4},
      },
      requirements: {miningTiles: 2, all},
      reserveUnits: {titanium: 2},

      metadata: {
        description: 'Requires 2 mining tiles on The Moon. Spend 2 titanium. Increase your M€ production 4 steps.',
        cardNumber: 'M43',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(2).nbsp;
          b.production((pb) => pb.megacredits(4)).br;
        }),
      },
    });
  }
}

================
File: cards/moon/ImprovedMoonConcrete.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class ImprovedMoonConcrete extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.IMPROVED_MOON_CONCRETE,
      type: CardType.ACTIVE,
      tags: [Tag.MOON],
      cost: 12,
      reserveUnits: {steel: 2},

      behavior: {
        moon: {miningRate: 1},
      },

      metadata: {
        description: 'Spend 2 steel. Raise the mining rate 1 step.',
        cardNumber: 'M37',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you build a mine on The Moon, you spend 1 titanium less.', (eb) => {
            eb.moonMine().startEffect.minus().titanium(1);
          }).br;
          b.minus().steel(2).moonMiningRate();
        }),
      },
    });
  }
}

================
File: cards/moon/IntragenSanctuaryHeadquarters.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {ICorporationCard} from '../corporation/ICorporationCard';
import {CorporationCard} from '../corporation/CorporationCard';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {all} from '../Options';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {ICard} from '../ICard';

export class IntragenSanctuaryHeadquarters extends CorporationCard {
  constructor() {
    super({
      name: CardName.INTRAGEN_SANCTUARY_HEADQUARTERS,
      tags: [Tag.ANIMAL, Tag.MOON],
      startingMegaCredits: 38,
      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},

      behavior: {
        // Gains the initial resource from its own tag.
        addResources: 1,
      },

      firstAction: {
        text: 'Place a habitat tile on The Moon.',
        moon: {habitatTile: {}},
      },

      metadata: {
        description: 'You start with 38 M€. ' +
        'As your first action, place a habitat tile on The Moon and raise the habitat rate 1 step. 1 VP for every 2 animals on this card.',
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(38).moonHabitat({secondaryTag: AltSecondaryTag.MOON_HABITAT_RATE}).br;
          b.effect('When any player plays an animal tag (including this), add 1 animal on this card.', (eb) => {
            eb.tag(Tag.ANIMAL, {all}).startEffect.resource(CardResource.ANIMAL);
          }).br;
        }),
      },
    });
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    this.onCardPlayed(player, card);
  }

  public onCardPlayed(player: IPlayer, card: ICard) {
    const count = player.tags.cardTagCount(card, Tag.ANIMAL);
    player.addResourceTo(this, {qty: count, log: true});
  }
}

================
File: cards/moon/IronExtractionCenter.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class IronExtractionCenter extends Card {
  constructor() {
    super({
      name: CardName.IRON_EXTRACTION_CENTER,
      type: CardType.AUTOMATED,
      tags: [Tag.BUILDING],
      cost: 10,
      reserveUnits: {titanium: 1},

      behavior: {
        production: {steel: {moon: {miningRate: {}}, per: 2}},
      },

      metadata: {
        description: 'Spend 1 titanium. Increase your steel production 1 step for every 2 raised steps of mining rate.',
        cardNumber: 'M25',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1).br;
          b.production((pb) => pb.steel(1)).slash().moonMiningRate({amount: 2});
        }),
      },
    });
  }
}

================
File: cards/moon/LTFHeadquarters.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class LTFHeadquarters extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LTF_HEADQUARTERS,
      type: CardType.AUTOMATED,
      tags: [Tag.SPACE],
      cost: 31,

      behavior: {
        moon: {habitatRate: 1},
        colonies: {
          buildColony: {},
          addTradeFleet: 1,
        },
      },

      metadata: {
        description: 'Raise the habitat rate 1 step. Place a colony. Gain 1 Trade Fleet.',
        cardNumber: 'M79',
        renderData: CardRenderer.builder((b) => {
          b.moonHabitatRate().colonies(1).tradeFleet();
        }),
      },
    });
  }
}

================
File: cards/moon/LTFPrivileges.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class LTFPrivileges extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LTF_PRIVILEGES,
      type: CardType.ACTIVE,
      tags: [Tag.MOON],
      cost: 21,

      metadata: {
        cardNumber: 'M82',
        renderData: CardRenderer.builder((b) => {
          b.effect('When playing a Moon tag, you do not pay additional steel or titanium for playing it.',
            (eb) => {
              eb.tag(Tag.MOON).startEffect.text('0').steel(1).nbsp.text('0').titanium(1);
            });
        }),
      },
    });
  }
}

================
File: cards/moon/LunaArchives.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';
import {CardResource} from '../../../common/CardResource';
import {IActionCard} from '../ICard';

export class LunaArchives extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.LUNA_ARCHIVES,
      type: CardType.ACTIVE,
      tags: [Tag.SCIENCE, Tag.MOON],
      cost: 13,
      resourceType: CardResource.SCIENCE,

      action: {
        addResources: {tag: Tag.MOON},
      },

      metadata: {
        cardNumber: 'M69',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 science resource here for each Moon tag you have.',
            (ab) => ab.empty().startAction.resource(CardResource.SCIENCE).slash().tag(Tag.MOON));
          b.br;
          b.effect('When playing a Moon tag, science resources here may be used as payment, and are worth 1M€ each.',
            (eb) => eb.tag(Tag.MOON).startEffect.resource(CardResource.SCIENCE).equals().megacredits(1));
        }),
      },
    });
  }
}

================
File: cards/moon/LunaConference.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {PartyName} from '../../../common/turmoil/PartyName';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class LunaConference extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNA_CONFERENCE,
      type: CardType.EVENT,
      tags: [Tag.SCIENCE, Tag.MOON],
      cost: 5,
      requirements: {party: PartyName.SCIENTISTS},

      behavior: {
        stock: {megacredits: {moon: {road: {}, habitat: {}}, each: 2}},
      },

      metadata: {
        description: 'Requires that Scientists are ruling or that you have 2 delegates there. ' +
        'Gain 2 M€ per road tile on The Moon. Gain 2M€ per habitat tile on The Moon.',
        cardNumber: 'M58',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(2).slash().moonRoad({size: Size.SMALL, all}).br;
          b.megacredits(2).slash().moonHabitat({size: Size.SMALL, all}).br;
        }),
      },
    });
  }
}

================
File: cards/moon/LunaEcumenopolis.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {Card} from '../Card';
import {TileType} from '../../../common/TileType';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {PlaceMoonHabitatTile} from '../../moon/PlaceMoonHabitatTile';
import {Space} from '../../boards/Space';
import {MoonData} from '../../moon/MoonData';

export class LunaEcumenopolis extends Card {
  constructor() {
    super({
      name: CardName.LUNA_ECUMENOPOLIS,
      type: CardType.AUTOMATED,
      tags: [Tag.CITY, Tag.CITY, Tag.MOON],
      cost: 35,
      reserveUnits: {titanium: 2},

      metadata: {
        cardNumber: 'M84',
        hasExternalHelp: true,
        description: 'Spend 2 titanium. ' +
        'Place 2 habitat tiles adjacent to at least 2 other habitat tiles and raise habitat rate 2 steps. ' +
        'Increase your TR 1 step for each 2 steps of the habitat rate.',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(2).nbsp;
          b.text('2').moonHabitat({secondaryTag: AltSecondaryTag.MOON_HABITAT_RATE}).asterix().br;
          b.tr(1).slash().moonHabitatRate().moonHabitatRate();
        }),
      },
      tilesBuilt: [TileType.MOON_HABITAT, TileType.MOON_HABITAT],
    });
  }

  private canAffordTRBump(player: IPlayer) {
    // Note for someone paying close attention:
    //
    // In the real world, this card can be resolved in one of two orders:
    // 1. Raise the TR rate before raising the habitat rate
    // 2. Raise the habitat rate before the TR rate.
    // In the first case, the player will get fewer TR, but also is more likely to afford the costs.
    // In the second case, the player will get the most TR, but will have to pay up to 3 more MC, the cost
    // of that additional TR bump.
    //
    // This algorithm assumes the second case.
    //
    // If someone wants to optimize for this, they can change this algorithm to use the current habitat rate instead
    // of the expected habitat rate, but then they must also change the order in which the player gains those bonuses
    // in play().
    //
    const moonData = MoonExpansion.moonData(player.game);
    const expectedHabitatRate = Math.min(moonData.habitatRate + 2, 8);
    const expectedTRBump = Math.floor(expectedHabitatRate / 2);
    return player.canAfford({cost: 0, tr: {moonHabitat: 2, tr: expectedTRBump}});
  }

  public override bespokeCanPlay(player: IPlayer) {
    if (!this.canAffordTRBump(player)) {
      return false;
    }

    const moonData = MoonExpansion.moonData(player.game);
    const spaces = moonData.moon.getAvailableSpacesOnLand(player);
    const len = spaces.length;

    let firstSpaceId = '';

    // This function returns true when this space is next to two colonies. Don't try to understand firstSpaceId yet.
    const nextToTwoColonies = function(space: Space): boolean {
      const adjacentSpaces = moonData.moon.getAdjacentSpaces(space).filter((adjacentSpace) => {
        return MoonExpansion.spaceHasType(adjacentSpace, TileType.MOON_HABITAT) || adjacentSpace.id === firstSpaceId;
      });
      return adjacentSpaces.length >= 2;
    };

    // Go through every available land space.
    for (let x = 0; x < len; x++) {
      const first = spaces[x];
      // If it's next to two colonies
      if (nextToTwoColonies(first) === true) {
        // Remember it.
        firstSpaceId = first.id;
        // Now go through all the land spaces again
        for (let y = 0; y < len; y++) {
          const second = spaces[y];
          if (second.id === firstSpaceId) continue;
          // Now if it's next to two colonies, it includes the first colony you placed. That's what firstSpaceId is for.
          if (nextToTwoColonies(second) === true) {
            return true;
          }
        }
      }
    }
    return false;
  }

  public override bespokePlay(player: IPlayer) {
    // These all have the same priority: Default.
    player.game.defer(new CustomPlaceMoonTile(player));
    player.game.defer(new CustomPlaceMoonTile(player));
    player.defer(() => {
      const habitatRate = MoonExpansion.moonData(player.game).habitatRate;
      player.increaseTerraformRating(Math.floor(habitatRate / 2));
    });
    return undefined;
  }
}

class CustomPlaceMoonTile extends PlaceMoonHabitatTile {
  protected override getSpaces(moonData: MoonData) {
    const spaces = moonData.moon.getAvailableSpacesOnLand(this.player);
    const filtered = spaces.filter((space) => {
      const adjacentSpaces = moonData.moon.getAdjacentSpaces(space).filter((adjacentSpace) => {
        return MoonExpansion.spaceHasType(adjacentSpace, TileType.MOON_HABITAT);
      });
      return adjacentSpaces.length >= 2;
    });
    return filtered;
  }
}

================
File: cards/moon/LunaFirstIncorporated.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CorporationCard} from '../corporation/CorporationCard';
import {CardRenderer} from '../render/CardRenderer';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class LunaFirstIncorporated extends CorporationCard {
  constructor() {
    super({
      name: CardName.LUNA_FIRST_INCORPORATED,
      tags: [Tag.MOON],
      startingMegaCredits: 40,

      behavior: {
        // stock: {steel: 2, titanium: 2},
        stock: {steel: 1, titanium: 1},
      },

      metadata: {
        // description: 'You start with 40 M€, 2 steel, and 2 titanium.',
        description: 'You start with 40 M€, 1 steel, and 1 titanium.',
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          // b.megacredits(40).steel(2).titanium(2).br;
          b.megacredits(40).steel(1).titanium(1).br;
          b.effect('When you raise any Moon Rate, increase your M€ production 1 step per step.', (eb) => {
            eb.moonHabitatRate({size: Size.SMALL}).slash()
              .moonMiningRate({size: Size.SMALL}).slash()
              .moonLogisticsRate({size: Size.SMALL})
              .startEffect.production((pb) => pb.megacredits(1));
          }).br,
          b.effect('When any player raises any Moon Rate, gain 1M€ per step.', (eb) => {
            eb.moonHabitatRate({size: Size.SMALL, all}).slash()
              .moonMiningRate({size: Size.SMALL, all}).slash()
              .moonLogisticsRate({size: Size.SMALL, all})
              .startEffect.megacredits(1);
          }).br;
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    MoonExpansion.moonData(player.game).lunaFirstPlayer = player;
    return undefined;
  }
}

================
File: cards/moon/LunaHyperloopCorporation.ts
================
import {CardName} from '../../../common/cards/CardName';
import {all} from '../Options';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {ActiveCorporationCard} from '../corporation/CorporationCard';

export class LunaHyperloopCorporation extends ActiveCorporationCard {
  constructor() {
    super({
      name: CardName.LUNA_HYPERLOOP_CORPORATION,
      tags: [Tag.MOON, Tag.BUILDING],
      startingMegaCredits: 38,

      behavior: {
        stock: {steel: 4},
      },

      action: {
        stock: {megacredits: {moon: {road: {}}, all}},
      },

      victoryPoints: {moon: {road: {}}, all},

      metadata: {
        description: 'You start with 38 M€ and 4 steel.',
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(38).steel(4).br;
          b.action('Gain 1 M€ for each road tile on The Moon.', (eb) => {
            eb.empty().startAction.megacredits(1).slash().moonRoad({all});
          }).br,
          b.vpText('1 VP for each road tile on The Moon.').br;
        }),
      },
    });
  }
}

================
File: cards/moon/LunaMiningHub.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {TileType} from '../../../common/TileType';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';

export class LunaMiningHub extends Card {
  constructor() {
    super({
      name: CardName.LUNA_MINING_HUB,
      type: CardType.AUTOMATED,
      tags: [Tag.BUILDING],
      cost: 23,
      reserveUnits: {steel: 1, titanium: 1},

      behavior: {
        production: {steel: 1, titanium: 1},
        // TODO(kberg): mining rate ought to occur after tile is placed.
        moon: {
          tile: {type: TileType.LUNA_MINING_HUB},
          miningRate: 1,
        },
      },

      victoryPoints: 'special',
      requirements: {miningRate: 5},

      metadata: {
        cardNumber: 'M14',
        description: {
          text: '2 VP PER MINING TILE ADJACENT TO THIS TILE.',
          align: 'left',
        },
        renderData: CardRenderer.builder((b) => {
          b.text('Requires a mining rate of 5 or higher.', Size.TINY, false, false).br;
          b.minus().steel(1).minus().titanium(1).production((pb) => pb.steel(1).titanium(1)).br;
          b.text('Spend 1 steel and 1 titanium and raise your steel and titanium production 1 step.', Size.TINY, false, false).br;
          b.tile(TileType.LUNA_MINING_HUB, true).moonMiningRate({size: Size.SMALL});
          b.text('Place this tile on The Moon and raise the mining rate 1 step.', Size.TINY, false, false);
        }),
        victoryPoints: CardRenderDynamicVictoryPoints.moonMiningTile(2, true),
      },
    });
  }

  public override getVictoryPoints(player: IPlayer) {
    const moonData = MoonExpansion.moonData(player.game);
    const usedSpace = moonData.moon.getSpaceByTileCard(this.name);
    if (usedSpace !== undefined) {
      const adjacentSpaces = moonData.moon.getAdjacentSpaces(usedSpace);
      const adjacentMines = adjacentSpaces.filter((s) => MoonExpansion.spaceHasType(s, TileType.MOON_MINE));
      return 2 * adjacentMines.length;
    }
    return 0;
  }
}

================
File: cards/moon/LunaPoliticalInstitute.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class LunaPoliticalInstitute extends ActionCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNA_POLITICAL_INSTITUTE,
      type: CardType.ACTIVE,
      tags: [Tag.MOON, Tag.EARTH],
      cost: 6,
      requirements: {tag: Tag.MOON, count: 2},

      action: {
        turmoil: {
          sendDelegates: {count: 1},
        },
      },

      metadata: {
        description: 'Requires that you have 2 Moon tags.',
        cardNumber: 'M71',
        renderData: CardRenderer.builder((b) => {
          b.action(
            'Place one of your delegates in any party.',
            (eb) => eb.empty().startAction.delegates(1));
        }),
      },
    });
  }
}

================
File: cards/moon/LunaProjectOffice.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';

export class LunaProjectOffice extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNA_PROJECT_OFFICE,
      type: CardType.AUTOMATED,
      tags: [Tag.SCIENCE],
      cost: 4,
      requirements: {tag: Tag.SCIENCE, count: 2},

      metadata: {
        description: 'Requires 2 science tags.',
        cardNumber: 'M20',
        renderData: CardRenderer.builder((b) => {
          b.text('DRAW 5 CARDS DURING THE RESEARCH PHASE FOR THE NEXT 2 GENERATIONS.', Size.MEDIUM, true);
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    MoonExpansion.moonData(player.game).lunaProjectOfficeLastGeneration = player.game.generation + 2;
    return undefined;
  }

  // Returns true when the current player has played Luna Project Office and the card is still valid
  public static isActive(player: IPlayer): boolean {
    return MoonExpansion.ifElseMoon(player.game, (moonData) => {
      if (!player.cardIsInEffect(CardName.LUNA_PROJECT_OFFICE)) {
        return false;
      }
      return player.game.generation <= (moonData.lunaProjectOfficeLastGeneration ?? -1);
    }, () => false);
  }
}

================
File: cards/moon/LunarDustProcessingPlant.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {TileType} from '../../../common/TileType';
import {Card} from '../Card';

export class LunarDustProcessingPlant extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNAR_DUST_PROCESSING_PLANT,
      type: CardType.ACTIVE,
      tags: [Tag.BUILDING],
      cost: 6,
      reserveUnits: {titanium: 1},

      behavior: {
        moon: {logisticsRate: 1},
      },

      metadata: {
        description: 'Spend 1 titanium. Raise the logistic rate 1 step.',
        cardNumber: 'M17',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you place a road tile on The Moon, you spend no steel on it.', (eb) => {
            eb.startEffect.tile(TileType.MOON_ROAD, false).colon().text('0').steel(1);
          }).br;
          b.minus().titanium(1).moonLogisticsRate();
        }),
      },
    });
  }
}

================
File: cards/moon/LunaResort.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all} from '../Options';

export class LunaResort extends Card {
  constructor() {
    super({
      name: CardName.LUNA_RESORT,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON],
      cost: 11,
      reserveUnits: {titanium: 2},

      behavior: {
        production: {energy: -1, megacredits: 3},
        moon: {habitatRate: 1},
      },

      requirements: {habitatTiles: 2, all},
      metadata: {
        description:
          'Requires 2 habitats on The Moon. Spend 2 titanium. Decrease your energy production 1 step and increase your M€ production 3 steps. Raise the habitat rate 1 step.',
        cardNumber: 'M21',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(2).production((pb) => {
            pb.minus().energy(1).nbsp.plus().megacredits(3);
          }).br;
          b.moonHabitatRate();
        }),
      },
    });
  }
}

================
File: cards/moon/LunarIndustryComplex.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class LunarIndustryComplex extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNAR_INDUSTRY_COMPLEX,
      type: CardType.AUTOMATED,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 28,

      behavior: {
        production: {steel: 1, titanium: 1, energy: 2, heat: 1},
        moon: {mineTile: {}},
      },
      reserveUnits: {titanium: 2},

      metadata: {
        description: 'Spend 2 titanium. Place a mine tile on The Moon and raise the mining rate 1 step. ' +
          'Increase your steel, titanium, and heat production 1 step each. Increase your energy production 2 steps.',
        cardNumber: 'M74',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(2).moonMine({secondaryTag: AltSecondaryTag.MOON_MINING_RATE}).br;
          b.production((pb) => pb.steel(1).titanium(1).heat(1).energy(2));
        }),
      },
    });
  }
}

================
File: cards/moon/LunarMineUrbanization.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {TileType} from '../../../common/TileType';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Card} from '../Card';

export class LunarMineUrbanization extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNAR_MINE_URBANIZATION,
      type: CardType.EVENT,
      tags: [Tag.MOON, Tag.BUILDING],
      cost: 8,

      behavior: {
        production: {megacredits: 1},
      },
      requirements: {miningTiles: 1},
      tr: {moonHabitat: 1},

      metadata: {
        description: 'Requires you have 1 mine tile. Increase your M€ production 1 step. Raise the habitat rate 1 step. ' +
        'Remove 1 of your mine tiles (does not affect the mining rate.) ' +
        'Place this special tile there, regardless of placement rules. ' +
        'Gain placement bonuses as usual. This tile counts both as a habitat and a mine tile.',

        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1));
          b.moonHabitatRate();
          b.tile(TileType.LUNAR_MINE_URBANIZATION, true).asterix();
        }),
      },
      tilesBuilt: [TileType.LUNAR_MINE_URBANIZATION],
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return MoonExpansion.spaces(player.game, TileType.MOON_MINE, {ownedBy: player, upgradedTiles: false}).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    const spaces = MoonExpansion.spaces(player.game, TileType.MOON_MINE, {ownedBy: player, upgradedTiles: false});
    return new SelectSpace('Select one of your mines to upgrade', spaces)
      .andThen((space) => {
        if (space.tile === undefined) {
          throw new Error(`Space ${space.id} should have a tile, how doesn't it?`);
        }
        space.tile = undefined;
        space.player = undefined;
        MoonExpansion.addTile(player, space.id, {tileType: TileType.LUNAR_MINE_URBANIZATION, card: this.name});
        MoonExpansion.raiseHabitatRate(player);
        return undefined;
      });
  }
}

================
File: cards/moon/LunarObservationPost.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class LunarObservationPost extends ActionCard {
  constructor() {
    super({
      name: CardName.LUNAR_OBSERVATION_POST,
      type: CardType.ACTIVE,
      tags: [Tag.SCIENCE, Tag.SCIENCE],
      cost: 7,

      resourceType: CardResource.DATA,
      victoryPoints: {resourcesHere: {}, per: 3},
      reserveUnits: {titanium: 1},

      action: {
        addResourcesToAnyCard: {type: CardResource.DATA, count: 1},
      },

      metadata: {
        description: 'Spend 1 titanium. 1 VP for every 3 data resources here.',
        cardNumber: 'M22',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 data resource to ANY card', (ab) => {
            ab.empty().startAction.resource(CardResource.DATA).asterix();
          });
          b.br;
          b.minus().titanium(1);
        }),
      },
    });
  }
}

================
File: cards/moon/LunarPlanningOffice.ts
================
import {CardName} from '../../../common/cards/CardName';
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardRenderer} from '../render/CardRenderer';
import {IProjectCard} from '../IProjectCard';

export class LunarPlanningOffice extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNAR_PlANNING_OFFICE,
      tags: [Tag.MOON, Tag.BUILDING],

      behavior: {
        stock: {steel: 6},
        drawCard: {tag: Tag.MOON, count: 2},
      },

      metadata: {
        description: 'Draw 2 cards with a Moon tag. Gain 6 steel.',
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.cards(2, {secondaryTag: Tag.MOON}).br.steel(6);
        }),
      },
    });
  }
}

================
File: cards/moon/LunarSecurityStations.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {all} from '../Options';

export class LunarSecurityStations extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNAR_SECURITY_STATIONS,
      type: CardType.ACTIVE,
      tags: [Tag.MOON],
      cost: 9,
      requirements: {roadTiles: 3, all},

      behavior: {
        moon: {logisticsRate: 1},
      },

      metadata: {
        description: 'Requires 3 road tiles on The Moon. Raise the logistic rate 1 step.',
        cardNumber: 'M42',
        renderData: CardRenderer.builder((b) => {
          b.text('Opponents may not remove your', Size.SMALL, true).br;
          b.steel(1).titanium(1).production((pb) => pb.steel(1).titanium(1)).br;
          b.moonLogisticsRate();
        }),
      },
    });
  }
}

================
File: cards/moon/LunarSteel.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {Card} from '../Card';

export class LunarSteel extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNAR_STEEL,
      type: CardType.ACTIVE,
      tags: [Tag.MOON],
      cost: 5,

      behavior: {
        steelValue: 1,
      },

      metadata: {
        cardNumber: 'M87',
        renderData: CardRenderer.builder((b) => {
          b.effect('Your steel resources are worth 1 M€ extra.', (eb) => {
            eb.steel(1).startEffect.plus(Size.SMALL).megacredits(1);
          });
        }),
      },
    });
  }
}

================
File: cards/moon/LunarTradeFleet.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class LunarTradeFleet extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNAR_TRADE_FLEET,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON, Tag.SPACE],
      cost: 8,

      behavior: {
        production: {megacredits: 1},
        moon: {logisticsRate: 1},
      },

      requirements: {production: Resource.TITANIUM, count: 2},
      metadata: {
        description: 'Requires that you have 2 titanium production. ' +
        'Increase your M€ production 1 step. Raise the logistic rate 1 step.',
        cardNumber: 'M35',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1));
          b.br;
          b.moonLogisticsRate();
        }),
      },
    });
  }
}

================
File: cards/moon/LunaSenate.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all} from '../Options';

export class LunaSenate extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNA_SENATE,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON, Tag.MOON],
      cost: 32,
      victoryPoints: {tag: Tag.MOON},

      behavior: {
        production: {megacredits: {tag: Tag.MOON, others: true}},
        // production: {megacredits: {tag: Tag.MOON, all: true}},
      },

      requirements: {tag: Tag.MOON, count: 3},
      metadata: {
        // description: 'Requires that you have 3 Moon tags. Increase your M€ production 1 step per Moon tag in the game (including these.)',
        description: 'Requires that you have 3 Moon tags. Increase your M€ production 1 step per Moon tag your OPPONENTS have.',
        cardNumber: 'M70',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).slash().tag(Tag.MOON, {all}).asterix()).br;
          b.vpText('1 VP per Moon tag you have.');
        }),
      },
    });
  }
}

================
File: cards/moon/LunaStagingStation.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class LunaStagingStation extends Card {
  constructor() {
    super({
      name: CardName.LUNA_STAGING_STATION,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON, Tag.BUILDING],
      cost: 12,
      reserveUnits: {titanium: 1},

      behavior: {
        moon: {logisticsRate: 2},
      },

      requirements: {logisticRate: 2},
      metadata: {
        description: 'Requires the logistic rate to be 2 or higher. Spend 1 titanium. Raise the logistic rate 2 steps.',
        cardNumber: 'M30',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1).br;
          b.moonLogisticsRate({amount: 2});
        }),
      },
    });
  }
}

================
File: cards/moon/LunaTradeFederation.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CorporationCard} from '../corporation/CorporationCard';
import {CardRenderer} from '../render/CardRenderer';
import {TileType} from '../../../common/TileType';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {Space} from '../../boards/Space';
import {Resource} from '../../../common/Resource';
import {Size} from '../../../common/cards/render/Size';
// import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
// import {all, multiplier} from '../Options';

export class LunaTradeFederation extends CorporationCard {
  constructor() {
    super({
      name: CardName.LUNA_TRADE_FEDERATION,
      tags: [Tag.MOON, Tag.SPACE],
      startingMegaCredits: 15,

      behavior: {
        stock: {titanium: 10},
      },
      // firstAction: {
      //   text: 'Place a mine tile on The Moon.',
      //   moon: {mineTile: {}},
      // },

      metadata: {
        // description: 'You start with 15 M€ and 10 titanium. As your first action, place a mine tile on The Moon and raise the mining rate 1 step.',
        description: 'You start with 15 M€ and 10 titanium.',
        cardNumber: 'MC9',
        renderData: CardRenderer.builder((b) => {
          // b.megacredits(15).titanium(10).moonMine({secondaryTag: AltSecondaryTag.MOON_MINING_RATE}).br;
          b.megacredits(15).titanium(10).br;
          // b.effect('When any mine tile is placed on The Moon, raise your titanium production 1 step.', (eb) => {
          //   eb.moonMine({size: Size.SMALL, all}).startEffect.production((pb) => pb.titanium(1)).nbsp;
          // });
          b.effect('When you place a mine tile on The Moon, raise your titanium production 1 step.', (eb) => {
            eb.moonMine({size: Size.SMALL}).startEffect.production((pb) => pb.titanium(1)).nbsp;
          });
          b.br;
          b.effect('You may use titanium resources as 2M€ each.', (eb) => {
            eb.startEffect.text('X').titanium(1).equals().megacredits(1, {text: '2x'});
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.canUseTitaniumAsMegacredits = true;
    return undefined;
  }

  // public onTilePlaced(cardOwner: IPlayer, _activePlayer: IPlayer, , space: Space) {
  //   if (MoonExpansion.spaceHasType(space, TileType.MOON_MINE)) {
  //     cardOwner.production.add(Resources.TITANIUM, 1, {log: true});
  //   }
  // }
  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (activePlayer === cardOwner && MoonExpansion.spaceHasType(space, TileType.MOON_MINE)) {
      cardOwner.production.add(Resource.TITANIUM, 1, {log: true});
    }
  }
}

================
File: cards/moon/LunaTradeStation.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {MoonSpaces} from '../../../common/moon/MoonSpaces';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';
import {IActionCard} from '../ICard';
import {ActionCard} from '../ActionCard';
import {all} from '../Options';

export class LunaTradeStation extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.LUNA_TRADE_STATION,
      type: CardType.ACTIVE,
      tags: [Tag.MOON, Tag.MOON, Tag.SPACE],
      cost: 10,
      reserveUnits: {titanium: 2},

      action: {
        stock: {megacredits: {moon: {habitat: {}}, each: 2}},
      },

      behavior: {
        moon: {
          tile: {
            type: TileType.LUNA_TRADE_STATION,
            space: MoonSpaces.LUNA_TRADE_STATION,
          },
        },
      },

      metadata: {
        description: 'Spend 2 titanium. Place this tile ON THE RESERVED AREA.',
        cardNumber: 'M13',
        renderData: CardRenderer.builder((b) => {
          b.action('Gain 2 M€ for each habitat tile on The Moon.', (eb) =>
            eb.empty().startAction.megacredits(2).slash().moonHabitat({all}));
          b.br.minus().titanium(2).tile(TileType.LUNA_TRADE_STATION, true).asterix();
        }),
      },
    });
  }
}

================
File: cards/moon/LunaTrainStation.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {TileType} from '../../../common/TileType';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {digit} from '../Options';

export class LunaTrainStation extends Card {
  constructor() {
    super({
      name: CardName.LUNA_TRAIN_STATION,
      type: CardType.AUTOMATED,
      tags: [Tag.BUILDING],
      cost: 24,
      reserveUnits: {steel: 2},
      victoryPoints: 'special',

      behavior: {
        production: {megacredits: 4},
        moon: {
          tile: {type: TileType.LUNA_TRAIN_STATION},
          logisticsRate: 1,
        },
      },

      requirements: {logisticRate: 5},

      metadata: {
        description: 'Requires a logistic rate of 5 or higher. Spend 2 steel. ' +
        'Increase your M€ production 4 steps. Place this tile on The Moon and raise the logistic rate 1 step. ' +
        '2 VP FOR EACH ROAD TILE ADJACENT TO THIS TILE.',
        cardNumber: 'M15',
        renderData: CardRenderer.builder((b) => {
          b.minus().steel(2, {digit});
          b.production((pb) => pb.megacredits(4));
          b.tile(TileType.LUNA_TRAIN_STATION, true).moonLogisticsRate();
        }),
        victoryPoints: CardRenderDynamicVictoryPoints.moonRoadTile(2, true),
      },
    });
  }

  public override getVictoryPoints(player: IPlayer) {
    const moonData = MoonExpansion.moonData(player.game);
    const usedSpace = moonData.moon.getSpaceByTileCard(this.name);
    if (usedSpace !== undefined) {
      const adjacentSpaces = moonData.moon.getAdjacentSpaces(usedSpace);
      const adjacentMines = adjacentSpaces.filter((s) => MoonExpansion.spaceHasType(s, TileType.MOON_ROAD));
      return 2 * adjacentMines.length;
    }
    return 0;
  }
}

================
File: cards/moon/MareImbriumMine.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {MoonSpaces} from '../../../common/moon/MoonSpaces';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class MareImbriumMine extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.MARE_IMBRIUM_MINE,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON, Tag.BUILDING],
      cost: 19,
      reserveUnits: {titanium: 1},

      behavior: {
        production: {steel: 1, titanium: 1},
        moon: {
          mineTile: {space: MoonSpaces.MARE_IMBRIUM},
        },
      },

      metadata: {
        description: 'Spend 1 titanium. Increase your steel production 1 step and your titanium production 1 step. Place a mine ON THE RESERVED AREA and raise the mining rate 1 step.',
        cardNumber: 'M03',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1);
          b.production((pb) => pb.steel(1).titanium(1)).br;
          b.moonMine({secondaryTag: AltSecondaryTag.MOON_MINING_RATE}).asterix();
        }),
      },
    });
  }
}

================
File: cards/moon/MareNectarisMine.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {MoonSpaces} from '../../../common/moon/MoonSpaces';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class MareNectarisMine extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.MARE_NECTARIS_MINE,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON, Tag.BUILDING],
      cost: 14,

      behavior: {
        production: {steel: 1},
        moon: {
          mineTile: {space: MoonSpaces.MARE_NECTARIS},
        },
      },
      reserveUnits: {titanium: 1},

      metadata: {
        description: 'Spend 1 titanium. Increase your steel production 1 step. Place a mine ON THE RESERVED AREA and raise the mining rate 1 step.',
        cardNumber: 'M01',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1).nbsp;
          b.production((pb) => pb.steel(1));
          b.moonMine({secondaryTag: AltSecondaryTag.MOON_MINING_RATE}).asterix();
        }),
      },
    });
  }
}

================
File: cards/moon/MareNubiumMine.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {MoonSpaces} from '../../../common/moon/MoonSpaces';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class MareNubiumMine extends Card {
  constructor() {
    super({
      name: CardName.MARE_NUBIUM_MINE,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON, Tag.BUILDING],
      cost: 17,

      behavior: {
        production: {titanium: 1},
        moon: {
          mineTile: {space: MoonSpaces.MARE_NUBIUM},
        },
      },
      reserveUnits: {titanium: 1},

      metadata: {
        description: 'Spend 1 titanium. Increase your titanium production 1 step. Place a mine ON THE RESERVED AREA and raise the mining rate 1 step.',
        cardNumber: 'M02',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1);
          b.production((pb) => pb.titanium(1)).moonMine({secondaryTag: AltSecondaryTag.MOON_MINING_RATE}).asterix();
        }),
      },
    });
  }
}

================
File: cards/moon/MareSerenitatisMine.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {MoonSpaces} from '../../../common/moon/MoonSpaces';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {PlaceMoonRoadTile} from '../../moon/PlaceMoonRoadTile';
import {SpaceType} from '../../../common/boards/SpaceType';
import {TileType} from '../../../common/TileType';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class MareSerenitatisMine extends Card {
  constructor() {
    super({
      name: CardName.MARE_SERENITATIS_MINE,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON, Tag.BUILDING],
      cost: 21,

      behavior: {
        production: {steel: 1, titanium: 1},
      },
      reserveUnits: {steel: 1, titanium: 2},
      tr: {moonMining: 1, moonLogistics: 1},

      metadata: {
        description: 'Spend 2 titanium and 1 steel. Increase your steel and titanium production 1 step. ' +
        'Place a mine ON THE RESERVED AREA and a road tile adjacent to it. Raise the mining rate 1 step and the logistic rate 1 step.',
        cardNumber: 'M04',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(2).minus().steel(1).br;
          b.production((pb) => pb.steel(1).titanium(1)).br;
          b.moonMine({secondaryTag: AltSecondaryTag.MOON_MINING_RATE}).asterix().nbsp.moonRoad({secondaryTag: AltSecondaryTag.MOON_LOGISTICS_RATE}).asterix();
        }),
      },
      tilesBuilt: [TileType.MOON_MINE, TileType.MOON_ROAD],
    });
  }

  public override bespokePlay(player: IPlayer) {
    MoonExpansion.addMineTile(player, MoonSpaces.MARE_SERENITATIS, this.name);
    MoonExpansion.raiseMiningRate(player);
    const moon = MoonExpansion.moonData(player.game).moon;
    const spaces = moon.getAdjacentSpaces(moon.getSpaceOrThrow(MoonSpaces.MARE_SERENITATIS));
    const availableRoadSpaces = spaces.filter((space) => {
      return space.player === undefined && space.spaceType === SpaceType.LAND;
    });
    player.game.defer(new PlaceMoonRoadTile(player, availableRoadSpaces, 'Select a space next to Mare Serintatis to play a road'));
    return undefined;
  }
}

================
File: cards/moon/MarketCard.ts
================
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectAmount} from '../../inputs/SelectAmount';
import {SelectOption} from '../../inputs/SelectOption';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {Card, StaticCardProperties} from '../Card';
import {IActionCard} from '../ICard';
import {message} from '../../logs/MessageBuilder';
import {PathfindersExpansion} from '../../pathfinders/PathfindersExpansion';

export interface Terms {
  from: number,
  to: number,
  limit: number
}

// An abstract base class for SteelMarketMonopolists and TitaniumMarketMonopolists
export abstract class MarketCard extends Card implements IActionCard {
  constructor(
    public readonly tradeResource: Resource,
    public readonly buyingTerms: Terms,
    public readonly sellingTerms: Terms,
    properties: StaticCardProperties) {
    super(properties);
  }

  private canBuy(player: IPlayer) {
    return player.spendableMegacredits() >= this.buyingTerms.from;
  }

  private canSell(player: IPlayer) {
    return player.stock.get(this.tradeResource) >= this.sellingTerms.from;
  }

  public canAct(player: IPlayer): boolean {
    return this.canBuy(player) || this.canSell(player);
  }

  public action(player: IPlayer) {
    const offerBuy = this.canBuy(player);
    const offerSell = this.canSell(player);
    if (offerBuy && offerSell) {
      return new OrOptions(
        new SelectOption(message('Buy ${0}', (b) => b.string(this.tradeResource)), 'Buy').andThen(() => this.getBuyingOption(player)),
        new SelectOption(message('Sell ${0}', (b) => b.string(this.tradeResource)), 'Sell').andThen(() => this.getSellingOption(player)),
      );
    } else if (offerBuy) {
      return this.getBuyingOption(player);
    } else if (offerSell) {
      return this.getSellingOption(player);
    }
    return undefined;
  }

  private getBuyingOption(player: IPlayer): SelectAmount {
    const availableMC = player.spendableMegacredits();
    const terms = this.buyingTerms;
    let limit = Math.floor(availableMC / terms.from);
    limit = Math.min(limit, terms.limit);

    return new SelectAmount(
      message(
        'Select a number of trades (${0} M€ => ${1} ${2}, max ${3})',
        (b) => b.number(terms.from).number(terms.to).string(this.tradeResource).number(limit)),
      `Buy ${this.tradeResource}`,
      1,
      limit,
    ).andThen( (tradesRequested: number) => {
      const cashDue = tradesRequested * terms.from;
      const unitsEarned = tradesRequested * terms.to;
      player.game.defer(new SelectPaymentDeferred(player, cashDue))
        .andThen(() => player.stock.add(this.tradeResource, unitsEarned, {log: true}));
      return undefined;
    });
  }

  private getSellingOption(player: IPlayer) {
    const terms = this.sellingTerms;
    if (terms.from !== 1) {
      throw new Error('selling from !== 1 not yet supported.');
    }
    let limit = player.stock.get(this.tradeResource);
    limit = Math.min(limit, terms.limit);


    return new SelectAmount(
      message(
        'Select a number of trades (${0} ${1} => ${2} M€, max ${3})',
        (b) => b.number(terms.from).string(this.tradeResource).number(terms.to).number(limit)),
      `Sell ${this.tradeResource}`, 1, limit,
    ).andThen((unitsSold: number) => {
      const cashEarned = unitsSold * terms.to;
      player.stock.add(Resource.MEGACREDITS, cashEarned);
      player.stock.deduct(this.tradeResource, unitsSold);
      PathfindersExpansion.addToSolBank(player);

      player.game.log('${0} sold ${1} ${2}', (b) => b.player(player).number(unitsSold).string(this.tradeResource));
      return undefined;
    });
  }
}

================
File: cards/moon/MartianEmbassy.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {PathfindersExpansion} from '../../pathfinders/PathfindersExpansion';

export class MartianEmbassy extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.MARTIAN_EMBASSY,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON, Tag.MARS],
      cost: 11,

      metadata: {
        cardNumber: 'M76',
        description: 'Raise the Mars Planetary Track 1 step for every 3 Moon tags you have, including this.',
        renderData: CardRenderer.builder((b) => {
          b.tag(Tag.MARS).planetaryTrack().text('+1').slash().tag(Tag.MOON, 3);
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    // The +1 is "including this".
    const tags = player.tags.count(Tag.MOON) + 1;
    const rate = Math.floor(tags / 3);
    PathfindersExpansion.raiseTrack(Tag.MARS, player, rate);
    return undefined;
  }
}

================
File: cards/moon/MicrosingularityPlant.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all} from '../Options';
import {IProjectCard} from '../IProjectCard';

export class MicrosingularityPlant extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.MICROSINGULARITY_PLANT,
      type: CardType.AUTOMATED,
      tags: [Tag.POWER],
      cost: 10,
      requirements: {habitatTiles: 2, all},

      behavior: {
        production: {energy: 2},
      },

      metadata: {
        description: 'Requires 2 habitats on The Moon. Increase your energy production 2 steps.',
        cardNumber: 'M40',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2));
        }),
      },
    });
  }
}

================
File: cards/moon/MiningComplex.ts
================
import {CardName} from '../../../common/cards/CardName';
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardRenderer} from '../render/CardRenderer';
import {PlaceMoonMineTile} from '../../moon/PlaceMoonMineTile';
import {IPlayer} from '../../IPlayer';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {PlaceMoonRoadTile} from '../../moon/PlaceMoonRoadTile';
import {SpaceType} from '../../../common/boards/SpaceType';
import {Resource} from '../../../common/Resource';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {TileType} from '../../../common/TileType';

export class MiningComplex extends PreludeCard {
  constructor() {
    super({
      name: CardName.MINING_COMPLEX,
      tags: [Tag.MOON],
      startingMegacredits: -7,
      tilesBuilt: [TileType.MOON_MINE, TileType.MOON_ROAD],

      metadata: {
        description: 'Place a mine tile on The Moon and raise the mining rate 1 step. ' +
        'Place a road tile adjacent to placed mine tile and raise the Logistics Rate 1 step. ' +
        'Pay 7 M€.',
        cardNumber: '',
        renderData: CardRenderer.builder((b) =>
          b.moonMine({secondaryTag: AltSecondaryTag.MOON_MINING_RATE}).moonRoad({secondaryTag: AltSecondaryTag.MOON_LOGISTICS_RATE}).asterix().br.minus().megacredits(7),
        ),
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    return player.canAfford(7);
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new PlaceMoonMineTile(player))
      .andThen((space) => {
        const moon = MoonExpansion.moonData(player.game).moon;
        const spaces = moon.getAdjacentSpaces(space);
        const availableRoadSpaces = spaces.filter((space) => {
          return space.player === undefined && space.spaceType === SpaceType.LAND;
        });
        player.game.defer(
          new PlaceMoonRoadTile(
            player,
            availableRoadSpaces,
            'Select a space next to the mine for a road',
          ));
      });
    player.stock.deduct(Resource.MEGACREDITS, 7);
    return undefined;
  }
}

================
File: cards/moon/MiningRobotsManufCenter.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class MiningRobotsManufCenter extends Card {
  constructor() {
    super({
      name: CardName.MINING_ROBOTS_MANUF_CENTER,
      type: CardType.AUTOMATED,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 12,
      reserveUnits: {titanium: 1},

      behavior: {
        moon: {miningRate: 2},
      },

      metadata: {
        description: 'Spend 1 titanium. Raise the mining rate 2 steps.',
        cardNumber: 'M23',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1).br;
          b.moonMiningRate({amount: 2});
        }),
      },
    });
  }
}

================
File: cards/moon/MomentumViriumHabitat.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {MoonSpaces} from '../../../common/moon/MoonSpaces';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class MomentumViriumHabitat extends Card {
  constructor() {
    super({
      name: CardName.MOMENTUM_VIRUM_HABITAT,
      type: CardType.AUTOMATED,
      tags: [Tag.CITY, Tag.SPACE],
      cost: 23,

      behavior: {
        production: {heat: 2, megacredits: 3},
        moon: {
          habitatTile: {space: MoonSpaces.MOMENTUM_VIRIUM},
        },
      },
      reserveUnits: {titanium: 1},

      metadata: {
        description: 'Spend 1 titanium. Increase your heat production 2 steps and your M€ production 3 steps. ' +
        'Place a habitat tile ON THE RESERVED AREA and raise the habitat rate 1 step.',
        cardNumber: 'M12',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1).br;
          b.production((pb) => {
            pb.heat(2).megacredits(3);
          }).br;
          b.moonHabitat({secondaryTag: AltSecondaryTag.MOON_HABITAT_RATE}).asterix();
        }),
      },
    });
  }
}

================
File: cards/moon/MoonCardManifest.ts
================
import {CardName} from '../../../common/cards/CardName';
import {ModuleManifest} from '../ModuleManifest';
import {AIControlledMineNetwork} from './AIControlledMineNetwork';
import {AlgaeBioreactors} from './AlgaeBioreactors';
import {AncientShipyards} from './AncientShipyards';
import {AnOfferYouCantRefuse} from './AnOfferYouCantRefuse';
import {ArchimedesHydroponicsStation} from './ArchimedesHydroponicsStation';
import {AristarchusRoadNetwork} from './AristarchusRoadNetwork';
import {BasicInfrastructure} from './BasicInfrastructure';
import {ColonistShuttles} from './ColonistShuttles';
import {CopernicusSolarArrays} from './CopernicusSolarArrays';
import {CopernicusTower} from './CopernicusTower';
import {CoreMine} from './CoreMine';
import {CosmicRadiation} from './CosmicRadiation';
import {CrescentResearchAssociation} from './CrescentResearchAssociation';
import {DarksideIncubationPlant} from './DarksideIncubationPlant';
import {DarksideMeteorBombardment} from './DarksideMeteorBombardment';
import {DarksideMiningSyndicate} from './DarksideMiningSyndicate';
import {DarksideObservatory} from './DarksideObservatory';
import {DarksideSmugglersUnion} from './DarksideSmugglersUnion';
import {DeepLunarMining} from './DeepLunarMining';
import {EarthEmbassy} from './EarthEmbassy';
import {FirstLunarSettlement} from './FirstLunarSettlement';
import {GeodesicTents} from './GeodesicTents';
import {GrandLunaAcademy} from './GrandLunaAcademy';
import {Habitat14} from './Habitat14';
import {HE3FusionPlant} from './HE3FusionPlant';
import {HE3Lobbyists} from './HE3Lobbyists';
import {HE3ProductionQuotas} from './HE3ProductionQuotas';
import {HE3Refinery} from './HE3Refinery';
import {HeavyDutyRovers} from './HeavyDutyRovers';
import {HeliostatMirrorArray} from './HeliostatMirrorArray';
import {HostileTakeover} from './HostileTakeover';
import {HypersensitiveSiliconChipFactory} from './HypersensitiveSiliconChipFactory';
import {ImprovedMoonConcrete} from './ImprovedMoonConcrete';
import {IntragenSanctuaryHeadquarters} from './IntragenSanctuaryHeadquarters';
import {IronExtractionCenter} from './IronExtractionCenter';
import {LTFHeadquarters} from './LTFHeadquarters';
import {LTFPrivileges} from './LTFPrivileges';
import {LunaArchives} from './LunaArchives';
import {LunaConference} from './LunaConference';
import {LunaEcumenopolis} from './LunaEcumenopolis';
import {LunaFirstIncorporated} from './LunaFirstIncorporated';
import {LunaHyperloopCorporation} from './LunaHyperloopCorporation';
import {LunaMiningHub} from './LunaMiningHub';
import {LunaPoliticalInstitute} from './LunaPoliticalInstitute';
import {LunaProjectOffice} from './LunaProjectOffice';
import {LunarDustProcessingPlant} from './LunarDustProcessingPlant';
import {LunaResort} from './LunaResort';
// import {LunarIndependenceWar} from './LunarIndependenceWar';
import {LunarIndustryComplex} from './LunarIndustryComplex';
import {LunarMineUrbanization} from './LunarMineUrbanization';
import {LunarObservationPost} from './LunarObservationPost';
import {LunarPlanningOffice} from './LunarPlanningOffice';
import {LunarSecurityStations} from './LunarSecurityStations';
import {LunarSteel} from './LunarSteel';
import {LunarTradeFleet} from './LunarTradeFleet';
import {LunaSenate} from './LunaSenate';
import {LunaStagingStation} from './LunaStagingStation';
import {LunaTradeStation} from './LunaTradeStation';
import {LunaTrainStation} from './LunaTrainStation';
import {LunaTradeFederation} from './LunaTradeFederation';
import {MareImbriumMine} from './MareImbriumMine';
import {MareNectarisMine} from './MareNectarisMine';
import {MareNubiumMine} from './MareNubiumMine';
import {MareSerenitatisMine} from './MareSerenitatisMine';
import {MartianEmbassy} from './MartianEmbassy';
import {MicrosingularityPlant} from './MicrosingularityPlant';
import {MiningComplex} from './MiningComplex';
import {MiningRobotsManufCenter} from './MiningRobotsManufCenter';
import {MomentumViriumHabitat} from './MomentumViriumHabitat';
import {MoonHabitatStandardProject} from './MoonHabitatStandardProject';
import {MoonHabitatStandardProjectVariant1, MoonMineStandardProjectVariant1, MoonRoadStandardProjectVariant1} from './MoonStandardProjectVariants1';
import {MoonHabitatStandardProjectVariant2, MoonMineStandardProjectVariant2, MoonRoadStandardProjectVariant2} from './MoonStandardProjectVariants2';
import {MooncrateBlockFactory} from './MooncrateBlockFactory';
import {MooncrateConvoysToMars} from './MooncrateConvoysToMars';
import {MoonMineStandardProject} from './MoonMineStandardProject';
import {MoonRoadStandardProject} from './MoonRoadStandardProject';
import {MoonTether} from './MoonTether';
import {NanotechIndustries} from './NanotechIndustries';
import {NewColonyPlanningInitiatives} from './NewColonyPlanningInitiatives';
import {OffWorldCityLiving} from './OffWorldCityLiving';
import {PreliminaryDarkside} from './PreliminaryDarkside';
import {OrbitalPowerGrid} from './OrbitalPowerGrid';
import {PrideoftheEarthArkship} from './PrideoftheEarthArkship';
import {ProcessorFactory} from './ProcessorFactory';
import {RevoltingColonists} from './RevoltingColonists';
import {RoadPiracy} from './RoadPiracy';
import {RoverDriversUnion} from './RoverDriversUnion';
import {RustEatingBacteria} from './RustEatingBacteria';
import {SinusIrdiumRoadNetwork} from './SinusIrdiumRoadNetwork';
import {SmallDutyRovers} from './SmallDutyRovers';
import {SolarPanelFoundry} from './SolarPanelFoundry';
import {SphereHabitats} from './SphereHabitats';
import {StagingStationBehemoth} from './StagingStationBehemoth';
import {SteelMarketMonopolists} from './SteelMarketMonopolists';
import {SubterraneanHabitats} from './SubterraneanHabitats';
import {SyndicatePirateRaids} from './SyndicatePirateRaids';
import {TempestConsultancy} from './TempestConsultancy';
import {TheArchaicFoundationInstitute} from './TheArchaicFoundationInstitute';
import {TheDarksideofTheMoonSyndicate} from './TheDarksideofTheMoonSyndicate';
import {TheGrandLunaCapitalGroup} from './TheGrandLunaCapitalGroup';
import {TheWomb} from './TheWomb';
import {ThoriumRush} from './ThoriumRush';
import {TitaniumExtractionCenter} from './TitaniumExtractionCenter';
import {TitaniumMarketMonopolists} from './TitaniumMarketMonopolists';
import {TychoRoadNetwork} from './TychoRoadNetwork';
import {UndergroundDetonators} from './UndergroundDetonators';
import {UndermoonDrugLordsNetwork} from './UndermoonDrugLordsNetwork';
import {WaterTreatmentComplex} from './WaterTreatmentComplex';
import {WeGrowAsOne} from './WeGrowAsOne';

export const MOON_CARD_MANIFEST = new ModuleManifest({
  module: 'moon',
  projectCards: {
    [CardName.MARE_NECTARIS_MINE]: {Factory: MareNectarisMine},
    [CardName.MARE_NUBIUM_MINE]: {Factory: MareNubiumMine},
    [CardName.MARE_IMBRIUM_MINE]: {Factory: MareImbriumMine},
    [CardName.MARE_SERENITATIS_MINE]: {Factory: MareSerenitatisMine},
    [CardName.HABITAT_14]: {Factory: Habitat14},
    [CardName.GEODESIC_TENTS]: {Factory: GeodesicTents},
    [CardName.SPHERE_HABITATS]: {Factory: SphereHabitats},
    [CardName.THE_WOMB]: {Factory: TheWomb},
    [CardName.TYCHO_ROAD_NETWORK]: {Factory: TychoRoadNetwork},
    [CardName.ARISTARCHUS_ROAD_NETWORK]: {Factory: AristarchusRoadNetwork},
    [CardName.SINUS_IRDIUM_ROAD_NETWORK]: {Factory: SinusIrdiumRoadNetwork},
    [CardName.MOMENTUM_VIRUM_HABITAT]: {Factory: MomentumViriumHabitat},
    [CardName.LUNA_TRADE_STATION]: {Factory: LunaTradeStation},
    [CardName.LUNA_MINING_HUB]: {Factory: LunaMiningHub},
    [CardName.LUNA_TRAIN_STATION]: {Factory: LunaTrainStation},
    [CardName.COLONIST_SHUTTLES]: {Factory: ColonistShuttles},
    [CardName.LUNAR_DUST_PROCESSING_PLANT]: {Factory: LunarDustProcessingPlant},
    [CardName.DEEP_LUNAR_MINING]: {Factory: DeepLunarMining},
    [CardName.ANCIENT_SHIPYARDS]: {Factory: AncientShipyards},
    [CardName.LUNA_PROJECT_OFFICE]: {Factory: LunaProjectOffice},
    [CardName.LUNA_RESORT]: {Factory: LunaResort},
    [CardName.LUNAR_OBSERVATION_POST]: {Factory: LunarObservationPost},
    [CardName.MINING_ROBOTS_MANUF_CENTER]: {Factory: MiningRobotsManufCenter},
    [CardName.PRIDE_OF_THE_EARTH_ARKSHIP]: {Factory: PrideoftheEarthArkship},
    [CardName.IRON_EXTRACTION_CENTER]: {Factory: IronExtractionCenter},
    [CardName.TITANIUM_EXTRACTION_CENTER]: {Factory: TitaniumExtractionCenter},
    [CardName.ARCHIMEDES_HYDROPONICS_STATION]: {Factory: ArchimedesHydroponicsStation},
    [CardName.STEEL_MARKET_MONOPOLISTS]: {Factory: SteelMarketMonopolists},
    [CardName.TITANIUM_MARKET_MONOPOLISTS]: {Factory: TitaniumMarketMonopolists},
    [CardName.LUNA_STAGING_STATION]: {Factory: LunaStagingStation},
    [CardName.NEW_COLONY_PLANNING_INITIAITIVES]: {Factory: NewColonyPlanningInitiatives},
    [CardName.AI_CONTROLLED_MINE_NETWORK]: {Factory: AIControlledMineNetwork},
    [CardName.DARKSIDE_METEOR_BOMBARDMENT]: {Factory: DarksideMeteorBombardment},
    [CardName.UNDERGROUND_DETONATORS]: {Factory: UndergroundDetonators},
    [CardName.LUNAR_TRADE_FLEET]: {Factory: LunarTradeFleet},
    [CardName.SUBTERRANEAN_HABITATS]: {Factory: SubterraneanHabitats},
    [CardName.IMPROVED_MOON_CONCRETE]: {Factory: ImprovedMoonConcrete},
    [CardName.MOONCRATE_BLOCK_FACTORY]: {Factory: MooncrateBlockFactory},
    [CardName.HEAVY_DUTY_ROVERS]: {Factory: HeavyDutyRovers},
    [CardName.MICROSINGULARITY_PLANT]: {Factory: MicrosingularityPlant},
    [CardName.HELIOSTAT_MIRROR_ARRAY]: {Factory: HeliostatMirrorArray},
    [CardName.LUNAR_SECURITY_STATIONS]: {Factory: LunarSecurityStations},
    [CardName.HYPERSENSITIVE_SILICON_CHIP_FACTORY]: {Factory: HypersensitiveSiliconChipFactory},
    [CardName.COPERNICUS_SOLAR_ARRAYS]: {Factory: CopernicusSolarArrays},
    [CardName.DARKSIDE_INCUBATION_PLANT]: {Factory: DarksideIncubationPlant},
    [CardName.WATER_TREATMENT_COMPLEX]: {Factory: WaterTreatmentComplex},
    [CardName.ALGAE_BIOREACTORS]: {Factory: AlgaeBioreactors},
    [CardName.HE3_FUSION_PLANT]: {Factory: HE3FusionPlant},
    [CardName.HE3_REFINERY]: {Factory: HE3Refinery},
    [CardName.HE3_LOBBYISTS]: {Factory: HE3Lobbyists},
    //   // Start of second pack.
    [CardName.REVOLTING_COLONISTS]: {Factory: RevoltingColonists},
    [CardName.COSMIC_RADIATION]: {Factory: CosmicRadiation},
    [CardName.OFF_WORLD_CITY_LIVING]: {Factory: OffWorldCityLiving},
    [CardName.ROAD_PIRACY]: {Factory: RoadPiracy},
    [CardName.LUNAR_MINE_URBANIZATION]: {Factory: LunarMineUrbanization},
    [CardName.THORIUM_RUSH]: {Factory: ThoriumRush},
    [CardName.HE3_PRODUCTION_QUOTAS]: {Factory: HE3ProductionQuotas, compatibility: 'turmoil'},
    [CardName.LUNA_CONFERENCE]: {Factory: LunaConference, compatibility: 'turmoil'},
    [CardName.WE_GROW_AS_ONE]: {Factory: WeGrowAsOne, compatibility: ['turmoil', 'colonies']},
    [CardName.MOONCRATE_CONVOYS_TO_MARS]: {Factory: MooncrateConvoysToMars, compatibility: ['turmoil']},
    // // [CardName.LUNAR_INDEPENDENCE_WAR]: {Factory: LunarIndependenceWar},
    [CardName.AN_OFFER_YOU_CANT_REFUSE]: {Factory: AnOfferYouCantRefuse, compatibility: 'turmoil'},
    [CardName.PRELIMINARY_DARKSIDE]: {Factory: PreliminaryDarkside},
    [CardName.HOSTILE_TAKEOVER]: {Factory: HostileTakeover},
    [CardName.SYNDICATE_PIRATE_RAIDS]: {Factory: SyndicatePirateRaids, compatibility: 'colonies'},
    [CardName.DARKSIDE_MINING_SYNDICATE]: {Factory: DarksideMiningSyndicate},
    //   // [CardName.HE3_PROPULSION]: {Factory: HE3Propulsion, compatibility: 'colonies'},
    [CardName.STAGING_STATION_BEHEMOTH]: {Factory: StagingStationBehemoth, compatibility: 'colonies'},
    [CardName.LUNA_ARCHIVES]: {Factory: LunaArchives},
    [CardName.LUNA_SENATE]: {Factory: LunaSenate},
    [CardName.LUNA_POLITICAL_INSTITUTE]: {Factory: LunaPoliticalInstitute, compatibility: 'turmoil'},
    [CardName.COPERNICUS_TOWER]: {Factory: CopernicusTower},
    [CardName.SMALL_DUTY_ROVERS]: {Factory: SmallDutyRovers},
    [CardName.LUNAR_INDUSTRY_COMPLEX]: {Factory: LunarIndustryComplex},
    [CardName.DARKSIDE_OBSERVATORY]: {Factory: DarksideObservatory},
    [CardName.MARTIAN_EMBASSY]: {Factory: MartianEmbassy, compatibility: 'pathfinders'},
    [CardName.EARTH_EMBASSY]: {Factory: EarthEmbassy},
    [CardName.ROVER_DRIVERS_UNION]: {Factory: RoverDriversUnion},
    [CardName.LTF_HEADQUARTERS]: {Factory: LTFHeadquarters, compatibility: 'colonies'},
    [CardName.DARKSIDE_SMUGGLERS_UNION]: {Factory: DarksideSmugglersUnion, compatibility: 'colonies'},
    [CardName.UNDERMOON_DRUG_LORDS_NETWORK]: {Factory: UndermoonDrugLordsNetwork},
    [CardName.LTF_PRIVILEGES]: {Factory: LTFPrivileges},
    [CardName.GRAND_LUNA_ACADEMY]: {Factory: GrandLunaAcademy},
    [CardName.LUNA_ECUMENOPOLIS]: {Factory: LunaEcumenopolis},
    [CardName.ORBITAL_POWER_GRID]: {Factory: OrbitalPowerGrid},
    [CardName.PROCESSOR_FACTORY]: {Factory: ProcessorFactory},
    [CardName.LUNAR_STEEL]: {Factory: LunarSteel},
    [CardName.RUST_EATING_BACTERIA]: {Factory: RustEatingBacteria},
    [CardName.SOLAR_PANEL_FOUNDRY]: {Factory: SolarPanelFoundry},
    [CardName.MOON_TETHER]: {Factory: MoonTether},
  },
  corporationCards: {
    [CardName.NANOTECH_INDUSTRIES]: {Factory: NanotechIndustries, compatibility: 'moon'},
    [CardName.TEMPEST_CONSULTANCY]: {Factory: TempestConsultancy, compatibility: ['turmoil', 'moon']},
    [CardName.THE_DARKSIDE_OF_THE_MOON_SYNDICATE]: {Factory: TheDarksideofTheMoonSyndicate, compatibility: 'moon'},
    [CardName.LUNA_HYPERLOOP_CORPORATION]: {Factory: LunaHyperloopCorporation, compatibility: 'moon'},
    [CardName.CRESCENT_RESEARCH_ASSOCIATION]: {Factory: CrescentResearchAssociation, compatibility: 'moon'},
    [CardName.LUNA_FIRST_INCORPORATED]: {Factory: LunaFirstIncorporated, compatibility: 'moon'},
    [CardName.THE_GRAND_LUNA_CAPITAL_GROUP]: {Factory: TheGrandLunaCapitalGroup, compatibility: 'moon'},
    [CardName.INTRAGEN_SANCTUARY_HEADQUARTERS]: {Factory: IntragenSanctuaryHeadquarters, compatibility: 'moon'},
    [CardName.LUNA_TRADE_FEDERATION]: {Factory: LunaTradeFederation, compatibility: 'moon'},
    [CardName.THE_ARCHAIC_FOUNDATION_INSTITUTE]: {Factory: TheArchaicFoundationInstitute, compatibility: 'moon'},
  },
  standardProjects: {
    [CardName.MOON_HABITAT_STANDARD_PROJECT]: {Factory: MoonHabitatStandardProject},
    [CardName.MOON_HABITAT_STANDARD_PROJECT_VARIANT_1]: {Factory: MoonHabitatStandardProjectVariant1},
    [CardName.MOON_HABITAT_STANDARD_PROJECT_VARIANT_2]: {Factory: MoonHabitatStandardProjectVariant2},
    [CardName.MOON_MINE_STANDARD_PROJECT]: {Factory: MoonMineStandardProject},
    [CardName.MOON_MINE_STANDARD_PROJECT_VARIANT_1]: {Factory: MoonMineStandardProjectVariant1},
    [CardName.MOON_MINE_STANDARD_PROJECT_VARIANT_2]: {Factory: MoonMineStandardProjectVariant2},
    [CardName.MOON_ROAD_STANDARD_PROJECT]: {Factory: MoonRoadStandardProject},
    [CardName.MOON_ROAD_STANDARD_PROJECT_VARIANT_1]: {Factory: MoonRoadStandardProjectVariant1},
    [CardName.MOON_ROAD_STANDARD_PROJECT_VARIANT_2]: {Factory: MoonRoadStandardProjectVariant2},
  },
  preludeCards: {
    [CardName.FIRST_LUNAR_SETTLEMENT]: {Factory: FirstLunarSettlement, compatibility: 'moon'},
    [CardName.CORE_MINE]: {Factory: CoreMine, compatibility: 'moon'},
    [CardName.BASIC_INFRASTRUCTURE]: {Factory: BasicInfrastructure, compatibility: ['moon', 'colonies']},
    [CardName.LUNAR_PlANNING_OFFICE]: {Factory: LunarPlanningOffice, compatibility: 'moon'},
    [CardName.MINING_COMPLEX]: {Factory: MiningComplex, compatibility: 'moon'},
  },
});

================
File: cards/moon/MooncrateBlockFactory.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class MooncrateBlockFactory extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.MOONCRATE_BLOCK_FACTORY,
      type: CardType.ACTIVE,
      tags: [Tag.BUILDING],
      cost: 8,
      requirements: {miningTiles: 1},

      // Behavior is in MoonHabitatStandardProject, MoonMineStandardProject and MoonRoadStandardProject.

      metadata: {
        description: 'Requires 1 mine on The Moon.',
        cardNumber: 'M38',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you pay for a Lunar standard project, you spend 4M€ less.', (eb) => {
            eb.plate('Lunar standard projects').startEffect.megacredits(-4);
          });
        }),
      },
    });
  }
}

================
File: cards/moon/MooncrateConvoysToMars.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IPlayer} from '../../IPlayer';
import {SellSteel} from '../../moon/SellSteel';
import {all} from '../Options';
import {IProjectCard} from '../IProjectCard';

export class MooncrateConvoysToMars extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.MOONCRATE_CONVOYS_TO_MARS,
      type: CardType.EVENT,
      cost: 13,
      requirements: {party: PartyName.MARS},

      behavior: {
        moon: {logisticsRate: 1},
      },

      metadata: {
        description: 'Requires that Mars First are ruling or that you have 2 delegates there. ' +
          'Raise the logistic rate 1 step. All players may sell their steel resources for 3M€ each.',
        cardNumber: 'M60',
        renderData: CardRenderer.builder((b) => {
          b.moonLogisticsRate().br;
          b.text('X').steel(1, {all}).colon().text('X').megacredits(3);
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    game.getPlayers().forEach((player) => {
      game.defer(new SellSteel(player));
    });
    return undefined;
  }
}

================
File: cards/moon/MoonHabitatStandardProject.ts
================
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {StandardProjectCard} from '../StandardProjectCard';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {PlaceMoonHabitatTile} from '../../moon/PlaceMoonHabitatTile';
import {Resource} from '../../../common/Resource';
import {TileType} from '../../../common/TileType';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';


export class MoonHabitatStandardProject extends StandardProjectCard {
  constructor(properties = {
    name: CardName.MOON_HABITAT_STANDARD_PROJECT,
    cost: 22,
    reserveUnits: {titanium: 1},
    tr: {moonHabitat: 1},
    tilesBuilt: [TileType.MOON_HABITAT],

    metadata: {
      cardNumber: '',
      renderData: CardRenderer.builder((b) =>
        b.standardProject('Spend 22 M€ and 1 titanium to place a habitat on The Moon and raise your M€ production 1 step.', (eb) => {
          eb.megacredits(22).titanium(1).startAction.moonHabitat({secondaryTag: AltSecondaryTag.MOON_HABITAT_RATE}).production((pb) => pb.megacredits(1));
        }),
      ),
    },
  }) {
    super(properties);
  }

  protected override discount(player: IPlayer): number {
    if (player.playedCards.find((card) => card.name === CardName.MOONCRATE_BLOCK_FACTORY)) {
      return 4;
    }
    return super.discount(player);
  }

  public override canAct(player: IPlayer): boolean {
    const moonData = MoonExpansion.moonData(player.game);
    const spaces = moonData.moon.getAvailableSpacesOnLand(player);

    if (spaces.length === 0) {
      return false;
    }

    return super.canAct(player);
  }

  // TODO(kberg): subclass MoonCard? This is starting to show the problems with just using subclassing.
  actionEssence(player: IPlayer): void {
    const adjustedReserveUnits = MoonExpansion.adjustedReserveCosts(player, this);
    player.stock.deductUnits(adjustedReserveUnits);
    player.game.defer(new PlaceMoonHabitatTile(player));
    player.production.add(Resource.MEGACREDITS, 1, {log: true});
  }
}

================
File: cards/moon/MoonMineStandardProject.ts
================
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {StandardProjectCard} from '../StandardProjectCard';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {PlaceMoonMineTile} from '../../moon/PlaceMoonMineTile';
import {Resource} from '../../../common/Resource';
import {TileType} from '../../../common/TileType';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class MoonMineStandardProject extends StandardProjectCard {
  constructor(properties = {
    name: CardName.MOON_MINE_STANDARD_PROJECT,
    cost: 20,
    reserveUnits: {titanium: 1},
    tr: {moonMining: 1},
    tilesBuilt: [TileType.MOON_MINE],

    metadata: {
      cardNumber: '',
      renderData: CardRenderer.builder((b) =>
        b.standardProject('Spend 20 M€ and 1 titanium to place a mine on The Moon, raise the mining rate 1 step, and raise steel production 1 step.', (eb) => {
          eb.megacredits(20).titanium(1).startAction.moonMine({secondaryTag: AltSecondaryTag.MOON_MINING_RATE}).production((pb) => pb.steel(1));
        }),
      ),
    },
  }) {
    super(properties);
  }

  protected override discount(player: IPlayer): number {
    if (player.playedCards.find((card) => card.name === CardName.MOONCRATE_BLOCK_FACTORY)) {
      return 4;
    }
    return super.discount(player);
  }

  public override canAct(player: IPlayer): boolean {
    const moonData = MoonExpansion.moonData(player.game);
    const spaces = moonData.moon.getAvailableSpacesForMine(player);

    if (spaces.length === 0) {
      return false;
    }

    return super.canAct(player);
  }

  actionEssence(player: IPlayer): void {
    const adjustedReserveUnits = MoonExpansion.adjustedReserveCosts(player, this);
    player.stock.deductUnits(adjustedReserveUnits);
    player.game.defer(new PlaceMoonMineTile(player));
    player.production.add(Resource.STEEL, 1, {log: true});
  }
}

================
File: cards/moon/MoonRoadStandardProject.ts
================
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {StandardProjectCard} from '../StandardProjectCard';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {PlaceMoonRoadTile} from '../../moon/PlaceMoonRoadTile';
import {TileType} from '../../../common/TileType';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class MoonRoadStandardProject extends StandardProjectCard {
  constructor(properties = {
    name: CardName.MOON_ROAD_STANDARD_PROJECT,
    cost: 18,
    reserveUnits: {steel: 1},
    tr: {moonLogistics: 1},
    tilesBuilt: [TileType.MOON_ROAD],

    metadata: {
      cardNumber: '',
      renderData: CardRenderer.builder((b) =>
        b.standardProject('Spend 18 M€ and 1 steel to place a road on The Moon and raise the Logistics Rate 1 step.', (eb) => {
          eb.megacredits(18).steel(1).startAction.moonRoad({secondaryTag: AltSecondaryTag.MOON_LOGISTICS_RATE});
        }),
      ),
    },
  }) {
    super(properties);
  }

  protected override discount(player: IPlayer): number {
    if (player.playedCards.find((card) => card.name === CardName.MOONCRATE_BLOCK_FACTORY)) {
      return 4;
    }
    return super.discount(player);
  }

  public override canAct(player: IPlayer): boolean {
    const moonData = MoonExpansion.moonData(player.game);
    const spaces = moonData.moon.getAvailableSpacesOnLand(player);

    if (spaces.length === 0) {
      return false;
    }

    return super.canAct(player);
  }

  actionEssence(player: IPlayer): void {
    const adjustedReserveUnits = MoonExpansion.adjustedReserveCosts(player, this);
    player.stock.deductUnits(adjustedReserveUnits);
    player.game.defer(new PlaceMoonRoadTile(player));
  }
}

================
File: cards/moon/MoonStandardProjectVariants1.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardRenderer} from '../render/CardRenderer';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {MoonHabitatStandardProject} from './MoonHabitatStandardProject';
import {MoonMineStandardProject} from './MoonMineStandardProject';
import {MoonRoadStandardProject} from './MoonRoadStandardProject';
import {TileType} from '../../../common/TileType';

export class MoonHabitatStandardProjectVariant1 extends MoonHabitatStandardProject {
  constructor() {
    super({
      name: CardName.MOON_HABITAT_STANDARD_PROJECT_VARIANT_1,
      cost: 23,
      reserveUnits: {titanium: 1},
      tr: {moonHabitat: 1},
      tilesBuilt: [TileType.MOON_HABITAT],

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 23 M€ (titanium may be used) AND 1 titanium to place a habitat on The Moon and raise your M€ production 1 step.', (eb) => {
            eb.megacredits(23).super((b) => b.titanium(1)).titanium(1).startAction.moonHabitat({secondaryTag: AltSecondaryTag.MOON_HABITAT_RATE}).production((pb) => pb.megacredits(1));
          }),
        ),
      },
    });
  }

  public override canAct(player: IPlayer) {
    return player.game.gameOptions.moonStandardProjectVariant1 && super.canAct(player);
  }

  public override canPayWith() {
    return {titanium: true};
  }
}

export class MoonMineStandardProjectVariant1 extends MoonMineStandardProject {
  constructor() {
    super({
      name: CardName.MOON_MINE_STANDARD_PROJECT_VARIANT_1,
      cost: 21,
      reserveUnits: {titanium: 1},
      tr: {moonMining: 1},
      tilesBuilt: [TileType.MOON_MINE],

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 21 M€ (titanium may be used) AND 1 titanium to place a mine on The Moon, raise the mining rate 1 step, and raise steel production 1 step.', (eb) => {
            eb.megacredits(21).super((b) => b.titanium(1)).titanium(1).startAction.moonMine({secondaryTag: AltSecondaryTag.MOON_MINING_RATE}).production((pb) => pb.steel(1));
          }),
        ),
      },
    });
  }

  public override canAct(player: IPlayer) {
    return player.game.gameOptions.moonStandardProjectVariant1 && super.canAct(player);
  }

  public override canPayWith() {
    return {titanium: true};
  }
}

export class MoonRoadStandardProjectVariant1 extends MoonRoadStandardProject {
  constructor() {
    super({
      name: CardName.MOON_ROAD_STANDARD_PROJECT_VARIANT_1,
      cost: 19,
      reserveUnits: {steel: 1},
      tr: {moonLogistics: 1},
      tilesBuilt: [TileType.MOON_ROAD],

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 19 M€ (steel may be used) AND 1 steel to place a road on The Moon and raise the Logistics Rate 1 step.', (eb) => {
            eb.megacredits(19).super((b) => b.steel(1)).steel(1).startAction.moonRoad({secondaryTag: AltSecondaryTag.MOON_LOGISTICS_RATE});
          }),
        ),
      },
    });
  }

  public override canAct(player: IPlayer) {
    return player.game.gameOptions.moonStandardProjectVariant1 && super.canAct(player);
  }

  public override canPayWith() {
    return {steel: true};
  }
}

================
File: cards/moon/MoonStandardProjectVariants2.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {Units} from '../../../common/Units';
import {CardRenderer} from '../render/CardRenderer';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {MoonHabitatStandardProject} from './MoonHabitatStandardProject';
import {MoonMineStandardProject} from './MoonMineStandardProject';
import {MoonRoadStandardProject} from './MoonRoadStandardProject';
import {TileType} from '../../../common/TileType';

export class MoonHabitatStandardProjectVariant2 extends MoonHabitatStandardProject {
  constructor() {
    super({
      name: CardName.MOON_HABITAT_STANDARD_PROJECT_VARIANT_2,
      cost: 26,
      reserveUnits: Units.EMPTY,
      tr: {moonHabitat: 1},
      tilesBuilt: [TileType.MOON_HABITAT],

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 26 M€ to place a habitat on The Moon and raise your M€ production 1 step.', (eb) => {
            eb.megacredits(26).startAction.moonHabitat({secondaryTag: AltSecondaryTag.MOON_HABITAT_RATE}).production((pb) => pb.megacredits(1));
          }),
        ),
      },
    });
  }

  public override canAct(player: IPlayer) {
    return player.game.gameOptions.moonStandardProjectVariant && super.canAct(player);
  }
}

export class MoonMineStandardProjectVariant2 extends MoonMineStandardProject {
  constructor() {
    super({
      name: CardName.MOON_MINE_STANDARD_PROJECT_VARIANT_2,
      cost: 23,
      reserveUnits: Units.EMPTY,
      tr: {moonMining: 1},
      tilesBuilt: [TileType.MOON_MINE],

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 23 M€ to place a mine on The Moon, raise the mining rate 1 step, and raise steel production 1 step.', (eb) => {
            eb.megacredits(23).startAction.moonMine({secondaryTag: AltSecondaryTag.MOON_MINING_RATE}).production((pb) => pb.steel(1));
          }),
        ),
      },
    });
  }

  public override canAct(player: IPlayer) {
    return player.game.gameOptions.moonStandardProjectVariant && super.canAct(player);
  }
}

export class MoonRoadStandardProjectVariant2 extends MoonRoadStandardProject {
  constructor() {
    super({
      name: CardName.MOON_ROAD_STANDARD_PROJECT_VARIANT_2,
      cost: 21,
      reserveUnits: Units.EMPTY,
      tr: {moonLogistics: 1},
      tilesBuilt: [TileType.MOON_ROAD],

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 21 M€ to place a road on The Moon and raise the Logistics Rate 1 step.', (eb) => {
            eb.megacredits(21).startAction.moonRoad({secondaryTag: AltSecondaryTag.MOON_LOGISTICS_RATE});
          }),
        ),
      },
    });
  }

  public override canAct(player: IPlayer) {
    return player.game.gameOptions.moonStandardProjectVariant && super.canAct(player);
  }
}

================
File: cards/moon/MoonTether.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class MoonTether extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.MOON_TETHER,
      type: CardType.ACTIVE,
      tags: [Tag.MOON, Tag.SPACE],
      cost: 18,
      victoryPoints: 1,

      requirements: {tag: Tag.SPACE, count: 6},
      cardDiscount: {amount: 2},
      metadata: {
        cardNumber: 'M90',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a card, you pay 2 M€ less for it.', (eb) => {
            eb.empty().startEffect.megacredits(-2);
          }).br;
        }),
        description: 'Requires 6 space tags.',
      },
    });
  }
}

================
File: cards/moon/NanotechIndustries.ts
================
import {CardName} from '../../../common/cards/CardName';
import {Tag} from '../../../common/cards/Tag';
import {CorporationCard} from '../corporation/CorporationCard';
import {CardRenderer} from '../render/CardRenderer';
import {IActionCard} from '../ICard';
import {CardResource} from '../../../common/CardResource';
import {IPlayer} from '../../IPlayer';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {MoonCards} from '../../moon/MoonCards';

export class NanotechIndustries extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.NANOTECH_INDUSTRIES,
      tags: [Tag.SCIENCE, Tag.MOON],
      startingMegaCredits: 42,
      resourceType: CardResource.SCIENCE,

      firstAction: {
        text: 'Draw 3 cards and keep 2.',
        drawCard: {count: 3, keep: 2},
      },

      victoryPoints: {resourcesHere: {}, per: 2},

      metadata: {
        cardNumber: 'MC1',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(42).cards(3).minus().cards(1).br;
          b.action('Add 1 science resource to ANY card [except those giving 2 or more VP per 1 science resource.]', (eb) => {
            eb.empty().startAction.resource(CardResource.SCIENCE).asterix();
          });
        }),
        description: 'You start with 42 M€. As your first action, draw 3 cards. Take 2 of them into hand, and discard the rest. ' +
          '1 VP for every 2 science resources here.',
      },
    });
  }

  public canAct() {
    return true;
  }

  public action(player: IPlayer) {
    player.game.defer(new AddResourcesToCard(
      player,
      CardResource.SCIENCE,
      {filter: (card): boolean => MoonCards.scienceCardsWithLessThan2VP.has(card.name)},
    ));
    return undefined;
  }
}

================
File: cards/moon/NewColonyPlanningInitiatives.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';

export class NewColonyPlanningInitiatives extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.NEW_COLONY_PLANNING_INITIAITIVES,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON],
      cost: 6,

      behavior: {
        moon: {habitatRate: 1},
      },

      requirements: {habitatRate: 2},
      metadata: {
        description: 'Requires the habitat rate to be 2 or higher. Raise the habitat rate 1 step.',
        cardNumber: 'M31',
        renderData: CardRenderer.builder((b) => {
          b.moonHabitatRate();
        }),
      },
    });
  }
}

================
File: cards/moon/OffWorldCityLiving.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all} from '../Options';

export class OffWorldCityLiving extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.OFF_WORLD_CITY_LIVING,
      type: CardType.AUTOMATED,
      tags: [Tag.CITY, Tag.SPACE],
      cost: 35,
      victoryPoints: {cities: {}, all: true, per: 3},

      behavior: {
        moon: {habitatRate: 1},
        production: {megacredits: {cities: {where: 'offmars'}}},
      },

      metadata: {
        // Check the card for a clever icon.
        description: 'Increase your M€ production 1 step per city tile NOT ON MARS. Increase habitat rate 1 step.',
        cardNumber: 'M53',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1)).slash().city({all, secondaryTag: Tag.SPACE}).br;
          b.moonHabitatRate().br;
          b.vpText('1 VP for every 3rd City in play.');
        }),
      },
    });
  }
}

================
File: cards/moon/OrbitalPowerGrid.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all} from '../Options';

export class OrbitalPowerGrid extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.ORBITAL_POWER_GRID,
      type: CardType.AUTOMATED,
      tags: [Tag.POWER, Tag.SPACE],
      cost: 19,
      victoryPoints: 1,

      behavior: {
        production: {energy: {cities: {where: 'offmars'}}},
      },

      metadata: {
        description: 'Increase your energy production 1 step per city tile NOT ON MARS.',
        cardNumber: 'M85',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1)).slash().city({all, secondaryTag: Tag.SPACE});
        }),
      },
    });
  }
}

================
File: cards/moon/PreliminaryDarkside.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {Resource} from '../../../common/Resource';
import {Card} from '../Card';
import {digit} from '../Options';

export class PreliminaryDarkside extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.PRELIMINARY_DARKSIDE,
      type: CardType.EVENT,
      tags: [Tag.MOON],
      cost: 13,

      behavior: {
        moon: {miningRate: 1},
      },

      metadata: {
        description: 'Gain 3 titanium or 4 steel. Raise the mining rate 1 step.',
        cardNumber: 'M63',
        renderData: CardRenderer.builder((b) => {
          b.titanium(3, {digit}).or().steel(4, {digit}).br;
          b.moonMiningRate();
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    return new OrOptions(
      new SelectOption('Gain 3 titanium', 'Gain titanium').andThen(() => {
        player.stock.add(Resource.TITANIUM, 3, {log: true});
        return undefined;
      }),
      new SelectOption('Gain 4 steel', 'Gain steel').andThen(() => {
        player.stock.add(Resource.STEEL, 4, {log: true});
        return undefined;
      }));
  }
}

================
File: cards/moon/PrideoftheEarthArkship.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {IActionCard} from '../ICard';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class PrideoftheEarthArkship extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.PRIDE_OF_THE_EARTH_ARKSHIP,
      type: CardType.ACTIVE,
      tags: [Tag.SCIENCE, Tag.SCIENCE, Tag.SPACE],
      cost: 22,

      resourceType: CardResource.SCIENCE,
      victoryPoints: {resourcesHere: {}},
      requirements: [{tag: Tag.SCIENCE}, {tag: Tag.SPACE, count: 2}],
      reserveUnits: {titanium: 2},

      action: {
        addResources: {tag: Tag.SCIENCE, per: 5},
      },

      metadata: {
        description: 'Requires 1 science and 2 space tags. Spend 2 titanium. 1 VP per science resource here.',
        cardNumber: 'M24',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 science resource here per every 5 science tags you have.', (eb) => {
            eb.empty().startAction.resource(CardResource.SCIENCE).slash().text('5').tag(Tag.SCIENCE);
          }).br;
          b.minus().titanium(2);
        }),
      },
    });
  }
}

================
File: cards/moon/ProcessorFactory.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class ProcessorFactory extends ActionCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.PROCESSOR_FACTORY,
      type: CardType.ACTIVE,
      tags: [Tag.MOON, Tag.BUILDING],
      cost: 8,

      action: {
        spend: {steel: 1},
        addResourcesToAnyCard: {type: CardResource.DATA, count: 2},
      },

      resourceType: CardResource.DATA,
      victoryPoints: {resourcesHere: {}, per: 3},

      metadata: {
        cardNumber: 'M86',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 steel to add 2 data resources to ANY card.', (eb) => eb.startAction.steel(1).arrow().resource(CardResource.DATA, 2).asterix());
          b.br;
          b.vpText('1 VP for every 3 data resources here.');
        }),
      },
    });
  }
}

================
File: cards/moon/RevoltingColonists.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {message} from '../../logs/MessageBuilder';

export class RevoltingColonists extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.REVOLTING_COLONISTS,
      type: CardType.EVENT,
      tags: [Tag.MOON],
      cost: 3,
      requirements: {habitatRate: 4},

      metadata: {
        description: 'Requires 4 habitat rate. All players pay 3M€ for each habitat tile they own.',
        cardNumber: 'M51',
        renderData: CardRenderer.builder((b) => {
          b.minus().megacredits(3, {all}).slash().moonHabitat({size: Size.SMALL, all});
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    const colonies = MoonExpansion.spaces(game, TileType.MOON_HABITAT);
    game.getPlayers().forEach((target) => {
      const owned = colonies.filter((colony) => colony.player?.id === target.id).length;
      if (owned > 0) {
        const bill = owned * 3;
        const owes = Math.min(bill, target.spendableMegacredits());

        if (owes > 0) {
          target.maybeBlockAttack(player, (proceed) => {
            if (proceed) {
              game.defer(new SelectPaymentDeferred(target, owes, {
                title: message('You must spend ${0} M€ for ${1} habitat tiles', (b) => b.number(owes).number(owned))}))
                .andThen(() =>
                  game.log(
                    '${0} spends ${1} M€ for the ${2} habitat tiles they own.',
                    (b) => b.player(target).number(owes).number(owned)));
            }
            return undefined;
          });
        }
      }
    });
    return undefined;
  }
}

================
File: cards/moon/RoadPiracy.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all, digit} from '../Options';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {message} from '../../logs/MessageBuilder';
import {AndOptions} from '../../inputs/AndOptions';
import {SelectAmount} from '../../inputs/SelectAmount';
import {Resource} from '../../../common/Resource';
import {sum} from '../../../common/utils/utils';
import {Message} from '../../../common/logs/Message';
import {SimpleDeferredAction} from '../../deferredActions/DeferredAction';
import {Priority} from '../../deferredActions/Priority';

export class RoadPiracy extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.ROAD_PIRACY,
      type: CardType.EVENT,
      tags: [Tag.MOON],
      cost: 10,
      requirements: {logisticRate: 3},

      metadata: {
        description: 'Requires 3 logistic rate. ' +
          'Steal up to 6 steel or 4 titanium from other players. ' +
          '(Resources may be stolen from more than 1 opponent.)',
        cardNumber: 'M54',
        renderData: CardRenderer.builder((b) => {
          b.text('STEAL').steel(6, {all}).slash().titanium(4, {all, digit}).asterix();
        }),
      },
    });
  }

  private generateOption(player: IPlayer, resource: Resource, title: Message, limit: number) {
    const selectAmounts = [];
    const ledger: Map<IPlayer, number> = new Map();
    for (const opponent of player.getOpponents()) {
      if (opponent.stock.get(resource) > 0 && !opponent.alloysAreProtected()) {
        const selectAmount =
          new SelectAmount(
            message('${0}', (b) => b.player(opponent)), undefined, 0, opponent.stock.get(resource))
            .andThen((amount: number) => {
              ledger.set(opponent, amount);
              return undefined;
            });
        selectAmounts.push(selectAmount);
      }
    }
    if (selectAmounts.length === 0) {
      return undefined;
    }

    const cb = () => {
      const total = sum(Array.from(ledger.values()));
      if (total > limit) {
        // throw new Error(newMessage('You may only steal up to ${0} ${1} from all players', (b) => b.number(limit).string(resource)));
        ledger.clear();
        throw new Error(`You may only steal up to ${limit} ${resource} from all players`);
      }
      for (const [target, count] of ledger) {
        target.maybeBlockAttack(player, (proceed) => {
          if (proceed) {
            target.stock.steal(resource, count, player);
          }
          return undefined;
        });
      }
      return undefined;
    };
    // TODO(kberg): does title always have to be set separately? That's fixable.
    const option = new AndOptions(...selectAmounts).andThen(cb);
    option.title = title;
    return option;
  }


  public override bespokePlay(player: IPlayer) {
    player.game.defer(new SimpleDeferredAction(player, () => this.do(player)), Priority.ATTACK_OPPONENT);
    return undefined;
  }

  public do(player: IPlayer) {
    const game = player.game;
    const stealSteel = message('Steal ${0} steel', (b) => b.number(6));
    const stealTitanium = message('Steal ${0} titanium', (b) => b.number(4));
    if (game.isSoloMode()) {
      return new OrOptions(
        new SelectOption(stealSteel, 'Steal steel').andThen(() => {
          player.steel += 6;
          return undefined;
        }),
        new SelectOption(stealTitanium, 'Steal titanium').andThen(() => {
          player.titanium += 4;
          return undefined;
        }),
      );
    }

    const options = new OrOptions();

    const steelOption = this.generateOption(player, Resource.STEEL, stealSteel, 6);
    if (steelOption !== undefined) {
      options.options.push(steelOption);
    }

    const titaniumOption = this.generateOption(player, Resource.TITANIUM, stealTitanium, 4);
    if (titaniumOption !== undefined) {
      options.options.push(titaniumOption);
    }

    if (options.options.length === 0) {
      return undefined;
    }

    options.options.push(new SelectOption('Do not steal'));
    return options;
  }
}

================
File: cards/moon/RoverDriversUnion.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {Resource} from '../../../common/Resource';
import {Card} from '../Card';

export class RoverDriversUnion extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.ROVER_DRIVERS_UNION,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON],
      cost: 16,
      requirements: {logisticRate: 2},

      behavior: {
        moon: {logisticsRate: 1},
      },

      metadata: {
        description: 'Requires 2 logistic rate. Raise the logistic rate 1 step. Increase your M€ production 1 step per logistic rate.',
        cardNumber: 'M78',
        renderData: CardRenderer.builder((b) => {
          b.moonLogisticsRate().br;
          b.production((pb) => pb.megacredits(1)).slash().moonLogisticsRate();
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    MoonExpansion.ifMoon(player.game, (moonData) => {
      player.production.add(Resource.MEGACREDITS, moonData.logisticRate, {log: true});
    });
    return undefined;
  }
}

================
File: cards/moon/RustEatingBacteria.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class RustEatingBacteria extends ActionCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.RUST_EATING_BACTERIA,
      type: CardType.ACTIVE,
      tags: [Tag.MICROBE],
      cost: 7,

      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 3},

      action: {
        spend: {steel: 1},
        addResources: 2,
      },

      metadata: {
        cardNumber: 'M88',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 steel to add 2 microbes here.', (eb) => {
            eb.startAction.steel(1).arrow().resource(CardResource.MICROBE, 2);
          }).br;
          b.vpText('1 VP per 3 microbes here.');
        }),
      },
    });
  }
}

================
File: cards/moon/SinusIrdiumRoadNetwork.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class SinusIrdiumRoadNetwork extends Card {
  constructor() {
    super({
      name: CardName.SINUS_IRDIUM_ROAD_NETWORK,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON],
      cost: 15,

      behavior: {
        production: {energy: -1, megacredits: 3},
        moon: {
          roadTile: {},
        },
      },
      reserveUnits: {steel: 1},

      metadata: {
        description: 'Decrease your energy production 1 step and increase your M€ production 3 steps. ' +
          'Spend 1 steel. ' +
          'Place a road tile on The Moon and raise the Logistics Rate 1 step.',
        cardNumber: 'M11',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).nbsp.plus().megacredits(3);
          }).br;
          b.minus().steel(1).br;
          b.moonRoad({secondaryTag: AltSecondaryTag.MOON_LOGISTICS_RATE});
        }),
      },
    });
  }
}

================
File: cards/moon/SmallDutyRovers.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {SpaceType} from '../../../common/boards/SpaceType';
import {Resource} from '../../../common/Resource';
import {Size} from '../../../common/cards/render/Size';
import {TileType} from '../../../common/TileType';
import {all} from '../Options';
import {Card} from '../Card';

export class SmallDutyRovers extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.SMALL_DUTY_ROVERS,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON, Tag.SPACE],
      cost: 9,
      reserveUnits: {titanium: 1},

      behavior: {
        moon: {logisticsRate: 1},
      },

      metadata: {
        description: 'Spend 1 titanium. Raise the logistic rate 1 step. Gain 1 M€ per habitat tile, mine tile and road tile on The Moon.',
        cardNumber: 'M73',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1).moonLogisticsRate().br;
          b.megacredits(1).slash()
            .moonHabitat({size: Size.SMALL, all})
            .moonMine({size: Size.SMALL, all})
            .moonRoad({size: Size.SMALL, all});
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const moonData = MoonExpansion.moonData(player.game);
    let gain = moonData.moon.spaces.filter((s) => s.tile !== undefined && s.spaceType !== SpaceType.COLONY).length;
    if (moonData.moon.spaces.some((s) => s.tile?.tileType === TileType.LUNAR_MINE_URBANIZATION)) {
      gain++;
    }
    player.stock.add(Resource.MEGACREDITS, gain, {log: true});

    return undefined;
  }
}

================
File: cards/moon/SolarPanelFoundry.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class SolarPanelFoundry extends ActionCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.SOLAR_PANEL_FOUNDRY,
      type: CardType.ACTIVE,
      tags: [Tag.POWER, Tag.MOON, Tag.BUILDING],
      cost: 11,

      action: {
        spend: {steel: 2},
        production: {energy: 1},
      },

      metadata: {
        cardNumber: 'M89',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 steel to increase your energy production 1 step.',
            (eb) => eb.startAction.steel(2).arrow().production((pb) => pb.energy(1)));
        }),
      },
    });
  }
}

================
File: cards/moon/SphereHabitats.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class SphereHabitats extends Card {
  constructor() {
    super({
      name: CardName.SPHERE_HABITATS,
      type: CardType.AUTOMATED,
      tags: [Tag.CITY, Tag.MOON],
      cost: 14,
      reserveUnits: {titanium: 1},

      behavior: {
        moon: {
          habitatTile: {},
        },
      },

      metadata: {
        description: 'Spend 1 titanium. Place a habitat tile on The Moon and raise the habitat rate 1 step.',
        cardNumber: 'M07',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(1).br;
          b.moonHabitat({secondaryTag: AltSecondaryTag.MOON_HABITAT_RATE});
        }),
      },
    });
  }
}

================
File: cards/moon/StagingStationBehemoth.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class StagingStationBehemoth extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.STAGING_STATION_BEHEMOTH,
      type: CardType.AUTOMATED,
      tags: [Tag.SPACE],
      cost: 24,

      behavior: {
        moon: {logisticsRate: 1},
        colonies: {addTradeFleet: 2},
      },

      metadata: {
        description: 'Gain 2 Trade Fleets. Raise the logistic rate 1 step.',
        cardNumber: 'M68',
        renderData: CardRenderer.builder((b) => {
          b.tradeFleet().tradeFleet().moonLogisticsRate();
        }),
      },
    });
  }
}

================
File: cards/moon/SteelMarketMonopolists.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {MarketCard} from './MarketCard';

export class SteelMarketMonopolists extends MarketCard {
  constructor() {
    super(
      Resource.STEEL,
      {from: 3, to: 2, limit: 3},
      {from: 1, to: 3, limit: 3},
      {
        name: CardName.STEEL_MARKET_MONOPOLISTS,
        type: CardType.ACTIVE,
        cost: 15,
        requirements: {miningRate: 3},

        metadata: {
          description: 'Requires the mining rate to be 3 or higher.',
          cardNumber: 'M28',
          renderData: CardRenderer.builder((b) => {
            b.action('Spend 3X M€ to gain 2X steel (max 9 M€)', (eb) => {
              eb.megacredits(1, {text: '3x'}).startAction.text('x').steel(2).asterix();
            }).br;
            b.or().br;
            b.action('Spend X steel to gain 3X M€ (max 3 steel).', (eb) => {
              eb.text('X').steel(1).startAction.text('x').megacredits(3).asterix();
            });
          }),
        },
      });
  }
}

================
File: cards/moon/SubterraneanHabitats.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class SubterraneanHabitats extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.SUBTERRANEAN_HABITATS,
      type: CardType.ACTIVE,
      tags: [Tag.MOON],
      cost: 12,
      reserveUnits: {steel: 2},

      behavior: {
        moon: {habitatRate: 1},
      },

      metadata: {
        description: 'Spend 2 steel. Raise the habitat rate 1 step.',
        cardNumber: 'M36',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you build a habitat on THE MOON, you spend 1 titanium less.', (eb) => {
            eb.startEffect.moonHabitat().colon().minus().titanium(1);
          });
          b.br;
          b.minus().steel(2).moonHabitatRate();
        }),
      },
    });
  }
}

================
File: cards/moon/SyndicatePirateRaids.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class SyndicatePirateRaids extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.SYNDICATE_PIRATE_RAIDS,
      type: CardType.EVENT,
      tags: [Tag.SPACE],
      cost: 8,

      metadata: {
        description: 'ALL OPPONENTS CANNOT RETRIEVE THEIR TRADE FLEETS THIS GENERATION',
        cardNumber: 'M65',
        renderData: CardRenderer.builder((b) => {
          b.tradeFleet().asterix();
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    game.syndicatePirateRaider = player.id;

    game.log(
      'All players except ${0} may not retrieve their trade fleets this generation.',
      (b) => b.player(player));
    return undefined;
  }
}

================
File: cards/moon/TempestConsultancy.ts
================
import {CardName} from '../../../common/cards/CardName';
import {SendDelegateToArea} from '../../deferredActions/SendDelegateToArea';
import {IPlayer} from '../../IPlayer';
import {CorporationCard} from '../corporation/CorporationCard';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {Tag} from '../../../common/cards/Tag';
import {Turmoil} from '../../turmoil/Turmoil';
import {digit} from '../Options';

export class TempestConsultancy extends CorporationCard {
  constructor() {
    super({
      name: CardName.TEMPEST_CONSULTANCY,
      tags: [Tag.MOON],
      startingMegaCredits: 37,

      firstAction: {
        text: 'Place 2 delegates in one party',
        turmoil: {sendDelegates: {count: 2}},
      },

      metadata: {
        description: 'You start with 37 M€. As your first action, place 2 delegates in one party.',
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(37).delegates(1).delegates(1).br;
          b.action('Place 1 delegate in any party for every 5 Moon tags you have [max 3.]', (eb) => {
            eb.empty().startAction.delegates(1).text('(max 3)', Size.SMALL).slash().tag(Tag.MOON, {amount: 5, digit});
          }).br;
          b.effect('When your delegate becomes the chairman, increase your TR 1 step.', (eb) => {
            eb.chairman().startEffect.tr(1);
          });
        }),
      },
    });
  }

  public initialAction(player: IPlayer) {
    const title = 'Tempest Consultancy first action - Select where to send two delegates';
    player.game.defer(new SendDelegateToArea(player, title, {count: 2}));

    return undefined;
  }

  public canAct(player: IPlayer) {
    return player.tags.count(Tag.MOON) >= 5 && Turmoil.getTurmoil(player.game).getAvailableDelegateCount(player) > 0;
  }

  public action(player: IPlayer) {
    let count = Math.floor(player.tags.count(Tag.MOON) / 5);
    count = Math.min(count, 3);
    count = Math.min(count, Turmoil.getTurmoil(player.game).getAvailableDelegateCount(player));
    if (count > 0) {
      player.game.defer(new SendDelegateToArea(
        player,
        `Select a party to send ${count} delegate(s) to`,
        {count: count}));
    }
    return undefined;
  }
}

================
File: cards/moon/TheArchaicFoundationInstitute.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CorporationCard} from '../corporation/CorporationCard';
import {IProjectCard} from '../IProjectCard';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';
import {ICard} from '../ICard';
import {Size} from '../../../common/cards/render/Size';
import {digit} from '../Options';
import {LogHelper} from '../../LogHelper';

export class TheArchaicFoundationInstitute extends CorporationCard {
  constructor() {
    super({
      name: CardName.THE_ARCHAIC_FOUNDATION_INSTITUTE,
      tags: [Tag.MOON, Tag.MOON],
      startingMegaCredits: 55,
      resourceType: CardResource.RESOURCE_CUBE,

      behavior: {
        addResources: 2,
      },

      metadata: {
        hasExternalHelp: true,
        cardNumber: '',
        description: 'You start with 55 M€.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(55).nbsp;
          b.effect('When you play a Moon tag, including these, add a cube to this card.', (eb) => {
            eb.tag(Tag.MOON).startEffect.resource(CardResource.RESOURCE_CUBE);
          }).br;
          b.effect('Automatically remove 3 cubes here and gain 1 TR.', (eb) => {
            eb.resource(CardResource.RESOURCE_CUBE, {amount: 3, digit}).startEffect.tr(1, {size: Size.TINY});
          }).br;
          b.action('Remove 3 cubes here; gain 1 TR.', (ab) => {
            ab.resource(CardResource.RESOURCE_CUBE, {amount: 3, digit}).startAction.tr(1, {size: Size.TINY});
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    if (player.isCorporation(this.name)) {
      const moonTags = card.tags.filter((t) => t === Tag.MOON);
      const count = moonTags.length;
      if (count > 0) {
        player.addResourceTo(this, {qty: count, log: true});
      }
    }
  }

  public canAct(player: IPlayer) {
    return (this.resourceCount >= 3 && player.canAfford({cost: 0, tr: {tr: 1}}));
  }

  // The only reason Archaic Foundation Institute has an action is if Reds is
  // in effect when the player gains the Moon tag. Ideally, this is always
  // automatically resolved, even at strange times, even production.
  //
  public action(player: IPlayer) {
    // How should this interact in a Merger with UNMO?
    let tr = Math.floor(this.resourceCount / 3);
    while (!player.canAfford({cost: 0, tr: {tr: tr}})) {
      tr--;
    }
    player.removeResourceFrom(this, tr * 3);
    player.increaseTerraformRating(tr);
    LogHelper.logRemoveResource(player, this, tr * 3, `Gain ${tr} TR`);
  }

  public onResourceAdded(player: IPlayer, playedCard: ICard): void {
    if (playedCard.name !== this.name) return;
    if (this.canAct(player)) {
      this.action(player);
    }
  }
}

================
File: cards/moon/TheDarksideofTheMoonSyndicate.ts
================
import {CardName} from '../../../common/cards/CardName';
import {Tag} from '../../../common/cards/Tag';
import {CorporationCard} from '../corporation/CorporationCard';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {MultiSet} from 'mnemonist';
import {Resource} from '../../../common/Resource';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {Size} from '../../../common/cards/render/Size';
import {Phase} from '../../../common/Phase';
import {all} from '../Options';
import {Payment} from '../../../common/inputs/Payment';

export class TheDarksideofTheMoonSyndicate extends CorporationCard {
  constructor() {
    super({
      name: CardName.THE_DARKSIDE_OF_THE_MOON_SYNDICATE,
      tags: [Tag.MOON],
      startingMegaCredits: 40,
      resourceType: CardResource.SYNDICATE_FLEET,

      behavior: {
        addResources: 2,
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(40).resource(CardResource.SYNDICATE_FLEET, 2).br;
          b.text('You start with 40 M€ and 2 syndicate fleets on this card.', Size.SMALL, false, false).br;
          b.titanium(1).arrow(Size.SMALL).resource(CardResource.SYNDICATE_FLEET)
            .slash(Size.SMALL)
            .resource(CardResource.SYNDICATE_FLEET).arrow(Size.SMALL).text('steal', Size.TINY).megacredits(2, {all}).asterix().br;
          b.text('Action: Spend 1 titanium to add 1 syndicate fleet on this card OR ' +
                'remove 1 syndicate fleet from this card to steal 2M€ from every opponent.', Size.TINY, false, false).br;
          b.effect('When you place a tile on The Moon, steal 2 M€ from opponents for each of their tiles next to yours.', (eb) => {
            eb.emptyTile('normal', {size: Size.SMALL, secondaryTag: Tag.MOON})
              .startEffect
              .text('STEAL').megacredits(2, {all}).slash().emptyTile('normal', {size: Size.SMALL}).emptyTile('normal', {size: Size.SMALL, all});
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.titanium > 0 || this.resourceCount > 0;
  }

  public action(player: IPlayer) {
    const orOptions = new OrOptions();
    if (player.titanium > 0) {
      orOptions.options.push(new SelectOption('Spend 1 titanium to add 1 syndicate fleet on this card', 'Add syndicate fleet').andThen(() => {
        player.pay(Payment.of({titanium: 1}));
        player.addResourceTo(this, {qty: 1, log: true});
        return undefined;
      }));
    }
    if (this.resourceCount > 0) {
      orOptions.options.push(new SelectOption('Remove 1 syndicate fleet from this card to steal 2M€ from every opponent.', 'Remove syndicate fleet').andThen(() => {
        player.removeResourceFrom(this);
        for (const target of player.getOpponents()) {
          target.maybeBlockAttack(player, (proceed) => {
            if (proceed) {
              target.stock.steal(Resource.MEGACREDITS, 2, player);
            }
            return undefined;
          });
        }
        return undefined;
      }));
    }

    if (orOptions.options.length === 1) {
      return orOptions.options[0].cb();
    }
    return orOptions;
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (activePlayer.game.phase === Phase.SOLAR) {
      return;
    }
    if (activePlayer !== cardOwner) {
      return undefined;
    }
    // Unlikely, but the compiler now thinks space.tile is defined.
    if (space.tile === undefined) {
      return undefined;
    }
    const game = activePlayer.game;
    if (MoonExpansion.MOON_TILES.has(space.tile.tileType)) {
      const costs = new MultiSet<IPlayer>();
      MoonExpansion.moonData(game).moon.getAdjacentSpaces(space).forEach((space) => {
        if (space.tile !== undefined && space.player !== undefined && space.player !== activePlayer) {
          costs.add(space.player, 2);
        }
      });
      costs.forEachMultiplicity((qty, target) => {
        // TODO(kberg): Create a Game.steal method that manages this, both here
        // and in StealResources.
        const adjustedQuantity = Math.min(qty, target.megaCredits);
        activePlayer.stock.add(Resource.MEGACREDITS, adjustedQuantity, {log: true});
        target.stock.deduct(Resource.MEGACREDITS, adjustedQuantity, {log: true, from: activePlayer});
      });
    }
    return undefined;
  }
}

================
File: cards/moon/TheGrandLunaCapitalGroup.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CorporationCard} from '../corporation/CorporationCard';
import {CardRenderer} from '../render/CardRenderer';
import {TileType} from '../../../common/TileType';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {Space} from '../../boards/Space';
import {SpaceId} from '../../../common/Types';
import {Resource} from '../../../common/Resource';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';
import {Size} from '../../../common/cards/render/Size';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {all} from '../Options';

export class TheGrandLunaCapitalGroup extends CorporationCard {
  constructor() {
    super({
      name: CardName.THE_GRAND_LUNA_CAPITAL_GROUP,
      tags: [Tag.CITY, Tag.MOON],
      startingMegaCredits: 32,
      victoryPoints: 'special',

      behavior: {
        stock: {titanium: 1},
      },

      firstAction: {
        text: 'Place a habitat tile',
        moon: {habitatTile: {}},
      },

      metadata: {
        description: {
          text: 'You start with 32 M€ and 1 titanium. As your first action, place a habitat tile on The Moon and raise the habitat rate 1 step.',
          align: 'left',
        },
        cardNumber: 'MC7',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(32).titanium(1).moonHabitat({secondaryTag: AltSecondaryTag.MOON_HABITAT_RATE}).br;
          b.effect('When you place a habitat tile, gain 2 M€ for each adjacent habitat tile.', (eb) => {
            eb.moonHabitat({size: Size.SMALL, all}).moonHabitat({size: Size.SMALL}).asterix()
              .startEffect
              .megacredits(2).slash().moonHabitat({size: Size.SMALL, all});
          }).br,
          b.vpText('1 VP for each habitat tile adjacent to your habitat tiles.').br;
        }),
        victoryPoints: CardRenderDynamicVictoryPoints.moonHabitatTile(1),
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (cardOwner.id !== activePlayer.id) {
      return;
    }
    if (!MoonExpansion.spaceHasType(space, TileType.MOON_HABITAT)) {
      return;
    }
    const adjacentSpaces = MoonExpansion.moonData(cardOwner.game).moon.getAdjacentSpaces(space);
    const filtered = adjacentSpaces.filter((space) => MoonExpansion.spaceHasType(space, TileType.MOON_HABITAT));
    cardOwner.stock.add(Resource.MEGACREDITS, filtered.length * 2, {log: true});
  }

  public override getVictoryPoints(player: IPlayer) {
    const moon = MoonExpansion.moonData(player.game).moon;
    const neighboringColonyTiles: Set<SpaceId> = new Set();
    const colonyTiles = MoonExpansion.spaces(player.game, TileType.MOON_HABITAT, {ownedBy: player});
    colonyTiles.forEach((tile) =>
      moon.getAdjacentSpaces(tile).forEach((neighbor) => {
        if (MoonExpansion.spaceHasType(neighbor, TileType.MOON_HABITAT)) {
          neighboringColonyTiles.add(neighbor.id);
        }
      }),
    );

    return neighboringColonyTiles.size;
  }
}

================
File: cards/moon/TheWomb.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class TheWomb extends Card {
  constructor() {
    super({
      name: CardName.THE_WOMB,
      type: CardType.AUTOMATED,
      tags: [Tag.CITY, Tag.MOON],
      cost: 16,

      behavior: {
        production: {energy: -2, megacredits: 4},
        moon: {
          habitatTile: {},
        },
      },
      reserveUnits: {titanium: 2},

      metadata: {
        description: 'Decrease your energy production 2 steps and increase your M€ production 4 steps. ' +
          'Spend 2 titanium. Place a habitat tile on The Moon and raise the habitat rate 1 step.',
        cardNumber: 'M08',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).nbsp.plus().megacredits(4);
          }).br;
          b.minus().titanium(2).moonHabitat({secondaryTag: AltSecondaryTag.MOON_HABITAT_RATE});
        }),
      },
    });
  }
}

================
File: cards/moon/ThoriumRush.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

// TODO(kberg): Add a test for how this card operates with Reds. It will be a good verification.
export class ThoriumRush extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.THORIUM_RUSH,
      type: CardType.EVENT,
      tags: [Tag.MOON, Tag.BUILDING],
      cost: 39,

      behavior: {
        moon: {
          habitatTile: {},
          mineTile: {},
          roadTile: {},
        },
      },

      metadata: {
        description: 'Place 1 habitat tile, 1 mining tile and 1 road tile on The Moon. ' +
        'Raise the habitat rate, mining rate and logistic rate 1 step.',
        cardNumber: 'M56',
        renderData: CardRenderer.builder((b) => {
          b.moonHabitat({secondaryTag: AltSecondaryTag.MOON_HABITAT_RATE})
            .moonMine({secondaryTag: AltSecondaryTag.MOON_MINING_RATE})
            .moonRoad({secondaryTag: AltSecondaryTag.MOON_LOGISTICS_RATE});
        }),
      },
    });
  }
}

================
File: cards/moon/TitaniumExtractionCenter.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class TitaniumExtractionCenter extends Card {
  constructor() {
    super({
      name: CardName.TITANIUM_EXTRACTION_CENTER,
      type: CardType.AUTOMATED,
      tags: [Tag.BUILDING],
      cost: 14,
      reserveUnits: {titanium: 2},

      behavior: {
        production: {titanium: {moon: {miningRate: {}}, per: 2}},
      },

      metadata: {
        description: 'Spend 2 titanium. Increase your titanium production 1 step for every 2 raised steps of mining rate.',
        cardNumber: 'M26',
        renderData: CardRenderer.builder((b) => {
          b.minus().titanium(2).br;
          b.production((pb) => pb.titanium(1)).slash().moonMiningRate({amount: 2});
        }),
      },
    });
  }
}

================
File: cards/moon/TitaniumMarketMonopolists.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {MarketCard} from './MarketCard';

export class TitaniumMarketMonopolists extends MarketCard {
  constructor() {
    super(
      Resource.TITANIUM,
      {from: 2, to: 1, limit: 4},
      {from: 1, to: 4, limit: 4},
      {
        name: CardName.TITANIUM_MARKET_MONOPOLISTS,
        type: CardType.ACTIVE,
        cost: 21,

        requirements: {miningRate: 3},
        metadata: {
          description: 'Requires the mining rate to be 3 or higher.',
          cardNumber: 'M29',
          renderData: CardRenderer.builder((b) => {
            b.action('Spend 2X M€ to gain X titanium [max 8 M€]', (eb) => {
              eb.megacredits(1, {text: '2x'}).startAction.text('X').titanium(1).asterix();
            }).br;
            b.or().br;
            b.action('Spend X titanium to gain 4X M€ [max 4 titanium].', (eb) => {
              eb.text('X').titanium(1).startAction.text('X').megacredits(4).asterix();
            });
          }),
        },
      });
  }
}

================
File: cards/moon/TychoRoadNetwork.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class TychoRoadNetwork extends Card {
  constructor() {
    super({
      name: CardName.TYCHO_ROAD_NETWORK,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON],
      cost: 15,

      behavior: {
        production: {megacredits: 1},
        moon: {
          roadTile: {},
        },
      },
      reserveUnits: {steel: 1},

      metadata: {
        description: 'Spend 1 steel. Increase your M€ production 1 step. ' +
        'Place a road tile on The Moon and raise the Logistics Rate 1 step.',
        cardNumber: 'M09',
        renderData: CardRenderer.builder((b) => {
          b.minus().steel(1).br;
          b.production((eb) => eb.megacredits(1)).br;
          b.moonRoad({secondaryTag: AltSecondaryTag.MOON_LOGISTICS_RATE});
        }),
      },
    });
  }
}

================
File: cards/moon/UndergroundDetonators.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class UndergroundDetonators extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.UNDERGROUND_DETONATORS,
      type: CardType.EVENT,
      cost: 9,

      behavior: {
        stock: {steel: 1, titanium: 1},
        moon: {miningRate: 1},
      },

      metadata: {
        description: 'Gain 1 steel and 1 titanium. Raise the mining rate 1 step.',
        cardNumber: 'M34',
        renderData: CardRenderer.builder((b) => {
          b.steel(1).titanium(1);
          b.br;
          b.moonMiningRate();
        }),
      },
    });
  }
}

================
File: cards/moon/UndermoonDrugLordsNetwork.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class UndermoonDrugLordsNetwork extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.UNDERMOON_DRUG_LORDS_NETWORK,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON],
      cost: 2,
      victoryPoints: -1,

      behavior: {
        production: {megacredits: {moon: {habitatRate: {}}, per: 2}},
      },

      metadata: {
        description: 'Increase your M€ production 1 step per 2 steps of habitat rate.',
        cardNumber: 'M81',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1);
          }).slash().moonHabitatRate({amount: 2});
        }),
      },
    });
  }
}

================
File: cards/moon/WaterTreatmentComplex.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all} from '../Options';
import {Tag} from '../../../common/cards/Tag';

export class WaterTreatmentComplex extends Card {
  constructor() {
    super({
      name: CardName.WATER_TREATMENT_COMPLEX,
      type: CardType.AUTOMATED,
      tags: [Tag.MOON],
      cost: 12,
      requirements: {habitatTiles: 1, all},
      reserveUnits: {titanium: 1},

      behavior: {
        moon: {habitatRate: 2},
      },

      metadata: {
        description: 'Requires 1 habitat tile on The Moon. Spend 1 titanium. Raise the habitat rate 2 steps.',
        cardNumber: 'M46',
        renderData: CardRenderer.builder((b) => b.minus().titanium(1).br.moonHabitatRate({amount: 2})),
      },
    });
  }
}

================
File: cards/moon/WeGrowAsOne.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {PartyName} from '../../../common/turmoil/PartyName';
import {Card} from '../Card';
import {all} from '../Options';

export class WeGrowAsOne extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.WE_GROW_AS_ONE,
      type: CardType.EVENT,
      tags: [Tag.SPACE],
      cost: 8,
      requirements: {party: PartyName.UNITY},

      metadata: {
        description: 'Requires that Unity are ruling or that you have 2 delegates there. ' +
        'Increase ALL colony tile tracks 1 step. ' +
        'Increase each colony tile track 1 step if you have a colony on that colony tile.',
        cardNumber: 'M59',
        renderData: CardRenderer.builder((b) => {
          b.colonyTile({all}).text('+1').br;
          b.colonies(1).asterix().slash().colonyTile().text('+1');
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.game.colonies.forEach((colony) => {
      if (colony.colonies.includes(player.id)) {
        colony.increaseTrack(2);
      } else {
        colony.increaseTrack(1);
      }
    });
    return undefined;
  }
}

================
File: cards/Options.ts
================
// This source file needs a new name.
//
// These constants are used with card rendering as a way to initialize
// options using ES6 Object Literals
//
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer
//
// So instead when annotating card items, {played: true} can be reduced to {played}.

export const all = true;
export const clone = true;
export const digit = true;
export const max = true;
export const nextTo = true;
export const cancelled = true;

================
File: cards/pathfinders/AdhaiHighOrbitConstructions.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {IProjectCard} from '../IProjectCard';
import {isPlanetaryTag} from '../../pathfinders/PathfindersData';
import {Size} from '../../../common/cards/render/Size';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class AdhaiHighOrbitConstructions extends CorporationCard {
  constructor() {
    super({
      name: CardName.ADHAI_HIGH_ORBIT_CONSTRUCTIONS,
      tags: [Tag.SPACE],
      startingMegaCredits: 43,
      resourceType: CardResource.ORBITAL,

      behavior: {
        // This is the onCardPlayed effect.
        addResources: 1,
      },

      metadata: {
        cardNumber: 'PfC23',
        description: 'You start with 43 M€.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(43).nbsp.nbsp.tag(Tag.SPACE, {secondaryTag: AltSecondaryTag.NO_PLANETARY_TAG}).colon().resource(CardResource.ORBITAL).br;
          b.text('(Effect: Whenever you play a card with a space tag BUT NO PLANETARY TAG (including this) add 1 orbital on this card.)', Size.SMALL, false, false);
          b.br;
          b.effect('For every 2 orbitals on this card, cards with a space tag but with no planetary tag or the STANDARD COLONY PROJECT or TRADE ACTION costs 1M€ less.', (eb) => {
            eb.tag(Tag.SPACE, {secondaryTag: AltSecondaryTag.NO_PLANETARY_TAG}).slash(Size.SMALL).colonies(1, {size: Size.SMALL}).slash(Size.SMALL).trade({size: Size.SMALL})
              .startEffect
              .minus().megacredits(1).text('/2').resource(CardResource.ORBITAL);
          });
        }),
      },
    });
  }


  private matchingTags(tags: Array<Tag>): boolean {
    let spaceTag = false;
    for (const tag of tags) {
      if (tag === Tag.SPACE) spaceTag = true;
      if (isPlanetaryTag(tag)) return false;
    }
    return spaceTag;
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (player.isCorporation(CardName.ADHAI_HIGH_ORBIT_CONSTRUCTIONS) && this.matchingTags(card.tags)) {
      player.addResourceTo(this, 1);
    }
  }

  // TODO(kberg): it's not possible to make this a cardDiscount type, which just means rendering is tricky.
  public override getCardDiscount(player: IPlayer, card: IProjectCard) {
    if (player.isCorporation(CardName.ADHAI_HIGH_ORBIT_CONSTRUCTIONS) && this.matchingTags(card.tags)) {
      return Math.floor(this.resourceCount / 2);
    } else {
      return 0;
    }
  }
}

================
File: cards/pathfinders/AdvancedPowerGrid.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class AdvancedPowerGrid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ADVANCED_POWER_GRID,
      cost: 18,
      tags: [Tag.POWER, Tag.BUILDING, Tag.MARS],

      behavior: {
        production: {megacredits: {tag: Tag.POWER}, energy: 2},
      },

      metadata: {
        cardNumber: 'Pf56',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2).br.megacredits(1).slash().tag(Tag.POWER));
        }),
        description: 'Increase your energy production 2 steps. Increase your M€ production 1 step per power tag you have, including this.',
      },
    });
  }
}

================
File: cards/pathfinders/AgroDrones.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IActionCard} from '../ICard';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {Units} from '../../../common/Units';
import {PathfindersExpansion} from '../../pathfinders/PathfindersExpansion';

export class AgroDrones extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.AGRO_DRONES,
      cost: 14,
      tags: [Tag.PLANT, Tag.MARS],

      requirements: {temperature: -18},
      metadata: {
        cardNumber: 'Pf04',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 steel and 1 energy to gain 3 plants.', (eb) => {
            eb.steel(1).energy(1).startAction.plants(3);
          });
        }),
        description: 'Requires -18° C or warmer.',
      },
    });
  }

  public canAct(player: IPlayer) {
    return player.steel > 0 && player.energy > 0;
  }

  public action(player: IPlayer) {
    // TODO(kberg): add method Stock.adjust?
    player.stock.deductUnits(Units.of({steel: 1, energy: 1}));
    player.stock.add(Resource.PLANTS, 3);
    player.game.log('${0} spent 1 steel and 1 energy to gain 3 plants.', (b) => b.player(player));
    PathfindersExpansion.addToSolBank(player);
    return undefined;
  }
}

================
File: cards/pathfinders/Ambient.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {ICorporationCard} from '../corporation/ICorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {ICard} from '../ICard';
import {MAX_TEMPERATURE} from '../../../common/constants';
import {Size} from '../../../common/cards/render/Size';
import {Units} from '../../../common/Units';

export class Ambient extends CorporationCard {
  constructor() {
    super({
      name: CardName.AMBIENT,
      tags: [Tag.VENUS],
      startingMegaCredits: 38,

      firstAction: {
        text: 'Raise the Venus scale 2 steps.',
        //     LogHelper.logVenusIncrease(player, actual);
        global: {venus: 2},
      },

      metadata: {
        cardNumber: 'PfC3',
        description: 'You start with 38 M€. As your first action, raise the Venus scale 2 steps.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(38).venus(2, {size: Size.SMALL}).br;
          b.effect('When you play a card with a Venus tag (including this) increase your heat production 1 step.', (eb) => {
            eb.tag(Tag.VENUS).startEffect.production((pb) => pb.heat(1));
          }).br;
          b.action('When temperature is maxed, spend 8 heat gain 1 TR. ' +
            'You may repeat this action like a standard project.', (ab) => {
            ab.heat(8, {digit, size: Size.SMALL}).startAction.tr(1, {size: Size.SMALL}).text('∞');
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    this.onCorpCardPlayed(player, this);
    return undefined;
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    this.onCardPlayed(player, card);
  }

  public onCardPlayed(player: IPlayer, card: ICard): void {
    if (player.isCorporation(this.name) && card.tags.includes(Tag.VENUS)) {
      player.production.add(Resource.HEAT, 1, {log: true});
    }
  }

  public canAct(player: IPlayer) {
    return player.heat >= 8 && player.game.getTemperature() === MAX_TEMPERATURE && player.canAfford({cost: 0, reserveUnits: Units.of({heat: 8}), tr: {tr: 1}});
  }

  public action(player: IPlayer) {
    player.heat -= 8;
    player.increaseTerraformRating();
    // A hack that allows this action to be replayable.
    player.defer(() => {
      player.getActionsThisGeneration().delete(this.name);
    });
    return undefined;
  }
}

================
File: cards/pathfinders/Anthozoa.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IActionCard} from '../ICard';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';

export class Anthozoa extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ANTHOZOA,
      cost: 9,
      tags: [Tag.PLANT, Tag.ANIMAL, Tag.MARS],
      requirements: {oceans: 3},
      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}, per: 2},

      metadata: {
        cardNumber: 'Pf55',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 plant to add an animal to this card.', (eb) => {
            eb.plants(1).startAction.resource(CardResource.ANIMAL);
          });
        }),
        description: 'Requires 3 oceans on Mars. 1 VP per 2 animals on this card.',
      },
    });
  }


  public canAct(player: IPlayer) {
    return player.plants > 0;
  }

  public action(player: IPlayer) {
    player.stock.deduct(Resource.PLANTS, 1);
    player.addResourceTo(this);
    player.game.log('${0} spent 1 plant to place an animal on ${1}.', (b) => b.player(player).card(this));
    return undefined;
  }
}

================
File: cards/pathfinders/AsteroidResources.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {Size} from '../../../common/cards/render/Size';
import {digit} from '../Options';

export class AsteroidResources extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ASTEROID_RESOURCES,
      cost: 17,
      tags: [Tag.JOVIAN, Tag.SPACE],
      reserveUnits: {energy: 3},
      victoryPoints: 1,

      behavior: {
        or: {
          autoSelect: true,
          behaviors: [
            {
              title: 'Increase your steel and titanium production 1 step.',
              spend: {energy: 3},
              production: {steel: 1, titanium: 1},
            },
            {
              title: 'Place an ocean, and gain 2 steel and one titanium.',
              spend: {energy: 3},
              ocean: {},
              stock: {steel: 2, titanium: 1},
            },
          ],
        },
      },

      metadata: {
        cardNumber: 'Pf40',
        renderData: CardRenderer.builder((b) => {
          b.minus().energy(3, {digit}).production((pb) => pb.steel(1).titanium(1)).br
            .or(Size.SMALL).br;
          b.minus().energy(3, {digit}).oceans(1, {size: Size.SMALL}).steel(2, {digit}).titanium(1);
        }),
        description: 'Spend 3 energy. Either increase your steel and titanium production one step, OR ' +
          'place an ocean, and gain 2 steel and one titanium.',
      },
    });
  }
}

================
File: cards/pathfinders/Aurorai.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {Priority} from '../../deferredActions/Priority';

export class Aurorai extends CorporationCard {
  constructor() {
    super({
      name: CardName.AURORAI,
      tags: [Tag.MARS],
      startingMegaCredits: 33,
      resourceType: CardResource.DATA,

      behavior: {
        addResources: 2,
      },

      metadata: {
        cardNumber: 'PfC9',
        description: 'You start with 33 M€. and 2 data on this card',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(33).resource(CardResource.DATA, 2).br;
          b.effect('Whenever you increase your terraform rating, add 1 data per step to ANY card.', (eb) => {
            eb.tr(1).startEffect.resource(CardResource.DATA).asterix();
          }).br;
          b.effect('You can use data on this card as 3M€ each to pay for standard projects.', (eb) => {
            eb.resource(CardResource.DATA).startEffect.megacredits(3).asterix().text('standard project');
          });
        }),
      },
    });
  }

  public onIncreaseTerraformRating(player: IPlayer, cardOwner: IPlayer, steps: number) {
    if (player === cardOwner) {
      player.game.defer(new AddResourcesToCard(player, CardResource.DATA, {count: steps}), Priority.GAIN_RESOURCE_OR_PRODUCTION);
    }
  }
}

================
File: cards/pathfinders/BalancedDevelopment.ts
================
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../../turmoil/Turmoil';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().tag(Tag.MARS).influence({size: Size.SMALL});
});

export class BalancedDevelopment extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.BALANCED_DEVELOPMENT,
      description: 'Gain 2M€ for each Mars tag you have (max 5) and influence.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const tags = player.tags.count(Tag.MARS, 'raw');
      const total = Math.min(tags, 5) + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.MEGACREDITS, 2 * total, {log: true, from: this.name});
    });
  }
}

================
File: cards/pathfinders/BioSol.ts
================
import {ActiveCorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';

export class BioSol extends ActiveCorporationCard {
  constructor() {
    super({
      name: CardName.BIO_SOL,
      tags: [Tag.MICROBE],
      startingMegaCredits: 42,
      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 3},

      firstAction: {
        text: 'Draw 2 cards with a microbe tag',
        drawCard: {count: 2, tag: Tag.MICROBE},
      },

      action: {
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 1},
      },

      metadata: {
        cardNumber: 'PfC14',
        description: 'You start with 42 M€. As your first action, draw 2 cards with a microbe tag.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(42).cards(2, {secondaryTag: Tag.MICROBE}).br;
          b.corpBox('action', (corpbox) => corpbox.action(
            'Add 1 microbe to ANY card',
            (ab) => ab.empty().startAction.resource(CardResource.MICROBE).asterix()));
        }),
      },
    });
  }
}

================
File: cards/pathfinders/BotanicalExperience.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all, digit} from '../Options';
import {Tag} from '../../../common/cards/Tag';
import {Size} from '../../../common/cards/render/Size';
import {Space} from '../../boards/Space';
import {Board} from '../../boards/Board';
import {CardResource} from '../../../common/CardResource';
import {ICard} from '../ICard';
import {Resource} from '../../../common/Resource';

export class BotanicalExperience extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.BOTANICAL_EXPERIENCE,
      cost: 14,
      tags: [Tag.PLANT, Tag.MARS, Tag.SCIENCE],
      requirements: {greeneries: 1, all},
      resourceType: CardResource.DATA,

      metadata: {
        cardNumber: 'Pf50',
        hasExternalHelp: true,
        renderData: CardRenderer.builder((b) => {
          b.greenery({size: Size.SMALL, withO2: false, any: true}).colon().resource(CardResource.DATA, {size: Size.SMALL});
          b.nbsp;
          b.resource(CardResource.DATA, {amount: 3, digit}).asterix().colon().production((pb) => pb.plants(1));
          b.br;
          b.text('(EFFECT: Whenever a greenery tile is placed, add 1 data on this card.) ' +
            '(EFFECT: Whenever this card has at least 3 data, automatically remove 3 data to raise your plant production 1 step.) ' +
            '(EFFECT: Players may remove your plants, but you only lose half, rounded up.)', Size.SMALL, false, false);
        }),
        description: 'Requires one greenery tile on Mars.',
      },
    });
  }


  public onTilePlaced(cardOwner: IPlayer, _activePlayer: IPlayer, space: Space) {
    if (Board.isGreenerySpace(space)) {
      cardOwner.addResourceTo(this, 1);
    }
  }

  public onResourceAdded(player: IPlayer, playedCard: ICard) {
    if (playedCard.name !== this.name) return;
    if (this.resourceCount >= 3) {
      const delta = Math.floor(this.resourceCount / 3);
      const deducted = delta * 3;
      this.resourceCount -= deducted;
      player.production.add(Resource.PLANTS, delta, {log: false});
      player.game.log('${0} removed ${1} data from ${2} to increase plant production ${3} steps.',
        (b) => b.player(player).number(deducted).card(this).number(delta));
    }
  }
}

================
File: cards/pathfinders/BreedingFarms.ts
================
import {IProjectCard} from '../IProjectCard';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';

export class BreedingFarms extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.BREEDING_FARMS,
      cost: 16,
      tags: [Tag.SCIENCE, Tag.ANIMAL, Tag.BUILDING],

      behavior: {
        global: {temperature: 1},
      },

      action: {
        spend: {plants: 1},
        addResourcesToAnyCard: {count: 1, type: CardResource.ANIMAL, mustHaveCard: true},
      },

      requirements: [{tag: Tag.SCIENCE}, {tag: Tag.ANIMAL}],
      metadata: {
        cardNumber: 'Pf01',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 plant to add 1 animal to ANY card.', (eb) => {
            eb.plants(1).startAction.resource(CardResource.ANIMAL);
          });
          b.br;
          b.temperature(1);
        }),
        description: 'Requires 1 science tag and 1 animal tag. Raise the temperature 1 step.',
      },
    });
  }
}

================
File: cards/pathfinders/CassiniStation.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {all} from '../Options';
import {SelectCard} from '../../inputs/SelectCard';

export class CassiniStation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CASSINI_STATION,
      cost: 23,
      tags: [Tag.POWER, Tag.SCIENCE, Tag.SPACE],

      behavior: {
        production: {energy: {colonies: {colonies: {}}, all}},
      },

      metadata: {
        cardNumber: 'Pf62',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).slash().colonies(1, {all})).br;
          b.resource(CardResource.FLOATER, 2).asterix().or().br;
          b.resource(CardResource.DATA, 3).asterix();
        }),
        description: 'Increase your energy production 1 step for every colony in play. ' +
          'Add 2 floaters to ANY card OR add 3 data to ANY card.',
      },
    });
  }

  // TODO(kberg): Repalce this with counter / behavior.
  public override bespokePlay(player: IPlayer) {
    const cards = [
      ...player.getResourceCards(CardResource.FLOATER),
      ...player.getResourceCards(CardResource.DATA),
    ];

    if (cards.length === 0) {
      return undefined;
    }
    const input = new SelectCard(
      'Select card to gain 2 floaters or 3 data',
      'Add resources',
      cards)
      .andThen(([card]) => {
        if (card.resourceType === CardResource.FLOATER) {
          player.addResourceTo(card, {qty: 2, log: true});
        } else {
          player.addResourceTo(card, {qty: 3, log: true});
        }
        return undefined;
      });

    if (cards.length === 1) {
      input.cb(cards);
      return undefined;
    }
    return input;
  }
}

================
File: cards/pathfinders/CeresSpaceport.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {SpaceName} from '../../SpaceName';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class CeresSpaceport extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CERES_SPACEPORT,
      tags: [Tag.JOVIAN, Tag.JOVIAN, Tag.CITY, Tag.SPACE],
      cost: 36,
      victoryPoints: 1,

      behavior: {
        drawCard: 1,
        ocean: {},
        city: {space: SpaceName.CERES_SPACEPORT},
        production: {megacredits: 2, titanium: {tag: Tag.JOVIAN, per: 2}},
      },

      metadata: {
        cardNumber: 'Pf14',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2))
            .production((pb) => pb.titanium(1).slash().tag(Tag.JOVIAN, 2))
            .br
            .cards(1).oceans(1).city().asterix().br;
        }),
        description: 'Increase your M€ production 2 steps, and titanium production 1 step for every 2 Jovian tags (including these.) ' +
          'Draw a card. Place an ocean tile. Place a city tile ON THE RESERVED AREA.',
      },
    });
  }
}

================
File: cards/pathfinders/CharityDonation.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {LogHelper} from '../../LogHelper';
import {SelectCard} from '../../inputs/SelectCard';
import {DeferredAction} from '../../deferredActions/DeferredAction';
import {Priority} from '../../deferredActions/Priority';

export class CharityDonation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.CHARITY_DONATION,
      tags: [Tag.MARS],
      cost: 7,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'Pf58',
        renderData: CardRenderer.builder((b) =>
          b.text('Reveal cards from the deck equal to the player count plus 1.')
            .br
            .text('In player order starting with you, each player takes one card in hand. Discard the remaining card.')),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    const players = game.getPlayersInGenerationOrder();
    const thisIdx = players.findIndex((p) => p === player);
    const cards = game.projectDeck.drawByCondition(game, players.length + 1, () => true);
    LogHelper.logDrawnCards(player, cards);
    game.defer(new SelectCharityDonationCard(players, thisIdx, thisIdx, cards));
    return undefined;
  }
}

export class SelectCharityDonationCard extends DeferredAction {
  constructor(private players: ReadonlyArray<IPlayer>, private playerIdx: number, private boundaryIndex: number, private cards: Array<IProjectCard>) {
    super(players[playerIdx], Priority.DRAW_CARDS);
  }

  public execute() {
    return new SelectCard(
      'Select a card to keep',
      'Choose',
      this.cards)
      .andThen(
        ([card]) => {
          const game = this.player.game;

          const cardIdx = this.cards.indexOf(card);
          if (cardIdx > -1) {
            this.cards.splice(cardIdx, 1);
          }

          this.player.cardsInHand.push(card);
          game.log('${0} drew ${1}', (b) => b.player(this.player).card(card));

          const nextIndex = (this.playerIdx + 1) % this.players.length;
          if (nextIndex !== this.boundaryIndex) {
            game.defer(new SelectCharityDonationCard(this.players, nextIndex, this.boundaryIndex, this.cards));
          } else {
            game.projectDeck.discard(this.cards[0]);
            game.log('${0} was discarded.', (b) => b.card(this.cards[0]));
          }
          return undefined;
        },
      );
  }
}

================
File: cards/pathfinders/Chimera.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Chimera extends CorporationCard {
  constructor() {
    super({
      name: CardName.CHIMERA,
      tags: [Tag.WILD, Tag.WILD],
      startingMegaCredits: 36,

      behavior: {
        stock: {steel: 1, titanium: 1},
      },

      metadata: {
        cardNumber: 'PfC5',
        description: 'You start with 36 M€, 1 steel, and 1 titanium.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(36).steel(1).titanium(1);
          b.corpBox('effect', (ce) => {
            ce.effect('When you perform an action, these wild tags count as any tags of your choice. ' +
              'For claiming milestones and funding awards, both symbols count as one. ' +
              '(Other wild tags still do not count toward awards.)',
            (ce) => ce.tag(Tag.WILD, 2).startEffect.tag(Tag.WILD, 2).slash().tag(Tag.WILD).asterix());
          });
        }),
      },
    });
  }
}

================
File: cards/pathfinders/CO2Reducers.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class CO2Reducers extends PreludeCard {
  constructor() {
    super({
      name: CardName.CO2_REDUCERS,
      tags: [Tag.MICROBE, Tag.VENUS],

      behavior: {
        production: {megacredits: 3},
        drawCard: {count: 2, tag: Tag.MICROBE},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(3)).br;
          b.cards(2, {secondaryTag: Tag.MICROBE});
        }),
        description: 'Increase your M€ production 3 steps. Draw 2 cards with a microbe tag.',
      },
    });
  }
}

================
File: cards/pathfinders/CollegiumCopernicus.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {ICorporationCard} from '../corporation/ICorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IActionCard, ICard} from '../ICard';
import {CardResource} from '../../../common/CardResource';
import {ColoniesHandler} from '../../colonies/ColoniesHandler';
import {SelectColony} from '../../inputs/SelectColony';
import {IColonyTrader} from '../../colonies/IColonyTrader';
import {IColony} from '../../colonies/IColony';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {message} from '../../logs/MessageBuilder';

function tradeCost(player: IPlayer) {
  return Math.max(0, 3 - player.colonies.tradeDiscount);
}
export class CollegiumCopernicus extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.COLLEGIUM_COPERNICUS,
      tags: [Tag.SCIENCE, Tag.EARTH],
      startingMegaCredits: 33,
      resourceType: CardResource.DATA,

      behavior: {
        addResourcesToAnyCard: {count: 1, type: CardResource.DATA},
      },

      firstAction: {
        text: 'Draw 2 cards with a science tag',
        drawCard: {count: 2, tag: Tag.SCIENCE},
      },

      metadata: {
        cardNumber: 'PfC4',
        description: 'You start with 33 M€. As your first action, draw 2 cards with a science tag.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(33).cards(2, {secondaryTag: Tag.SCIENCE}).br;
          b.effect('When you play a card with a science tag (including this) Add 1 data to ANY card.', (eb) => {
            eb.tag(Tag.SCIENCE).startEffect.resource(CardResource.DATA).asterix();
          }).br;
          b.action('Spend 3 data from this card to trade.', (eb) => {
            eb.resource(CardResource.DATA, 3).startAction.trade();
          });
        }),
      },
    });
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    this.onCardPlayed(player, card);
  }

  public onCardPlayed(player: IPlayer, card: ICard): void {
    if (player.tags.cardHasTag(card, Tag.SCIENCE) && player.isCorporation(this.name)) {
      player.game.defer(new AddResourcesToCard(player, CardResource.DATA, {count: 1}));
    }
  }

  public canAct(player: IPlayer) {
    return player.colonies.canTrade() && this.resourceCount >= tradeCost(player);
  }

  public action(player: IPlayer) {
    const game = player.game;
    player.defer(
      new SelectColony('Select colony tile to trade with', 'Select', ColoniesHandler.tradeableColonies(game))
        .andThen((colony) => {
          tradeWithColony(this, player, colony);
          return undefined;
        }),
    );
    return undefined;
  }
}

export function tradeWithColony(card: ICorporationCard, player: IPlayer, colony: IColony) {
  const cost = tradeCost(player);
  card.resourceCount -= cost;
  player.game.log('${0} spent ${1} data from ${2} to trade with ${3}', (b) => b.player(player).number(cost).card(card).colony(colony));
  colony.trade(player);
}
export class TradeWithCollegiumCopernicus implements IColonyTrader {
  private collegiumCopernicus: ICorporationCard | undefined;

  constructor(private player: IPlayer) {
    this.collegiumCopernicus = player.getCorporation(CardName.COLLEGIUM_COPERNICUS);
  }

  public canUse() {
    return (this.collegiumCopernicus?.resourceCount ?? 0) >= tradeCost(this.player) &&
      !this.player.getActionsThisGeneration().has(CardName.COLLEGIUM_COPERNICUS);
  }

  public optionText() {
    return message('Pay ${0} data (use ${1} action)', (b) => b.number(tradeCost(this.player)).cardName(CardName.COLLEGIUM_COPERNICUS));
  }

  public trade(colony: IColony) {
    this.player.addActionThisGeneration(CardName.COLLEGIUM_COPERNICUS);
    if (this.collegiumCopernicus !== undefined) {
      tradeWithColony(this.collegiumCopernicus, this.player, colony);
    }
  }
}

================
File: cards/pathfinders/CommunicationBoom.ts
================
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../../turmoil/Turmoil';
import {Resource} from '../../../common/Resource';
import {CardResource} from '../../../common/CardResource';
import {AddResourcesToCards} from '../../deferredActions/AddResourcesToCards';
import {CardRenderer} from '../render/CardRenderer';
import {PathfindersExpansion} from '../../pathfinders/PathfindersExpansion';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-10).nbsp.resource(CardResource.DATA, 2).asterix().nbsp;
  b.resource(CardResource.DATA).slash().influence();
});

export class CommunicationBoom extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.COMMUNICATION_BOOM,
      description: 'Pay 10M€. Add 2 data to EVERY data card. Add 1 data to any data card for each influence you have.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const deducted = Math.min(10, player.megaCredits);
      if (deducted > 0) {
        player.stock.deduct(Resource.MEGACREDITS, 10, {log: true, from: this.name});
        PathfindersExpansion.addToSolBank(player);
      }
      player.getResourceCards(CardResource.DATA).forEach((card) => {
        player.addResourceTo(card, {qty: 2, log: true});
      });
      const count = turmoil.getPlayerInfluence(player);
      game.defer(new AddResourcesToCards(player, CardResource.DATA, count));
    });
  }
}

================
File: cards/pathfinders/CommunicationCenter.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {all, digit} from '../Options';
import {Size} from '../../../common/cards/render/Size';
import {ICard} from '../ICard';
import {Priority} from '../../deferredActions/Priority';

export class CommunicationCenter extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.COMMUNICATION_CENTER,
      cost: 8,
      tags: [Tag.SCIENCE, Tag.MARS, Tag.BUILDING],
      resourceType: CardResource.DATA,

      behavior: {
        production: {energy: -1},
        addResources: 2,
      },

      metadata: {
        cardNumber: 'Pf28',
        renderData: CardRenderer.builder((b) => {
          b.tag(Tag.EVENT, {all}).colon().resource(CardResource.DATA).nbsp.resource(CardResource.DATA, {amount: 3, digit}).colon().cards(1).br;
          b.text('(Effect: Whenever ANY PLAYER plays an event, add 1 data to this card.)', Size.TINY, false, false).br;
          b.text('(Effect: Remove 3 data to draw a card automatically.)', Size.TINY, false, false).br;
          b.minus().production((pb) => pb.energy(1)).resource(CardResource.DATA, 2);
        }),
        description: 'Decrease your energy production 1 step. Place 2 data on this card.',
      },
    });
  }

  public onResourceAdded(player: IPlayer, playedCard: ICard) {
    if (playedCard.name !== this.name) return;
    while (this.resourceCount >= 3) {
      this.resourceCount -= 3;
      player.drawCard(1);
      player.game.log('${0} automatically removed 3 data from ${1} to draw a card.', (b) => {
        b.player(player).card(this);
      });
    }
  }

  public onCardPlayedFromAnyPlayer(thisCardOwner: IPlayer, _playedCardOwner: IPlayer, card: IProjectCard) {
    if (card.type === CardType.EVENT) {
      // Resolve CEO's Favorite Project before adding the resource.
      const priority = (card.name === CardName.CEOS_FAVORITE_PROJECT) ? Priority.BACK_OF_THE_LINE : Priority.DEFAULT;
      thisCardOwner.defer(() => {
        thisCardOwner.addResourceTo(this, {qty: 1, log: true});
      }, priority);
    }
    return undefined;
  }
}

================
File: cards/pathfinders/ConstantStruggle.ts
================
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../../turmoil/Turmoil';
import {Resource} from '../../../common/Resource';
import {PathfindersExpansion} from '../../pathfinders/PathfindersExpansion';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().megacredits(10).influence({size: Size.SMALL}).planetaryTrack().text('2');
});

export class ConstantStruggle extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.CONSTANT_STRUGGLE,
      description: 'Pay 10M€, reduced by 1M€ per influence. Raise every planetary track 2 steps. Nobody gains the "rising player" bonus.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const influence = turmoil.getPlayerInfluence(player);
      const deducted = Math.max(10 - influence, 0);
      player.stock.deduct(Resource.MEGACREDITS, deducted, {log: true, from: this.name});
      if (deducted > 0) {
        PathfindersExpansion.addToSolBank(player);
      }
    });
    PathfindersExpansion.raiseTrackForGlobalEvent(Tag.VENUS, this.name, game, 2, false);
    PathfindersExpansion.raiseTrackForGlobalEvent(Tag.EARTH, this.name, game, 2, false);
    PathfindersExpansion.raiseTrackForGlobalEvent(Tag.MARS, this.name, game, 2, false);
    PathfindersExpansion.raiseTrackForGlobalEvent(Tag.JOVIAN, this.name, game, 2, false);
    PathfindersExpansion.raiseTrackForGlobalEvent(Tag.MOON, this.name, game, 2, false);
  }
}

================
File: cards/pathfinders/ControlledBloom.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';

export class ControlledBloom extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.CONTROLLED_BLOOM,
      cost: 13,
      tags: [Tag.MICROBE, Tag.PLANT],
      victoryPoints: 1,

      requirements: {oceans: 3},

      behavior: {
        stock: {plants: 3},
        addResourcesToAnyCard: {count: 3, type: CardResource.MICROBE},
      },

      metadata: {
        cardNumber: 'PFTmp',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.MICROBE, 3).asterix().br;
          b.plants(3);
        }),
        description: 'Requires 3 oceans. Add 3 microbes to ANY card. Gain 3 plants.',
      },
    });
  }
}

================
File: cards/pathfinders/CoordinatedRaid.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';
import {SelectColony} from '../../inputs/SelectColony';
import {IColony} from '../../colonies/IColony';

export class CoordinatedRaid extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 5,
      name: CardName.COORDINATED_RAID,
      type: CardType.EVENT,
      requirements: {colonies: 1},

      metadata: {
        cardNumber: 'Pf64',
        renderData: CardRenderer.builder((b) => b.trade().asterix()),
        // TODO(kberg): restoring this behaivor will be quite a tricky thing, mostly for visualization etc.
        // description: 'Requires at least 1 colony in play. Send one of your unused Trade Fleets to ANY colony tile (can be a tile already used this generation.) ' +
        //   'Collect the trade bonus and colony bonus for every colony on this tile. Other players do not get their colony bonuses from this action.',
        description: 'Requires at least 1 colony in play. Send one of your unused Trade Fleets to any colony tile. ' +
          'Collect the trade bonus and colony bonus for every colony on this tile. Other players do not get their colony bonuses from this action.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.colonies.getFleetSize() > player.colonies.tradesThisGeneration;
  }

  public override bespokePlay(player: IPlayer) {
    const activeColonies = player.game.colonies.filter((colony) => colony.isActive);
    return new SelectColony('Select colony tile for trade', 'trade', activeColonies)
      .andThen((colony: IColony) => {
        colony.trade(player, {selfishTrade: true});
        return undefined;
      });
  }
}

================
File: cards/pathfinders/Crashlanding.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Space} from '../../boards/Space';
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {TileType} from '../../../common/TileType';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardRenderer} from '../render/CardRenderer';
import {Board} from '../../boards/Board';
import {Size} from '../../../common/cards/render/Size';
import {OrOptions} from '../../inputs/OrOptions';
import {CardResource} from '../../../common/CardResource';
import {SelectOption} from '../../inputs/SelectOption';
import {Tile} from '../../Tile';
import {CrashlandingBonus} from '../../pathfinders/CrashlandingBonus';
import {message} from '../../logs/MessageBuilder';

export class Crashlanding extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.CRASHLANDING,
      cost: 20,
      tilesBuilt: [TileType.CRASHLANDING],

      behavior: {
        addResourcesToAnyCard: [
          {type: CardResource.DATA, count: 1, autoSelect: true},
          {type: undefined, count: 1, autoSelect: true},
        ],
      },

      metadata: {
        cardNumber: 'Pf48',
        renderData: CardRenderer.builder((b) => {
          b.tile(TileType.CRASHLANDING, false, true).asterix().resource(CardResource.DATA).asterix().wild(1).asterix().br;
          b.text('(Place AND ORIENT this tile on a non-reserved space adjacent to no more than 1 city.', Size.TINY, false, false).br;
          b.text('Crashsite grants an ADJACENCY BONUS of 1 data, and either 1 steel or 1 titanium.', Size.TINY, false, false).br;
          b.text('When placing Crashsite, for each tile you own next it, gain those bonuses.', Size.TINY, false, false).br;
          b.text('Add 1 data to any card. Add 1 resource to any card.)', Size.TINY, false, false).br;
        }),
      },
    });
  }

  private playableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): Array<Space> {
    const board = player.game.board;
    const spaces = board.getAvailableSpacesOnLand(player, canAffordOptions);
    return spaces.filter((space) => board.getAdjacentSpaces(space).filter(Board.isCitySpace).length <= 1);
  }

  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions): boolean {
    return this.playableSpaces(player, canAffordOptions).length > 0;
  }
  public override bespokePlay(player: IPlayer) {
    return new SelectSpace(
      message('Select space for ${0} tile', (b) => b.card(this)),
      this.playableSpaces(player))
      .andThen((space) => {
        space.adjacency = {bonus: ['callback']};
        const tile: Tile = {
          tileType: TileType.CRASHLANDING,
          card: this.name,
        };
        player.game.addTile(player, space, tile);
        const orOptions = new OrOptions(
          new SelectOption('Leave as it is').andThen(() => {
            tile.rotated = undefined;
            this.grantPlacementBonuses(player, space);
            return undefined;
          }),
          new SelectOption('Rotate Crashlanding').andThen(() => {
            tile.rotated = true;
            this.grantPlacementBonuses(player, space);
            return undefined;
          }),
        );
        orOptions.title = 'Orient Crashlanding';
        return orOptions;
      });
  }

  private grantPlacementBonuses(player: IPlayer, space: Space) {
    const game = player.game;
    for (const adjacentSpace of game.board.getAdjacentSpaces(space)) {
      if (adjacentSpace.player === player && adjacentSpace.tile !== undefined) {
        const bonuses = CrashlandingBonus.onTilePlacedAdjacentToCrashlanding(game, space, adjacentSpace);
        for (const bonus of bonuses) {
          game.grantSpaceBonus(player, bonus);
        }
      }
    }
  }
}

================
File: cards/pathfinders/CrewTraining.ts
================
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {ICloneTagCard} from './ICloneTagCard';
import {DeclareCloneTag} from '../../pathfinders/DeclareCloneTag';
import {Size} from '../../../common/cards/render/Size';

export class CrewTraining extends PreludeCard implements ICloneTagCard {
  constructor() {
    super({
      name: CardName.CREW_TRAINING,

      behavior: {
        tr: 2,
      },

      metadata: {
        cardNumber: 'P08',
        renderData: CardRenderer.builder((b) => {
          b.planetaryTrack().text('2')
            .tag(Tag.VENUS).or(Size.SMALL)
            .tag(Tag.EARTH).or(Size.SMALL).br;
          b.tag(Tag.MARS).or(Size.SMALL)
            .tag(Tag.JOVIAN).or(Size.SMALL)
            .tag(Tag.MOON).br;

          b.tr(2);
        }),
        description: 'Choose a planet tag. This card counts as having 2 of that tag. ' +
          'Raise the corresponding planetary track 2 steps. Gain 2 TR.',
      },
    });
  }

  public cloneTag: Tag = Tag.CLONE;

  public override get tags(): Array<Tag> {
    return [this.cloneTag, this.cloneTag];
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new DeclareCloneTag(player, this));
    return undefined;
  }
}

================
File: cards/pathfinders/Cryptocurrency.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IActionCard} from '../ICard';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';

export class Cryptocurrency extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CRYPTOCURRENCY,
      cost: 6,
      tags: [Tag.POWER],
      resourceType: CardResource.DATA,

      metadata: {
        cardNumber: 'Pf51',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 energy to add 1 data to this card.', (eb) => {
            eb.energy(1).startAction.resource(CardResource.DATA).or();
          }).br;
          b.action('Remove all data from this card to gain 3M€ per data removed.', (eb) => {
            eb.text('x').resource(CardResource.DATA).startAction.text('x').megacredits(3);
          });
        }),
      },
    });
  }


  public canAct(player: IPlayer) {
    return player.energy > 0 || this.resourceCount > 0;
  }

  public action(player: IPlayer) {
    const firstOption = new SelectOption(
      'Spend 1 energy to add 1 data to this card.',
      'Spend energy')
      .andThen(() => {
        player.stock.deduct(Resource.ENERGY, 1);
        player.addResourceTo(this, {qty: 1, log: true});
        return undefined;
      });

    const secondOption = new SelectOption(
      'Remove all data from this card to gain 3M€ per data removed.',
      'Spend data')
      .andThen(() => {
        player.stock.add(Resource.MEGACREDITS, 3 * this.resourceCount, {log: true});
        this.resourceCount = 0; // Should this use addResourceTo?
        return undefined;
      });

    if (this.resourceCount === 0) {
      firstOption.cb(undefined);
      return undefined;
    }
    if (player.energy === 0) {
      secondOption.cb(undefined);
      return undefined;
    }
    return new OrOptions(firstOption, secondOption);
  }
}

================
File: cards/pathfinders/CultivationOfVenus.ts
================
import {IProjectCard} from '../IProjectCard';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class CultivationOfVenus extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CULTIVATION_OF_VENUS,
      cost: 18,
      tags: [Tag.PLANT, Tag.VENUS],
      victoryPoints: {tag: Tag.VENUS, per: 2},

      action: {
        spend: {plants: 3},
        global: {venus: 1},
        //   player.game.log('${0} spent 3 plants to raise the Venus level 1 step', (b) => b.player(player));
      },

      metadata: {
        cardNumber: 'Pf45',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 3 plants to raise Venus 1 step.', (eb) => {
            eb.plants(3).startAction.venus(1);
          }).br;
        }),
        description: '1 VP for every 2 Venus tags you own.',
      },
    });
  }
}

================
File: cards/pathfinders/Cyanobacteria.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {AddResourcesToCards} from '../../deferredActions/AddResourcesToCards';

export class Cyanobacteria extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CYANOBACTERIA,
      cost: 12,
      tags: [Tag.MICROBE, Tag.MARS],

      behavior: {
        global: {oxygen: 1},
      },

      metadata: {
        cardNumber: 'Pf27',
        renderData: CardRenderer.builder((b) => {
          b.oxygen(1).br;
          b.resource(CardResource.MICROBE).asterix().slash().oceans(1).br;
        }),
        description: 'Raise the oxygen level 1%. For every ocean tile, add a microbe to ANY card.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const microbes = player.game.board.getOceanSpaces({upgradedOceans: true, wetlands: true}).length;
    player.game.defer(new AddResourcesToCards(player, CardResource.MICROBE, microbes));
    return undefined;
  }
}

================
File: cards/pathfinders/DataLeak.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';

export class DataLeak extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.DATA_LEAK,
      cost: 5,

      behavior: {
        addResourcesToAnyCard: {count: 5, type: CardResource.DATA},
      },

      metadata: {
        cardNumber: 'Pf30',
        renderData: CardRenderer.builder((b) => b.resource(CardResource.DATA, 5).asterix()),
        description: 'Add 5 data to ANY card.',
      },
    });
  }
}

================
File: cards/pathfinders/DeclarationOfIndependence.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class DeclarationOfIndependence extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.DECLARATION_OF_INDEPENDENCE,
      cost: 20,
      tags: [Tag.MARS],
      requirements: {tag: Tag.MARS, count: 6},
      victoryPoints: 4,

      behavior: {
        turmoil: {sendDelegates: {count: 2}},
      },

      metadata: {
        cardNumber: 'Pf34',
        renderData: CardRenderer.builder((b) => b.delegates(2).asterix),
        description: 'Requires that you have at least 6 Mars tags in play. Place 2 delegates in any party.',
      },
    });
  }
}

================
File: cards/pathfinders/DeepSpaceOperations.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';

export class DeepSpaceOperations extends PreludeCard {
  constructor() {
    super({
      name: CardName.DEEP_SPACE_OPERATIONS,
      tags: [Tag.SPACE],

      behavior: {
        stock: {titanium: 4},
        drawCard: {count: 2, tag: Tag.SPACE, type: CardType.EVENT},
      },

      metadata: {
        cardNumber: 'P08',
        renderData: CardRenderer.builder((b) => {
          b.titanium(4).br;
          b.cards(2, {secondaryTag: Tag.EVENT}).super((sb) => sb.tag(Tag.SPACE));
        }),
        description: 'Gain 4 titanium. Draw 2 event cards with a space tag.',
      },
    });
  }
}

================
File: cards/pathfinders/DesignCompany.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class DesignCompany extends PreludeCard {
  constructor() {
    super({
      name: CardName.DESIGN_COMPANY,
      tags: [Tag.MARS],

      behavior: {
        production: {steel: 1},
        drawCard: {count: 3, tag: Tag.BUILDING},
      },

      metadata: {
        cardNumber: 'P08',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(1)).br;
          b.cards(3, {secondaryTag: Tag.BUILDING});
        }),
        description: 'Increase your steel production 1 step. Draw 3 cards with a building tag.',
      },
    });
  }
}

================
File: cards/pathfinders/DesignedOrganisms.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';

export class DesignedOrganisms extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DESIGNED_ORGANISMS,
      cost: 13,
      tags: [Tag.SCIENCE, Tag.PLANT, Tag.MARS],
      requirements: {tag: Tag.SCIENCE, count: 5},

      behavior: {
        production: {plants: 2},
        stock: {plants: 3},
        addResourcesToAnyCard: [
          {count: 3, type: CardResource.MICROBE},
          {count: 1, type: CardResource.ANIMAL},
        ],
      },

      metadata: {
        cardNumber: 'Pf23',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(2)).plants(3).br;
          b.resource(CardResource.MICROBE, 3).asterix().resource(CardResource.ANIMAL).asterix();
        }),
        description: 'Requires 5 science tags. Increase your plant production 2 steps. Gain 3 plants. ' +
          'Add 3 microbes to ANY card. Add 1 animal to ANY card.',
      },
    });
  }
}

================
File: cards/pathfinders/DustStorm.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {all} from '../Options';

export class DustStorm extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.DUST_STORM,
      cost: 17,
      tags: [Tag.MARS],

      behavior: {
        global: {temperature: 2},
      },

      metadata: {
        cardNumber: 'Pf08',
        renderData: CardRenderer.builder((b) => {
          b.minus().energy(1, {all}).asterix();
          b.br;
          b.temperature(2);
        }),
        description: 'Every player loses all energy. Raise the temperature 2 steps.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.game.getPlayers().forEach((target) => {
      target.maybeBlockAttack(player, (proceed) => {
        if (proceed) {
          target.stock.deduct(Resource.ENERGY, target.energy, {log: true});
        }
        return undefined;
      });
    });
    return undefined;
  }
}

================
File: cards/pathfinders/DysonScreens.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {Size} from '../../../common/cards/render/Size';
import {SpaceName} from '../../SpaceName';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {ActionCard} from '../ActionCard';

export class DysonScreens extends ActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.DYSON_SCREENS,
      tags: [Tag.SCIENCE, Tag.VENUS, Tag.POWER, Tag.SPACE],
      cost: 28,
      victoryPoints: 1,

      behavior: {
        production: {energy: 2, heat: 2},
        drawCard: 1,
        global: {temperature: 1},
        city: {space: SpaceName.DYSON_SCREENS},
      },

      action: {
        spend: {titanium: 2},
        production: {energy: 1, heat: 1},
      },

      metadata: {
        cardNumber: 'Pf15',
        renderData: CardRenderer.builder((b) => {
          b.action(
            'Pay 2 titanium to raise your heat and energy production 1 step each.',
            (ab) => ab.titanium(2, {digit}).startAction.production((pb) => pb.heat(1).energy(1))).br;
          b.temperature(1).cards(1, {size: Size.SMALL}).city({size: Size.SMALL}).asterix();
          b.production((pb) => pb.heat(2, {digit}).energy(2, {digit}));
        }),
        description: 'Raise the temperature 1 step. Draw a card. Place a city tile ON THE RESERVED AREA. Raise your energy and heat production 2 steps.',
      },
    });
  }
}

================
File: cards/pathfinders/EarlyExpedition.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {max} from '../Options';

export class EarlyExpedition extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.EARLY_EXPEDITION,
      cost: 15,
      tags: [Tag.SCIENCE, Tag.SPACE, Tag.CITY],
      requirements: {temperature: -18, max},

      behavior: {
        production: {energy: -1, megacredits: 3},
        addResourcesToAnyCard: {type: CardResource.DATA, count: 1},
        city: {on: 'isolated'},
      },

      metadata: {
        cardNumber: 'Pf18',
        renderData: CardRenderer.builder((b) => {
          b.minus().production((pb) => pb.energy(1)).production((pb) => pb.megacredits(3)).br;
          b.resource(CardResource.DATA).asterix().city().asterix();
        }),
        description: 'Temperature must be -18 C or lower. Decrease your energy production 1 step and ' +
          'Raise your M€ production 3 steps. Add 1 data to ANY card. Place a city tile on Mars NEXT TO NO OTHER TILE.',
      },
    });
  }
}

================
File: cards/pathfinders/EconomicEspionage.ts
================
import {IProjectCard} from '../IProjectCard';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';

export class EconomicEspionage extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ECONOMIC_ESPIONAGE,
      cost: 8,
      tags: [Tag.EARTH],
      resourceType: CardResource.DATA,
      victoryPoints: {resourcesHere: {}, per: 3},

      action: {
        spend: {megacredits: 2},
        addResourcesToAnyCard: {count: 1, type: CardResource.DATA},
      },

      metadata: {
        cardNumber: 'Pf37',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 M€ to Add 1 data to ANY card.', (eb) => {
            eb.megacredits(2).startAction.resource(CardResource.DATA).asterix();
          }).br;
        }),
        description: '1VP for every 3 data here.',
      },
    });
  }
}

================
File: cards/pathfinders/EconomicHelp.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {isPlanetaryTag, PlanetaryTag} from '../../pathfinders/PathfindersData';
import {PathfindersExpansion, TRACKS} from '../../pathfinders/PathfindersExpansion';
import {Tag} from '../../../common/cards/Tag';
import {Size} from '../../../common/cards/render/Size';
import {PathfindersData} from '../../pathfinders/PathfindersData';

export class EconomicHelp extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.ECONOMIC_HELP,
      cost: 9,

      behavior: {
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'Pf42',
        renderData: CardRenderer.builder((b) => {
          b.planetaryTrack().text('3').or().text('2')
            .tag(Tag.VENUS).or(Size.SMALL)
            .tag(Tag.EARTH).or(Size.SMALL).br;
          b.tag(Tag.MARS).or(Size.SMALL)
            .tag(Tag.JOVIAN).or(Size.SMALL)
            .tag(Tag.MOON).br;
          b.production((pb) => pb.megacredits(1));
        }),
        description: 'Raise the lowest non-completed planetary influence track 3 steps. When tied, raise all lowest tracks 2 steps. ' +
         'Increase your M€ production 1 step',
      },
    });
  }

  private trackOffset(tag: PlanetaryTag, data: PathfindersData): number {
    const value = data[tag];
    const maxValue = TRACKS[tag].spaces.length - 1;
    return maxValue === value ? -1 : value;
  }

  public override bespokePlay(player: IPlayer) {
    const data = player.game.pathfindersData;
    if (data === undefined) {
      return undefined;
    }
    const tags = player.game.tags.filter(isPlanetaryTag);
    const values = tags.map((tag) => this.trackOffset(tag, data));

    // Filter any maximized track.
    // Filter out -1.
    const lowest = Math.min(...(values.filter((v) => v >= 0)));
    const count = values.filter((v) => v === lowest).length;
    const increment = (count === 1) ? 3 : 2;
    if (data.earth === lowest) PathfindersExpansion.raiseTrack(Tag.EARTH, player, increment);
    if (data.jovian === lowest) PathfindersExpansion.raiseTrack(Tag.JOVIAN, player, increment);
    if (data.mars === lowest) PathfindersExpansion.raiseTrack(Tag.MARS, player, increment);
    if (data.moon === lowest && player.game.gameOptions.moonExpansion === true) PathfindersExpansion.raiseTrack(Tag.MOON, player, increment);
    if (data.venus === lowest && player.game.gameOptions.venusNextExtension === true) PathfindersExpansion.raiseTrack(Tag.VENUS, player, increment);
    return undefined;
  }
}

================
File: cards/pathfinders/ExpeditionToTheSurfaceVenus.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class ExpeditionToTheSurfaceVenus extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.EXPEDITION_TO_THE_SURFACE_VENUS,
      cost: 16,
      tags: [Tag.VENUS],

      behavior: {
        drawCard: 2,
        global: {venus: 1},
        stock: {megacredits: {tag: Tag.VENUS}},
      },

      metadata: {
        cardNumber: 'Pf46',
        renderData: CardRenderer.builder((b) => {
          b.cards(2).venus(1).br;
          b.megacredits(1).slash().tag(Tag.VENUS);
        }),
        description: 'Draw 2 cards. Raise Venus 1 step. Gain 1M€ for each of your Venus tags, including this.',
      },
    });
  }
}

================
File: cards/pathfinders/ExperiencedMartians.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class ExperiencedMartians extends PreludeCard {
  constructor() {
    super({
      name: CardName.EXPERIENCED_MARTIANS,

      behavior: {
        production: {megacredits: 2},
        drawCard: {count: 2, tag: Tag.MARS},
        turmoil: {sendDelegates: {count: 1}},
      },

      metadata: {
        cardNumber: 'P08',
        renderData: CardRenderer.builder((b) => {
          b.delegates(1).cards(1, {secondaryTag: Tag.MARS}).cards(1, {secondaryTag: Tag.MARS}).production((pb) => pb.megacredits(2));
        }),
        description: 'Place 1 delegate in any party. Draw 2 cards with a Mars tag. Increase your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/pathfinders/FlatMarsTheory.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {max} from '../Options';

export class FlatMarsTheory extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FLAT_MARS_THEORY,
      cost: 8,
      tags: [Tag.EARTH],
      requirements: {tag: Tag.SCIENCE, count: 1, max},

      metadata: {
        cardNumber: 'Pf39',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1)).slash().text('GENERATION');
        }),
        description: 'Requires maximum 1 science tag. Increase your M€ production 1 step for every generation played so far.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const generation = player.game.generation;
    player.production.add(Resource.MEGACREDITS, generation, {log: true});
    return undefined;
  }
}

================
File: cards/pathfinders/FloaterUrbanism.ts
================
import {IProjectCard} from '../IProjectCard';
import {IActionCard} from '../ICard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';
import {SelectCard} from '../../inputs/SelectCard';

export class FloaterUrbanism extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.FLOATER_URBANISM,
      cost: 7,
      tags: [Tag.VENUS],
      resourceType: CardResource.VENUSIAN_HABITAT,
      requirements: {tag: Tag.VENUS, count: 4},
      victoryPoints: {resourcesHere: {}},

      metadata: {
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 floater from any card to add 1 Venusian habitat on this card.', (ab) => {
            ab.minus().resource(CardResource.FLOATER).startAction.resource(CardResource.VENUSIAN_HABITAT);
          }).br;
          b.vpText('1 VP for every Venusian habitat on this card.');
        }),
        description: 'Requires 4 Venus tags.',
      },
    });
  }


  public canAct(player: IPlayer) {
    return player.getResourceCount(CardResource.FLOATER) > 0;
  }

  public action(player: IPlayer) {
    const cards = player.getCardsWithResources(CardResource.FLOATER);
    const input = new SelectCard(
      'Choose a card to move a floater to a Venusian habitat.',
      'Choose',
      cards)
      .andThen(([card]) => {
        player.removeResourceFrom(card, 1);
        player.addResourceTo(this, {log: true});
        return undefined;
      });
    if (cards.length === 0) {
      return undefined;
    }
    if (cards.length === 1) {
      input.cb(cards);
      return undefined;
    }
    return input;
  }
}

================
File: cards/pathfinders/GagarinMobileBase.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';
import {SpaceType} from '../../../common/boards/SpaceType';
import {Tag} from '../../../common/cards/Tag';
import {Space} from '../../boards/Space';
import {SelectSpace} from '../../inputs/SelectSpace';
import {IActionCard} from '../ICard';
import {BoardType} from '../../boards/BoardType';
import {Board} from '../../boards/Board';
import {message} from '../../logs/MessageBuilder';

export class GagarinMobileBase extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.GAGARIN_MOBILE_BASE,
      tags: [Tag.SCIENCE],
      startingMegaCredits: 42,
      initialActionText: 'Place Gagarin Mobile Base on ANY space ON MARS',

      metadata: {
        cardNumber: 'PfC13',
        description: 'You start with 42 M€. As your first action, put Gagarin Mobile Base on ANY area on Mars. Collect the bonus.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(42).br;
          b.action('Move the Base to ANY nearest empty area where it has not yet been. Collect the bonus.', (ab) =>
            ab.empty().startAction.text('move').asterix());
          b.br;
          b.effect('When another player places a tile where the Base is, move the Base.', (eb) =>
            eb.emptyTile().startEffect.text('move').asterix());
          b.br;
        }),
      },
    });
  }

  private closestSpaces(board: Board, availableSpaces: Array<Space>, space: Space): Array<Space> {
    const visitedSpaces = new Set<Space>();

    function searchSet(spaces: Set<Space>): Array<Space> {
      if (spaces.size === 0) {
        return [];
      }
      const adjacentSpaces = new Set(Array.from(spaces).map((s) => board.getAdjacentSpaces(s)).flat());
      const sizeBefore = visitedSpaces.size;
      adjacentSpaces.forEach((s) => visitedSpaces.add(s));
      const sizeAfter = visitedSpaces.size;
      if (sizeBefore === sizeAfter) {
        return [];
      }

      const candidateSpaces = [...adjacentSpaces].filter((s) => availableSpaces.includes(s));
      if (candidateSpaces.length > 0) {
        return candidateSpaces;
      }
      return searchSet(adjacentSpaces);
    }

    visitedSpaces.add(space);
    return searchSet(new Set([space]));
  }

  private availableSpaces(player: IPlayer) {
    const board = player.game.board;
    const visited = player.game.gagarinBase;
    const availableSpaces = board.spaces
      .filter((space) => space.spaceType !== SpaceType.COLONY)
      .filter((space) => space.spaceType !== SpaceType.RESTRICTED)
      .filter((space) => space.tile === undefined)
      .filter((space) => !visited.includes(space.id));

    if (visited[0] === undefined) {
      return availableSpaces;
    }
    const currentSpace = board.getSpaceOrThrow(visited[0]);
    return this.closestSpaces(board, availableSpaces, currentSpace);
  }

  public canAct(player: IPlayer): boolean {
    return this.availableSpaces(player).length > 0;
  }

  public action(player: IPlayer) {
    const spaces = this.availableSpaces(player);
    if (spaces.length > 0) {
      return new SelectSpace(
        message('Select new space for ${0}', (b) => b.card(this)), this.availableSpaces(player))
        .andThen((space) => {
          player.game.gagarinBase.unshift(space.id);
          player.game.grantSpaceBonuses(player, space);
          return undefined;
        });
    }
    return undefined;
  }

  public initialAction(player: IPlayer) {
    return this.action(player);
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space, boardType: BoardType) {
    if (boardType === BoardType.MOON) {
      return;
    }
    if (cardOwner === activePlayer) {
      return;
    }
    if (space.id === activePlayer.game.gagarinBase[0]) {
      cardOwner.defer(this.action(cardOwner));
    }
  }
}

================
File: cards/pathfinders/GeologicalExpedition.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {IPlayer} from '../../IPlayer';
import {BoardType} from '../../boards/BoardType';
import {Space} from '../../boards/Space';
import {Resource} from '../../../common/Resource';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {Priority} from '../../deferredActions/Priority';
import {SpaceType} from '../../../common/boards/SpaceType';
import {Phase} from '../../../common/Phase';

const VALID_BONUSES: Array<SpaceBonus> = [
  SpaceBonus.TITANIUM,
  SpaceBonus.STEEL,
  SpaceBonus.PLANT,
  SpaceBonus.HEAT,
  SpaceBonus.MEGACREDITS,
  SpaceBonus.ANIMAL,
  SpaceBonus.MICROBE,
  SpaceBonus.ENERGY,
  SpaceBonus.DATA,
  SpaceBonus.SCIENCE,
];

export class GeologicalExpedition extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.GEOLOGICAL_EXPEDITION,
      cost: 18,
      tags: [Tag.MARS, Tag.SCIENCE],
      victoryPoints: 2,

      metadata: {
        cardNumber: 'Pf17',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you place a tile ON MARS gain 1 additional resource on the space. If the space has no bonus, gain 1 steel.', (eb) => {
            eb.emptyTile().startEffect.plus().wild(1).or().steel(1).asterix();
          }).br;
        }),
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space, boardType: BoardType) {
    if (boardType !== BoardType.MARS || space.spaceType === SpaceType.COLONY) return;
    if (cardOwner !== activePlayer) return;
    if (cardOwner.game.phase === Phase.SOLAR) return;
    // Don't grant bonuses when overplacing.
    if (space.tile?.covers !== undefined) return;

    const bonuses = space.bonus;
    if (bonuses.length === 0) {
      activePlayer.stock.add(Resource.STEEL, 1, {log: true /* , from: this.name */});
      return;
    }
    const filtered = bonuses.filter((bonus) => VALID_BONUSES.includes(bonus));
    const unique = Array.from(new Set(filtered));
    const options = new OrOptions();
    options.title = 'Select an additional bonus from this space.';
    unique.forEach((bonus) => {
      options.options.push(new SelectOption(
        SpaceBonus.toString(bonus),
        'Select')
        .andThen(() => {
          activePlayer.game.grantSpaceBonus(activePlayer, bonus, 1);
          return undefined;
        }));
    });
    if (options.options.length === 1) {
      options.options[0].cb();
      return;
    }
    if (options.options.length === 0) {
      // should not happen.
      return;
    }
    activePlayer.defer(options, Priority.GAIN_RESOURCE_OR_PRODUCTION);
  }
}

================
File: cards/pathfinders/HabitatMarte.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class HabitatMarte extends CorporationCard {
  constructor() {
    super({
      name: CardName.HABITAT_MARTE,
      tags: [Tag.MARS],
      startingMegaCredits: 40,

      metadata: {
        cardNumber: 'PfC22',
        description: 'You start with 40 M€.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(40);
          b.corpBox('effect', (ce) => {
            ce.effect('Mars tags also count as science tags.', (eb) => {
              eb.tag(Tag.MARS).startEffect.tag(Tag.SCIENCE);
            });
          });
        }),
      },
    });
  }
  // Behavior in Player.getTagCount
}

================
File: cards/pathfinders/HighTempSuperconductors.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {PartyName} from '../../../common/turmoil/PartyName';

export class HighTempSuperconductors extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.HIGH_TEMP_SUPERCONDUCTORS,
      cost: 10,
      tags: [Tag.POWER, Tag.SCIENCE],

      requirements: {party: PartyName.KELVINISTS},
      cardDiscount: {tag: Tag.POWER, amount: 3},

      behavior: {
        production: {energy: 2},
      },

      metadata: {
        cardNumber: 'PfTMP',
        renderData: CardRenderer.builder((b) => {
          b.effect('When playing a power card, THE STANDARD PROJECT POWER PLANT, OR THE KELVINIST RULING POLICY ACTION, pay 3M€ less.', (eb) => {
            eb.tag(Tag.POWER).asterix().slash().text('Kelvinists').startEffect.megacredits(-3);
          }).br;
          b.production((pb) => pb.energy(2));
        }),
        description: 'Requires Kelvinists are ruling or you have 2 delegates there. Increase your energy production 2 steps.',
      },
    });
  }
}

================
File: cards/pathfinders/HuygensObservatory.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {BuildColony} from '../../deferredActions/BuildColony';
import {OrOptions} from '../../inputs/OrOptions';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectColony} from '../../inputs/SelectColony';
import {IColony} from '../../colonies/IColony';
import {ColoniesHandler} from '../../colonies/ColoniesHandler';

export class HuygensObservatory extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 27,
      tags: [Tag.SCIENCE, Tag.SPACE],
      name: CardName.HUYGENS_OBSERVATORY,
      type: CardType.AUTOMATED,
      victoryPoints: 1,

      behavior: {
        tr: 1,
      },

      metadata: {
        cardNumber: 'Pf61',
        renderData: CardRenderer.builder((b) => b.colonies(1).asterix().trade().asterix().tr(1)),
        description: 'Place a colony. MAY BE PLACED ON A COLONY TILE WHERE YOU ALREADY HAVE A COLONY. ' +
          'Trade for free. You may use a Trade Fleet that is already on a colony tile, but you may not ' +
          'trade with the tile that fleet came from. Gain 1 TR.',
      },
    });
  }

  private trade(player: IPlayer, colonies: Array<IColony>) {
    return new SelectColony('Select colony tile to trade with for free', 'Select', colonies)
      .andThen((colony) => {
        colony.trade(player);
        return undefined;
      });
  }

  private tryToTrade(player: IPlayer) {
    const game = player.game;
    const tradeableColonies = ColoniesHandler.tradeableColonies(player.game);
    if (tradeableColonies.length === 0) {
      game.log(
        '${0} cannot trade with ${1} because there is no colony they may visit.',
        (b) => b.player(player).card(this));
      return;
    }

    const orOptions = new OrOptions();
    orOptions.title = 'Select a trade fleet';

    const visitedColonies = game.colonies.filter((colony) => colony.visitor === player.id);
    const hasFreeTradeFleet = visitedColonies.length < player.colonies.getFleetSize();
    const tradeInput = this.trade(player, tradeableColonies);
    if (visitedColonies.length > 0) {
      orOptions.options.push(
        new SelectColony(
          'Select a colony tile to recall a trade fleet from',
          'OK',
          visitedColonies)
          .andThen((colony) => {
            game.log(
              '${0} is reusing a trade fleet from ${1}',
              (b) => b.player(player).colony(colony));
            colony.visitor = undefined;
            // TODO(kberg): counting the trades in a generation is not the same as using trade fleets. :[
            player.colonies.tradesThisGeneration--;
            player.defer(() => tradeInput);
            return undefined;
          }));
    }
    if (hasFreeTradeFleet) {
      if (orOptions.options.length === 1) {
        orOptions.options.push(new SelectOption('Use an available trade fleet').andThen(() => {
          player.defer(tradeInput);
          return undefined;
        }));
      } else {
        player.defer(tradeInput);
      }
    }
    if (orOptions.options.length === 1) {
      player.defer(orOptions.options[0]);
    }
    if (orOptions.options.length > 1) {
      player.defer(orOptions);
    }
  }
  public override bespokeCanPlay(player: IPlayer): boolean {
    // NOTE: Don't use canTrade.
    if (player.game.tradeEmbargo === true) {
      return false;
    }
    if (player.colonies.getPlayableColonies(/** allowDuplicate = */true).length === 0) {
      return false;
    }
    if (ColoniesHandler.tradeableColonies(player.game).length === 0) {
      return false;
    }
    return true;
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;

    if (player.colonies.getPlayableColonies(/** allowDuplicate = */true).length > 0) {
      game.defer(new BuildColony(player, {
        allowDuplicate: true,
        title: 'Select colony for Huygens Observatory',
      })).andThen(() => this.tryToTrade(player));
    } else {
      player.defer(() => this.tryToTrade(player));
    }
    return undefined;
  }
}

================
File: cards/pathfinders/HydrogenBombardment.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class HydrogenBombardment extends PreludeCard {
  constructor() {
    super({
      name: CardName.HYDROGEN_BOMBARDMENT,
      tags: [Tag.SPACE, Tag.VENUS],
      behavior: {
        production: {titanium: 1},
        global: {venus: 1},
        stock: {megacredits: 6},
      },

      metadata: {
        cardNumber: 'P04',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).br;
          b.production((pb) => pb.titanium(1)).br;
          b.megacredits(6);
        }),
        description: 'Increase the Venus scale 1 step. Increase your titanium production 1 step. Gain 6 M€.',
      },
    });
  }
}

================
File: cards/pathfinders/HydrogenProcessingPlant.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class HydrogenProcessingPlant extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HYDROGEN_PROCESSING_PLANT,
      cost: 9,
      tags: [Tag.BUILDING, Tag.POWER],
      requirements: {oxygen: 3},
      victoryPoints: -1,

      behavior: {
        global: {oxygen: -1},
        production: {energy: {oceans: {}, per: 2}},
      },

      metadata: {
        cardNumber: 'Pf19',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1)).slash().oceans(2).br;
          b.minus().oxygen(1).br;
        }),
        description: 'Oxygen level must be 3% or higher. Decrease oxygen level 1% ' +
          'Raise your energy production 1 step for every two ocean tiles on Mars.',
      },
    });
  }
}

================
File: cards/pathfinders/IapetusII.ts
================
import {Colony} from '../../colonies/Colony';
import {ColonyName} from '../../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../../common/colonies/ColonyBenefit';
import {CardResource} from '../../../common/CardResource';

export class IapetusII extends Colony {
  constructor() {
    super({
      name: ColonyName.IAPETUS_II,
      description: [
        'Add 3 data to ANY card',
        'Add n data to ANY card',
        'Add 1 data to ANY card',
      ],

      cardResource: CardResource.DATA,
      buildType: ColonyBenefit.ADD_RESOURCES_TO_CARD,
      buildQuantity: [3, 3, 3],

      tradeType: ColonyBenefit.ADD_RESOURCES_TO_CARD,
      tradeQuantity: [0, 1, 2, 3, 4, 5, 6],
      colonyBonusType: ColonyBenefit.ADD_RESOURCES_TO_CARD,
    });
  }
  public override isActive = false;
}

================
File: cards/pathfinders/ICloneTagCard.ts
================
import {Tag} from '../../../common/cards/Tag';

/*
 * Implementing clone tags is a little tricky and falls outside of fairly standard behavior.
 * To make a clone tag work:
 * 1) implement ICloneTag on the card.
 * 2) initialze cloneTag to Tag.CLONE, not in the constructor, but as an attribute.
 * 3) Don't define tags in the constructor, implement tags as a getter.
 *
 * These three steps create a card with a clone tag that serializes and deserializes.
 *
 * This could be simpler with some sort of mutliple inheritence, e.g.
 * https://stackoverflow.com/questions/40807808/typescript-multiple-inheritance
 * but not right now.
 */

// A card that has a clone tag icon also must store information about what that card's clone tag represents.
export interface ICloneTagCard {
  cloneTag: Tag;
}

export function isICloneTagCard(obj: object): obj is ICloneTagCard {
  return 'cloneTag' in obj;
}

================
File: cards/pathfinders/InterplanetaryTransport.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {all} from '../Options';

export class InterplanetaryTransport extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INTERPLANETARY_TRANSPORT,
      cost: 15,
      tags: [Tag.EARTH, Tag.JOVIAN, Tag.SPACE],
      victoryPoints: 1,

      behavior: {
        production: {megacredits: {cities: {where: 'offmars'}}},
      },

      metadata: {
        cardNumber: 'Pf43',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1)).slash().city({all, secondaryTag: Tag.SPACE}).asterix;
        }),
        description: 'Increase your M€ production 1 step for every offworld city tile.',
      },
    });
  }
}

================
File: cards/pathfinders/Kickstarter.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {DeclareCloneTag} from '../../pathfinders/DeclareCloneTag';
import {ICloneTagCard} from './ICloneTagCard';
import {PathfindersExpansion} from '../../pathfinders/PathfindersExpansion';

export class Kickstarter extends Card implements IProjectCard, ICloneTagCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.KICKSTARTER,
      cost: 12,

      metadata: {
        cardNumber: 'PfTBD',
        renderData: CardRenderer.builder((b) => {
          b.planetaryTrack().text('3');
        }),
        description: 'Choose a planet tag. This card counts as having 1 of that tag. Raise the corresponding planetary track 3 steps in total.',
      },
    });
  }

  public cloneTag: Tag = Tag.CLONE;

  public override get tags(): Array<Tag> {
    return [this.cloneTag];
  }

  public override bespokePlay(player: IPlayer) {
    // player.production.adjust(this.productionBox); Why was this here? Remove it, I suppose.
    player.game.defer(new DeclareCloneTag(player, this))
      // +2 instead of +3 because onCardPlayed covers applying one of the 3.
      .andThen((tag) => PathfindersExpansion.raiseTrack(tag, player, 2));
    return undefined;
  }
}

================
File: cards/pathfinders/LastResortIngenuity.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class LastResortIngenuity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.LAST_RESORT_INGENUITY,
      cost: 4,

      metadata: {
        cardNumber: 'Pf47',
        renderData: CardRenderer.builder((b) => {
          b.cards(1).asterix().colon().super((b) => b.steel(1).titanium(1));
          b.br;
          b.text('The next card you play this generation can be paid for with steel or titanium despite its tags.', Size.MEDIUM, true, true);
        }),
      },
    });
  }
  // Behavior in player.canUseSteel, player.canUseTitanium, and SelectPaymentDeferred.
}

================
File: cards/pathfinders/LeavittII.ts
================
import {Colony} from '../../colonies/Colony';
import {ColonyName} from '../../../common/colonies/ColonyName';
import {Resource} from '../../../common/Resource';
import {ColonyBenefit} from '../../../common/colonies/ColonyBenefit';

export class LeavittII extends Colony {
  constructor() {
    super({
      name: ColonyName.LEAVITT_II,
      description: [
        'Gain 2 science tags and 1 clone tag',
        'Raise any planetary track n steps',
        'Gain 2 M€',
      ],

      buildType: ColonyBenefit.GAIN_SCIENCE_TAGS_AND_CLONE_TAG,

      tradeType: ColonyBenefit.RAISE_PLANETARY_TRACK,
      tradeQuantity: [0, 1, 1, 2, 2, 3, 4],
      colonyBonusType: ColonyBenefit.GAIN_RESOURCES,
      colonyBonusQuantity: 2,
      colonyBonusResource: Resource.MEGACREDITS,
    });
  }
}

================
File: cards/pathfinders/LobbyHalls.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {DeclareCloneTag} from '../../pathfinders/DeclareCloneTag';
import {ICloneTagCard} from './ICloneTagCard';

export class LobbyHalls extends Card implements IProjectCard, ICloneTagCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LOBBY_HALLS,
      cost: 11,

      behavior: {
        production: {megacredits: 2},
        turmoil: {sendDelegates: {count: 1}},
      },

      metadata: {
        cardNumber: 'PfTBD',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).delegates(1);
        }),
        description: 'Increase your M€ production 2 steps. Place 1 delegate in any party.' +
                     ' Choose a planet tag. This card counts as having 1 of that tag. Raise the corresponding planetary track 1 step.',
      },
    });
  }

  public cloneTag: Tag = Tag.CLONE;

  public override get tags(): Array<Tag> {
    return [this.cloneTag, Tag.BUILDING];
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new DeclareCloneTag(player, this));
    return undefined;
  }
}

================
File: cards/pathfinders/LunarEmbassy.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {SpaceName} from '../../SpaceName';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class LunarEmbassy extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LUNAR_EMBASSY,
      tags: [Tag.EARTH, Tag.MARS, Tag.CITY, Tag.SPACE],
      cost: 28,
      victoryPoints: 2,

      behavior: {
        drawCard: 1,
        city: {space: SpaceName.LUNAR_EMBASSY},
        production: {megacredits: 3, plants: {tag: Tag.EARTH, per: 2}},
      },

      metadata: {
        cardNumber: 'Pf16',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(3))
            .production((pb) => pb.plants(1).slash().tag(Tag.EARTH, 2))
            .br
            .cards(1).city().asterix().br;
        }),
        description: 'Increase your M€ production 3 steps, and plant production 1 step for every 2 Earth tags (including this.) ' +
          'Draw a card. Place a city tile ON THE RESERVED AREA.',
      },
    });
  }
}

================
File: cards/pathfinders/LuxuryEstate.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class LuxuryEstate extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LUXURY_ESTATE,
      cost: 12,
      tags: [Tag.EARTH, Tag.MARS, Tag.BUILDING],
      requirements: {oxygen: 7},

      behavior: {
        stock: {titanium: {cities: {}, greeneries: {}, all: false}},
      },

      metadata: {
        cardNumber: 'Pf21',
        renderData: CardRenderer.builder((b) => {
          b.titanium(1).slash().city().plus().greenery({withO2: false});
        }),
        description: 'Oxygen must be 7% or greater. Gain 1 titanium for each city tile and greenery tile you own.',
      },
    });
  }
}

================
File: cards/pathfinders/MagneticFieldStimulationDelays.ts
================
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {CardRenderer} from '../render/CardRenderer';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().temperature(2).nbsp.minus().oxygen(2);
});

export class MagneticFieldStimulationDelays extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.MAGNETIC_FIELD_STIMULATION_DELAYS,
      description: 'Lower the temperature and oxygen 2 steps each. (-4C, -2% O2)',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame) {
    game.increaseOxygenLevel(game.getPlayersInGenerationOrder()[0], -2);
    game.increaseTemperature(game.getPlayersInGenerationOrder()[0], -2);
  }
}

================
File: cards/pathfinders/MarsDirect.ts
================
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {CorporationCard} from '../corporation/CorporationCard';
import {IProjectCard} from '../IProjectCard';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

// TODO(kberg): This card is actually different: it uses resources to track on this card, which
// means this result can be changed by cards like CEO's Favorite Project.
// It also means cards with a wild tag may impact this.
export class MarsDirect extends CorporationCard {
  constructor() {
    super({
      name: CardName.MARS_DIRECT,
      tags: [Tag.MARS],
      startingMegaCredits: 52,

      metadata: {
        description: 'You start with 52 M€.',
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(52).br;
          b.corpBox('effect', (ce) => {
            ce.effect('When you play a Mars tag, you pay 1 M€ less for each Mars tag you have.', (eb) => {
              eb.tag(Tag.MARS).startEffect.megacredits(1).slash().tag(Tag.MARS);
            });
          });
        }),
      },
    });
  }

  public override getCardDiscount(player: IPlayer, card: IProjectCard) {
    if (card.tags.indexOf(Tag.MARS) === -1) {
      return 0;
    }
    return player.tags.count(Tag.MARS);
  }
}

================
File: cards/pathfinders/MarsFrontierAlliance.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../../server/IPlayer';
import {PlayerInput} from '../../../server/PlayerInput';
import {Turmoil} from '../../turmoil/Turmoil';
import {ChooseAlliedParty} from '../../../server/deferredActions/ChooseAlliedParty';

export class MarsFrontierAlliance extends CorporationCard {
  constructor() {
    super({
      name: CardName.MARS_FRONTIER_ALLIANCE,
      tags: [],
      startingMegaCredits: 40,

      metadata: {
        cardNumber: 'PfCXXX',
        description:
          'You start with 40 M€. When you reveal this card, select any remaining political program tile (you may use its effect as a passive effect of your corporation or as ruling party this generation).',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(40).nbsp.policy().br;
          b.effect(
            'After new ruling party is chosen, place the political program tile of the second most popular party on this card (you may use its effect as a passive effect of your corporation or as ruling party this generation).',
            (eb) => {
              eb.empty().startEffect.plus().policy().asterix();
            },
          ).br;
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    const game = player.game;
    const turmoil = Turmoil.getTurmoil(game);

    game.defer(new ChooseAlliedParty(player, turmoil.parties, (selectedParty) => {
      player.setAlliedParty(selectedParty);
    }));
    return undefined;
  }
}

================
File: cards/pathfinders/MarsMaths.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class MarsMaths extends CorporationCard {
  constructor() {
    super({
      name: CardName.MARS_MATHS,
      tags: [Tag.SCIENCE],
      startingMegaCredits: 40,

      firstAction: {
        text: 'Draw 2 cards',
        drawCard: {count: 2},
      },

      metadata: {
        cardNumber: 'PfCXX',
        description: 'You start with 40 M€. As your first action, draw 2 cards',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(40).nbsp.cards(2).br;
          b.effect('At the beginning of the Research phase, you draw 5 cards, but may STILL only buy 4 cards. If you are drafting, keep 2 cards for your first draft.', (eb) => {
            eb.empty().startEffect.plus().cards(1).asterix();
          }).br;
          b.action('Take another two actions this turn.', (eb) => {
            eb.empty().startAction.colon().nbsp.arrow().arrow();
          });
        }),
      },
    });
  }

  public canAct() {
    return true;
  }

  public action(player: IPlayer) {
    player.availableActionsThisRound += 2;
    return undefined;
  }
}

================
File: cards/pathfinders/MartianCulture.ts
================
import {IProjectCard} from '../IProjectCard';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {all} from '../Options';

export class MartianCulture extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MARTIAN_CULTURE,
      cost: 11,
      tags: [Tag.MARS, Tag.MARS],
      resourceType: CardResource.DATA,
      requirements: {tag: Tag.MARS, count: 2, all},
      victoryPoints: {resourcesHere: {}, per: 2},

      action: {
        addResourcesToAnyCard: {type: CardResource.DATA, count: 1},
      },

      metadata: {
        cardNumber: 'Pf35',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 data to ANY card.', (eb) => eb.empty().startAction.resource(CardResource.DATA).asterix());
        }),
        description: 'Requires any 2 Mars tags in play.  1 VP for every 2 data here.',
      },
    });
  }
}

================
File: cards/pathfinders/MartianDustProcessingPlant.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class MartianDustProcessingPlant extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MARTIAN_DUST_PROCESSING_PLANT,
      cost: 15,
      tags: [Tag.MARS, Tag.BUILDING],

      behavior: {
        production: {energy: -1, steel: 2},
        tr: 1,
      },

      metadata: {
        cardNumber: 'Pf44',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().energy(1).nbsp.steel(2)).br;
          b.tr(1);
        }),
        description: 'Decrease your energy production 1 step, and raise your steel production 2 steps. Gain 1 TR.',
      },
    });
  }
}

================
File: cards/pathfinders/MartianInsuranceGroup.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {IProjectCard} from '../IProjectCard';

export class MartianInsuranceGroup extends CorporationCard {
  constructor() {
    super({
      name: CardName.MARTIAN_INSURANCE_GROUP,
      tags: [Tag.MARS],
      startingMegaCredits: 42,

      behavior: {
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'PfC12',
        description: 'You start with 42 M€ and 1 M€ production.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(42).production((pb) => pb.megacredits(1));
          b.corpBox('effect', (ce) => {
            ce.effect('Whenever you play an event card, raise your M€ production 1 step.', (eb) => {
              eb.tag(Tag.EVENT).startEffect.production((pb) => pb.megacredits(1));
            });
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    if (player.isCorporation(this.name) && card.type === CardType.EVENT) {
      player.production.add(Resource.MEGACREDITS, 1, {log: true});
    }
  }
}

================
File: cards/pathfinders/MartianMonuments.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {Board} from '../../boards/Board';
import {SpaceType} from '../../../common/boards/SpaceType';

export class MartianMonuments extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MARTIAN_MONUMENTS,
      cost: 10,
      tags: [Tag.MARS, Tag.BUILDING],
      requirements: {cities: 1, text: 'ON MARS'},

      behavior: {
        production: {megacredits: {tag: Tag.MARS}},
      },

      metadata: {
        cardNumber: 'Pf09',
        renderData: CardRenderer.builder((b) => {
          b.production(((pb) => pb.megacredits(1))).slash().tag(Tag.MARS);
        }),
        description: 'Requires that you own a city ON MARS. Raise your M€ production 1 step for every Mars tag you own (including this.)',
      },
    });
  }

  // Is this necessary?
  public override bespokeCanPlay(player: IPlayer) {
    return player.game.board.spaces.some((space) => {
      return Board.isCitySpace(space) && space.player?.id === player.id && space.spaceType !== SpaceType.COLONY;
    });
  }
}

================
File: cards/pathfinders/MartianNatureWonders.ts
================
import {IProjectCard} from '../IProjectCard';
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {SelectSpace} from '../../inputs/SelectSpace';
import {CardResource} from '../../../common/CardResource';
import {TileType} from '../../../common/TileType';
import {message} from '../../logs/MessageBuilder';

export class MartianNatureWonders extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MARTIAN_NATURE_WONDERS,
      cost: 13,
      tags: [Tag.MARS],
      victoryPoints: 2,

      behavior: {
        addResourcesToAnyCard: {type: CardResource.DATA, count: 2},
      },

      metadata: {
        cardNumber: 'Pf10',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.RESOURCE_CUBE).asterix().br;
          b.resource(CardResource.DATA, 2).asterix();
        }),
        description: 'Place a neutral player cube on a non-reserved space. No tile can be placed on that space this game. ' +
        'Gather any bonus on that space, but no bonuses from adjacent spaces. Add 2 data to ANY card.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions) {
    return player.game.board.getAvailableSpacesOnLand(player, canAffordOptions).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace(
      message('Select space for ${0}', (b) => b.card(this)),
      player.game.board.getAvailableSpacesOnLand(player))
      .andThen((space) => {
        player.game.simpleAddTile(player, space, {tileType: TileType.MARTIAN_NATURE_WONDERS});
        player.game.grantSpaceBonuses(player, space);
        return undefined;
      });
  }
}

================
File: cards/pathfinders/MartianRepository.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {ICard} from '../ICard';

export class MartianRepository extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MARTIAN_REPOSITORY,
      cost: 12,
      tags: [Tag.MARS, Tag.MARS, Tag.BUILDING],
      resourceType: CardResource.DATA,

      behavior: {
        production: {energy: -1},
      },

      victoryPoints: {resourcesHere: {}, per: 3},

      metadata: {
        cardNumber: 'Pf29',
        renderData: CardRenderer.builder((b) => {
          b.effect('For every science or Mars tag you play (including these) add 1 data to this card.', (eb) => {
            eb.tag(Tag.SCIENCE).tag(Tag.MARS).startEffect.resource(CardResource.DATA);
          }).br;
          b.minus().production((pb) => pb.energy(1));
        }),
        description: 'Decrease your energy production 1 step. 1 VP for every 3 data here.',
      },
    });
  }


  public onCardPlayed(player: IPlayer, card: ICard) {
    const qty = player.tags.cardTagCount(card, Tag.SCIENCE) + player.tags.cardTagCount(card, Tag. MARS);
    if (qty > 0) player.addResourceTo(this, {qty, log: true});
  }
}

================
File: cards/pathfinders/MicrobiologyPatents.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';

export class MicrobiologyPatents extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MICROBIOLOGY_PATENTS,
      cost: 6,
      tags: [Tag.MARS, Tag.MICROBE],

      metadata: {
        cardNumber: 'Pf63',
        renderData: CardRenderer.builder((b) => {
          b.effect('After you play a card with a microbe tag, increase your M€ production 1 step.',
            (eb) => eb.tag(Tag.MICROBE).startEffect.production((pb) => pb.megacredits(1)));
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.tags.includes(Tag.MICROBE)) {
      player.production.add(Resource.MEGACREDITS, 1, {log: true});
    }
  }
}

================
File: cards/pathfinders/MindSetMars.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {CardResource} from '../../../common/CardResource';
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {SendDelegateToArea} from '../../deferredActions/SendDelegateToArea';
import {Turmoil} from '../../turmoil/Turmoil';
import {PlaceCityTile} from '../../deferredActions/PlaceCityTile';
import {Size} from '../../../common/cards/render/Size';

export class MindSetMars extends CorporationCard {
  constructor() {
    super({
      name: CardName.MIND_SET_MARS,
      startingMegaCredits: 44,
      resourceType: CardResource.AGENDA,

      behavior: {
        addResources: 1,
      },

      metadata: {
        cardNumber: 'PfC21',
        description: 'You start with 44 M€ and 1 agenda resource to this card.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(44).resource(CardResource.AGENDA).nbsp.tag(Tag.BUILDING).colon(Size.SMALL).resource(CardResource.AGENDA).br;
          b.text('(Action: When you play a card with a building tag, add 1 agenda on this card.)', Size.SMALL, false, false).br;
          b.resource(CardResource.AGENDA, {amount: 2, digit}).arrow(Size.SMALL).delegates(1).nbsp;
          b.resource(CardResource.AGENDA, {amount: 5, digit}).arrow(Size.SMALL).city().br;
          b.text('(Action: Spend 2 agenda resources to place 1 delegate in any party.)', Size.SMALL, false, false).br;
          b.text('(Action: Spend 5 agenda resources to place a city tile on Mars.)', Size.SMALL, false, false);
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (player.game.getCardPlayerOrUndefined(this.name) !== player) return;
    if (card.tags.includes(Tag.BUILDING)) {
      player.addResourceTo(this, {qty: 1, log: true});
    }
  }

  private canAddDelegate(player: IPlayer) {
    const turmoil = Turmoil.getTurmoil(player.game);
    return this.resourceCount >= 2 && turmoil.getAvailableDelegateCount(player) > 0;
  }

  private canAddCity(player: IPlayer) {
    return this.resourceCount >= 5 && player.game.board.getAvailableSpacesForCity(player).length > 0;
  }
  public canAct(player: IPlayer) {
    return this.canAddDelegate(player) || this.canAddCity(player);
  }

  public action(player: IPlayer) {
    const options = new OrOptions();

    if (this.canAddDelegate(player)) {
      options.options.push(new SelectOption('Spend 2 agendas to add a delegate to any party').andThen(() => {
        player.removeResourceFrom(this, 2);
        player.game.defer(new SendDelegateToArea(player));
        return undefined;
      }));
    }
    if (this.canAddCity(player)) {
      options.options.push(new SelectOption('Spend 5 agendas to place a city on Mars').andThen(() => {
        player.removeResourceFrom(this, 5);
        player.game.defer(new PlaceCityTile(player));
        return undefined;
      }));
    }
    if (options.options.length === 0) {
      return undefined;
    }
    if (options.options.length === 1) {
      return options.options[0];
    }
    return options;
  }
}

================
File: cards/pathfinders/MuseumofEarlyColonisation.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {all} from '../Options';

export class MuseumofEarlyColonisation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MUSEUM_OF_EARLY_COLONISATION,
      cost: 20,
      tags: [Tag.BUILDING, Tag.MARS],
      requirements: [{oceans: 1}, {cities: 1, all}, {greeneries: 1, all}],

      behavior: {
        production: {energy: -1, steel: 1, titanium: 1, plants: 1},
        tr: 1,
      },

      metadata: {
        cardNumber: 'Pf11',
        renderData: CardRenderer.builder((b) => {
          b.production(((pb) => pb.minus().energy(1).nbsp.steel(1).titanium(1).plants(1)));
          b.br.tr(1);
        }),
        description: 'Requires 1 ocean, 1 city and one greenery on Mars. ' +
         'Decrease your energy production 1 step. Raise your steel, titanium, and plant production 1 step. ' +
         'Gain 1 TR.',
      },
    });
  }
}

================
File: cards/pathfinders/NewVenice.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {TileType} from '../../../common/TileType';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';

export class NewVenice extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.NEW_VENICE,
      tags: [Tag.MARS, Tag.POWER, Tag.BUILDING, Tag.CITY],
      cost: 21,

      behavior: {
        production: {energy: 1, megacredits: 2},
        tile: {
          type: TileType.OCEAN_CITY,
          on: 'upgradeable-ocean',
        },
      },
      reserveUnits: {plants: 2},
      requirements: {oceans: 3},

      metadata: {
        cardNumber: 'Pf3',
        renderData: CardRenderer.builder((b) => {
          b.minus().plants(2).br;
          b.production((pb) => {
            pb.energy(1).megacredits(2);
          }).nbsp.tile(TileType.OCEAN_CITY, false, true);
        }),
        description: 'Requires 3 ocean tiles. Lose 2 plants. Increase your energy production 1 step and your M€ production 2 steps. ' +
            'Place this tile on top of an existing ocean tile, IGNORING NORMAL PLACEMENT RESTRICTIONS FOR CITIES. The tile counts as a city as well as an ocean.',
      },
    });
  }
}

================
File: cards/pathfinders/NobelLabs.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IActionCard, ICard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {digit} from '../Options';

export class NobelLabs extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.NOBEL_LABS,
      cost: 8,
      tags: [Tag.SCIENCE],
      requirements: {tag: Tag.SCIENCE, count: 4},

      metadata: {
        cardNumber: 'Pf55',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 2 microbes OR 2 data OR 2 floaters to ANY card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE, {amount: 2, digit}).slash().resource(CardResource.DATA, {amount: 2, digit}).slash().resource(CardResource.FLOATER, {amount: 2, digit}).asterix();
          });
        }),
        description: 'Requires 4 science tags.',
      },
    });
  }

  private static RESOURCE_TYPES: Array<CardResource> = [CardResource.MICROBE, CardResource.DATA, CardResource.FLOATER, CardResource.WARE];
  private static PREDICATE = (card: ICard) => card.resourceType !== undefined && NobelLabs.RESOURCE_TYPES.includes(card.resourceType);

  public canAct(player: IPlayer) {
    return player.getResourceCards().some(NobelLabs.PREDICATE);
  }

  public action(player: IPlayer) {
    player.game.defer(new AddResourcesToCard(player, undefined, {filter: NobelLabs.PREDICATE, count: 2}));
    return undefined;
  }
}

================
File: cards/pathfinders/Odyssey.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {IActionCard} from '../ICard';
import {Size} from '../../../common/cards/render/Size';
import {SelectProjectCardToPlay} from '../../inputs/SelectProjectCardToPlay';

export class Odyssey extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.ODYSSEY,
      startingMegaCredits: 33,

      metadata: {
        cardNumber: 'PfC18',
        description: 'You start with 33 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br.br.br.br.megacredits(33).nbsp.nbsp.nbsp;
          b.colon().cards(1, {secondaryTag: Tag.EVENT}).asterix().br;
          b.text('(Effect: Your event cards stay face up, and their tags are in use as if those were automated (green) cards.)',
            Size.TINY, false, false).br;
          b.action('Pay for and play an event card you have already played that has a base cost of 16M€ or less (INCLUDING events that place special tiles,) after which discard that card.', (e) => {
            e.empty().startAction.tag(Tag.EVENT).asterix().nbsp.text('≤').nbsp.megacredits(16);
          });
        }),
      },
    });
  }

  // For Project Inspection
  private checkLoops: number = 0;

  public getCheckLoops(): number {
    return this.checkLoops;
  }


  private availableEventCards(player: IPlayer) {
    this.checkLoops++;
    try {
      const array = [];
      for (const card of player.playedCards) {
        // Special case Price Wars, which is not easy to work with.
        if (card.name === CardName.PRICE_WARS) {
          continue;
        }
        if (card.type === CardType.EVENT && card.cost <= 16) {
          const details = player.canPlay(card);
          if (details !== false) {
            array.push({card, details});
          }
        }
      }
      return array;
    } finally {
      this.checkLoops--;
    }
  }

  public canAct(player: IPlayer) {
    return this.availableEventCards(player).length > 0;
  }

  public action(player: IPlayer) {
    const eventCards = this.availableEventCards(player);
    return new SelectProjectCardToPlay(player, eventCards, {action: 'discard'})
      .andThen((card) => {
        player.removedFromPlayCards.push(card);
        return undefined;
      });
  }
}

================
File: cards/pathfinders/OrbitalLaboratories.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class OrbitalLaboratories extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ORBITAL_LABORATORIES,
      cost: 18,
      tags: [Tag.SCIENCE, Tag.PLANT, Tag.SPACE],

      behavior: {
        production: {plants: 2},
        stock: {plants: 1},
      },

      metadata: {
        cardNumber: 'Pf07',
        renderData: CardRenderer.builder((b) => {
          b.production(((pb) => pb.plants(2))).nbsp.plants(1);
        }),
        description: 'Increase your plant production 2 steps. Gain 1 plant.',
      },
    });
  }
}

================
File: cards/pathfinders/OumuamuaTypeObjectSurvey.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';
import {digit} from '../Options';
import {Resource} from '../../../common/Resource';
import {Size} from '../../../common/cards/render/Size';

export class OumuamuaTypeObjectSurvey extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.OUMUAMUA_TYPE_OBJECT_SURVEY,
      cost: 20,
      tags: [Tag.SPACE, Tag.SCIENCE],
      requirements: [{tag: Tag.SPACE}, {tag: Tag.SCIENCE}],

      metadata: {
        cardNumber: 'Pf53',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.DATA, 2).asterix().cards(2, {size: Size.SMALL}).asterix().br;
          b.tag(Tag.SCIENCE).tag(Tag.MICROBE).colon().text('play ', Size.SMALL, false, true);
          b.tag(Tag.SPACE).colon().production((pb) => pb.energy(3, {digit})).br;
          b.text(
            'Draw 2 cards face up. If the first has a science or microbe tag, play it outright ignoring requirements and cost. ' +
            'If not, and it has a space tag, gain 3 energy prod. If it has none of those, apply the check to the second card.',
            Size.SMALL, false, false);
        }),
        description: 'Requires 1 space tag and 1 science tag. Add 2 data to ANY card. ',
      },
    });
  }

  private keep(player: IPlayer, card: IProjectCard) {
    player.cardsInHand.push(card);
    player.game.log('${0} kept ${1}', (b) => b.player(player).card(card));
  }

  private processCard(player: IPlayer, card: IProjectCard): boolean {
    const tags = card.tags;
    if (player.tags.cardHasTag(card, Tag.SCIENCE) || player.tags.cardHasTag(card, Tag.MICROBE)) {
      player.playCard(card, undefined);
      return true;
    } else if (tags.includes(Tag.SPACE)) {
      player.production.add(Resource.ENERGY, 3, {log: true});
      this.keep(player, card);
      return true;
    } else {
      this.keep(player, card);
      return false;
    }
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.game.projectDeck.canDraw(2);
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    // TODO(kberg): Make sure this action occurs after the card play, in case the played card has data.
    game.defer(new AddResourcesToCard(player, CardResource.DATA, {count: 2}));
    const cards = game.projectDeck.drawNOrThrow(game, 2);

    player.game.log('${0} revealed ${1} and ${2}', (b) => b.player(player).card(cards[0], {tags: true}).card(cards[1], {tags: true}));
    if (this.processCard(player, cards[0])) {
      this.keep(player, cards[1]);
    } else {
      this.processCard(player, cards[1]);
    }

    return undefined;
  }
}

================
File: cards/pathfinders/OzoneGenerators.ts
================
import {IProjectCard} from '../IProjectCard';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class OzoneGenerators extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.OZONE_GENERATORS,
      cost: 14,
      tags: [Tag.MARS, Tag.SPACE],
      requirements: {oxygen: 6},

      action: {
        spend: {energy: 3},
        tr: 1,
        // player.game.log('${0} spent 3 energy to gain 1 TR', (b) => b.player(player));
      },

      metadata: {
        cardNumber: 'Pf36',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 3 energy to gain 1 TR.', (eb) => eb.energy(3).startAction.tr(1));
        }),
        description: 'Requires 6% Oxygen.',
      },
    });
  }
}

================
File: cards/pathfinders/PathfindersCardManifest.ts
================
import {ModuleManifest} from '../ModuleManifest';
import {CardName} from '../../../common/cards/CardName';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';

import {AdhaiHighOrbitConstructions} from './AdhaiHighOrbitConstructions';
import {AdvancedPowerGrid} from './AdvancedPowerGrid';
import {AgroDrones} from './AgroDrones';
import {Ambient} from './Ambient';
import {Anthozoa} from './Anthozoa';
import {AsteroidResources} from './AsteroidResources';
import {Aurorai} from './Aurorai';
import {BalancedDevelopment} from './BalancedDevelopment';
import {BioSol} from './BioSol';
import {BotanicalExperience} from './BotanicalExperience';
import {BreedingFarms} from './BreedingFarms';
import {CassiniStation} from './CassiniStation';
import {CeresSpaceport} from './CeresSpaceport';
import {CharityDonation} from './CharityDonation';
import {Chimera} from './Chimera';
import {CO2Reducers} from './CO2Reducers';
import {CollegiumCopernicus} from './CollegiumCopernicus';
import {CommunicationBoom} from './CommunicationBoom';
import {CommunicationCenter} from './CommunicationCenter';
import {ConstantStruggle} from './ConstantStruggle';
import {ControlledBloom} from './ControlledBloom';
import {CoordinatedRaid} from './CoordinatedRaid';
import {Crashlanding} from './Crashlanding';
import {CrewTraining} from './CrewTraining';
import {Cryptocurrency} from './Cryptocurrency';
import {CultivationOfVenus} from './CultivationOfVenus';
import {Cyanobacteria} from './Cyanobacteria';
import {DataLeak} from './DataLeak';
import {DeclarationOfIndependence} from './DeclarationOfIndependence';
import {DeepSpaceOperations} from './DeepSpaceOperations';
import {DesignCompany} from './DesignCompany';
import {DesignedOrganisms} from './DesignedOrganisms';
import {DustStorm} from './DustStorm';
import {DysonScreens} from './DysonScreens';
import {EarlyExpedition} from './EarlyExpedition';
import {EconomicEspionage} from './EconomicEspionage';
import {EconomicHelp} from './EconomicHelp';
import {ExpeditionToTheSurfaceVenus} from './ExpeditionToTheSurfaceVenus';
import {ExperiencedMartians} from './ExperiencedMartians';
import {FlatMarsTheory} from './FlatMarsTheory';
import {FloaterUrbanism} from './FloaterUrbanism';
import {GagarinMobileBase} from './GagarinMobileBase';
import {GeologicalExpedition} from './GeologicalExpedition';
import {HabitatMarte} from './HabitatMarte';
import {HighTempSuperconductors} from './HighTempSuperconductors';
import {HuygensObservatory} from './HuygensObservatory';
import {HydrogenBombardment} from './HydrogenBombardment';
import {HydrogenProcessingPlant} from './HydrogenProcessingPlant';
import {InterplanetaryTransport} from './InterplanetaryTransport';
import {Kickstarter} from './Kickstarter';
import {LastResortIngenuity} from './LastResortIngenuity';
import {LobbyHalls} from './LobbyHalls';
import {LunarEmbassy} from './LunarEmbassy';
import {LuxuryEstate} from './LuxuryEstate';
import {MagneticFieldStimulationDelays} from './MagneticFieldStimulationDelays';
import {MarsDirect} from './MarsDirect';
import {MarsMaths} from './MarsMaths';
import {MartianCulture} from './MartianCulture';
import {MartianDustProcessingPlant} from './MartianDustProcessingPlant';
import {MartianInsuranceGroup} from './MartianInsuranceGroup';
import {MartianMonuments} from './MartianMonuments';
import {MartianNatureWonders} from './MartianNatureWonders';
import {MartianRepository} from './MartianRepository';
import {MicrobiologyPatents} from './MicrobiologyPatents';
import {MindSetMars} from './MindSetMars';
import {MuseumofEarlyColonisation} from './MuseumofEarlyColonisation';
import {NewVenice} from './NewVenice';
import {NobelLabs} from './NobelLabs';
import {Odyssey} from './Odyssey';
import {OrbitalLaboratories} from './OrbitalLaboratories';
import {OumuamuaTypeObjectSurvey} from './OumuamuaTypeObjectSurvey';
import {OzoneGenerators} from './OzoneGenerators';
import {PersonalAgenda} from './PersonalAgenda';
import {Polaris} from './Polaris';
import {Pollinators} from './Pollinators';
import {PowerPlant} from './PowerPlant';
import {PrefabricationofHumanHabitats} from './PrefabricationofHumanHabitats';
import {PrivateSecurity} from './PrivateSecurity';
import {PublicSponsoredGrant} from './PublicSponsoredGrant';
import {RareEarthElements} from './RareEarthElements';
import {RedCity} from './RedCity';
import {ResearchGrant} from './ResearchGrant';
import {ReturntoAbandonedTechnology} from './ReturntoAbandonedTechnology';
import {RichDeposits} from './RichDeposits';
import {Ringcom} from './Ringcom';
import {RobinHaulings} from './RobinHaulings';
import {SecretLabs} from './SecretLabs';
import {SmallComet} from './SmallComet';
import {SmallOpenPitMine} from './SmallOpenPitMine';
import {SocialEvents} from './SocialEvents';
import {SoilDetoxification} from './SoilDetoxification';
import {Solarpedia} from './Solarpedia';
import {SolarStorm} from './SolarStorm';
import {SolBank} from './SolBank';
import {SoylentSeedlingSystems} from './SoylentSeedlingSystems';
import {SpaceDebrisCleaningOperation} from './SpaceDebrisCleaningOperation';
import {SpaceRaceToMars} from './SpaceRaceToMars';
import {SpaceRelay} from './SpaceRelay';
import {SpecializedSettlement} from './SpecializedSettlement';
import {Steelaris} from './Steelaris';
import {StrategicBasePlanning} from './StrategicBasePlanning';
import {SurveyMission} from './SurveyMission';
import {TerraformingControlStation} from './TerraformingControlStation';
import {TerraformingRobots} from './TerraformingRobots';
import {TheNewSpaceRace} from './TheNewSpaceRace';
import {ThinkTank} from './ThinkTank';
import {TiredEarth} from './TiredEarth';
import {ValuableGases} from './ValuableGases';
import {VeneraBase} from './VeneraBase';
import {VenusFirst} from './VenusFirst';
import {VitalColony} from './VitalColony';
import {Wetlands} from './Wetlands';
import {MarsFrontierAlliance} from './MarsFrontierAlliance';

export const PATHFINDERS_CARD_MANIFEST = new ModuleManifest({
  module: 'pathfinders',
  projectCards: {
    [CardName.BREEDING_FARMS]: {Factory: BreedingFarms},
    [CardName.PREFABRICATION_OF_HUMAN_HABITATS]: {Factory: PrefabricationofHumanHabitats},
    [CardName.NEW_VENICE]: {Factory: NewVenice},
    [CardName.AGRO_DRONES]: {Factory: AgroDrones},
    [CardName.WETLANDS]: {Factory: Wetlands},
    [CardName.RARE_EARTH_ELEMENTS]: {Factory: RareEarthElements},
    [CardName.ORBITAL_LABORATORIES]: {Factory: OrbitalLaboratories},
    [CardName.DUST_STORM]: {Factory: DustStorm},
    [CardName.MARTIAN_MONUMENTS]: {Factory: MartianMonuments},
    [CardName.MARTIAN_NATURE_WONDERS]: {Factory: MartianNatureWonders},
    [CardName.MUSEUM_OF_EARLY_COLONISATION]: {Factory: MuseumofEarlyColonisation},
    [CardName.TERRAFORMING_CONTROL_STATION]: {Factory: TerraformingControlStation, compatibility: 'venus'},
    // // [CardName.MARTIAN_TRANSHIPMENT_STATION]: {Factory: MartianTranshipmentStation},  // COMPLICATED EFFECT.
    [CardName.CERES_SPACEPORT]: {Factory: CeresSpaceport},
    [CardName.DYSON_SCREENS]: {Factory: DysonScreens},
    [CardName.LUNAR_EMBASSY]: {Factory: LunarEmbassy},
    [CardName.GEOLOGICAL_EXPEDITION]: {Factory: GeologicalExpedition},
    [CardName.EARLY_EXPEDITION]: {Factory: EarlyExpedition},
    [CardName.HYDROGEN_PROCESSING_PLANT]: {Factory: HydrogenProcessingPlant},
    [CardName.POWER_PLANT_PATHFINDERS]: {Factory: PowerPlant},
    [CardName.LUXURY_ESTATE]: {Factory: LuxuryEstate},
    [CardName.RETURN_TO_ABANDONED_TECHNOLOGY]: {Factory: ReturntoAbandonedTechnology},
    [CardName.DESIGNED_ORGANISMS]: {Factory: DesignedOrganisms},
    [CardName.SPACE_DEBRIS_CLEANING_OPERATION]: {Factory: SpaceDebrisCleaningOperation},
    [CardName.PRIVATE_SECURITY]: {Factory: PrivateSecurity},
    [CardName.SECRET_LABS]: {Factory: SecretLabs},
    [CardName.CYANOBACTERIA]: {Factory: Cyanobacteria},
    [CardName.COMMUNICATION_CENTER]: {Factory: CommunicationCenter},
    [CardName.MARTIAN_REPOSITORY]: {Factory: MartianRepository},
    [CardName.DATA_LEAK]: {Factory: DataLeak},
    [CardName.SMALL_OPEN_PIT_MINE]: {Factory: SmallOpenPitMine},
    [CardName.SOLAR_STORM]: {Factory: SolarStorm},
    [CardName.SPACE_RELAY]: {Factory: SpaceRelay},
    [CardName.DECLARATION_OF_INDEPENDENCE]: {Factory: DeclarationOfIndependence, compatibility: 'turmoil'},
    [CardName.MARTIAN_CULTURE]: {Factory: MartianCulture},
    [CardName.OZONE_GENERATORS]: {Factory: OzoneGenerators},
    [CardName.SMALL_COMET]: {Factory: SmallComet},
    [CardName.ECONOMIC_ESPIONAGE]: {Factory: EconomicEspionage},
    [CardName.FLAT_MARS_THEORY]: {Factory: FlatMarsTheory},
    [CardName.ASTEROID_RESOURCES]: {Factory: AsteroidResources},
    [CardName.KICKSTARTER]: {Factory: Kickstarter},
    [CardName.ECONOMIC_HELP]: {Factory: EconomicHelp},
    [CardName.INTERPLANETARY_TRANSPORT]: {Factory: InterplanetaryTransport},
    [CardName.MARTIAN_DUST_PROCESSING_PLANT]: {Factory: MartianDustProcessingPlant},
    [CardName.CULTIVATION_OF_VENUS]: {Factory: CultivationOfVenus, compatibility: 'venus'},
    [CardName.EXPEDITION_TO_THE_SURFACE_VENUS]: {Factory: ExpeditionToTheSurfaceVenus, compatibility: 'venus'},
    [CardName.LAST_RESORT_INGENUITY]: {Factory: LastResortIngenuity},
    [CardName.CRASHLANDING]: {Factory: Crashlanding, compatibility: 'ares'},
    [CardName.THINK_TANK]: {Factory: ThinkTank},
    [CardName.BOTANICAL_EXPERIENCE]: {Factory: BotanicalExperience},
    [CardName.CRYPTOCURRENCY]: {Factory: Cryptocurrency},
    [CardName.RICH_DEPOSITS]: {Factory: RichDeposits},
    [CardName.OUMUAMUA_TYPE_OBJECT_SURVEY]: {Factory: OumuamuaTypeObjectSurvey},
    [CardName.SOLARPEDIA]: {Factory: Solarpedia, compatibility: 'venus'},
    [CardName.ANTHOZOA]: {Factory: Anthozoa},
    [CardName.ADVANCED_POWER_GRID]: {Factory: AdvancedPowerGrid},
    [CardName.SPECIALIZED_SETTLEMENT]: {Factory: SpecializedSettlement},
    [CardName.CHARITY_DONATION]: {Factory: CharityDonation},
    // // [CardName.CURIOSITY_LABS]: {Factory: CuriosityLabs},                          // TWO RESOURCE TYPES
    [CardName.NOBEL_LABS]: {Factory: NobelLabs},
    [CardName.HUYGENS_OBSERVATORY]: {Factory: HuygensObservatory, compatibility: 'colonies'},
    [CardName.CASSINI_STATION]: {Factory: CassiniStation, compatibility: 'colonies'},
    [CardName.MICROBIOLOGY_PATENTS]: {Factory: MicrobiologyPatents},
    [CardName.COORDINATED_RAID]: {Factory: CoordinatedRaid, compatibility: 'colonies'},
    [CardName.LOBBY_HALLS]: {Factory: LobbyHalls, compatibility: 'turmoil'},
    [CardName.RED_CITY]: {Factory: RedCity, compatibility: 'turmoil'},
    [CardName.VENERA_BASE]: {Factory: VeneraBase, compatibility: ['turmoil', 'venus']},
    // // [CardName.GATEWAY_STATION]: {Factory: GatewayStation, compatibility: 'turmoil'}, // Place a city tile outside Mars with new adjacency??
    [CardName.FLOATER_URBANISM]: {Factory: FloaterUrbanism, compatibility: 'venus'},
    [CardName.SOIL_DETOXIFICATION]: {Factory: SoilDetoxification, compatibility: 'turmoil'},
    [CardName.HIGH_TEMP_SUPERCONDUCTORS]: {Factory: HighTempSuperconductors, compatibility: 'turmoil'},
    [CardName.PUBLIC_SPONSORED_GRANT]: {Factory: PublicSponsoredGrant, compatibility: 'turmoil'},
    [CardName.POLLINATORS]: {Factory: Pollinators},
    [CardName.SOCIAL_EVENTS]: {Factory: SocialEvents},
    [CardName.CONTROLLED_BLOOM]: {Factory: ControlledBloom},
    [CardName.TERRAFORMING_ROBOTS]: {Factory: TerraformingRobots},
  },
  corporationCards: {
    [CardName.POLARIS]: {Factory: Polaris},
    // [CardName.PLANET_PR]: {Factory: planetpr},
    [CardName.AMBIENT]: {Factory: Ambient, compatibility: 'venus'},
    [CardName.RINGCOM]: {Factory: Ringcom},
    [CardName.CHIMERA]: {Factory: Chimera},
    // [CardName.SISTEMAS_SEEBECK]: {Factory: SistemasSeebeck},
    // [CardName.SPIRE]: {Factory: Spire},
    [CardName.SOYLENT_SEEDLING_SYSTEMS]: {Factory: SoylentSeedlingSystems},
    [CardName.STEELARIS]: {Factory: Steelaris},
    [CardName.MARS_MATHS]: {Factory: MarsMaths},
    [CardName.MARS_DIRECT]: {Factory: MarsDirect, compatibility: 'pathfinders'},
    [CardName.MARTIAN_INSURANCE_GROUP]: {Factory: MartianInsuranceGroup, compatibility: 'pathfinders'},
    [CardName.SOLBANK]: {Factory: SolBank},
    [CardName.BIO_SOL]: {Factory: BioSol},
    [CardName.AURORAI]: {Factory: Aurorai, compatibility: 'pathfinders'},
    [CardName.COLLEGIUM_COPERNICUS]: {Factory: CollegiumCopernicus, compatibility: 'colonies'},
    [CardName.ROBIN_HAULINGS]: {Factory: RobinHaulings, compatibility: ['venus', 'pathfinders']},
    [CardName.ODYSSEY]: {Factory: Odyssey},
    [CardName.GAGARIN_MOBILE_BASE]: {Factory: GagarinMobileBase},
    [CardName.MARS_FRONTIER_ALLIANCE]: {Factory: MarsFrontierAlliance, compatibility: 'turmoil'},
    [CardName.MIND_SET_MARS]: {Factory: MindSetMars, compatibility: 'turmoil'},
    [CardName.HABITAT_MARTE]: {Factory: HabitatMarte, compatibility: 'pathfinders'},
    [CardName.ADHAI_HIGH_ORBIT_CONSTRUCTIONS]: {Factory: AdhaiHighOrbitConstructions, compatibility: 'colonies'},
  },
  preludeCards: {
    [CardName.VENUS_FIRST]: {Factory: VenusFirst, compatibility: 'venus'},
    [CardName.VALUABLE_GASES_PATHFINDERS]: {Factory: ValuableGases, compatibility: 'venus'},
    [CardName.CO2_REDUCERS]: {Factory: CO2Reducers, compatibility: 'venus'},
    [CardName.HYDROGEN_BOMBARDMENT]: {Factory: HydrogenBombardment, compatibility: 'venus'},
    [CardName.RESEARCH_GRANT_PATHFINDERS]: {Factory: ResearchGrant},
    [CardName.CREW_TRAINING]: {Factory: CrewTraining, compatibility: 'pathfinders'},
    [CardName.SURVEY_MISSION]: {Factory: SurveyMission},
    [CardName.DESIGN_COMPANY]: {Factory: DesignCompany},
    // [CardName.CONSOLIDATION]: {Factory: Consolidation},
    [CardName.PERSONAL_AGENDA]: {Factory: PersonalAgenda},
    [CardName.VITAL_COLONY]: {Factory: VitalColony, compatibility: 'colonies'},
    [CardName.STRATEGIC_BASE_PLANNING]: {Factory: StrategicBasePlanning, compatibility: 'colonies'},
    [CardName.DEEP_SPACE_OPERATIONS]: {Factory: DeepSpaceOperations},
    [CardName.EXPERIENCED_MARTIANS]: {Factory: ExperiencedMartians, compatibility: ['turmoil', 'pathfinders']},
    [CardName.THE_NEW_SPACE_RACE]: {Factory: TheNewSpaceRace, compatibility: 'turmoil'},
  },

  globalEvents: {
    [GlobalEventName.BALANCED_DEVELOPMENT]: {Factory: BalancedDevelopment},
    [GlobalEventName.SPACE_RACE_TO_MARS]: {Factory: SpaceRaceToMars},
    [GlobalEventName.CONSTANT_STRUGGLE]: {Factory: ConstantStruggle, negative: true},
    [GlobalEventName.TIRED_EARTH]: {Factory: TiredEarth, negative: true},
    [GlobalEventName.MAGNETIC_FIELD_STIMULATION_DELAYS]: {Factory: MagneticFieldStimulationDelays, negative: true},
    [GlobalEventName.COMMUNICATION_BOOM]: {Factory: CommunicationBoom, negative: true},
  },

  // Perhaps these community cards should just move to this manifest, but only if it becomes
  // generally easier to just add all the preludes that match what game someone's playing.
  cardsToRemove: [
    CardName.RESEARCH_GRANT,
    CardName.VALUABLE_GASES,
  ],
});

================
File: cards/pathfinders/PersonalAgenda.ts
================
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';

export class PersonalAgenda extends PreludeCard {
  constructor() {
    super({
      name: CardName.PERSONAL_AGENDA,

      behavior: {
        production: {megacredits: 3},
      },

      metadata: {
        cardNumber: 'P08',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(3)).br;
          // TODO(kberg): allow more than one secondary tag.
          b.cards(3, {secondaryTag: Tag.EVENT}).asterix();
        }),
        description: 'Increase your M€ production 3 steps. Draw 3 event cards that do not have a space tag.',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    player.drawCard(3, {
      include: (card) => {
        return card.type === CardType.EVENT &&
          (card.tags.includes(Tag.SPACE) === false);
      }});
    return undefined;
  }
}

================
File: cards/pathfinders/Polaris.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all, digit} from '../Options';
import {Space} from '../../boards/Space';
import {GainResources} from '../../deferredActions/GainResources';
import {Priority} from '../../deferredActions/Priority';
import {Size} from '../../../common/cards/render/Size';
import {Board} from '../../boards/Board';
import {Phase} from '../../../common/Phase';

export class Polaris extends CorporationCard {
  constructor() {
    super({
      name: CardName.POLARIS,
      tags: [Tag.SPACE],
      startingMegaCredits: 32,

      firstAction: {
        text: 'Place your initial ocean.',
        ocean: {},
      },

      metadata: {
        cardNumber: 'PfC1',
        description: 'You start with 32 M€. As your first action, place an ocean tile.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(32).oceans(1);
          b.corpBox('effect', (ce) => {
            ce.effect('When any ocean tile is placed ON MARS, increase your M€ production 1 step. When you place an ocean tile, gain 4M€.', (eb) => {
              eb.oceans(1, {size: Size.SMALL, all}).colon().production((pb) => pb.megacredits(1));
              eb.nbsp;
              eb.oceans(1, {size: Size.SMALL}).startEffect.megacredits(4, {digit});
            });
          });
        }),
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (Board.isUncoveredOceanSpace(space)) {
      // TODO(kberg): Find a way to add Card to addProduction log options.
      cardOwner.production.add(Resource.MEGACREDITS, 1);
      activePlayer.game.log(
        '${0} gained 1 ${1} production from ${2}',
        (b) => b.player(cardOwner).string(Resource.MEGACREDITS).cardName(this.name));
      if (activePlayer.id === cardOwner.id && cardOwner.game.phase !== Phase.SOLAR) {
        cardOwner.game.defer(
          new GainResources(cardOwner, Resource.MEGACREDITS, {
            count: 4,
          }).andThen(() => activePlayer.game.log(
            '${0} gained ${1} from ${2}',
            (b) => b.player(cardOwner).string(Resource.MEGACREDITS).cardName(this.name))),
          cardOwner.id !== activePlayer.id ? Priority.OPPONENT_TRIGGER : undefined,
        );
      }
    }
  }
}

================
File: cards/pathfinders/Pollinators.ts
================
import {IProjectCard} from '../IProjectCard';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';

export class Pollinators extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.POLLINATORS,
      cost: 19,
      tags: [Tag.PLANT, Tag.ANIMAL],
      resourceType: CardResource.ANIMAL,
      requirements: {tag: Tag.PLANT, count: 3},
      victoryPoints: {resourcesHere: {}},

      behavior: {
        production: {plants: 1, megacredits: 2},
      },

      action: {
        addResources: 1,
      },

      metadata: {
        cardNumber: '...',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal on this card', (ab) => ab.empty().startAction.resource(CardResource.ANIMAL)).br;
          b.production((pb) => pb.plants(1).megacredits(2));
          b.vpText('1 VP per animal on this card.');
        }),
        description: 'Requires 3 plant tags. Raise your plant production 1 step and your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/pathfinders/PowerPlant.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class PowerPlant extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.POWER_PLANT_PATHFINDERS,
      cost: 13,
      tags: [Tag.MARS, Tag.POWER, Tag.BUILDING],

      behavior: {
        production: {heat: 2, energy: 1},
      },

      metadata: {
        cardNumber: 'Pf20',
        renderData: CardRenderer.builder((b) => {
          b.production(((pb) => pb.heat(2).energy(1)));
        }),
        description: 'Increase your heat production 2 steps and your energy production 1 step.',
      },
    });
  }
}

================
File: cards/pathfinders/PrefabricationofHumanHabitats.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {Size} from '../../../common/cards/render/Size';

export class PrefabricationofHumanHabitats extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PREFABRICATION_OF_HUMAN_HABITATS,
      cost: 8,
      tags: [Tag.BUILDING, Tag.CITY],

      requirements: {production: Resource.STEEL, count: 1},
      cardDiscount: {tag: Tag.CITY, amount: 2},

      metadata: {
        cardNumber: 'Pf02',
        renderData: CardRenderer.builder((b) => {
          b.effect('Cards with a city tag cost 2M€ less.', (eb) => {
            eb.tag(Tag.CITY, {size: Size.MEDIUM}).startEffect.megacredits(-2);
          });
          b.br;
          b.effect('The CITY STANDARD PROJECT costs 2M€ less. STEEL MAY BE USED as if you were playing a building card.', (eb) => {
            eb.city().asterix().startEffect.megacredits(23).super((b) => b.steel(1));
          });
        }),
        description: 'Requires that you have steel production.',
      },
    });
  }
}

================
File: cards/pathfinders/PrivateSecurity.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {Size} from '../../../common/cards/render/Size';

export class PrivateSecurity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PRIVATE_SECURITY,
      cost: 8,
      tags: [Tag.EARTH],

      metadata: {
        cardNumber: 'Pf25',
        renderData: CardRenderer.builder((b) => {
          b.text('Opponents may not remove your basic resource production', Size.SMALL, true).br;
          b.production((pb) => pb.wild(1, {cancelled: true}));
        }),
      },
    });
  }
}

================
File: cards/pathfinders/PublicSponsoredGrant.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {ALL_TAGS, Tag} from '../../../common/cards/Tag';
import {PartyName} from '../../../common/turmoil/PartyName';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {all} from '../Options';
import {inplaceRemove} from '../../../common/utils/utils';

export class PublicSponsoredGrant extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.PUBLIC_SPONSORED_GRANT,
      cost: 6,
      requirements: {party: PartyName.SCIENTISTS},

      metadata: {
        cardNumber: 'PfTVD',
        renderData: CardRenderer.builder((b) => {
          b.minus().megacredits(2, {all}).br;
          b.cards(1, {secondaryTag: Tag.WILD}).cards(1, {secondaryTag: Tag.WILD}).asterix();
        }),
        description: 'Requires Scientists are ruling or that you have 2 delegates there. All players lose 2M€. Choose a tag (NOT CITY, ? OR PLANETARY TRACK) and draw 2 cards with that tag.',
      },
    });
  }

  private draw2Cards(player: IPlayer, tag: Tag) {
    player.drawCard(2, {tag: tag});
  }

  public override bespokePlay(player: IPlayer) {
    player.getOpponents().forEach((target) => {
      target.maybeBlockAttack(player, (proceed) => {
        if (proceed) {
          target.stock.deduct(Resource.MEGACREDITS, Math.min(target.megaCredits, 2), {log: true, from: player});
        }
        return undefined;
      });
    });

    const tags = [...ALL_TAGS];
    inplaceRemove(tags, Tag.CITY);
    inplaceRemove(tags, Tag.WILD);
    inplaceRemove(tags, Tag.CLONE);

    inplaceRemove(tags, Tag.EARTH);
    inplaceRemove(tags, Tag.JOVIAN);
    inplaceRemove(tags, Tag.VENUS);
    inplaceRemove(tags, Tag.MOON);
    inplaceRemove(tags, Tag.MARS);

    const options = tags.map((tag) => {
      return new SelectOption(tag).andThen(() => {
        this.draw2Cards(player, tag);
        return undefined;
      });
    });

    return new OrOptions(...options);
  }
}

================
File: cards/pathfinders/RareEarthElements.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {isSpecialTileSpace, playerTileFn} from '../../boards/Board';

export class RareEarthElements extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.RARE_EARTH_ELEMENTS,
      cost: 5,
      tags: [Tag.EARTH, Tag.MARS],

      metadata: {
        cardNumber: 'Pf06',
        renderData: CardRenderer.builder((b) => {
          b.production(((pb) => pb.megacredits(1))).slash().specialTile();
        }),
        description: 'Increase your M€ production by 1 for every special tile you own on Mars.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const spaces = player.game.board.spaces
      .filter(playerTileFn(player))
      .filter(isSpecialTileSpace);

    player.production.add(Resource.MEGACREDITS, spaces.length, {log: true});
    return undefined;
  }
}

================
File: cards/pathfinders/RedCity.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';
import {TileType} from '../../../common/TileType';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Board} from '../../boards/Board';
import {IProjectCard} from '../IProjectCard';
import {message} from '../../logs/MessageBuilder';
import {Space} from '../../boards/Space';
import {SpaceType} from '../../../common/boards/SpaceType';
import {isHazardTileType} from '../../../common/AresTileType';

export class RedCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.RED_CITY,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 21,

      behavior: {
        production: {energy: -1, megacredits: 2},
      },

      requirements: {party: PartyName.REDS},
      victoryPoints: 'special',

      metadata: {
        cardNumber: 'PFT2',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().energy(1).megacredits(2));
        }),
        description: 'Requires that Reds are ruling or that you have 2 delegates there. ' +
          '-1 energy prod, +2 M€ prod. ' +
          'Place the special tile on Mars ADJACENT TO NO GREENERY. ' +
          'NO GREENERY MAY BE PLACED NEXT TO THIS TILE. 1 VP for every empty space (or hazard) next to this tile.',
        victoryPoints: CardRenderDynamicVictoryPoints.questionmark(),
      },
    });
  }

  private availableRedCitySpaces(player: IPlayer) {
    const board = player.game.board;
    const citySpaces = board.getAvailableSpacesForCity(player);
    return citySpaces.filter((space) => !board.getAdjacentSpaces(space).some(Board.isGreenerySpace));
  }
  public override bespokeCanPlay(player: IPlayer) {
    return this.availableRedCitySpaces(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace(
      message('Select space for ${0}', (b) => b.card(this)),
      this.availableRedCitySpaces(player))
      .andThen((space) => {
        player.game.addTile(player, space, {tileType: TileType.RED_CITY, card: this.name});
        return undefined;
      });
  }

  public override getVictoryPoints(player: IPlayer): number {
    const space = player.game.board.getSpaceByTileCard(this.name);
    if (space === undefined) {
      return 0;
    }

    const neighbors = player.game.board.getAdjacentSpaces(space);
    return neighbors.filter((neighbor) => this.isEmpty(neighbor)).length;
  }

  private isEmpty(space: Space): boolean {
    return space.spaceType === SpaceType.RESTRICTED || space.tile === undefined || isHazardTileType(space.tile.tileType);
  }
}

================
File: cards/pathfinders/ResearchGrant.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class ResearchGrant extends PreludeCard {
  constructor() {
    super({
      name: CardName.RESEARCH_GRANT_PATHFINDERS,
      tags: [Tag.SCIENCE, Tag.SCIENCE],

      behavior: {
        production: {energy: 1},
        stock: {megacredits: 14},
      },

      metadata: {
        cardNumber: 'P08',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1)).br;
          b.megacredits(14);
        }),
        description: 'Increase your energy production 1 step. Gain 14 M€.',
      },
    });
  }
}

================
File: cards/pathfinders/ReturntoAbandonedTechnology.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {ChooseCards} from '../../deferredActions/ChooseCards';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {Size} from '../../../common/cards/render/Size';

export class ReturntoAbandonedTechnology extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.RETURN_TO_ABANDONED_TECHNOLOGY,
      cost: 4,
      tags: [Tag.MARS],

      metadata: {
        cardNumber: 'Pf22',
        renderData: CardRenderer.builder((b) => {
          b.text('Draw the top 4 cards from the discard pile. Choose 2 to keep and discard the rest.', Size.SMALL).br;
        }),
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    return player.game.projectDeck.discardPile.length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    const cards = [];
    for (let idx = 0; idx < 4; idx++) {
      const card = player.game.projectDeck.discardPile.pop();
      if (card === undefined) break;
      cards.push(card);
    }

    const cardsToKeep = Math.min(2, cards.length);
    player.game.defer(new ChooseCards(player, cards, {keepMax: cardsToKeep}));

    return undefined;
  }
}

================
File: cards/pathfinders/RichDeposits.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class RichDeposits extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.RICH_DEPOSITS,
      cost: 12,

      behavior: {
        production: {steel: 3},
      },

      requirements: {tag: Tag.SCIENCE, count: 2},
      metadata: {
        cardNumber: 'Pf52',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.steel(3))),
        description: 'Requires 2 science tags. Increase your steel production 3 steps.',
      },
    });
  }
}

================
File: cards/pathfinders/Ringcom.ts
================
import {ICorporationCard} from '../corporation/ICorporationCard';
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {ICard} from '../ICard';

export class Ringcom extends CorporationCard {
  constructor() {
    super({
      name: CardName.RINGCOM,
      tags: [Tag.JOVIAN],
      startingMegaCredits: 39,

      behavior: {
        production: {megacredits: 3},
      },

      firstAction: {
        text: 'Draw 2 cards with a Jovian tag',
        drawCard: {count: 2, tag: Tag.JOVIAN},
      },


      metadata: {
        cardNumber: 'PfC4',
        description: 'You start with 39 M€. and 3 M€ production. As your first action, draw 2 cards with a Jovian tag.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(39).production((pb) => pb.megacredits(3));
          b.cards(2, {secondaryTag: Tag.JOVIAN});
          b.corpBox('effect', (ce) => {
            ce.effect('When any player plays a card with a Jovian tag (including this) gain 1 titanium.', (eb) => {
              eb.tag(Tag.JOVIAN, {all}).startEffect.titanium(1);
            });
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    // Typically  onCardPlayed isn't necessary, but onCorpCardPlayed isn't called for your own corp card.
    this.onCardPlayed(player, this);
    return undefined;
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    this.onCardPlayed(player, card);
  }

  public onCardPlayed(player: IPlayer, card: ICard): void {
    if (card.tags.includes(Tag.JOVIAN)) {
      player.game.getPlayers().forEach((p) => {
        if (p.isCorporation(this.name)) {
          p.stock.add(Resource.TITANIUM, 1, {log: true});
        }
      });
    }
  }
}

================
File: cards/pathfinders/RobinHaulings.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {digit} from '../Options';
import {IProjectCard} from '../IProjectCard';
import {MAX_OXYGEN_LEVEL, MAX_VENUS_SCALE} from '../../../common/constants';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';

export class RobinHaulings extends CorporationCard {
  constructor() {
    super({
      name: CardName.ROBIN_HAULINGS,
      tags: [Tag.MARS, Tag.VENUS],
      startingMegaCredits: 39,
      resourceType: CardResource.FLOATER,

      behavior: {
        addResources: 1,
      },

      metadata: {
        cardNumber: 'PfC9',
        description: 'You start with 39 M€.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(39).br;
          b.effect('Whenever you play a card with a Venus tag add 1 floater to ANY card.', (eb) => {
            eb.tag(Tag.VENUS).startEffect.resource(CardResource.FLOATER).asterix();
          });
          b.br;
          b.action('Remove 3 floaters from this card to raise Venus 1 step or raise oxygen 1 step', (ab) => {
            ab.resource(CardResource.FLOATER, {amount: 3, digit}).startAction.venus(1).or().oxygen(1);
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (player.isCorporation(CardName.ROBIN_HAULINGS) && card.tags.includes(Tag.VENUS)) {
      player.game.defer(new AddResourcesToCard(player, CardResource.FLOATER));
    }
  }

  private canRaiseVenus(player: IPlayer) {
    return player.game.getVenusScaleLevel() < MAX_VENUS_SCALE && player.canAfford({cost: 0, tr: {venus: 1}});
  }

  private canRaiseOxygen(player: IPlayer) {
    return player.game.getOxygenLevel() < MAX_OXYGEN_LEVEL && player.canAfford({cost: 0, tr: {oxygen: 1}});
  }

  public canAct(player: IPlayer) {
    if (this.resourceCount < 3) return false;
    return this.canRaiseVenus(player) || this.canRaiseOxygen(player);
  }

  public action(player: IPlayer) {
    const options = new OrOptions();
    if (this.canRaiseVenus(player)) {
      options.options.push(
        new SelectOption('Spend 3 floaters to raise Venus 1 step')
          .andThen(() => {
            player.game.increaseVenusScaleLevel(player, 1);
            this.resourceCount -= 3;
            return undefined;
          }));
    }
    if (this.canRaiseOxygen(player)) {
      options.options.push(
        new SelectOption('Spend 3 floaters to raise oxygen 1 step')
          .andThen(() => {
            player.game.increaseOxygenLevel(player, 1);
            this.resourceCount -= 3;
            return undefined;
          }));
    }

    if (options.options.length === 0) {
      return undefined;
    }
    if (options.options.length === 1) {
      return options.options[0];
    }
    return options;
  }
}

================
File: cards/pathfinders/SecretLabs.ts
================
import {IProjectCard} from '../IProjectCard';
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {PlaceOceanTile} from '../../deferredActions/PlaceOceanTile';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {Resource} from '../../../common/Resource';
import {CardResource} from '../../../common/CardResource';
import {TRSource} from '../../../common/cards/TRSource';
import {digit} from '../Options';
import {MAX_OCEAN_TILES} from '../../../common/constants';

export class SecretLabs extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SECRET_LABS,
      cost: 21,
      tags: [Tag.JOVIAN, Tag.BUILDING, Tag.SPACE],
      requirements: [{tag: Tag.SCIENCE}, {tag: Tag.JOVIAN}],
      victoryPoints: 1,

      metadata: {
        cardNumber: 'Pf26',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).resource(CardResource.MICROBE, {amount: 2, digit}).asterix().or().temperature(1).br;
          b.plants(3, {digit}).or().oxygen(1).resource(CardResource.FLOATER, {amount: 2, digit}).asterix().br;
        }),
        description: 'Requires 1 science tag and 1 Jovian tag. ' +
          'Place an ocean tile. Add 2 microbes to ANY card. ' +
          'OR Raise temperature 1 step. Gain 3 plants. ' +
          'OR Raise oxygen level 1 step. Add 2 floaters to ANY card.',
      },
    });
  }

  private adjustedOptions(options: CanAffordOptions, trSource: TRSource, cost?: number): CanAffordOptions {
    const newOptions = {...options};
    newOptions.tr = trSource;
    if (cost !== undefined) {
      newOptions.cost = cost;
    }
    return newOptions;
  }

  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions) {
    return (
      player.canAfford(this.adjustedOptions(canAffordOptions, {oceans: 1})) ||
      player.canAfford(this.adjustedOptions(canAffordOptions, {temperature: 1})) ||
      player.canAfford(this.adjustedOptions(canAffordOptions, {oxygen: 1}))
    );
  }

  public override bespokePlay(player: IPlayer) {
    const options = new OrOptions();

    if (player.canAfford({cost: 0, tr: {oceans: 1}})) {
      const oceanPlacementAvailable = player.game.board.getOceanSpaces().length < MAX_OCEAN_TILES;
      const optionTitle = oceanPlacementAvailable ? 'Place an ocean tile. Add 2 microbes to ANY card.': 'Add 2 microbes to ANY card.';
      options.options.push(new SelectOption(optionTitle).andThen(() => {
        if (oceanPlacementAvailable || player.cardIsInEffect(CardName.WHALES)) {
          player.game.defer(new PlaceOceanTile(player));
        }
        player.game.defer(new AddResourcesToCard(player, CardResource.MICROBE, {count: 2}));
        return undefined;
      }));
    }
    if (player.canAfford({cost: 0, tr: {temperature: 1}})) {
      options.options.push(new SelectOption('Raise temperature 1 step. Gain 3 plants.').andThen(() => {
        player.game.increaseTemperature(player, 1);
        player.stock.add(Resource.PLANTS, 3, {log: true});
        return undefined;
      }));
    }
    if (player.canAfford({cost: 0, tr: {oxygen: 1}})) {
      options.options.push(new SelectOption('Raise oxygen level 1 step. Add 2 floaters to ANY card.').andThen(() => {
        player.game.increaseOxygenLevel(player, 1);
        player.game.defer(new AddResourcesToCard(player, CardResource.FLOATER, {count: 2}));
        return undefined;
      }));
    }

    return options;
  }
}

================
File: cards/pathfinders/SmallComet.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {all} from '../Options';
import {RemoveResources} from '../../deferredActions/RemoveResources';
import {Resource} from '../../../common/Resource';
import {Priority} from '../../../server/deferredActions/Priority';

export class SmallComet extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SMALL_COMET,
      cost: 32,
      tags: [Tag.MARS, Tag.SPACE],

      behavior: {
        stock: {titanium: 1},
        global: {temperature: 1, oxygen: 1},
        ocean: {on: 'land'},
      },

      metadata: {
        cardNumber: 'Pf37',
        renderData: CardRenderer.builder((b) => {
          b.minus().plants(2, {all}).asterix();
          b.br;
          b.temperature(1).oxygen(1).oceans(1).asterix();
          b.br;
          b.titanium(1);
        }),
        description: 'Every player loses 2 plants. Raise the temperature 1 step. Raise the oxygen 1 step. ' +
          'Place an ocean ON AN AREA NOT RESERVED FOR OCEAN. Gain 1 titanium.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    for (const target of game.getPlayers()) {
      game.defer(new RemoveResources(target, player, Resource.PLANTS, 2), Priority.ATTACK_OPPONENT);
    }
    return undefined;
  }
}

================
File: cards/pathfinders/SmallOpenPitMine.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {Resource} from '../../../common/Resource';

export class SmallOpenPitMine extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SMALL_OPEN_PIT_MINE,
      cost: 10,
      tags: [Tag.BUILDING],

      metadata: {
        cardNumber: 'Pf31',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(2)).or().production((pb) => pb.titanium(1));
        }),
        description: 'Increase your steel production 2 steps OR increase your titanium production 1 step.',
      },
    });
  }

  public produce(player: IPlayer) {
    player.defer(() => {
      return new OrOptions(
        new SelectOption('Increase your steel production 2 steps').andThen(() => {
          player.production.add(Resource.STEEL, 2, {log: true});
          return undefined;
        }),
        new SelectOption('Increase your titanium production 1 step').andThen(() => {
          player.production.add(Resource.TITANIUM, 1, {log: true});
          return undefined;
        }));
    });
  }

  public override bespokePlay(player: IPlayer) {
    this.produce(player);
    return undefined;
  }
}

================
File: cards/pathfinders/SocialEvents.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class SocialEvents extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SOCIAL_EVENTS,
      cost: 18,
      tags: [Tag.EARTH, Tag.MARS],

      metadata: {
        cardNumber: '...',
        renderData: CardRenderer.builder((b) => {
          b.tr(1).slash().tag(Tag.MARS, 2);
        }),
        description: 'Gain 1 TR for every 2 Mars tags you have (including this one.)',
      },
    });
  }

  public computeTr(player: IPlayer) {
    const expectedTr = Math.floor((player.tags.count(Tag.MARS) + 1) / 2); // +1 is the "including this";
    return {tr: expectedTr};
  }

  public override bespokePlay(player: IPlayer) {
    const steps = this.computeTr(player).tr;
    player.increaseTerraformRating(steps, {log: true});
    return undefined;
  }
}

================
File: cards/pathfinders/SoilDetoxification.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {PartyName} from '../../../common/turmoil/PartyName';

export class SoilDetoxification extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SOIL_DETOXIFICATION,
      cost: 10,
      tags: [Tag.PLANT, Tag.SCIENCE],

      requirements: {party: PartyName.GREENS},

      behavior: {
        production: {plants: 1},
        greeneryDiscount: 1,
      },

      metadata: {
        cardNumber: 'PfTmp',
        renderData: CardRenderer.builder((b) => {
          b.effect('Using the STANDARD GREENERY ACTION costs 1 plant less.', (eb) => eb.greenery().asterix().startEffect.minus().plants(1)).br;
          b.production((pb) => pb.plants(1));
        }),
        description: 'Requires that Greens are ruling or you have 2 delegates there. Increase your plant production 1 step',
      },
    });
  }
}

================
File: cards/pathfinders/Solarpedia.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {ActionCard} from '../ActionCard';

export class Solarpedia extends ActionCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.SOLARPEDIA,
      type: CardType.ACTIVE,
      tags: [Tag.SPACE],
      cost: 12,
      requirements: [{tag: Tag.VENUS}, {tag: Tag.EARTH}, {tag: Tag.MARS}, {tag: Tag.JOVIAN}],
      resourceType: CardResource.DATA,
      victoryPoints: {resourcesHere: {}, per: 6},

      behavior: {
        addResourcesToAnyCard: {type: CardResource.DATA, count: 2},
      },

      action: {
        addResourcesToAnyCard: {type: CardResource.DATA, count: 2},
      },

      metadata: {
        cardNumber: 'Pf54',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 2 data to ANY card.', (ab) => {
            ab.empty().startAction.resource(CardResource.DATA, 2).asterix();
          }).br;
          b.resource(CardResource.DATA, 2).asterix();
        }),
        description: 'Requires 1 Venus, Earth, Mars, and Jovian Tag. Add 2 data to ANY card. 1 VP for every 6 data resources here.',
      },
    });
  }
}

================
File: cards/pathfinders/SolarStorm.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {RemoveResourcesFromCard} from '../../deferredActions/RemoveResourcesFromCard';
import {CardResource} from '../../../common/CardResource';
import {all, digit} from '../Options';

export class SolarStorm extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SOLAR_STORM,
      cost: 12,
      tags: [Tag.SPACE],

      behavior: {
        production: {heat: 1},
        global: {temperature: 1},
      },

      metadata: {
        cardNumber: 'Pf32',
        renderData: CardRenderer.builder((b) => {
          b.minus().plants(2, {all}).asterix().nbsp.minus().resource(CardResource.DATA, {amount: 3, digit, all}).br;
          b.production((pb) => pb.heat(1)).nbsp.temperature(1);
        }),
        description: 'Every player loses 2 plants. Remove up to 3 data from any player. ' +
          'Raise your heat production 1 step. Raise the temperature 1 step.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    for (const p of player.game.getPlayers()) {
      if (!p.plantsAreProtected()) {
        // Botanical Experience reduces the impact in half.
        if (p.cardIsInEffect(CardName.BOTANICAL_EXPERIENCE)) {
          p.stock.deduct(Resource.PLANTS, 1, {log: true, from: player});
        } else {
          p.stock.deduct(Resource.PLANTS, 2, {log: true, from: player});
        }
      }
    }
    player.game.defer(new RemoveResourcesFromCard(
      player, CardResource.DATA, 3, {mandatory: false}));
    return undefined;
  }
}

================
File: cards/pathfinders/SolBank.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {IPlayer} from '../../IPlayer';

export class SolBank extends CorporationCard {
  constructor() {
    super({
      name: CardName.SOLBANK,
      startingMegaCredits: 40,
      resourceType: CardResource.DATA,

      metadata: {
        cardNumber: 'PfC13',
        description: 'You start with 40 M€',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(40).br;
          b.effect('Whenever you spend M€ (or steel or titanium) add 1 data to this card.', (eb) =>
            eb.minus().megacredits(1).slash().steel(1).slash().titanium(1).startEffect.resource(CardResource.DATA));
          b.br;
          b.effect('During the production phase convert each data from this card into 1M€ each.', (eb) => eb.resource(CardResource.DATA).asterix().startEffect.megacredits(1));
        }),
      },
    });
  }

  // Behavior is in Pathfinders.addToSolBank.
  public onProductionPhase(player: IPlayer): undefined {
    player.megaCredits += this.resourceCount;
    this.resourceCount = 0;
    return undefined;
  }
}

================
File: cards/pathfinders/SoylentSeedlingSystems.ts
================
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CorporationCard} from '../corporation/CorporationCard';
import {CardResource} from '../../../common/CardResource';
import {Space} from '../../boards/Space';
import {Board} from '../../boards/Board';

export class SoylentSeedlingSystems extends CorporationCard {
  constructor() {
    super({
      name: CardName.SOYLENT_SEEDLING_SYSTEMS,
      tags: [Tag.SCIENCE, Tag.PLANT],
      startingMegaCredits: 38,
      resourceType: CardResource.SEED,

      behavior: {
        addResources: 2,
      },

      metadata: {
        cardNumber: 'PfC8',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(38).resource(CardResource.SEED, 2).br;
          b.effect('When you place a greenery tile, add 1 seed resource to this card.', (eb) => {
            eb.greenery().startEffect.resource(CardResource.SEED);
          }).br;
          b.effect('When paying for a plant card, or the STANDARD GREENERY PROJECT, seeds here may be used as 5 M€ each.', (eb) => {
            eb.tag(Tag.PLANT).slash().greenery().startEffect.resource(CardResource.SEED).equals().megacredits(5);
          }).br;
        }),
        description: 'You start with 38M€ and 2 seeds on this card.',
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (cardOwner.id !== activePlayer.id) {
      return;
    }
    if (Board.isGreenerySpace(space)) {
      cardOwner.addResourceTo(this, {log: true});
    }
  }
}

================
File: cards/pathfinders/SpaceDebrisCleaningOperation.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {CardResource} from '../../../common/CardResource';
import {ICard} from '../ICard';
import {all} from '../Options';

export class SpaceDebrisCleaningOperation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SPACE_DEBRIS_CLEANING_OPERATION,
      cost: 7,
      tags: [Tag.MARS, Tag.SPACE],
      requirements: {tag: Tag.SPACE, count: 4, all},

      behavior: {
        stock: {titanium: 3},
        addResourcesToAnyCard: {count: 1, type: CardResource.DATA},
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'Pf24',
        renderData: CardRenderer.builder((b) => {
          b.titanium(3).br;
          b.wild(1).asterix().resource(CardResource.DATA).asterix().cards(1);
        }),
        // Nerfed by disallowing science resources (rather than the one The Moon does just to keep the text smaller.)
        description: 'Requires any 4 space tags in play. Gain 3 titanium. ' +
          'Add 1 resource to ANY card (not cards that take ANIMAL or SCIENCE resources.) ' +
          'Add 1 data to ANY card. Draw 1 card.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(
      new AddResourcesToCard(
        player,
        undefined,
        {
          count: 1,
          filter: (card: ICard) => {
            return card.resourceType !== undefined && card.resourceType !== CardResource.SCIENCE && !card.tags.includes(Tag.ANIMAL);
          },
        },
      ));
    return undefined;
  }
}

================
File: cards/pathfinders/SpaceRaceToMars.ts
================
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../../turmoil/Turmoil';
import {Resource} from '../../../common/Resource';
import {IPlayer} from '../../IPlayer';
import {isSpecialTileSpace, playerTileFn} from '../../boards/Board';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {CardRenderer} from '../render/CardRenderer';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.production((pb) => pb.megacredits(1)).slash().specialTile().nbsp;
  b.energy(1).slash().influence();
});

export class SpaceRaceToMars extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SPACE_RACE_TO_MARS,
      description: 'Increase your M€ production 1 step for every special tile you own (max 5.) Gain 1 energy for every influence you have',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const specialTileCount = this.specialTileCount(player);
      const bonus = Math.min(specialTileCount, 5);
      player.production.add(Resource.MEGACREDITS, bonus, {log: true, from: this.name});
      player.stock.add(Resource.ENERGY, turmoil.getPlayerInfluence(player), {log: true, from: this.name});
    });
  }

  private specialTileCount(player: IPlayer) {
    // This code is repeated in Land Specialist
    const spaces = player.game.board.spaces
      .filter(playerTileFn(player))
      .filter(isSpecialTileSpace);

    const marsCount = spaces.length;
    const moonCount = MoonExpansion.ifElseMoon(player.game, (moonData) => {
      return moonData.moon.spaces
        .filter(playerTileFn(player))
        .filter(isSpecialTileSpace)
        .length;
    },
    () => 0);
    return marsCount + moonCount;
  }
}

================
File: cards/pathfinders/SpaceRelay.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ICard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';

export class SpaceRelay extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SPACE_RELAY,
      cost: 13,
      tags: [Tag.SPACE, Tag.JOVIAN],

      behavior: {
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'Pf33',
        renderData: CardRenderer.builder((b) => {
          b.effect('Whenever you play a card with a Jovian tag, including this, draw a card.', (eb) => {
            eb.tag(Tag.JOVIAN).startEffect.cards(1);
          }).br;
          b.production((pb) => pb.megacredits(1));
        }),
        description: 'Increase your M€ production 1 step.',
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: ICard) {
    if (card.tags.includes(Tag.JOVIAN)) {
      player.drawCard();
    }
  }
}

================
File: cards/pathfinders/SpecializedSettlement.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Space} from '../../boards/Space';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {SelectResourceTypeDeferred} from '../../deferredActions/SelectResourceTypeDeferred';
import {Units} from '../../../common/Units';

export class SpecializedSettlement extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SPECIALIZED_SETTLEMENT,
      tags: [Tag.CITY, Tag.BUILDING, Tag.MARS],
      cost: 20,

      metadata: {
        cardNumber: 'PF57',
        description: 'Decrease your energy production 1 step and increase your M€ production 3 steps. ' +
          'Place a city tile on Mars. Increase your production by 1 of a resource on the map gained by placement bonus.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
            pb.plus().wild(1);
          }).nbsp.city();
        }),
      },
    });
  }

  public bonusResource?: Array<Resource>;

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.production.energy >= 1 &&
      player.game.board.getAvailableSpacesForCity(player).length > 0;
  }

  private bonusResources(space: Space) {
    const resources: Set<Resource> = new Set();
    space.bonus.forEach((bonus) => {
      switch (bonus) {
      case SpaceBonus.STEEL:
        resources.add(Resource.STEEL);
        break;
      case SpaceBonus.TITANIUM:
        resources.add(Resource.TITANIUM);
        break;
      case SpaceBonus.PLANT:
        resources.add(Resource.PLANTS);
        break;
      case SpaceBonus.ENERGY:
        resources.add(Resource.ENERGY);
        break;
      case SpaceBonus.HEAT:
        resources.add(Resource.HEAT);
        break;
      }
    });
    return Array.from(resources);
  }

  public override bespokePlay(player: IPlayer) {
    player.production.adjust(SpecializedSettlement.defaultProductionBox);
    return new SelectSpace(
      'Select space for city tile',
      player.game.board.getAvailableSpacesForCity(player))
      .andThen((space) => {
        const coveringExistingTile = space.tile !== undefined;

        player.game.addCity(player, space);

        if (coveringExistingTile) return;
        const bonusResources = this.bonusResources(space);
        if (bonusResources.length === 0) return;

        player.game.defer(new SelectResourceTypeDeferred(
          player, bonusResources,
          'Select a resource to gain 1 unit of production'))
          .andThen(
            (resource) => {
              player.production.add(resource, 1, {log: true});
              this.bonusResource = [resource];
            },
          );
        return undefined;
      },
      );
  }

  private static defaultProductionBox = Units.of({energy: -1, megacredits: 3});

  public productionBox() {
    const units = {...SpecializedSettlement.defaultProductionBox};
    if (this.bonusResource && this.bonusResource.length === 1) {
      units[this.bonusResource[0]] += 1;
    }
    return units;
  }

  public produceForTile(player: IPlayer, bonusResources: Array<Resource>) {
    if (bonusResources.length === 0) return;

    player.game.defer(new SelectResourceTypeDeferred(
      player, bonusResources,
      'Select a resource to gain 1 unit of production'))
      .andThen(
        (resource) => {
          player.production.add(resource, 1, {log: true});
          this.bonusResource = [resource];
        },
      );
  }
}

================
File: cards/pathfinders/Steelaris.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {Space} from '../../boards/Space';
import {TileType} from '../../../common/TileType';
import {GainStock} from '../../deferredActions/GainStock';
import {Priority} from '../../deferredActions/Priority';
import {Size} from '../../../common/cards/render/Size';
import {BoardType} from '../../boards/BoardType';
import {SpaceType} from '../../../common/boards/SpaceType';
import {Units} from '../../../common/Units';

export class Steelaris extends CorporationCard {
  constructor() {
    super({
      name: CardName.STEELARIS,
      tags: [Tag.BUILDING, Tag.CITY],
      startingMegaCredits: 42,

      metadata: {
        cardNumber: 'PfC9',
        description: 'You start with 42 M€.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(42).br;
          b.corpBox('effect', (ce) => {
            ce.effect('When any city or special tile is placed ON MARS, gain 1 steel and 1 plant.', (eb) => {
              eb.city({size: Size.SMALL, all}).slash().specialTile({size: Size.SMALL, all}).startEffect.steel(1).plants(1);
            });
          });
        }),
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space, boardType: BoardType) {
    const game = cardOwner.game;
    // Does not apply to The Moon.
    if (boardType !== BoardType.MARS) {
      return;
    }
    if (space.spaceType === SpaceType.COLONY) {
      return;
    }
    const tileType = space.tile?.tileType;
    if (tileType === TileType.OCEAN || tileType === TileType.GREENERY) {
      return;
    }
    game.defer(
      new GainStock(cardOwner, Units.of({steel: 1, plants: 1}), {
        cb: () => game.log(
          '${0} gained 1 ${1} and 1 ${2} from ${3}',
          (b) => b.player(cardOwner).string(Resource.STEEL).string(Resource.PLANTS).cardName(this.name)),
      }),
      cardOwner.id !== activePlayer.id ? Priority.OPPONENT_TRIGGER : undefined,
    );
  }
}

================
File: cards/pathfinders/StrategicBasePlanning.ts
================
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {PathfindersExpansion} from '../../pathfinders/PathfindersExpansion';

export class StrategicBasePlanning extends PreludeCard {
  constructor() {
    super({
      name: CardName.STRATEGIC_BASE_PLANNING,
      tags: [Tag.BUILDING],

      startingMegacredits: -8,

      behavior: {
        colonies: {buildColony: {}},
        city: {},
      },

      metadata: {
        cardNumber: 'P08',
        renderData: CardRenderer.builder((b) => {
          b.minus().megacredits(8).city().colonies();
        }),
        description: 'Pay 8M€. Place a city. Place a colony.',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    player.stock.deduct(Resource.MEGACREDITS, 8);
    PathfindersExpansion.addToSolBank(player);
    return undefined;
  }
}

================
File: cards/pathfinders/SurveyMission.ts
================
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {MarsBoard} from '../../boards/MarsBoard';
import {BoardType} from '../../boards/BoardType';
import {Space} from '../../boards/Space';
import {SelectSpace} from '../../inputs/SelectSpace';
import {LogHelper} from '../../LogHelper';
import {digit} from '../Options';

type Triplet = [Space, Space, Space];
export class SurveyMission extends PreludeCard {
  constructor() {
    super({
      name: CardName.SURVEY_MISSION,
      tags: [Tag.MARS],

      behavior: {
        stock: {steel: 5},
      },

      metadata: {
        cardNumber: 'P07',
        renderData: CardRenderer.builder((b) => {
          b.steel(5, {digit});
          b.br;
          b.surveyMission();
        }),
        description: 'Gain 5 steel. Land-claim three non-reserved spaces in a triangle shape. Gain all placement bonuses. ' +
          'Only you may place tiles there, and will gain placement bonuses again.',
      },
    });
  }

  private validTriplets(board: MarsBoard): Array<Triplet> {
    const spaces = board.getNonReservedLandSpaces().filter((space) => {
      return space.player === undefined && (space.tile === undefined || space.tile.protectedHazard === true);
    });

    const result: Array<Triplet> = [];

    function validAdjacentSpace(s1: Space, s2: Space) {
      // Ignore spaces before or above, those were covered earlier.
      // This is not just an optimization but also prevents storing
      // multiple triplets with the same spaces, but in a different order.
      if (s2.id < s1.id) return false;
      return spaces.includes(s2);
    }

    spaces.forEach((space) => {
      const adjacentSpaces = board.getAdjacentSpaces(space).filter((adjacent) => validAdjacentSpace(space, adjacent));
      for (let idx1 = 0; idx1 <= adjacentSpaces.length - 2; idx1++) {
        const n1 = adjacentSpaces[idx1];
        if (n1 === undefined) throw new Error('');
        for (let idx2 = idx1 + 1; idx2 <= adjacentSpaces.length - 1; idx2++) {
          const n2 = adjacentSpaces[idx2];
          if (n2 === undefined) throw new Error('');
          if (board.getAdjacentSpaces(n1).includes(n2)) {
            result.push([space, n1, n2]);
          }
        }
      }
    });

    return result;
  }

  public override bespokeCanPlay(player: IPlayer) {
    return this.validTriplets(player.game.board).length > 0;
  }

  private selectSpace(player: IPlayer, iteration: number, triplets: Array<Triplet>): SelectSpace {
    const messages = [
      'Select first space',
      'Select second space',
      'Select third space',
    ];
    const spaceSet: Set<Space> = new Set(triplets.flat());
    const spaces = Array.from(spaceSet).filter((space) => space.player === undefined);
    spaces.sort((s1, s2) => parseInt(s2.id) - parseInt(s1.id));
    return new SelectSpace(messages[iteration], spaces)
      .andThen((space) => {
        space.player = player;
        player.game.grantSpaceBonuses(player, space);
        LogHelper.logBoardTileAction(player, space, 'claimed');
        player.getCorporation(CardName.MINING_GUILD)?.onTilePlaced?.(player, player, space, BoardType.MARS);

        if (iteration === 2) return undefined;

        const revisedTriplets = triplets.filter((triplet) => {
          return triplet[0].id === space.id ||
          triplet[1].id === space.id ||
          triplet[2].id === space.id;
        });
        if (revisedTriplets.length === 0) return undefined;

        return this.selectSpace(player, iteration + 1, revisedTriplets);
      });
  }

  public override bespokePlay(player: IPlayer) {
    const triplets = this.validTriplets(player.game.board);
    return this.selectSpace(player, 0, triplets);
  }
}

================
File: cards/pathfinders/TerraformingControlStation.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class TerraformingControlStation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TERRAFORMING_CONTROL_STATION,
      cost: 18,
      tags: [Tag.VENUS, Tag.MARS, Tag.SPACE],

      behavior: {
        tr: 2,
      },

      cardDiscount: [{tag: Tag.VENUS, amount: 2}, {tag: Tag.MARS, amount: 2}],
      metadata: {
        cardNumber: 'Pf12',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a Venus or Mars tag, pay 2 M€ less.', (eb) => {
            eb.tag(Tag.VENUS).slash().tag(Tag.MARS).startEffect.megacredits(-2);
          });
          b.br.tr(2);
        }),
        description: 'Raise your TR 2 steps.',
      },
    });
  }
}

================
File: cards/pathfinders/TerraformingRobots.ts
================
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';

export class TerraformingRobots extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TERRAFORMING_ROBOTS,
      cost: 10,
      tags: [Tag.SCIENCE],
      resourceType: CardResource.SPECIALIZED_ROBOT,
      requirements: {tag: Tag.SCIENCE, count: 4},
      victoryPoints: {resourcesHere: {}},

      metadata: {
        cardNumber: 'PfT12',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a Mars tag, add 1 specialized robot on this card.', (eb) => {
            eb.tag(Tag.MARS).startEffect.resource(CardResource.SPECIALIZED_ROBOT);
          }).br;
          b.vpText('1 VP for every specialized robot on this card.');
        }),
        description: 'Requires 4 science tags.',
      },
    });
  }


  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    const qty = player.tags.cardTagCount(card, Tag.MARS);
    player.addResourceTo(this, {log: true, qty});
  }
}

================
File: cards/pathfinders/TheNewSpaceRace.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IProjectCard} from '../IProjectCard';
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {Tag} from '../../../common/cards/Tag';
import {IGame} from '../../IGame';
import {Turmoil} from '../../turmoil/Turmoil';
import {ChooseRulingPartyDeferred} from '../../turmoil/ChooseRulingPartyDeferred';

export class TheNewSpaceRace extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.THE_NEW_SPACE_RACE,
      tags: [Tag.SCIENCE, Tag.EARTH],

      behavior: {
        stock: {megacredits: 12},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.firstPlayer().rulingParty().megacredits(12).br;
        }),
        description: 'REVEALED BEFORE ANY OTHER PRELUDE. You become starting player for the game. Choose and set a ruling policy for the first generation. Gain 12 M€.',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    game.overrideFirstPlayer(player);
    Turmoil.ifTurmoil((player.game), (turmoil) => {
      player.game.defer(new ChooseRulingPartyDeferred(player, turmoil));
    });

    return undefined;
  }

  public static potentiallyChangeFirstPlayer(game: IGame) {
    const [cardHolder, card] = game.getCardHolder(CardName.THE_NEW_SPACE_RACE);
    if (cardHolder !== undefined && card !== undefined) {
      game.log('${0} has ${1}, which is played before any other Prelude and makes them first player.', (b) => b.player(cardHolder).card(card));
      cardHolder.playCard(card);
    }
  }
}

================
File: cards/pathfinders/ThinkTank.ts
================
import {CardRenderer} from '../render/CardRenderer';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {Size} from '../../../common/cards/render/Size';

export class ThinkTank extends ActionCard {
  constructor() {
    super({
      name: CardName.THINK_TANK,
      type: CardType.ACTIVE,
      cost: 12,
      tags: [Tag.MARS, Tag.VENUS, Tag.SCIENCE],
      resourceType: CardResource.DATA,

      action: {
        spend: {megacredits: 2},
        addResourcesToAnyCard: {count: 1, type: CardResource.DATA},
      },

      metadata: {
        cardNumber: 'Pf49',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 M€ to place 1 data on any card.', (ab) => {
            ab.megacredits(2).startAction.resource(CardResource.DATA).asterix();
          }).br;
          b.effect(
            'When playing a card, you can remove data from this card to ' +
            'change the card\'s global requirement by 1 step for every 1 data removed.',
            (eb) => eb.resource(CardResource.DATA).startEffect.text('+/-1 global parameter', Size.SMALL));
        }),
      },
    });
  }

  public override resourceCount = 0;
}

================
File: cards/pathfinders/TiredEarth.ts
================
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../../turmoil/Turmoil';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().plants(1).slash().tag(Tag.EARTH).influence({size: Size.SMALL});
});

export class TiredEarth extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.TIRED_EARTH,
      description: 'Lose 1 plant for each Earth tag you own (max 5) then reduced by influence.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const tags = player.tags.count(Tag.EARTH, 'raw');
      const rawTotal = Math.min(tags, 5) - turmoil.getPlayerInfluence(player);
      const total = Math.max(rawTotal, 0);
      player.stock.deduct(Resource.PLANTS, total, {log: true, from: this.name});
    });
  }
}

================
File: cards/pathfinders/ValuableGases.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {Resource} from '../../../common/Resource';
import {digit} from '../Options';
import {CardType} from '../../../common/cards/CardType';
import {SelectProjectCardToPlay} from '../../inputs/SelectProjectCardToPlay';

// TODO(kberg) like #3644, this card may have similar behavior.
export class ValuableGases extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.VALUABLE_GASES_PATHFINDERS,
      tags: [Tag.JOVIAN, Tag.VENUS],
      // 50 steps ensures "ignore requirements"
      globalParameterRequirementBonus: {steps: 50, nextCardOnly: true},

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(10).br;
          b.text('play', Size.MEDIUM, true).cards(1, {secondaryTag: AltSecondaryTag.FLOATER}).asterix().br;
          b.resource(CardResource.FLOATER, {amount: 5, digit});
        }),
        description: 'Gain 10 M€. Play an active floater card from hand, ignoring requirements, and add 5 floaters to it.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.stock.add(Resource.MEGACREDITS, 10);

    const playableCards = player.cardsInHand.filter((card) => {
      return card.resourceType === CardResource.FLOATER &&
        card.type === CardType.ACTIVE &&
        player.canAfford(player.affordOptionsForCard(card));
    }).map((card) => {
      return {
        card: card,
        details: true,
      };
    });
    if (playableCards.length !== 0) {
      player.defer(new SelectProjectCardToPlay(player, playableCards)
        .andThen((card) => {
          player.addResourceTo(card, 5);
          return undefined;
        }));
    }

    return undefined;
  }
}

================
File: cards/pathfinders/VeneraBase.ts
================
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';
import {PartyName} from '../../../common/turmoil/PartyName';
import {SpaceName} from '../../SpaceName';
import {ActionCard} from '../ActionCard';

export class VeneraBase extends ActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.VENERA_BASE,
      cost: 21,
      tags: [Tag.VENUS, Tag.VENUS, Tag.CITY],

      requirements: {party: PartyName.UNITY},
      victoryPoints: {tag: Tag.VENUS, per: 2},

      behavior: {
        production: {megacredits: 3},
        city: {space: SpaceName.VENERA_BASE},
      },

      action: {
        addResourcesToAnyCard: {type: CardResource.FLOATER, tag: Tag.VENUS, count: 1, mustHaveCard: true},
      },

      metadata: {
        cardNumber: 'Pf67',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to ANY Venus card', (ab) => ab.empty().startAction.resource(CardResource.FLOATER, {secondaryTag: Tag.VENUS}).asterix());
          b.br;
          b.production((pb) => pb.megacredits(3)).nbsp.city({secondaryTag: Tag.SPACE}).asterix();
          b.br;
          b.vpText('1 VP per 2 Venus tags you have.');
        }),
        description: 'Requires Unity is ruling or that you have 2 delegates there. Raise your M€ production 3 steps and place a city tile ON THE RESERVED AREA.',
      },
    });
  }
}

================
File: cards/pathfinders/VenusFirst.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class VenusFirst extends PreludeCard {
  constructor() {
    super({
      name: CardName.VENUS_FIRST,
      tags: [Tag.VENUS],

      behavior: {
        drawCard: {count: 2, tag: Tag.VENUS},
        global: {venus: 2},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.venus(2).br.br;
          b.cards(2, {secondaryTag: Tag.VENUS});
        }),
        description: 'Raise Venus 2 steps. Draw 2 Venus cards.',
      },
    });
  }
}

================
File: cards/pathfinders/VitalColony.ts
================
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {BuildColony} from '../../deferredActions/BuildColony';

export class VitalColony extends PreludeCard {
  constructor() {
    super({
      name: CardName.VITAL_COLONY,
      tags: [Tag.MARS, Tag.SPACE],

      metadata: {
        cardNumber: 'P08',
        renderData: CardRenderer.builder((b) => {
          b.colonies().text('2x bonus');
        }),
        description: 'Place a colony. Receive the placement bonus twice.',
      },
    });
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(
      new BuildColony(player, {giveBonusTwice: true}));
    return undefined;
  }
}

================
File: cards/pathfinders/Wetlands.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Space} from '../../boards/Space';
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {TileType} from '../../../common/TileType';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Board} from '../../boards/Board';
import {Size} from '../../../common/cards/render/Size';
import {message} from '../../logs/MessageBuilder';

export class Wetlands extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.WETLANDS,
      tags: [Tag.PLANT, Tag.MARS],
      cost: 20,
      tr: {oxygen: 1, tr: 1},
      requirements: {oceans: 2},
      reserveUnits: {plants: 4},
      victoryPoints: 1,

      metadata: {
        cardNumber: 'Pf03',
        renderData: CardRenderer.builder((b) => {
          b.minus().plants(4).br;
          b.tile(TileType.WETLANDS, false, false).asterix();
          b.oxygen(1).tr(1);
          b.br;
          b.text('(Requires 2 ocean tiles. Lose 4 plants. Place this tile on an UNRESERVED SPACE ' +
            'ADJACENT TO AT LEAST 2 OCEANS. Raise oxygen 1 step. Gain 1 TR.)', Size.TINY, false, false);
          b.br;
          b.text('(Effect: Wetlands counts as a greenery tile and an ocean tile, except it can\'t be covered and is not one of the 9 oceans required to end the game.)', Size.TINY, false, false);
        }),
      },
    });
  }

  public availableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions) {
    const board = player.game.board;
    const adjacentOceans: (space: Space) => number = (space) => {
      const adjacentSpaces = board.getAdjacentSpaces(space);
      return adjacentSpaces.filter(Board.isOceanSpace).length;
    };

    const redCity = board.getSpaceByTileCard(CardName.RED_CITY);
    const spacesNextToRedCity = redCity ?
      board.getAdjacentSpaces(redCity) :
      [];
    return board.getAvailableSpacesOnLand(player, canAffordOptions)
      .filter((space) => adjacentOceans(space) >= 2)
      .filter((space) => !spacesNextToRedCity.includes(space));
  }

  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions) {
    return this.availableSpaces(player, canAffordOptions).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace(
      message('Select space for ${0}', (b) => b.card(this)),
      this.availableSpaces(player))
      .andThen((space) => {
        const tile = {
          tileType: TileType.WETLANDS,
          card: this.name,
          covers: space.tile,
        };
        player.game.addTile(player, space, tile);
        player.game.increaseOxygenLevel(player, 1);
        return undefined;
      });
  }
}

================
File: cards/prelude/AcquiredSpaceAgency.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class AcquiredSpaceAgency extends PreludeCard {
  constructor() {
    super({
      name: CardName.ACQUIRED_SPACE_AGENCY,

      behavior: {
        stock: {titanium: 6},
        drawCard: {count: 2, tag: Tag.SPACE},
      },

      metadata: {
        cardNumber: 'P35',
        renderData: CardRenderer.builder((b) => {
          b.titanium(6, {digit}).br.br; // double break intentional
          b.cards(2, {secondaryTag: Tag.SPACE});
        }),
        description: 'Gain 6 titanium. Reveal cards until you reveal two cards with Space Tags. Take them into your hand, discard the rest.',
      },
    });
  }
}

================
File: cards/prelude/AlliedBanks.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class AlliedBanks extends PreludeCard {
  constructor() {
    super({
      name: CardName.ALLIED_BANK,
      tags: [Tag.EARTH],

      behavior: {
        production: {megacredits: 4},
        stock: {megacredits: 3},
      },

      metadata: {
        cardNumber: 'P01',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(4)).br;
          b.megacredits(3);
        }),
        description: 'Increase your M€ production 4 steps. Gain 3 M€.',
      },
    });
  }
}

================
File: cards/prelude/AquiferTurbines.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../render/CardRenderer';

export class AquiferTurbines extends PreludeCard {
  constructor() {
    super({
      name: CardName.AQUIFER_TURBINES,
      tags: [Tag.POWER],

      behavior: {
        production: {energy: 2},
        ocean: {},
      },

      startingMegacredits: -3,

      metadata: {
        cardNumber: 'P02',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).production((pb) => pb.energy(2)).br;
          b.megacredits(-3);
        }),
        description: 'Place an ocean tile. Increase your energy production 2 steps. Pay 3 M€.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer) {
    return player.canAfford(3);
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 3));
    return undefined;
  }
}

================
File: cards/prelude/Biofuels.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Biofuels extends PreludeCard {
  constructor() {
    super({
      name: CardName.BIOFUELS,
      tags: [Tag.MICROBE],

      behavior: {
        production: {energy: 1, plants: 1},
        stock: {plants: 2},
      },

      metadata: {
        cardNumber: 'P03',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).plants(1)).br;
          b.plants(2);
        }),
        description: 'Increase your energy and plant production 1 step. Gain 2 plants.',
      },
    });
  }
}

================
File: cards/prelude/Biolab.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Biolab extends PreludeCard {
  constructor() {
    super({
      name: CardName.BIOLAB,
      tags: [Tag.SCIENCE],

      behavior: {
        production: {plants: 1},
        drawCard: 3,
      },

      metadata: {
        cardNumber: 'P04',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).br;
          b.cards(3);
        }),
        description: 'Increase your plant production 1 step. Draw 3 cards.',
      },
    });
  }
}

================
File: cards/prelude/BiosphereSupport.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class BiosphereSupport extends PreludeCard {
  constructor() {
    super({
      name: CardName.BIOSPHERE_SUPPORT,
      tags: [Tag.PLANT],

      behavior: {
        production: {plants: 2, megacredits: -1},
      },

      metadata: {
        cardNumber: 'P05',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().megacredits(1).br;
            pb.plants(2);
          });
        }),
        description: 'Increase your plant production 2 steps. Decrease your M€ production 1 step.',
      },
    });
  }
}

================
File: cards/prelude/BufferGasStandardProject.ts
================
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {StandardProjectCard} from '../StandardProjectCard';

export class BufferGasStandardProject extends StandardProjectCard {
  constructor() {
    super({
      name: CardName.BUFFER_GAS_STANDARD_PROJECT,
      cost: 16,
      tr: {tr: 1},
      metadata: {
        cardNumber: 'SP3',
        renderData: CardRenderer.builder((b) =>
          b.standardProject('Spend 16 M€ to increase your TR 1 step. Solo games only.', (eb) => {
            eb.megacredits(16).startAction.tr(1);
          }),
        ),
      },
    });
  }

  actionEssence(player: IPlayer): void {
    player.increaseTerraformRating();
  }
}

================
File: cards/prelude/BusinessEmpire.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../render/CardRenderer';

export class BusinessEmpire extends PreludeCard {
  constructor() {
    super({
      name: CardName.BUSINESS_EMPIRE,
      tags: [Tag.EARTH],

      behavior: {
        production: {megacredits: 6},
      },
      startingMegacredits: -6,

      metadata: {
        cardNumber: 'P06',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(6)).br;
          b.megacredits(-6);
        }),
        description: 'Increase your M€ production 6 steps. Pay 6 M€.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer) {
    if (player.isCorporation(CardName.MANUTECH)) return true;
    return player.canAfford(6);
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 6));
    return undefined;
  }
}

================
File: cards/prelude/CheungShingMARS.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class CheungShingMARS extends CorporationCard {
  constructor() {
    super({
      name: CardName.CHEUNG_SHING_MARS,
      tags: [Tag.BUILDING],
      startingMegaCredits: 44,

      behavior: {
        production: {megacredits: 3},
      },

      cardDiscount: {tag: Tag.BUILDING, amount: 2},
      metadata: {
        cardNumber: 'R16',
        description: 'You start with 3 M€ production and 44 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.production((pb) => pb.megacredits(3)).nbsp.megacredits(44);
          b.corpBox('effect', (ce) => {
            ce.effect('When you play a building tag, you pay 2 M€ less for it.', (eb) => {
              eb.tag(Tag.BUILDING).startEffect.megacredits(-2);
            });
          });
        }),
      },
    });
  }
}

================
File: cards/prelude/DomeFarming.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class DomeFarming extends PreludeCard {
  constructor() {
    super({
      name: CardName.DOME_FARMING,
      tags: [Tag.PLANT, Tag.BUILDING],

      behavior: {
        production: {megacredits: 2, plants: 1},
      },

      metadata: {
        cardNumber: 'P07',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2).plants(1));
        }),
        description: 'Increase your M€ production 2 steps and plant production 1 step.',
      },
    });
  }
}

================
File: cards/prelude/Donation.ts
================
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Donation extends PreludeCard {
  constructor() {
    super({
      name: CardName.DONATION,

      behavior: {
        stock: {megacredits: 21},
      },

      metadata: {
        cardNumber: 'P08',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(21);
        }),
        description: 'Gain 21 M€.',
      },
    });
  }
}

================
File: cards/prelude/EarlySettlement.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class EarlySettlement extends PreludeCard {
  constructor() {
    super({
      name: CardName.EARLY_SETTLEMENT,
      tags: [Tag.BUILDING, Tag.CITY],

      behavior: {
        production: {plants: 1},
        city: {},
      },

      metadata: {
        cardNumber: 'P09',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).city();
        }),
        description: 'Increase your plant production 1 step. Place a city tile.',
      },
    });
  }
}

================
File: cards/prelude/EccentricSponsor.ts
================
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {PreludeCard} from './PreludeCard';
import {PlayProjectCard} from '../../deferredActions/PlayProjectCard';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {PreludesExpansion} from '../../preludes/PreludesExpansion';

export class EccentricSponsor extends PreludeCard {
  constructor() {
    super({
      name: CardName.ECCENTRIC_SPONSOR,

      metadata: {
        cardNumber: 'P11',
        renderData: CardRenderer.builder((b) => {
          b.text('Play a card from hand, reducing its cost by 25 M€', Size.SMALL, true);
        }),
      },
    });
  }

  // TODO(kberg): Make it possible to identify that the prelude will fizzle during canPlay, which
  // will present a warning to the player.

  public override getCardDiscount(player: IPlayer) {
    if (player.lastCardPlayed === this.name) {
      return 25;
    }
    return 0;
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new PlayProjectCard(player))
      .andThen((card) => {
        if (card === undefined) {
          PreludesExpansion.fizzle(player, this);
          // If this card fizzles, don't apply the discount to the next card.
          player.lastCardPlayed = undefined;
        }
      });
    return undefined;
  }
}

================
File: cards/prelude/EcologyExperts.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from './PreludeCard';
import {PlayProjectCard} from '../../deferredActions/PlayProjectCard';
import {CardRenderer} from '../render/CardRenderer';

export class EcologyExperts extends PreludeCard {
  constructor() {
    super({
      name: CardName.ECOLOGY_EXPERTS,
      tags: [Tag.PLANT, Tag.MICROBE],

      behavior: {
        production: {plants: 1},
      },

      metadata: {
        cardNumber: 'P10',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).br.br;
          b.projectRequirements();
        }),
        description: 'Increase your plant production 1 step. PLAY A CARD FROM HAND, IGNORING GLOBAL REQUIREMENTS.',
      },
    });
  }
  public override getGlobalParameterRequirementBonus(player: IPlayer): number {
    if (player.lastCardPlayed === this.name) {
      // Magic number high enough to always ignore requirements.
      return 50;
    }
    return 0;
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new PlayProjectCard(player));
    return undefined;
  }
}

================
File: cards/prelude/ExperimentalForest.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class ExperimentalForest extends PreludeCard {
  constructor() {
    super({
      name: CardName.EXPERIMENTAL_FOREST,
      tags: [Tag.PLANT],

      behavior: {
        drawCard: {count: 2, tag: Tag.PLANT},
        greenery: {},
      },

      metadata: {
        cardNumber: 'P12',
        renderData: CardRenderer.builder((b) => {
          b.greenery().cards(2, {secondaryTag: Tag.PLANT});
        }),
        description: 'Place 1 greenery tile and raise oxygen 1 step. Reveal cards until you reveal two cards with plant tags on them. Take them into your hand and discard the rest.',
      },
    });
  }
}

================
File: cards/prelude/GalileanMining.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../../cards/render/CardRenderer';

export class GalileanMining extends PreludeCard {
  constructor() {
    super({
      name: CardName.GALILEAN_MINING,
      tags: [Tag.JOVIAN],

      behavior: {
        production: {titanium: 2},
      },
      startingMegacredits: -5,

      metadata: {
        cardNumber: 'P13',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.titanium(2);
          }).br;
          b.megacredits(-5);
        }),
        description: 'Increase your titanium production 2 steps. Pay 5 M€.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer) {
    return player.canAfford(5);
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 5));
    return undefined;
  }
}

================
File: cards/prelude/GreatAquifer.ts
================
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class GreatAquifer extends PreludeCard {
  constructor() {
    super({
      name: CardName.GREAT_AQUIFER,

      behavior: {
        ocean: {count: 2},
      },

      metadata: {
        cardNumber: 'P13',
        renderData: CardRenderer.builder((b) => {
          b.oceans(2);
        }),
        description: 'Place 2 ocean tiles.',
      },
    });
  }
}

================
File: cards/prelude/HousePrinting.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IProjectCard} from '../IProjectCard';

export class HousePrinting extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HOUSE_PRINTING,
      tags: [Tag.BUILDING],
      cost: 10,

      behavior: {
        production: {steel: 1},
      },
      victoryPoints: 1,

      metadata: {
        cardNumber: 'P36',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(1));
        }),
        description: 'Increase your steel production 1 step.',
      },
    });
  }
}

================
File: cards/prelude/HugeAsteroid.ts
================
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../render/CardRenderer';

export class HugeAsteroid extends PreludeCard {
  constructor() {
    super({
      name: CardName.HUGE_ASTEROID,

      startingMegacredits: -5,

      behavior: {
        global: {temperature: 3},
      },

      metadata: {
        cardNumber: 'P15',
        renderData: CardRenderer.builder((b) => {
          b.temperature(3).br;
          b.megacredits(-5);
        }),
        description: 'Increase temperature 3 steps. Pay 5 M€.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer) {
    return player.canAfford(5);
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 5));
    return undefined;
  }
}

================
File: cards/prelude/IoResearchOutpost.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class IoResearchOutpost extends PreludeCard {
  constructor() {
    super({
      name: CardName.IO_RESEARCH_OUTPOST,
      tags: [Tag.JOVIAN, Tag.SCIENCE],

      behavior: {
        production: {titanium: 1},
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'P16',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).br;
          b.cards(1);
        }),
        description: 'Increase your titanium production 1 step. Draw a card.',
      },
    });
  }
}

================
File: cards/prelude/IPreludeCard.ts
================
import {ICard} from '../ICard';
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {PlayerInput} from '../../PlayerInput';
import {IPlayer} from '../../IPlayer';

export interface IPreludeCard extends IProjectCard {
  startingMegaCredits: number;
  type: CardType.PRELUDE;

  initialAction?(player: IPlayer): PlayerInput | undefined;
}

export function isPreludeCard(card: ICard): card is IPreludeCard {
  return card.type === CardType.PRELUDE;
}

================
File: cards/prelude/LavaTubeSettlement.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {PlaceCityTile} from '../../deferredActions/PlaceCityTile';
import {CardRenderer} from '../render/CardRenderer';
import {Space} from '../../boards/Space';

export class LavaTubeSettlement extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LAVA_TUBE_SETTLEMENT,
      tags: [Tag.BUILDING, Tag.CITY],
      cost: 15,

      behavior: {
        production: {energy: -1, megacredits: 2},
      },

      metadata: {
        cardNumber: 'P37',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(2);
          }).br;
          b.city().asterix();
        }),
        description: 'Decrease your energy production 1 step and increase your M€ production 2 steps. Place a city tile on a VOLCANIC AREA regardless of adjacent cities.',
      },
    });
  }

  private getSpacesForCity(player: IPlayer): ReadonlyArray<Space> {
    // https://boardgamegeek.com/thread/1953628/article/29627211#29627211
    const spaceType = player.game.board.volcanicSpaceIds.length === 0 ? 'city' : 'volcanic';
    return player.game.board.getAvailableSpacesForType(player, spaceType);
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return this.getSpacesForCity(player).length > 0 && player.production.energy >= 1;
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(
      new PlaceCityTile(
        player,
        {
          spaces: this.getSpacesForCity(player),
          title: 'Select either Tharsis Tholus, Ascraeus Mons, Pavonis Mons or Arsia Mons',
        }));
    return undefined;
  }
}

================
File: cards/prelude/Loan.ts
================
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Loan extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.LOAN,

      behavior: {
        production: {megacredits: -2},
        stock: {megacredits: 30},
      },

      metadata: {
        cardNumber: 'P17',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().megacredits(2)).br;
          b.megacredits(30);
        }),
        description: 'Gain 30 M€. Decrease your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/prelude/MartianIndustries.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class MartianIndustries extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.MARTIAN_INDUSTRIES,
      tags: [Tag.BUILDING],

      behavior: {
        production: {energy: 1, steel: 1},
        stock: {megacredits: 6},
      },

      metadata: {
        cardNumber: 'P18',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1).steel(1)).br;
          b.megacredits(6);
        }),
        description: 'Increase your energy and steel production 1 step. Gain 6 M€.',
      },
    });
  }
}

================
File: cards/prelude/MartianSurvey.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {max} from '../Options';

export class MartianSurvey extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.MARTIAN_SURVEY,
      tags: [Tag.SCIENCE],
      cost: 9,
      victoryPoints: 1,

      behavior: {
        drawCard: 2,
      },

      requirements: {oxygen: 4, max},
      metadata: {
        cardNumber: 'P38',
        renderData: CardRenderer.builder((b) => {
          b.cards(2);
        }),
        description: 'Oxygen must be 4% or lower. Draw two cards.',
      },
    });
  }
}

================
File: cards/prelude/MetalRichAsteroid.ts
================
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class MetalRichAsteroid extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.METAL_RICH_ASTEROID,

      behavior: {
        stock: {titanium: 4, steel: 4},
        global: {temperature: 1},
      },
      metadata: {
        cardNumber: 'P19',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1).titanium(4).br;
          b.steel(4);
        }),
        description: 'Increase temperature 1 step. Gain 4 titanium and 4 steel.',
      },
    });
  }
}

================
File: cards/prelude/MetalsCompany.ts
================
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class MetalsCompany extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.METALS_COMPANY,

      behavior: {
        production: {megacredits: 1, steel: 1, titanium: 1},
      },

      metadata: {
        cardNumber: 'P20',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).steel(1).titanium(1));
        }),
        description: 'Increase your M€, steel and titanium production 1 step.',
      },
    });
  }
}

================
File: cards/prelude/MiningOperations.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class MiningOperations extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.MINING_OPERATIONS,
      tags: [Tag.BUILDING],

      behavior: {
        production: {steel: 2},
        stock: {steel: 4},
      },

      metadata: {
        cardNumber: 'P21',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(2)).br;
          b.steel(4);
        }),
        description: 'Increase your steel production 2 steps. Gain 4 steel.',
      },
    });
  }
}

================
File: cards/prelude/Mohole.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Mohole extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.MOHOLE,
      tags: [Tag.BUILDING],

      behavior: {
        production: {heat: 3},
        stock: {heat: 3},
      },

      metadata: {
        cardNumber: 'P22',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(3)).br;
          b.heat(3);
        }),
        description: 'Increase your heat production 3 steps. Gain 3 heat.',
      },
    });
  }
}

================
File: cards/prelude/MoholeExcavation.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class MoholeExcavation extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.MOHOLE_EXCAVATION,
      tags: [Tag.BUILDING],

      behavior: {
        production: {steel: 1, heat: 2},
        stock: {heat: 2},
      },

      metadata: {
        cardNumber: 'P23',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.steel(1).br;
            pb.heat(2);
          }).heat(2);
        }),
        description: 'Increase your steel production 1 step and heat production 2 steps. Gain 2 heat.',
      },
    });
  }
}

================
File: cards/prelude/NitrogenShipment.ts
================
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class NitrogenShipment extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.NITROGEN_SHIPMENT,

      behavior: {
        production: {plants: 1},
        tr: 1,
        stock: {megacredits: 5},
      },

      metadata: {
        cardNumber: 'P24',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).tr(1).br;
          b.megacredits(5);
        }),
        description: 'Increase your plant production 1 step. Increase your TR 1 step. Gain 5 M€.',
      },
    });
  }
}

================
File: cards/prelude/OrbitalConstructionYard.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class OrbitalConstructionYard extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.ORBITAL_CONSTRUCTION_YARD,
      tags: [Tag.SPACE],

      behavior: {
        production: {titanium: 1},
        stock: {titanium: 4},
      },

      metadata: {
        cardNumber: 'P25',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).br;
          b.titanium(4);
        }),
        description: 'Increase your titanium production 1 step. Gain 4 titanium.',
      },
    });
  }
}

================
File: cards/prelude/PointLuna.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {ICorporationCard} from '../corporation/ICorporationCard';
import {CorporationCard} from '../corporation/CorporationCard';
import {ICard} from '../ICard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class PointLuna extends CorporationCard {
  constructor() {
    super({
      name: CardName.POINT_LUNA,
      tags: [Tag.SPACE, Tag.EARTH],
      startingMegaCredits: 38,

      behavior: {
        production: {titanium: 1},
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'R10',
        description: 'You start with 1 titanium production and 38 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.production((pb) => pb.titanium(1)).nbsp.megacredits(38);
          b.corpBox('effect', (ce) => {
            ce.effect('When you play an Earth tag, including this, draw a card.', (eb) => {
              eb.tag(Tag.EARTH).startEffect.cards(1);
            });
          });
        }),
      },
    });
  }
  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    return this.onCardPlayed(player, card);
  }

  public onCardPlayed(player: IPlayer, card: ICard) {
    if (player.isCorporation(this.name)) {
      const tagCount = player.tags.cardTagCount(card, Tag.EARTH);
      if (tagCount > 0) {
        player.drawCard(tagCount);
      }
    }
  }
}

================
File: cards/prelude/PolarIndustries.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class PolarIndustries extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.POLAR_INDUSTRIES,
      tags: [Tag.BUILDING],

      behavior: {
        production: {heat: 2},
        ocean: {},
      },

      metadata: {
        cardNumber: 'P26',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(2)).br;
          b.oceans(1);
        }),
        description: 'Increase your heat production 2 steps. Place an ocean tile.',
      },
    });
  }
}

================
File: cards/prelude/PowerGeneration.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class PowerGeneration extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.POWER_GENERATION,
      tags: [Tag.POWER],

      behavior: {
        production: {energy: 3},
      },

      metadata: {
        cardNumber: 'P27',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(3));
        }),
        description: 'Increase your energy production 3 steps.',
      },
    });
  }
}

================
File: cards/prelude/PreludeCard.ts
================
import {Card, StaticCardProperties} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardMetadata} from '../../../common/cards/CardMetadata';
import {CardName} from '../../../common/cards/CardName';
import {Tag} from '../../../common/cards/Tag';
import {TileType} from '../../../common/TileType';
import {Behavior} from '../../behavior/Behavior';
import {IPreludeCard} from './IPreludeCard';
import {CardResource} from '../../../common/CardResource';
import {IVictoryPoints} from '../../../common/cards/IVictoryPoints';
import {GlobalParameterRequirementBonus} from '../../../common/cards/Types';
import {OneOrArray} from '../../../common/utils/types';
import {CardDiscount} from '../../../common/cards/Types';

export type StaticPreludeProperties = {
  action?: Behavior;
  behavior?: Partial<Behavior>,
  globalParameterRequirementBonus?: GlobalParameterRequirementBonus;
  metadata: CardMetadata;
  name: CardName;
  tags?: Array<Tag>;
  tilesBuilt?: ReadonlyArray<TileType>,
  resourceType?: CardResource;
  startingMegacredits?: number,
  victoryPoints?: number | 'special' | IVictoryPoints,
  cardDiscount?: OneOrArray<CardDiscount>;
}

export abstract class PreludeCard extends Card implements IPreludeCard {
  constructor(properties: StaticPreludeProperties) {
    const startingMegaCredits = properties.startingMegacredits ?? properties.behavior?.stock?.megacredits;
    if (typeof(startingMegaCredits) === 'object') {
      throw new Error('Cannot have a Countable for a Prelude stock MC: ' + properties.name);
    }
    const obj: StaticCardProperties = {
      action: properties.action,
      behavior: properties.behavior,
      type: CardType.PRELUDE,
      name: properties.name,
      tags: properties.tags,
      globalParameterRequirementBonus: properties.globalParameterRequirementBonus,
      cardDiscount: properties.cardDiscount,
      metadata: properties.metadata,
      resourceType: properties.resourceType,
      tilesBuilt: properties.tilesBuilt,
      victoryPoints: properties.victoryPoints,
    };
    if (startingMegaCredits !== undefined) {
      obj.startingMegaCredits = startingMegaCredits;
    }
    super(obj);
  }
  public override get type(): CardType.PRELUDE {
    return CardType.PRELUDE;
  }
}

================
File: cards/prelude/PreludeCardManifest.ts
================
import {CardName} from '../../../common/cards/CardName';
import {ModuleManifest} from '../ModuleManifest';
import {AcquiredSpaceAgency} from './AcquiredSpaceAgency';
import {AlliedBanks} from './AlliedBanks';
import {AquiferTurbines} from './AquiferTurbines';
import {Biofuels} from './Biofuels';
import {Biolab} from './Biolab';
import {BiosphereSupport} from './BiosphereSupport';
import {BusinessEmpire} from './BusinessEmpire';
import {CheungShingMARS} from './CheungShingMARS';
import {DomeFarming} from './DomeFarming';
import {Donation} from './Donation';
import {EarlySettlement} from './EarlySettlement';
import {EccentricSponsor} from './EccentricSponsor';
import {EcologyExperts} from './EcologyExperts';
import {ExperimentalForest} from './ExperimentalForest';
import {GalileanMining} from './GalileanMining';
import {GreatAquifer} from './GreatAquifer';
import {HousePrinting} from './HousePrinting';
import {HugeAsteroid} from './HugeAsteroid';
import {IoResearchOutpost} from './IoResearchOutpost';
import {LavaTubeSettlement} from './LavaTubeSettlement';
import {Loan} from './Loan';
import {MartianIndustries} from './MartianIndustries';
import {MartianSurvey} from './MartianSurvey';
import {MetalRichAsteroid} from './MetalRichAsteroid';
import {MetalsCompany} from './MetalsCompany';
import {MiningOperations} from './MiningOperations';
import {Mohole} from './Mohole';
import {MoholeExcavation} from './MoholeExcavation';
import {NitrogenShipment} from './NitrogenShipment';
import {OrbitalConstructionYard} from './OrbitalConstructionYard';
import {PointLuna} from './PointLuna';
import {PolarIndustries} from './PolarIndustries';
import {PowerGeneration} from './PowerGeneration';
import {Psychrophiles} from './Psychrophiles';
import {ResearchCoordination} from './ResearchCoordination';
import {ResearchNetwork} from './ResearchNetwork';
import {RobinsonIndustries} from './RobinsonIndustries';
import {SelfSufficientSettlement} from './SelfSufficientSettlement';
import {SFMemorial} from './SFMemorial';
import {SmeltingPlant} from './SmeltingPlant';
import {SocietySupport} from './SocietySupport';
import {SpaceHotels} from './SpaceHotels';
import {Supplier} from './Supplier';
import {SupplyDrop} from './SupplyDrop';
import {UNMIContractor} from './UNMIContractor';
import {ValleyTrust} from './ValleyTrust';
import {Vitor} from './Vitor';

export const PRELUDE_CARD_MANIFEST = new ModuleManifest({
  module: 'prelude',
  projectCards: {
    [CardName.SF_MEMORIAL]: {Factory: SFMemorial},
    [CardName.HOUSE_PRINTING]: {Factory: HousePrinting},
    [CardName.SPACE_HOTELS]: {Factory: SpaceHotels},
    [CardName.MARTIAN_SURVEY]: {Factory: MartianSurvey},
    [CardName.RESEARCH_COORDINATION]: {Factory: ResearchCoordination},
    [CardName.LAVA_TUBE_SETTLEMENT]: {Factory: LavaTubeSettlement},
    [CardName.PSYCHROPHILES]: {Factory: Psychrophiles},
  },

  corporationCards: {
    [CardName.CHEUNG_SHING_MARS]: {Factory: CheungShingMARS},
    [CardName.POINT_LUNA]: {Factory: PointLuna},
    [CardName.ROBINSON_INDUSTRIES]: {Factory: RobinsonIndustries},
    [CardName.VALLEY_TRUST]: {Factory: ValleyTrust},
    [CardName.VITOR]: {Factory: Vitor},
  },

  preludeCards: {
    [CardName.ALLIED_BANK]: {Factory: AlliedBanks},
    [CardName.BIOSPHERE_SUPPORT]: {Factory: BiosphereSupport},
    [CardName.AQUIFER_TURBINES]: {Factory: AquiferTurbines},
    [CardName.MOHOLE_EXCAVATION]: {Factory: MoholeExcavation},
    [CardName.EARLY_SETTLEMENT]: {Factory: EarlySettlement},
    [CardName.BIOFUELS]: {Factory: Biofuels},
    [CardName.POWER_GENERATION]: {Factory: PowerGeneration},
    [CardName.SELF_SUFFICIENT_SETTLEMENT]: {Factory: SelfSufficientSettlement},
    [CardName.MINING_OPERATIONS]: {Factory: MiningOperations},
    [CardName.UNMI_CONTRACTOR]: {Factory: UNMIContractor},
    [CardName.DOME_FARMING]: {Factory: DomeFarming},
    [CardName.BUSINESS_EMPIRE]: {Factory: BusinessEmpire},
    [CardName.DONATION]: {Factory: Donation},
    [CardName.NITROGEN_SHIPMENT]: {Factory: NitrogenShipment},
    [CardName.SMELTING_PLANT]: {Factory: SmeltingPlant},
    [CardName.SUPPLIER]: {Factory: Supplier},
    [CardName.SUPPLY_DROP]: {Factory: SupplyDrop},
    [CardName.GREAT_AQUIFER]: {Factory: GreatAquifer},
    [CardName.BIOLAB]: {Factory: Biolab},
    [CardName.MARTIAN_INDUSTRIES]: {Factory: MartianIndustries},
    [CardName.IO_RESEARCH_OUTPOST]: {Factory: IoResearchOutpost},
    [CardName.POLAR_INDUSTRIES]: {Factory: PolarIndustries},
    [CardName.SOCIETY_SUPPORT]: {Factory: SocietySupport},
    [CardName.GALILEAN_MINING]: {Factory: GalileanMining},
    [CardName.HUGE_ASTEROID]: {Factory: HugeAsteroid},
    [CardName.METALS_COMPANY]: {Factory: MetalsCompany},
    [CardName.LOAN]: {Factory: Loan},
    [CardName.MOHOLE]: {Factory: Mohole},
    [CardName.METAL_RICH_ASTEROID]: {Factory: MetalRichAsteroid},
    [CardName.ORBITAL_CONSTRUCTION_YARD]: {Factory: OrbitalConstructionYard},
    [CardName.ACQUIRED_SPACE_AGENCY]: {Factory: AcquiredSpaceAgency},
    [CardName.RESEARCH_NETWORK]: {Factory: ResearchNetwork},
    [CardName.ECCENTRIC_SPONSOR]: {Factory: EccentricSponsor},
    [CardName.ECOLOGY_EXPERTS]: {Factory: EcologyExperts},
    [CardName.EXPERIMENTAL_FOREST]: {Factory: ExperimentalForest},
  },
});

================
File: cards/prelude/Psychrophiles.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {max} from '../Options';

export class Psychrophiles extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PSYCHROPHILES,
      tags: [Tag.MICROBE],
      cost: 2,
      resourceType: CardResource.MICROBE,

      action: {
        addResources: 1,
      },

      requirements: {temperature: -20, max},
      metadata: {
        cardNumber: 'P39',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.effect('When paying for a plant card, microbes here may be used as 2 M€ each.', (eb) => {
            eb.tag(Tag.PLANT).startEffect.resource(CardResource.MICROBE).equals().megacredits(2);
          });
        }),
        description: 'Temperature must be -20 C or lower.',
      },
    });
  }
}

================
File: cards/prelude/ResearchCoordination.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';

export class ResearchCoordination extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.RESEARCH_COORDINATION,
      tags: [Tag.WILD],
      cost: 4,

      metadata: {
        cardNumber: 'P40',
        description: 'After being played, when you perform an action, the wild tag counts as any tag of your choice.',
      },
    });
  }
}

================
File: cards/prelude/ResearchNetwork.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class ResearchNetwork extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.RESEARCH_NETWORK,
      tags: [Tag.WILD],

      behavior: {
        production: {megacredits: 1},
        drawCard: 3,
      },

      metadata: {
        cardNumber: 'P28',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1)).br;
          b.cards(3);
        }),
        description: 'Increase your M€ production 1 step. Draw 3 cards. After being played, when you perform an action, the wild tag counts as any tag of your choice.',
      },
    });
  }
}

================
File: cards/prelude/RobinsonIndustries.ts
================
import {IActionCard} from '../ICard';
import {IPlayer} from '../../IPlayer';
import {CorporationCard} from '../corporation/CorporationCard';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {ALL_RESOURCES} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {TITLES} from '../../inputs/titles';

export class RobinsonIndustries extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.ROBINSON_INDUSTRIES,
      startingMegaCredits: 47,

      metadata: {
        cardNumber: 'R27',
        description: 'You start with 47 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(47);
          b.corpBox('action', (ce) => {
            ce.action('Spend 4 M€ to increase (one of) your LOWEST production 1 step.', (eb) => {
              eb.megacredits(4).startAction.production((pb) => pb.wild(1).asterix());
            });
          });
        }),
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.canAfford(4);
  }

  public action(player: IPlayer) {
    let minimum = player.production.megacredits;
    let lowest: Array<SelectOption> = [];

    ALL_RESOURCES.forEach((resource) => {
      const option = new SelectOption('Increase ' + resource + ' production 1 step').andThen(() => {
        player.game.defer(new SelectPaymentDeferred(player, 4, {title: TITLES.payForCardAction(this.name)}))
          // Add production after payment, to prevent Manutech from being in the way.
          .andThen(() => player.production.add(resource, 1, {log: true}));
        return undefined;
      });

      if (player.production[resource] < minimum) {
        lowest = [];
        minimum = player.production[resource];
      }
      if (player.production[resource] === minimum) lowest.push(option);
    });

    const result = new OrOptions();
    result.options = lowest;
    return result;
  }
}

================
File: cards/prelude/SelfSufficientSettlement.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SelfSufficientSettlement extends PreludeCard implements IProjectCard {
  constructor() {
    super({
      name: CardName.SELF_SUFFICIENT_SETTLEMENT,
      tags: [Tag.BUILDING, Tag.CITY],

      behavior: {
        production: {megacredits: 2},
        city: {},
      },

      metadata: {
        cardNumber: 'P29',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).city();
        }),
        description: 'Increase your M€ production 2 steps. Place a city tile.',
      },
    });
  }
}

================
File: cards/prelude/SFMemorial.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SFMemorial extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SF_MEMORIAL,
      tags: [Tag.BUILDING],
      cost: 7,
      victoryPoints: 1,

      behavior: {
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'P41',
        renderData: CardRenderer.builder((b) => b.cards(1)),
        description: 'Draw 1 card.',
      },
    });
  }
}

================
File: cards/prelude/SmeltingPlant.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SmeltingPlant extends PreludeCard {
  constructor() {
    super({
      name: CardName.SMELTING_PLANT,
      tags: [Tag.BUILDING],

      behavior: {
        stock: {steel: 5},
        global: {oxygen: 2},
      },

      metadata: {
        cardNumber: 'P30',
        renderData: CardRenderer.builder((b) => {
          b.oxygen(2).br;
          b.steel(5);
        }),
        description: 'Raise oxygen 2 steps. Gain 5 steel.',
      },
    });
  }
}

================
File: cards/prelude/SocietySupport.ts
================
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SocietySupport extends PreludeCard {
  constructor() {
    super({
      name: CardName.SOCIETY_SUPPORT,

      behavior: {
        production: {plants: 1, energy: 1, heat: 1, megacredits: -1},
      },

      metadata: {
        cardNumber: 'P31',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(-1).plants(1).br;
            pb.energy(1).heat(1);
          });
        }),
        description: 'Increase your plant, energy and heat production 1 step. Decrease M€ production 1 step.',
      },
    });
  }
}

================
File: cards/prelude/SpaceHotels.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SpaceHotels extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SPACE_HOTELS,
      tags: [Tag.SPACE, Tag.EARTH],
      cost: 12,

      behavior: {
        production: {megacredits: 4},
      },

      requirements: {tag: Tag.EARTH, count: 2},
      metadata: {
        cardNumber: 'P42',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(4);
          });
        }),
        description: 'Requires 2 Earth tags. Increase M€ production 4 steps.',
      },
    });
  }
}

================
File: cards/prelude/Supplier.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Supplier extends PreludeCard {
  constructor() {
    super({
      name: CardName.SUPPLIER,
      tags: [Tag.POWER],

      behavior: {
        production: {energy: 2},
        stock: {steel: 4},
      },

      metadata: {
        cardNumber: 'P32',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2)).br;
          b.steel(4);
        }),
        description: 'Increase your energy production 2 steps. Gain 4 steel.',
      },
    });
  }
}

================
File: cards/prelude/SupplyDrop.ts
================
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class SupplyDrop extends PreludeCard {
  constructor() {
    super({
      name: CardName.SUPPLY_DROP,

      behavior: {
        stock: {titanium: 3, steel: 8, plants: 3},
      },

      metadata: {
        cardNumber: 'P33',
        renderData: CardRenderer.builder((b) => {
          b.titanium(3, {digit}).steel(8, {digit}).plants(3, {digit});
        }),
        description: 'Gain 3 titanium, 8 steel and 3 plants.',
      },
    });
  }
}

================
File: cards/prelude/UNMIContractor.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from './PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class UNMIContractor extends PreludeCard {
  constructor() {
    super({
      name: CardName.UNMI_CONTRACTOR,
      tags: [Tag.EARTH],

      behavior: {
        drawCard: 1,
        tr: 3,
      },

      metadata: {
        cardNumber: 'P34',
        renderData: CardRenderer.builder((b) => {
          b.tr(3).br;
          b.cards(1);
        }),
        description: 'Increase your TR 3 steps. Draw a card.',
      },
    });
  }
}

================
File: cards/prelude/ValleyTrust.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CorporationCard} from '../corporation/CorporationCard';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {PreludesExpansion} from '../../preludes/PreludesExpansion';

export class ValleyTrust extends CorporationCard {
  constructor() {
    super({
      name: CardName.VALLEY_TRUST,
      tags: [Tag.EARTH],
      startingMegaCredits: 37,
      initialActionText: 'Draw 3 Prelude cards, and play one of them',

      cardDiscount: {tag: Tag.SCIENCE, amount: 2},
      metadata: {
        cardNumber: 'R34',
        description: 'You start with 37 M€. As your first action, draw 3 Prelude cards, and play one of them. Discard the other two.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(37).nbsp.prelude().asterix();
          b.corpBox('effect', (ce) => {
            ce.effect('When you play a science tag, you pay 2M€ less for it.', (eb) => {
              eb.tag(Tag.SCIENCE).startEffect.megacredits(-2);
            });
          });
        }),
      },
    });
  }

  public override getCardDiscount(player: IPlayer, card: IProjectCard) {
    // TODO(chosta) -> improve once the discounts property is given a go
    return player.tags.cardTagCount(card, Tag.SCIENCE) * 2;
  }

  // TODO(kberg): find a way to feed warnings for initialAction.
  public initialAction(player: IPlayer) {
    const game = player.game;
    const cards = game.preludeDeck.drawN(game, 3);
    return PreludesExpansion.playPrelude(player, cards);
  }
}

================
File: cards/prelude/Vitor.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CorporationCard} from '../corporation/CorporationCard';
import {IProjectCard} from '../IProjectCard';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {IAward} from '../../awards/IAward';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {message} from '../../logs/MessageBuilder';

export class Vitor extends CorporationCard {
  constructor() {
    super({
      name: CardName.VITOR,
      tags: [Tag.EARTH],
      startingMegaCredits: 48, // It's 45 + 3 when this corp is played
      initialActionText: 'Fund an award for free',

      metadata: {
        cardNumber: 'R35',
        description: 'You start with 45 M€. As your first action, fund an award for free.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(45).nbsp.award();
          b.corpBox('effect', (ce) => {
            ce.effect('When you play a card with a NON-NEGATIVE VP icon, including this, gain 3 M€.', (eb) => {
              eb.vpIcon().asterix().startEffect.megacredits(3);
            });
          });
        }),
      },
    });
  }

  private selectAwardToFund(player: IPlayer, award: IAward): SelectOption {
    return new SelectOption(message('Fund ${0} award', (b) => b.award(award))).andThen(() => {
      player.game.fundAward(player, award);
      return undefined;
    });
  }

  public initialAction(player: IPlayer) {
    const game = player.game;

    // Awards are disabled for 1 player games
    if (game.isSoloMode()) return;

    const freeAward = new OrOptions();
    freeAward.title = 'Select award to fund';
    freeAward.buttonLabel = 'Confirm';

    // If Vitor isn't going first and someone else funds awards, filter them out.
    const availableAwards = game.awards.filter((award) => !game.fundedAwards.map((fa) => fa.award).includes(award));
    freeAward.options = availableAwards.map((award) => this.selectAwardToFund(player, award));

    return freeAward;
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (!player.isCorporation(this.name)) {
      return;
    }
    const victoryPoints = card.metadata.victoryPoints;
    if (victoryPoints === undefined) return;
    if (typeof(victoryPoints) === 'number') {
      if (victoryPoints <= 0) return;
    } else {
      // victoryPoints type is CardRenderDynamicVictoryPoints
      if (victoryPoints.points <= 0) return;
    }

    player.stock.add(Resource.MEGACREDITS, 3, {log: true, from: this});
  }
}

================
File: cards/prelude2/ActivePreludeCard.ts
================
import {IActionCard} from '../ICard';
import {PreludeCard} from '../prelude/PreludeCard';
import {IPlayer} from '../../IPlayer';
import {getBehaviorExecutor} from '../../behavior/BehaviorExecutor';

/** A prelude card with an action. Duplicates code from ActionCard. */
export abstract class ActivePreludeCard extends PreludeCard implements IActionCard {
  public canAct(player: IPlayer) {
    if (this.properties.action === undefined) {
      throw new Error('action not defined');
    }
    if (!getBehaviorExecutor().canExecute(this.properties.action, player, this)) {
      return false;
    }
    return this.bespokeCanAct(player);
  }

  public action(player: IPlayer) {
    if (this.properties.action === undefined) {
      throw new Error('action not defined');
    }
    getBehaviorExecutor().execute(this.properties.action, player, this);
    return this.bespokeAction(player);
  }

  public bespokeCanAct(_player: IPlayer): boolean {
    return true;
  }

  public bespokeAction(_player: IPlayer) {
    return undefined;
  }
}

================
File: cards/prelude2/AppliedScience.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {IActionCard} from '../ICard';
import {digit} from '../Options';
import {ActivePreludeCard} from './ActivePreludeCard';

export class AppliedScience extends ActivePreludeCard implements IActionCard {
  constructor() {
    super({
      name: CardName.APPLIED_SCIENCE,
      tags: [Tag.WILD],
      resourceType: CardResource.SCIENCE,

      behavior: {
        addResources: 6,
      },

      action: {
        or: {
          behaviors: [
            {
              spend: {resourcesHere: 1},
              standardResource: 1,
              title: 'Spend 1 science resource here to gain 1 standard resource',
            },
            {
              spend: {resourcesHere: 1},
              addResourcesToAnyCard: {
                count: 1,
                min: 1,
                mustHaveCard: true,
                robotCards: true,
              },
              title: 'Spend 1 science resource here to gain 1 resource on ANY CARD WITH A RESOURCE.',
            },
          ],
          autoSelect: true,
        },
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.action('Remove 1 resource here to gain 1 standard resource of your choice or add 1 resource on ANY CARD WITH A RESOURCE.', (ab) => {
            ab.resource(CardResource.SCIENCE).startAction.wild(1).asterix();
          }).br;
          b.resource(CardResource.SCIENCE, {amount: 6, digit}).br;
        }),
        description: 'Add 6 resources here.',
      },
    });
  }
}

================
File: cards/prelude2/AtmosphericEnhancers.ts
================
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {TRSource} from '../../../common/cards/TRSource';
import {digit} from '../Options';
import {floaterCards} from '../venusNext/floaterCards';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {Size} from '../../../common/cards/render/Size';

export class AtmosphericEnhancers extends PreludeCard {
  constructor() {
    super({
      name: CardName.ATMOSPHERIC_ENHANCERS,
      tags: [Tag.VENUS],

      behavior: {
        or: {
          behaviors: [
            {global: {temperature: 2}, title: 'Raise the temperature 2 steps'},
            {global: {oxygen: 2}, title: 'Raise the oxygen level 2 steps'},
            {global: {venus: 2}, title: 'Raise the Venus scale level 2 steps'},
          ],
        },
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.temperature(2, {digit}).or(Size.SMALL).oxygen(2, {digit}).br.or(Size.SMALL).venus(2, {digit}).br;
          b.cards(2, {secondaryTag: AltSecondaryTag.FLOATER});
        }),
        description: 'Effect: Raise either the temperature or oxygen or Venus 2 steps. ' +
        'Reveal cards from the deck until you have revealed 2 cards with a floater icon on it. ' +
        'Take those 2 cards into hand and discard the rest.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions) {
    function adjusted(trSource: TRSource) {
      return {...canAffordOptions, tr: trSource};
    }
    return (
      player.canAfford(adjusted({oxygen: 2})) ||
      player.canAfford(adjusted({temperature: 2})) ||
      player.canAfford(adjusted({venus: 2}))
    );
  }

  public override bespokePlay(player: IPlayer) {
    player.drawCard(2, {
      include: (card) => floaterCards.has(card.name) || card.resourceType === CardResource.FLOATER,
    });
    return undefined;
  }
}

================
File: cards/prelude2/CeresTechMarket.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';
import {digit} from '../Options';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IActionCard} from '../ICard';
import {PlayerInput} from '../../PlayerInput';
import {SelectCard} from '../../inputs/SelectCard';

export class CeresTechMarket extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.CERES_TECH_MARKET,
      type: CardType.ACTIVE,
      tags: [Tag.SCIENCE, Tag.SPACE],
      cost: 12,
      victoryPoints: 1,

      behavior: {
        stock: {
          megacredits: {
            colonies: {colonies: {}},
            each: 2,
          },
        },
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.action('Discard any number of cards from your hand to gain 2 M€ for each discarded card.', (ab) =>
            ab.text('-X').cards(1).startAction.text('2x').megacredits(1, {digit})).br;
          b.megacredits(2).slash().colonies().br;
          b.plainText('(Gain 2 M€ per colony you own.)').br;
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.cardsInHand.length > 0;
  }

  // Pretty much a duplicate of SellPatents. Also similar to Ender.
  // Should make card discarding a behavior.
  public action(player: IPlayer): PlayerInput | undefined {
    return new SelectCard(
      'Discard cards for 2 M€ each',
      'Discard',
      player.cardsInHand,
      {max: player.cardsInHand.length, played: false})
      .andThen((cards) => {
        cards.forEach((card) => player.discardCardFromHand(card));
        const megacredits = cards.length * 2;
        player.megaCredits += megacredits;
        player.game.log('${0} gained ${1} M€ by discarding ${2} cards', (b) => b.player(player).number(megacredits).number(cards.length));
        return undefined;
      });
  }
}

================
File: cards/prelude2/CloudTourism.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {ActionCard} from '../ActionCard';
import {CardResource} from '../../../common/CardResource';
import {Resource} from '../../../common/Resource';

export class CloudTourism extends ActionCard {
  constructor() {
    super({
      name: CardName.CLOUD_TOURISM,
      type: CardType.ACTIVE,
      tags: [Tag.JOVIAN, Tag.VENUS],
      cost: 11,
      victoryPoints: {resourcesHere: 1, per: 3},
      resourceType: CardResource.FLOATER,

      action: {
        addResources: 1,
      },

      metadata: {
        cardNumber: '',
        description: 'Increase your M€ production 1 step for each pair of Earth and Venus tags you own. 1 VP for every 3rd floater on this card.',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER);
          }).br;
          b.production((pb) => {
            pb.megacredits(1).slash().tag(Tag.EARTH).tag(Tag.VENUS);
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    // This does its own calculation because player.tags isn't robust enough at the moment
    const counts = {
      earth: player.tags.count(Tag.EARTH, 'raw'),
      // The +1 is "including this"
      venus: player.tags.count(Tag.VENUS, 'raw') + 1,
    };
    if (player.cardIsInEffect(CardName.EARTH_EMBASSY)) {
      counts.earth += player.tags.count(Tag.MOON, 'raw');
    }
    let wildTags = player.tags.count(Tag.WILD, 'raw');
    while (wildTags > 0) {
      if (counts.earth < counts.venus) {
        counts.earth++;
      } else {
        counts.venus++;
      }
      wildTags--;
    }
    const production = Math.min(counts.earth, counts.venus);
    player.production.add(Resource.MEGACREDITS, production, {log: true});
    return undefined;
  }
}

================
File: cards/prelude2/ColonyTradeHub.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {PreludeCard} from '../prelude/PreludeCard';
import {all} from '../Options';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';

export class ColonyTradeHub extends PreludeCard {
  constructor() {
    super({
      name: CardName.COLONY_TRADE_HUB,
      tags: [Tag.SPACE],

      behavior: {
        production: {energy: 1},
        stock: {titanium: 3},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(1)).titanium(3).br;
          b.effect('When a colony is placed, gain 2 M€', (eb) => eb.colonies(1, {all}).startEffect.megacredits(2));
        }),
        description: 'Increase your energy production 1 step. Gain 3 titanium',
      },
    });
  }

  onColonyAdded(_player: IPlayer, cardOwner: IPlayer) {
    cardOwner.stock.add(Resource.MEGACREDITS, 2, {log: true});
  }
}

================
File: cards/prelude2/CorridorsOfPower.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {PreludeCard} from '../prelude/PreludeCard';

export class CorridorsOfPower extends PreludeCard {
  constructor() {
    super({
      name: CardName.CORRIDORS_OF_POWER,
      tags: [Tag.EARTH],

      behavior: {
        tr: 1,
        stock: {megacredits: 4},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.effect('Whenever one of your delegates becomes a Party Leader, draw a card', (ab) => {
            ab.partyLeaders(1).startEffect.cards(1);
          }).br;
          b.tr(1).megacredits(4).br;
          b.plainText('Increase your TR one step. Gain 4 M€');
        }),
      },
    });

    // Behavior in Party.ts
  }
}

================
File: cards/prelude2/Ecotec.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';
import {CardResource} from '../../../common/CardResource';
import {Resource} from '../../../common/Resource';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectCard} from '../../inputs/SelectCard';

export class Ecotec extends CorporationCard {
  constructor() {
    super({
      name: CardName.ECOTEC,
      tags: [Tag.MICROBE, Tag.PLANT],
      startingMegaCredits: 42,

      behavior: {
        production: {plants: 1},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(42).production((pb) => pb.plants(1)).br;
          b.effect('When you play a microbe, plant, or animal tag, gain 1 plant or add a microbe to ANY card.',
            (eb) => eb.tag(Tag.MICROBE).tag(Tag.PLANT).tag(Tag.ANIMAL).startEffect.plants(1).slash().resource(CardResource.MICROBE).asterix());
        }),
        description: 'You start with 42 M€. Increase your plant production 1 step.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    this.onCardPlayed(player, this);
    return undefined;
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (!player.isCorporation(this.name)) {
      return undefined;
    }
    const resourceCount = player.tags.cardTagCount(card, [Tag.ANIMAL, Tag.PLANT, Tag.MICROBE]);
    if (resourceCount === 0) {
      return undefined;
    }

    const microbeCards = player.getResourceCards(CardResource.MICROBE);
    if (microbeCards.length === 0) {
      player.stock.add(Resource.PLANTS, resourceCount, {log: true});
      return undefined;
    }

    for (let i = 0; i < resourceCount; i++) {
      player.defer(
        () => new OrOptions(
          new SelectCard(
            'Select card to gain a microbe',
            'Add microbe',
            microbeCards)
            .andThen(([card]) => {
              player.addResourceTo(card, {qty: 1, log: true});
              return undefined;
            }),

          new SelectOption('Gain plant').andThen(() => {
            player.stock.add(Resource.PLANTS, 1, {log: true});
            return undefined;
          }),
        ),
      );
    }
    return undefined;
  }
}

================
File: cards/prelude2/FocusedOrganization.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {PreludeCard} from '../prelude/PreludeCard';
import {IPlayer} from '../../IPlayer';
import {IActionCard} from '../ICard';
import {Units} from '../../../common/Units';
import {sum} from '../../../common/utils/utils';
import {AndOptions} from '../../inputs/AndOptions';
import {SelectCard} from '../../inputs/SelectCard';
import {SelectResource} from '../../inputs/SelectResource';
import {PathfindersExpansion} from '../../pathfinders/PathfindersExpansion';

export class FocusedOrganization extends PreludeCard implements IActionCard {
  constructor() {
    super({
      name: CardName.FOCUSED_ORGANIZATION,
      tags: [Tag.SPACE],

      behavior: {
        drawCard: 1,
        standardResource: 1,
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.action('Discard 1 card and spend 1 standard resource to draw 1 card and gain 1 standard resource', (ab) => {
            ab.cards(1).wild(1).startAction.cards(1).wild(1);
          }).br;
          b.cards(1).wild(1).br;
          b.plainText('Draw 1 card and gain 1 standard resource.');
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.cardsInHand.length > 0 && sum(Units.values(player.stock)) > 0;
  }

  public action(player: IPlayer) {
    const discardableStandardResources = Units.keys.filter((type) => player.stock[type] > 0);
    return new AndOptions(
      new SelectResource('Select resource to discard', discardableStandardResources)
        .andThen((type) => {
          player.stock.deduct(Units.ResourceMap[type], 1, {log: true});
          if (type === 'megacredits' || type === 'steel' || type === 'titanium') {
            PathfindersExpansion.addToSolBank(player);
          }
          return undefined;
        }),
      new SelectCard('Select card to discard', 'select', player.cardsInHand)
        .andThen(([card]) => {
          player.discardCardFromHand(card);
          return undefined;
        })).andThen(() => {
      player.drawCard();
      return new SelectResource('Select resource to gain')
        .andThen((type) => {
          player.stock.add(Units.ResourceMap[type], 1, {log: true});
          return undefined;
        });
    });
  }
}

================
File: cards/prelude2/GhgShipment.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardType} from '../../../common/cards/CardType';
import {Card} from '../Card';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardResource} from '../../../common/CardResource';

export class GhgShipment extends Card {
  constructor() {
    super({
      name: CardName.GHG_SHIPMENT,
      type: CardType.EVENT,
      tags: [Tag.SPACE],
      cost: 3,

      behavior: {
        production: {heat: 1},
        stock: {heat: {floaters: {}}},
      },

      requirements: {party: PartyName.KELVINISTS},

      metadata: {
        cardNumber: '',
        description: 'Requires that Kelvinists are in power or that you have 2 delegates there. ' +
         'Increase your heat production 1 step. Gain 1 heat for each floater you have.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(1)).br;
          b.heat(1).slash().resource(CardResource.FLOATER);
        }),
      },
    });
  }
}

================
File: cards/prelude2/IshtarExpedition.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';

export class IshtarExpedition extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.ISHTAR_EXPEDITION,
      cost: 6,
      tags: [Tag.VENUS],
      type: CardType.EVENT,

      requirements: {venus: 10},

      behavior: {
        stock: {
          titanium: 3,
        },
        drawCard: {count: 2, tag: Tag.VENUS},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.titanium(3).cards(2, {secondaryTag: Tag.VENUS});
        }),
        description: 'Requires Venus 10%. Gain 3 titanium and draw 2 Venus cards.',
      },
    });
  }
}

================
File: cards/prelude2/L1TradeTerminal.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {SelectCard} from '../../inputs/SelectCard';
import {ICard} from '../ICard';

export class L1TradeTerminal extends Card {
  constructor() {
    super({
      name: CardName.L1_TRADE_TERMINAL,
      type: CardType.ACTIVE,
      tags: [Tag.SPACE],
      cost: 25,
      victoryPoints: 2,

      behavior: {
        colonies: {
          tradeOffset: 2, // TODO(kberg): mandatory
        },
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you trade, first increase that colony tile track 2 steps.', (eb) =>
            eb.trade().startEffect.text('+2')).br;
          b.text('3').diverseTag().asterix().br;
          b.plainText('(Add a resource to 3 different cards.)').br;
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    function addResources(cards: ReadonlyArray<ICard>): void {
      for (const card of cards) {
        player.addResourceTo(card, {qty: 1, log: true});
      }
    }

    const cards = player.getResourceCards();
    if (cards.length <= 3) {
      addResources(cards);
      return undefined;
    }

    return new SelectCard('Select 3 cards to gain 1 resource each', 'Add Resources', cards, {min: 3, max: 3})
      .andThen((cards) => {
        addResources(cards);
        return undefined;
      });
  }
}

================
File: cards/prelude2/NirgalEnterprises.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class NirgalEnterprises extends CorporationCard {
  constructor() {
    super({
      name: CardName.NIRGAL_ENTERPRISES,
      tags: [Tag.POWER, Tag.PLANT, Tag.BUILDING],
      startingMegaCredits: 33,

      behavior: {
        production: {energy: 1, plants: 1, steel: 1},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br.br;
          b.megacredits(33).production((pb) => pb.energy(1).plants(1).steel(1)).br;
          b.effect('AWARDS and MILESTONES ALWAYS COST 0 M€ FOR YOU.', (eb) => {
            // TODO(kberg): replace with award().slash.milestone() when award and milestone can be stacked.
            eb.plate('Awards and Milestones').startEffect.megacredits(1, {text: '0'});
          });
        }),
        description: 'You start with 33 M€. Raise your energy, plant, and steel production 1 step each.',
      },
    });
  }
}

================
File: cards/prelude2/NobelPrize.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {PreludeCard} from '../prelude/PreludeCard';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {IPlayer} from '../../IPlayer';

export class NobelPrize extends PreludeCard {
  constructor() {
    super({
      name: CardName.NOBEL_PRIZE,
      tags: [Tag.WILD],
      victoryPoints: 2,

      behavior: {
        stock: {megacredits: 2},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(2).cards(2, {secondaryTag: AltSecondaryTag.REQ});
        }),
        description: 'Gain 2 M€. Draw 2 cards with requirements.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.drawCard(2, {include: ((card) =>card.requirements.length > 0)});
    return undefined;
  }
}

================
File: cards/prelude2/OldMiningColony.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {PreludeCard} from '../prelude/PreludeCard';
import {IPlayer} from '../../IPlayer';
import {DiscardCards} from '../../deferredActions/DiscardCards';
import {Priority} from '../../deferredActions/Priority';

export class OldMiningColony extends PreludeCard {
  constructor() {
    super({
      name: CardName.OLD_MINING_COLONY,
      tags: [Tag.SPACE],

      behavior: {
        production: {titanium: 1},
        colonies: {buildColony: {}},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(1)).colonies(1).minus().cards(1);
        }),
        description: 'Increase your titanium production 1 step. Place 1 colony. Discard 1 card.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    return player.cardsInHand.length > 0;
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new DiscardCards(player, 1), Priority.DISCARD_CARDS);
    return undefined;
  }
}

================
File: cards/prelude2/PalladinShipping.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {digit} from '../Options';
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';
import {Resource} from '../../../common/Resource';
import {IActionCard} from '../ICard';
import {Behavior} from '../../behavior/Behavior';
import {getBehaviorExecutor} from '../../behavior/BehaviorExecutor';

export class PalladinShipping extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.PALLADIN_SHIPPING,
      tags: [Tag.SPACE],
      startingMegaCredits: 36,

      behavior: {
        stock: {titanium: 5},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(36).titanium(5, {digit}).br;
          b.effect('When you play a space event, gain 1 titanium.', (eb) => {
            eb.tag(Tag.SPACE).tag(Tag.EVENT).startEffect.titanium(1);
          });
          b.br;
          b.action('Spend 2 titanium to raise the temperature 1 step.', (ab) => {
            ab.titanium(2).startAction.temperature(1);
          });
        }),
        description: 'You start with 36 M€ and 5 titanium.',
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (player.isCorporation(this.name)) {
      if (card.type === CardType.EVENT && card.tags.includes(Tag.SPACE)) {
        player.stock.add(Resource.TITANIUM, 1, {log: true});
      }
    }
  }

  public canAct(player: IPlayer) {
    return getBehaviorExecutor().canExecute(PalladinShipping.actionBehavior, player, this);
  }

  private static actionBehavior: Behavior = {
    spend: {titanium: 2},
    global: {temperature: 1},
  };

  public action(player: IPlayer) {
    getBehaviorExecutor().execute(PalladinShipping.actionBehavior, player, this);
    return undefined;
  }
}

================
File: cards/prelude2/Prelude2CardManifest.ts
================
import {CardName} from '../../../common/cards/CardName';
import {ModuleManifest} from '../ModuleManifest';
import {AppliedScience} from './AppliedScience';
import {AtmosphericEnhancers} from './AtmosphericEnhancers';
import {CeresTechMarket} from './CeresTechMarket';
import {CloudTourism} from './CloudTourism';
import {ColonyTradeHub} from './ColonyTradeHub';
import {CorridorsOfPower} from './CorridorsOfPower';
import {Ecotec} from './Ecotec';
import {FocusedOrganization} from './FocusedOrganization';
import {GhgShipment} from './GhgShipment';
import {IshtarExpedition} from './IshtarExpedition';
import {L1TradeTerminal} from './L1TradeTerminal';
import {NirgalEnterprises} from './NirgalEnterprises';
import {NobelPrize} from './NobelPrize';
import {OldMiningColony} from './OldMiningColony';
import {PalladinShipping} from './PalladinShipping';
import {RedAppeasement} from './RedAppeasement';
import {SagittaFrontierServices} from './SagittaFrontierServices';
import {SpaceCorridors} from './SpaceCorridors';
import {Spire} from './Spire';
import {SponsoringNation} from './SponsoringNation';
import {SummitLogistics} from './SummitLogistics';

export const PRELUDE2_CARD_MANIFEST = new ModuleManifest({
  module: 'prelude2',
  projectCards: {
    [CardName.ISHTAR_EXPEDITION]: {Factory: IshtarExpedition, compatibility: 'venus'},
    [CardName.SUMMIT_LOGISTICS]: {Factory: SummitLogistics, compatibility: 'turmoil'},
    [CardName.CERES_TECH_MARKET]: {Factory: CeresTechMarket, compatibility: 'colonies'},
    [CardName.RED_APPEASEMENT]: {Factory: RedAppeasement, compatibility: 'turmoil'},
    [CardName.L1_TRADE_TERMINAL]: {Factory: L1TradeTerminal, compatibility: 'colonies'},
    [CardName.CLOUD_TOURISM]: {Factory: CloudTourism, compatibility: 'venus'},
    // [CardName.FLOATING_REFINERY]: {Factory: FloatingRefinery, compatibility: 'colonies'},
    // [CardName.VENUS_TRADE_HUB]: {Factory: VenusTradeHub, compatibility: 'colonies'},
    [CardName.GHG_SHIPMENT]: {Factory: GhgShipment, compatibility: 'turmoil'},
    [CardName.SPONSORING_NATION]: {Factory: SponsoringNation, compatibility: 'turmoil'},
  },

  preludeCards: {
    [CardName.APPLIED_SCIENCE]: {Factory: AppliedScience},
    [CardName.NOBEL_PRIZE]: {Factory: NobelPrize},
    [CardName.COLONY_TRADE_HUB]: {Factory: ColonyTradeHub, compatibility: 'colonies'},
    [CardName.OLD_MINING_COLONY]: {Factory: OldMiningColony, compatibility: 'colonies'},
    [CardName.FOCUSED_ORGANIZATION]: {Factory: FocusedOrganization},
    [CardName.SPACE_CORRIDORS]: {Factory: SpaceCorridors},
    // [CardName.BOARD_OF_DIRECTORS]: {Factory: BoardOfDirectors},
    [CardName.CORRIDORS_OF_POWER]: {Factory: CorridorsOfPower, compatibility: 'turmoil'},
    [CardName.ATMOSPHERIC_ENHANCERS]: {Factory: AtmosphericEnhancers, compatibility: 'venus'},
  },

  corporationCards: {
    [CardName.NIRGAL_ENTERPRISES]: {Factory: NirgalEnterprises},
    [CardName.PALLADIN_SHIPPING]: {Factory: PalladinShipping},
    [CardName.SAGITTA_FRONTIER_SERVICES]: {Factory: SagittaFrontierServices},
    [CardName.ECOTEC]: {Factory: Ecotec},
    [CardName.SPIRE]: {Factory: Spire},
  },
});

================
File: cards/prelude2/RedAppeasement.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {PartyName} from '../../../common/turmoil/PartyName';

export class RedAppeasement extends Card {
  constructor() {
    super({
      name: CardName.RED_APPEASEMENT,
      type: CardType.EVENT,
      cost: 1,
      requirements: {party: PartyName.REDS},

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.plainText('Requires that Reds are ruling or that you have 2 delegates there, ' +
          'AND THAT NO OTHER PLAYER HAS PASSED.').br;
          b.production((pb) => pb.megacredits(2)).text('PASS').asterix().br;
          b.plainText('Increase M€ production 2 steps. This counts as passing. You get no other turns this generation.');
        }),
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.game.getPassedPlayers().length === 0;
  }

  public override bespokePlay(player: IPlayer) {
    player.pass();
    return undefined;
  }
}

================
File: cards/prelude2/SagittaFrontierServices.ts
================
import {ICorporationCard} from '../corporation/ICorporationCard';
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {ICard} from '../ICard';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {GainResources} from '../../deferredActions/GainResources';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';

export class SagittaFrontierServices extends CorporationCard {
  constructor() {
    super({
      name: CardName.SAGITTA_FRONTIER_SERVICES,
      startingMegaCredits: 28,

      behavior: {
        production: {energy: 1, megacredits: 2},
      },

      metadata: {
        cardNumber: '',
        hasExternalHelp: true,
        renderData: CardRenderer.builder((b) => {
          // TODO(kberg): provide reasonable secondary tag. It's not rendered on CardRenderItemComponent.
          b.megacredits(28).production((pb) => pb.energy(1).megacredits(2)).cards(1, {secondaryTag: AltSecondaryTag.NO_TAGS}).br;
          b.effect('When you play a card with no tags, including this, gain 4 M€.', (eb) => eb.noTags().startEffect.megacredits(4)).br;
          b.effect('When you play a card with EXACTLY 1 TAG, gain 1 M€.', (eb) => eb.emptyTag().asterix().startEffect.megacredits(1)).br;
        }),
        description: 'You start with 28 M€. Increase energy production 1 step and M€ production 2 steps. Draw a card with no tags.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    // Gain the 4 MC for playing itself.
    player.stock.megacredits += 4;
    player.game.log('${0} gained 4 M€ for playing a card with no tags.', (b) => b.player(player));

    player.drawCard(1, {include: (c) => c.tags.length === 0 && c.type !== CardType.EVENT});
    return undefined;
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard, cardOwner: IPlayer) {
    if (player === cardOwner) {
      this.onCardPlayed(cardOwner, card);
    }
  }

  public onCardPlayed(player: IPlayer, card: ICard) {
    if (player.isCorporation(this.name)) {
      const count = card.tags.filter((tag) => tag !== Tag.WILD).length + (card.type === CardType.EVENT ? 1 : 0);
      if (count === 0) {
        player.game.defer(new GainResources(player, Resource.MEGACREDITS, {count: 4}))
          .andThen(() => {
            player.game.log('${0} gained 4 M€ for playing ${1}, which has no tags.', (b) => b.player(player).card(card));
          });
      }
      if (count === 1) {
        player.game.defer(new GainResources(player, Resource.MEGACREDITS, {count: 1}))
          .andThen(() => {
            player.game.log('${0} gained 1 M€ for playing ${1}, which has exactly 1 tag.', (b) => b.player(player).card(card));
          });
      }
    }
  }
}

================
File: cards/prelude2/SpaceCorridors.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {PreludeCard} from '../prelude/PreludeCard';

export class SpaceCorridors extends PreludeCard {
  constructor() {
    super({
      name: CardName.SPACE_CORRIDORS,
      tags: [Tag.SPACE],

      cardDiscount: [
        {tag: Tag.JOVIAN, amount: 2},
        {tag: Tag.EARTH, amount: 2},
        {tag: Tag.VENUS, amount: 2},
      ],

      behavior: {
        stock: {titanium: 3},
      },

      metadata: {
        cardNumber: '',
        description: 'Gain 3 titanium',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a Jovian, Earth, or Venus tag, you pay 2 M€ less for it.', (eb) => {
            eb.tag(Tag.JOVIAN).tag(Tag.EARTH).tag(Tag.VENUS).startEffect.megacredits(-2);
          });
          b.br;
          b.titanium(3);
        }),
      },
    });
  }
}

================
File: cards/prelude2/Spire.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {ICard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {digit} from '../Options';
import {SelectCard} from '../../inputs/SelectCard';
import {CardResource} from '../../../common/CardResource';
import {ICorporationCard} from '../corporation/ICorporationCard';

export class Spire extends CorporationCard implements ICorporationCard {
  constructor() {
    super({
      name: CardName.SPIRE,
      tags: [Tag.CITY, Tag.EARTH],
      startingMegaCredits: 44,
      initialActionText: 'Draw 4 cards, then discard 3 cards.',
      resourceType: CardResource.SCIENCE,

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(44).plus().cards(4, {digit}).minus().cards(3, {digit}).br,
          b.plainText('You start with 44 M€. As your first action, draw 4 cards, ' +
              'then discard 3 cards from your hand.').br;

          b.effect('When you play a card with at least 2 tags. including this, add a science resource here.',
            (eb) => eb.emptyTag(2).asterix().startEffect.resource(CardResource.SCIENCE)).br;
          b.effect('When you use a standard project, science resources here may be spent as 2 M€ each.',
            (eb) => eb.plate('Standard Project').startEffect.resource(CardResource.SCIENCE).equals().megacredits(2)).br;
        }),
      },
    });
  }

  public initialAction(player: IPlayer) {
    player.drawCard(4);
    return new SelectCard('Select 3 cards to discard', 'Discard', player.cardsInHand, {min: 3, max: 3})
      .andThen((cards) => {
        for (const card of cards) {
          player.discardCardFromHand(card);
        }
        return undefined;
      });
  }

  public override bespokePlay(player: IPlayer) {
    // Including this.
    this.onCardPlayed(player, this);
    return undefined;
  }

  public onCardPlayed(player: IPlayer, card: ICard) {
    if (player.isCorporation(this.name)) {
      const count = card.tags.length + (card.type === CardType.EVENT ? 1 : 0);
      if (count >= 2) {
        player.addResourceTo(this, {qty: 1, log: true});
      }
    }
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    this.onCardPlayed(player, card);
  }
}

================
File: cards/prelude2/SponsoringNation.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardType} from '../../../common/cards/CardType';
import {Card} from '../Card';

export class SponsoringNation extends Card {
  constructor() {
    super({
      name: CardName.SPONSORING_NATION,
      type: CardType.AUTOMATED,
      tags: [Tag.EARTH],
      cost: 21,

      behavior: {
        tr: 3,
        turmoil: {sendDelegates: {count: 2}},
      },

      requirements: {tag: Tag.EARTH, count: 4},

      metadata: {
        cardNumber: '',
        description: 'Requires 4 Earth tags. Gain 3 TR. Place 2 delegates.',
        renderData: CardRenderer.builder((b) => {
          b.tr(3).br.delegates(2);
        }),
      },
    });
  }
}

================
File: cards/prelude2/SummitLogistics.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardType} from '../../../common/cards/CardType';

export class SummitLogistics extends Card {
  constructor() {
    super({
      name: CardName.SUMMIT_LOGISTICS,
      type: CardType.AUTOMATED,
      tags: [Tag.BUILDING, Tag.SPACE],
      cost: 10,

      requirements: {party: PartyName.SCIENTISTS},

      behavior: {
        stock: {
          megacredits: {
            tag: [Tag.JOVIAN, Tag.EARTH, Tag.VENUS, Tag.MARS],
            colonies: {colonies: {}},
          },
        },
        drawCard: 2,
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(1).slash().tag(Tag.JOVIAN).tag(Tag.EARTH).tag(Tag.VENUS).colonies(1);
          b.br;
          b.cards(2).br;
          b.plainText('(Requires that Scientists are ruling or that you have 2 delegates there. ' +
            'Gain 1 M€ per planet tag and colony you have. Draw 2 cards.)');
          b.br;
          b.plainText('(FAN EXPANSION NOTE: This includes Mars but not The Moon.)');
        }),
      },
    });
  }
}

================
File: cards/promo/16Psyche.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';

export class Psyche extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PSYCHE,
      tags: [Tag.SPACE],
      cost: 31,
      victoryPoints: 2,
      behavior: {
        production: {titanium: 2},
        stock: {titanium: 3},
      },

      metadata: {
        cardNumber: 'X44',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.titanium(2)).br.titanium(3);
        }),
        description: 'Increase titanium production 2 steps. Gain 3 titanium.',
      },
    });
  }
}

================
File: cards/promo/Advertising.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';

export class Advertising extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ADVERTISING,
      tags: [Tag.EARTH],
      cost: 4,

      metadata: {
        cardNumber: 'X13',
        renderData: CardRenderer.builder((b) => b.effect('When you play a card with a basic cost of 20 M€ or more, increase your M€ production 1 step.', (be) => {
          be.megacredits(20).asterix().startEffect.production((pb) => pb.megacredits(1));
        })),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.cost >= 20) {
      player.production.add(Resource.MEGACREDITS, 1, {log: true});
    }
  }
}

================
File: cards/promo/AntidesertificationTechniques.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class AntidesertificationTechniques extends PreludeCard {
  constructor() {
    super({
      name: CardName.ANTI_DESERTIFICATION_TECHNIQUES,
      tags: [Tag.MICROBE, Tag.PLANT],

      behavior: {
        production: {plants: 1, steel: 1},
        stock: {megacredits: 3},
      },

      metadata: {
        cardNumber: 'P08',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(3).br;
          b.production((pb) => pb.plants(1).steel(1));
        }),
        description: 'Gain 3 M€. Increase your plant production 1 step and your steel production 1 step.',
      },
    });
  }
}

================
File: cards/promo/AqueductSystems.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Board} from '../../boards/Board';
import {nextTo} from '../Options';

export class AqueductSystems extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.AQUEDUCT_SYSTEMS,
      tags: [Tag.BUILDING],
      cost: 9,

      victoryPoints: 1,

      behavior: {
        drawCard: {count: 3, tag: Tag.BUILDING},
      },

      requirements: [{cities: 1, nextTo}, {oceans: 1}],

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.cards(3, {secondaryTag: Tag.BUILDING});
        }),
        description: 'Requires you have a city next to an ocean. Draw 3 cards with a building tag.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    const board = player.game.board;
    const oceans = board.getOceanSpaces({upgradedOceans: true, wetlands: true});
    return oceans.some((ocean) => {
      return board.getAdjacentSpaces(ocean).some((space) => {
        return Board.isCitySpace(space) && space.player === player;
      });
    });
  }
}

================
File: cards/promo/ArcadianCommunities.ts
================
import {IPlayer} from '../../IPlayer';
import {CorporationCard} from '../corporation/CorporationCard';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Space} from '../../boards/Space';
import {IActionCard} from '../ICard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {digit} from '../Options';

export class ArcadianCommunities extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.ARCADIAN_COMMUNITIES,
      startingMegaCredits: 40,
      initialActionText: 'Place a community (player marker) on a non-reserved area',

      behavior: {
        stock: {steel: 10},
      },

      metadata: {
        cardNumber: 'R44',
        description: 'You start with 40 M€ and 10 steel. AS YOUR FIRST ACTION, PLACE A COMMUNITY [PLAYER MARKER] ON A NON-RESERVED AREA.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(40).nbsp.steel(10, {digit}).nbsp.community().asterix();
          b.corpBox('action', (ce) => {
            ce.text('ACTION: PLACE A COMMUNITY (PLAYER MARKER) ON A NON-RESERVED AREA ADJACENT TO ONE OF YOUR TILES OR MARKED AREAS.', Size.TINY, true);
            ce.vSpace(Size.MEDIUM);
            ce.text('EFFECT: MARKED AREAS ARE RESERVED FOR YOU. WHEN YOU PLACE A TILE THERE, GAIN 3 M€.', Size.TINY, true);
          });
        }),
      },
    });
  }

  public initialAction(player: IPlayer) {
    return new SelectSpace(
      'Select space for claim',
      player.game.board.getAvailableSpacesOnLand(player))
      .andThen((space: Space) => {
        space.player = player;
        player.game.log('${0} placed a Community (player marker)', (b) => b.player(player));
        return undefined;
      });
  }

  public getAvailableSpacesForMarker(player: IPlayer): Array<Space> {
    const board = player.game.board;
    const candidateSpaces = board.getAvailableSpacesOnLand(player);
    const spaces = candidateSpaces.filter((space) => {
      // Exclude spaces that already have a player marker.
      if (space.player !== undefined) return false;
      const adjacentSpaces = board.getAdjacentSpaces(space);
      return adjacentSpaces.find((adj) => adj.player === player) !== undefined;
    });
      // Remove duplicates
    return spaces.filter((space, index) => spaces.indexOf(space) === index);
  }

  public canAct(player: IPlayer): boolean {
    return this.getAvailableSpacesForMarker(player).length > 0;
  }

  public action(player: IPlayer) {
    return new SelectSpace('Select space for claim', this.getAvailableSpacesForMarker(player))
      .andThen((space) => {
        space.player = player;
        return undefined;
      });
  }
}

================
File: cards/promo/AsteroidDeflectionSystem.ts
================
import {IProjectCard} from '../IProjectCard';
import {IActionCard} from '../ICard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class AsteroidDeflectionSystem extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ASTEROID_DEFLECTION_SYSTEM,
      tags: [Tag.SPACE, Tag.EARTH, Tag.BUILDING],
      cost: 13,

      resourceType: CardResource.ASTEROID,
      victoryPoints: {resourcesHere: {}},

      behavior: {
        production: {energy: -1},
      },

      metadata: {
        cardNumber: 'X14',
        renderData: CardRenderer.builder((b) => {
          b.action('REVEAL AND DISCARD the top card of the deck. If it has a space tag, add an asteroid here.', (eb) => {
            eb.empty().startAction.cards(1).asterix().nbsp.tag(Tag.SPACE).colon().resource(CardResource.ASTEROID);
          }).br;
          b.production((pb) => pb.minus().energy(1)).text('opponents may not remove your plants', Size.SMALL, true);
        }),
        description: {
          text: 'Decrease your energy production 1 step. 1VP per asteroid on this card.',
          align: 'left',
        },
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    if (!player.game.projectDeck.canDraw(1)) {
      this.warnings.add('deckTooSmall');
    }
    return true;
  }

  public action(player: IPlayer) {
    const card = player.game.projectDeck.draw(player.game);
    if (card === undefined) {
      return;
    }
    player.game.log('${0} revealed and discarded ${1}', (b) => b.player(player).card(card, {tags: true}));
    if (card.tags.includes(Tag.SPACE)) {
      player.addResourceTo(this, {qty: 1, log: true});
    }
    player.game.projectDeck.discard(card);
    return undefined;
  }
}

================
File: cards/promo/AsteroidHollowing.ts
================
import {IProjectCard} from '../IProjectCard';
import {ActionCard} from '../ActionCard';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';

export class AsteroidHollowing extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ASTEROID_HOLLOWING,
      tags: [Tag.SPACE],
      cost: 16,
      resourceType: CardResource.ASTEROID,

      action: {
        spend: {titanium: 1},
        production: {megacredits: 1},
        addResources: 1,
      },

      victoryPoints: {resourcesHere: {}, per: 2},

      metadata: {
        cardNumber: 'X15',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add 1 asteroid resource here and increase M€ production 1 step.', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.ASTEROID).production((pb) => pb.megacredits(1));
          }).br;
          b.vpText('1VP for each 2 asteroids on this card.');
        }),
      },
    });
  }
}

================
File: cards/promo/AsteroidRights.ts
================
import {IProjectCard} from '../IProjectCard';
import {IActionCard} from '../ICard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {LogHelper} from '../../LogHelper';
import {SelectCard} from '../../inputs/SelectCard';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../render/CardRenderer';

export class AsteroidRights extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ASTEROID_RIGHTS,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 10,
      resourceType: CardResource.ASTEROID,

      behavior: {
        addResources: 2,
      },

      metadata: {
        cardNumber: 'X31',
        description: 'Add 2 asteroids to this card.',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 M€ to add 1 asteroid to ANY card.', (eb) => {
            eb.megacredits(1).startAction.resource(CardResource.ASTEROID).asterix().nbsp.or();
          }).br;
          b.action('Spend 1 asteroid here to increase M€ production 1 step OR gain 2 titanium.', (eb) => {
            eb.resource(CardResource.ASTEROID)
              .startAction.production((pb) => pb.megacredits(1))
              .or()
              .titanium(2);
          }).br;
          b.resource(CardResource.ASTEROID, 2);
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.canAfford(1) || this.resourceCount > 0;
  }

  public action(player: IPlayer) {
    const canAddAsteroid = player.canAfford(1);
    const hasAsteroids = this.resourceCount > 0;
    const asteroidCards = player.getResourceCards(CardResource.ASTEROID);

    const gainTitaniumOption = new SelectOption('Remove 1 asteroid on this card to gain 2 titanium', 'Remove asteroid').andThen(() => {
      this.resourceCount--;
      player.titanium += 2;
      LogHelper.logRemoveResource(player, this, 1, 'gain 2 titanium');
      return undefined;
    });

    const increaseMcProdOption = new SelectOption('Remove 1 asteroid on this card to increase M€ production 1 step', 'Remove asteroid').andThen(() => {
      this.resourceCount--;
      player.production.add(Resource.MEGACREDITS, 1);
      LogHelper.logRemoveResource(player, this, 1, 'increase M€ production 1 step');
      return undefined;
    });

    const addAsteroidToSelf = new SelectOption('Add 1 asteroid to this card', 'Add asteroid').andThen(() => {
      player.game.defer(new SelectPaymentDeferred(player, 1, {title: 'Select how to pay for asteroid'}));
      player.addResourceTo(this, {log: true});

      return undefined;
    });

    const addAsteroidOption = new SelectCard('Select card to add 1 asteroid', 'Add asteroid', asteroidCards)
      .andThen(([card]) => {
        player.game.defer(new SelectPaymentDeferred(player, 1, {title: 'Select how to pay for asteroid'}));
        player.addResourceTo(card, {log: true});

        return undefined;
      });

    // Spend asteroid
    if (!canAddAsteroid) return new OrOptions(gainTitaniumOption, increaseMcProdOption);

    // Add asteroid to any card
    if (!hasAsteroids) {
      if (asteroidCards.length === 1) return addAsteroidToSelf.cb(undefined);
      return addAsteroidOption;
    }

    const opts = [];
    opts.push(gainTitaniumOption);
    opts.push(increaseMcProdOption);
    asteroidCards.length === 1 ? opts.push(addAsteroidToSelf) : opts.push(addAsteroidOption);

    return new OrOptions(...opts);
  }
}

================
File: cards/promo/AstraMechanica.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {SelectCard} from '../../inputs/SelectCard';
import {isSpecialTile} from '../../boards/Board';

export class AstraMechanica extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ASTRA_MECHANICA,
      tags: [Tag.SCIENCE],
      cost: 7,

      metadata: {
        cardNumber: '',
        hasExternalHelp: true,
        renderData: CardRenderer.builder((b) => {
          b.cards(2, {secondaryTag: Tag.EVENT}).asterix();
        }),
        description: 'RETURN UP TO 2 OF YOUR PLAYED EVENT CARDS TO YOUR HAND. THEY MAY NOT BE CARDS THAT PLACE SPECIAL TILES.',
      },
    });
  }

  private getCards(player: IPlayer): ReadonlyArray<IProjectCard> {
    return player.playedCards.filter((card) => {
      if (card.type !== CardType.EVENT) {
        return false;
      }
      if (card.name === CardName.PATENT_MANIPULATION || card.name === CardName.RETURN_TO_ABANDONED_TECHNOLOGY) {
        return false;
      }
      if (card.name === CardName.HOSTILE_TAKEOVER) {
        return false;
      }
      if (card.tilesBuilt.some(isSpecialTile)) {
        return false;
      }
      return true;
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    return this.getCards(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    const events = this.getCards(player);
    if (events.length === 0) {
      player.game.log('${0} had no events', (b) => b.player(player));
      return undefined;
    }
    return new SelectCard(
      'Select up to 2 events to return to your hand',
      'Select',
      events,
      {max: 2, min: 0})
      .andThen(
        (cards) => {
          for (const card of cards) {
            player.playedCards = player.playedCards.filter((c) => c.name !== card.name);
            player.cardsInHand.push(card);
            card.onDiscard?.(player);
            player.game.log('${0} returned ${1} to their hand', (b) => b.player(player).card(card));
          }
          return undefined;
        });
  }
}

================
File: cards/promo/Astrodrill.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CorporationCard} from '../corporation/CorporationCard';
import {IActionCard} from '../ICard';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectCard} from '../../inputs/SelectCard';
import {OrOptions} from '../../inputs/OrOptions';
import {LogHelper} from '../../LogHelper';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {digit} from '../Options';

export class Astrodrill extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.ASTRODRILL,
      tags: [Tag.SPACE],
      startingMegaCredits: 35,
      resourceType: CardResource.ASTEROID,

      behavior: {
        addResources: 3,
      },

      metadata: {
        cardNumber: 'R21',
        description: 'You start with 35 M€ and 3 asteroid resources.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(35).nbsp.resource(CardResource.ASTEROID, {amount: 3, digit});
          b.corpBox('action', (ce) => {
            ce.vSpace(Size.LARGE);
            ce.action(undefined, (eb) => {
              eb.empty().startAction.resource(CardResource.ASTEROID).asterix().slash().wild(1).or();
            });
            ce.vSpace();
            ce.action('Add an asteroid resource to ANY card OR gain any standard resource, OR remove an asteroid resource from this card to gain 3 titanium.', (eb) => {
              eb.resource(CardResource.ASTEROID).startAction.titanium(3, {digit});
            });
          });
        }),
      },
    });
  }

  public canAct(): boolean {
    return true;
  }

  public action(player: IPlayer) {
    const asteroidCards = player.getResourceCards(CardResource.ASTEROID);
    const opts = [];

    const gainStandardResource = new SelectOption('Gain a standard resource', 'Gain').andThen(() => {
      return new OrOptions(
        new SelectOption('Gain 1 titanium', 'Gain titanium').andThen(() => {
          player.stock.add(Resource.TITANIUM, 1, {log: true});
          return undefined;
        }),
        new SelectOption('Gain 1 steel', 'Gain steel').andThen(() => {
          player.stock.add(Resource.STEEL, 1, {log: true});
          return undefined;
        }),
        new SelectOption('Gain 1 plant', 'Gain plant').andThen(() => {
          player.stock.add(Resource.PLANTS, 1, {log: true});
          return undefined;
        }),
        new SelectOption('Gain 1 energy', 'Gain energy').andThen(() => {
          player.stock.add(Resource.ENERGY, 1, {log: true});
          return undefined;
        }),
        new SelectOption('Gain 1 heat', 'Gain heat').andThen(() => {
          player.stock.add(Resource.HEAT, 1, {log: true});
          return undefined;
        }),
        new SelectOption('Gain 1 M€', 'Gain M€').andThen(() => {
          player.stock.add(Resource.MEGACREDITS, 1, {log: true});
          return undefined;
        }),
      );
    });

    const addResourceToSelf = new SelectOption('Add 1 asteroid to this card', 'Add asteroid').andThen(() => {
      player.addResourceTo(this, {log: true});

      return undefined;
    });

    const addResource = new SelectCard(
      'Select card to add 1 asteroid',
      'Add asteroid',
      asteroidCards)
      .andThen(([card]) => {
        player.addResourceTo(card, {log: true});
        return undefined;
      });

    const spendResource = new SelectOption('Remove 1 asteroid on this card to gain 3 titanium', 'Remove asteroid').andThen(() => {
      this.resourceCount--;
      player.titanium += 3;
      LogHelper.logRemoveResource(player, this, 1, 'gain 3 titanium');

      return undefined;
    });

    if (this.resourceCount > 0) opts.push(spendResource);
    asteroidCards.length === 1 ? opts.push(addResourceToSelf) : opts.push(addResource);
    opts.push(gainStandardResource);

    return new OrOptions(...opts);
  }
}

================
File: cards/promo/BactoviralResearch.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';

export class BactoviralResearch extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BACTOVIRAL_RESEARCH,
      tags: [Tag.MICROBE, Tag.SCIENCE],
      cost: 10,

      behavior: {
        drawCard: 1,
        addResourcesToAnyCard: {count: {tag: Tag.SCIENCE}, type: CardResource.MICROBE},
      },

      metadata: {
        cardNumber: 'X35',
        renderData: CardRenderer.builder((b) => {
          b.cards(1).br.br; // double br is intentional for visual appeal
          b.resource(CardResource.MICROBE).asterix().slash().tag(Tag.SCIENCE);
        }),
        description: 'Draw 1 card. Choose 1 of your played cards and add 1 microbe to it for each science tag you have, including this.',
      },
    });
  }
}

================
File: cards/promo/BioPrintingFacility.ts
================
import {IProjectCard} from '../IProjectCard';
import {IActionCard} from '../ICard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {SelectCard} from '../../inputs/SelectCard';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {message} from '../../logs/MessageBuilder';

export class BioPrintingFacility extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.BIO_PRINTING_FACILITY,
      tags: [Tag.BUILDING],
      cost: 7,

      metadata: {
        cardNumber: 'X36',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 energy to gain 2 plants OR to add 1 animal to ANOTHER card.', (eb) => {
            eb.energy(2, {digit}).startAction.plants(2);
            eb.or().resource(CardResource.ANIMAL).asterix();
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.energy >= 2;
  }

  public action(player: IPlayer) {
    const availableAnimalCards = player.getResourceCards(CardResource.ANIMAL);
    player.stock.deduct(Resource.ENERGY, 2);


    if (availableAnimalCards.length === 0) {
      player.stock.add(Resource.PLANTS, 2, {log: true});
      return undefined;
    }

    const gainPlantOption = new SelectOption('Gain 2 plants', 'Gain plants').andThen(() => {
      player.stock.add(Resource.PLANTS, 2, {log: true});
      return undefined;
    });

    if (availableAnimalCards.length === 1) {
      const targetCard = availableAnimalCards[0];

      return new OrOptions(
        new SelectOption(message('Add ${0} animal to ${1}', (b) => b.number(1).card(targetCard)), 'Add animal').andThen(() => {
          player.addResourceTo(targetCard, {log: true});
          return undefined;
        }),
        gainPlantOption,
      );
    }

    return new OrOptions(
      new SelectCard(
        'Select card to add 1 animal',
        'Add animal',
        availableAnimalCards)
        .andThen(([card]) => {
          player.addResourceTo(card, {log: true});
          return undefined;
        }),
      gainPlantOption,
    );
  }
}

================
File: cards/promo/CarbonNanosystems.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {Size} from '../../../common/cards/render/Size';

export class CarbonNanosystems extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CARBON_NANOSYSTEMS,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 14,
      victoryPoints: 1,
      resourceType: CardResource.GRAPHENE,

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a science tag, including this, add a graphene resource here.', (eb) => eb.tag(Tag.SCIENCE).startEffect.resource(CardResource.GRAPHENE)).br;
          b.effect('When playing a space or city tag, graphenes may be used as 4 M€ each.', (eb) => eb.tag(Tag.SPACE).or().tag(Tag.CITY, {size: Size.MEDIUM}).startEffect.resource(CardResource.GRAPHENE).equals().megacredits(4)).br;
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    const tags = card.tags.filter((tag) => tag === Tag.SCIENCE).length;
    player.addResourceTo(this, {qty: tags, log: true});
    return undefined;
  }
  public onColonyAddedToLeavitt(player: IPlayer): void {
    player.addResourceTo(this, {qty: 1, log: true});
  }
}

================
File: cards/promo/CityPark.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class CityPark extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CITY_PARK,
      tags: [Tag.PLANT],
      cost: 7,
      victoryPoints: 2,

      requirements: {cities: 3},

      behavior: {
        stock: {plants: 2},
      },

      metadata: {
        description: 'Requires that you have 3 cities. Gain 2 plants.',
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.plants(2);
        }),
      },
    });
  }
}

================
File: cards/promo/CometAiming.ts
================
import {IProjectCard} from '../IProjectCard';
import {IActionCard} from '../ICard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {SelectCard} from '../../inputs/SelectCard';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {LogHelper} from '../../LogHelper';
import {PlaceOceanTile} from '../../deferredActions/PlaceOceanTile';
import {CardRenderer} from '../render/CardRenderer';
import {Payment} from '../../../common/inputs/Payment';

export class CometAiming extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.COMET_AIMING,
      tags: [Tag.SPACE],
      cost: 17,
      resourceType: CardResource.ASTEROID,

      metadata: {
        cardNumber: 'X16',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add 1 asteroid resource to ANY CARD.', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.ASTEROID).asterix();
          }).br;
          b.or().br;
          b.action('Remove 1 asteroid here to place an ocean.', (eb) => {
            eb.resource(CardResource.ASTEROID).startAction.oceans(1);
          });
        }),
      },
    });
  }

  private canPlaceOcean(player: IPlayer) {
    return player.game.canAddOcean() && player.canAfford({cost: 0, tr: {oceans: 1}});
  }

  public canAct(player: IPlayer): boolean {
    if (player.titanium > 0) {
      return true;
    }
    return this.resourceCount > 0 && this.canPlaceOcean(player);
  }

  public action(player: IPlayer) {
    const asteroidCards = player.getResourceCards(CardResource.ASTEROID);

    const addAsteroidToSelf = function() {
      player.pay(Payment.of({titanium: 1}));
      player.addResourceTo(asteroidCards[0], {log: true});
      return undefined;
    };

    const addAsteroidToCard = new SelectCard(
      'Select card to add 1 asteroid',
      'Add asteroid',
      asteroidCards)
      .andThen(([card]) => {
        player.pay(Payment.of({titanium: 1}));
        player.addResourceTo(card, {log: true});
        return undefined;
      });

    const spendAsteroidResource = () => {
      this.resourceCount--;
      LogHelper.logRemoveResource(player, this, 1, 'place an ocean');
      player.game.defer(new PlaceOceanTile(player));
      return undefined;
    };

    if (this.resourceCount === 0) {
      if (asteroidCards.length === 1) return addAsteroidToSelf();
      return addAsteroidToCard;
    }

    if (player.titanium === 0) return spendAsteroidResource();

    const availableActions = [];

    if (this.canPlaceOcean(player)) {
      availableActions.push(new SelectOption('Remove an asteroid resource to place an ocean', 'Remove asteroid').andThen(spendAsteroidResource));
    }

    if (asteroidCards.length === 1) {
      availableActions.push(new SelectOption('Spend 1 titanium to gain 1 asteroid resource', 'Spend titanium').andThen(addAsteroidToSelf));
    } else {
      availableActions.push(addAsteroidToCard);
    }

    if (availableActions.length === 1) {
      const action = availableActions[0];

      if (action instanceof SelectOption) return action.cb(undefined);
      return availableActions[0]; // SelectCard
    }

    return new OrOptions(...availableActions);
  }
}

================
File: cards/promo/CorporateArchives.ts
================
import {Tag} from '../../../common/cards/Tag';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class CorporateArchives extends PreludeCard {
  constructor() {
    super({
      name: CardName.CORPORATE_ARCHIVES,
      tags: [Tag.SCIENCE],

      behavior: {
        drawCard: {count: 7, keep: 2},
        stock: {megacredits: 13},
      },

      metadata: {
        cardNumber: 'X58',
        description: 'Gain 13 M€',
        renderData: CardRenderer.builder((b) => {
          b.text('Look at the top 7 cards from the deck. Take 2 of them into hand and discard the other 5.', Size.SMALL, true);
          b.br;
          b.megacredits(13);
        }),
      },
    });
  }
}

================
File: cards/promo/CrashSiteCleanup.ts
================
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';

export class CrashSiteCleanup extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.CRASH_SITE_CLEANUP,
      cost: 4,
      requirements: {plantsRemoved: true},
      victoryPoints: 1,

      metadata: {
        description: 'Requires that a player removed ANOTHER PLAYER\'s plants this generation. Gain 1 titanium or 2 steel.',
        cardNumber: 'X17',
        renderData: CardRenderer.builder((b) => {
          b.titanium(1).nbsp.or().nbsp.steel(2);
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const gainTitanium = new SelectOption(
      'Gain 1 titanium',
      'Gain titanium')
      .andThen(() => {
        player.stock.add(Resource.TITANIUM, 1, {log: true});
        return undefined;
      });

    const gain2Steel = new SelectOption(
      'Gain 2 steel',
      'Gain steel')
      .andThen(() => {
        player.stock.add(Resource.STEEL, 2, {log: true});
        return undefined;
      });

    return new OrOptions(gainTitanium, gain2Steel);
  }

  public static resourceHook(player: IPlayer, resource: Resource, amount: number, from: IPlayer) {
    if (from === player || amount >= 0) {
      return;
    }
    if (resource === Resource.PLANTS && amount < 0) {
      player.game.someoneHasRemovedOtherPlayersPlants = true;
    }
  }
}

================
File: cards/promo/CuttingEdgeTechnology.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

export class CuttingEdgeTechnology extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CUTTING_EDGE_TECHNOLOGY,
      tags: [Tag.SCIENCE],
      cost: 12,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'X18',
        renderData: CardRenderer.builder((b) => {
          b.effect('When playing a card with a requirement, you pay 2 M€ less for it.', (eb) => {
            eb.cards(1, {secondaryTag: AltSecondaryTag.REQ}).startEffect.megacredits(-2);
          });
        }),
      },
    });
  }

  public override getCardDiscount(_player: IPlayer, card: IProjectCard) {
    return card.requirements.length > 0 ? 2 : 0;
  }
}

================
File: cards/promo/CyberiaSystems.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {RoboticWorkforceBase} from '../base/RoboticWorkforceBase';
import {Size} from '../../../common/cards/render/Size';
import {IPlayer} from '../../IPlayer';
import {ICard} from '../ICard';
import {Priority} from '../../deferredActions/Priority';

export class CyberiaSystems extends RoboticWorkforceBase {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CYBERIA_SYSTEMS,
      tags: [Tag.BUILDING],
      cost: 17,

      behavior: {production: {steel: 1}},

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(1));
          b.text('Copy', Size.SMALL, true)
            .production((pb) => pb.tag(Tag.BUILDING))
            .production((pb) => pb.tag(Tag.BUILDING))
            .br;
        }),
        description: 'Raise your steel production 1 step. Copy the production boxes of 2 of your other cards with building tags.',
      },
    });
  }

  protected override getPlayableBuildingCards(player: IPlayer): ReadonlyArray<ICard> {
    return super.getPlayableBuildingCards(player).filter((c) => c.name !== CardName.CYBERIA_SYSTEMS);
  }

  public override bespokePlay(player: IPlayer) {
    const firstSet = this.getPlayableBuildingCards(player);
    const selectFirstCard = this.selectBuildingCard(player, firstSet, 'Select first builder card to copy', (card) => {
      const secondSet = this.getPlayableBuildingCards(player).filter((c) => c !== card);
      player.defer(this.selectBuildingCard(player, secondSet, 'Select second card to copy'), Priority.ROBOTIC_WORKFORCE);
      return undefined;
    });

    player.defer(selectFirstCard, Priority.ROBOTIC_WORKFORCE);
    return undefined;
  }
}

================
File: cards/promo/DeimosDownPromo.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';
import {all, digit} from '../Options';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';

export class DeimosDownPromo extends Card implements IProjectCard {
  constructor(
    name = CardName.DEIMOS_DOWN_PROMO,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: 'X31',
      renderData: CardRenderer.builder((b) => {
        b.temperature(3).br;
        b.tile(TileType.DEIMOS_DOWN, true).asterix().br;
        b.steel(4, {digit}).nbsp.minus().plants(-6, {all});
      }),
      description: 'Raise temperature 3 steps and gain 4 steel. Place this tile ADJACENT TO no other city tile. Remove up to 6 plants from any player.',
    },
  ) {
    super({
      type: CardType.EVENT,
      name,
      tags: [Tag.SPACE],
      cost: 31,
      metadata,
      behavior: {
        stock: {steel: 4},
        global: {temperature: 3},
        removeAnyPlants: 6,
        tile: {
          type: TileType.DEIMOS_DOWN,
          on: 'city',
          adjacencyBonus: adjacencyBonus,
        },
      },
    });
  }
}

================
File: cards/promo/DirectedHeatUsage.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';
import {digit} from '../Options';

export class DirectedHeatUsage extends ActionCard {
  constructor() {
    super({
      name: CardName.DIRECTED_HEAT_USAGE,
      type: CardType.ACTIVE,
      cost: 1,

      action: {
        or: {
          behaviors: [
            {
              title: 'Spend 3 heat to gain 4 M€',
              spend: {heat: 3},
              stock: {megacredits: 4},
            },
            {
              title: 'Spend 3 heat to gain 2 plants',
              spend: {heat: 3},
              stock: {plants: 2},
            },
          ],
        },
      },

      metadata: {
        // cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 3 heat to gain either 4 M€ or 2 plants.', (eb) =>
            eb.empty().heat(3, {digit}).startAction.megacredits(4).or().plants(2));
        }),
      },
    });
  }
}

================
File: cards/promo/DirectedImpactors.ts
================
import {IProjectCard} from '../IProjectCard';
import {IActionCard, ICard} from '../ICard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {SelectCard} from '../../inputs/SelectCard';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {MAX_TEMPERATURE} from '../../../common/constants';
import {LogHelper} from '../../LogHelper';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../render/CardRenderer';
import {TITLES} from '../../inputs/titles';

export class DirectedImpactors extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.DIRECTED_IMPACTORS,
      tags: [Tag.SPACE],
      cost: 8,
      resourceType: CardResource.ASTEROID,

      metadata: {
        cardNumber: 'X19',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 6 M€ to add 1 asteroid to ANY CARD (titanium may be used to pay for this).', (eb) => {
            eb.megacredits(6).super((b) => b.titanium(1)).startAction.resource(CardResource.ASTEROID).asterix();
          }).br;
          b.or().br;
          b.action('Remove 1 asteroid here to raise temperature 1 step.', (eb) => {
            eb.resource(CardResource.ASTEROID).startAction.temperature(1);
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    const cardHasResources = this.resourceCount > 0;
    const canPayForAsteroid = player.canAfford({cost: 6, titanium: true});

    if (player.game.getTemperature() === MAX_TEMPERATURE && cardHasResources) return true;
    if (canPayForAsteroid) return true;

    return player.canAfford({cost: 0, tr: {temperature: 1}}) && cardHasResources;
  }

  public action(player: IPlayer) {
    const asteroidCards = player.getResourceCards(CardResource.ASTEROID);
    const opts = [];

    const addResource = new SelectOption('Pay 6 M€ to add 1 asteroid to a card', 'Pay').andThen(() => this.addResource(player, asteroidCards));
    const spendResource = new SelectOption('Remove 1 asteroid to raise temperature 1 step', 'Remove asteroid').andThen(() => this.spendResource(player));
    const temperatureIsMaxed = player.game.getTemperature() === MAX_TEMPERATURE;

    if (this.resourceCount > 0) {
      if (!temperatureIsMaxed && player.canAfford({cost: 0, tr: {temperature: 1}})) {
        opts.push(spendResource);
      }
    } else {
      return this.addResource(player, asteroidCards);
    }

    if (player.canAfford({cost: 6, titanium: true})) {
      opts.push(addResource);
    } else {
      return this.spendResource(player);
    }

    return new OrOptions(...opts);
  }

  private addResource(player: IPlayer, asteroidCards: ICard[]) {
    player.game.defer(new SelectPaymentDeferred(player, 6, {canUseTitanium: true, title: TITLES.payForCardAction(this.name)}));

    if (asteroidCards.length === 1) {
      player.addResourceTo(this, {log: true});
      return undefined;
    }

    return new SelectCard(
      'Select card to add 1 asteroid',
      'Add asteroid',
      asteroidCards)
      .andThen(([card]) => {
        player.addResourceTo(card, {log: true});
        return undefined;
      });
  }

  private spendResource(player: IPlayer) {
    this.resourceCount--;
    LogHelper.logRemoveResource(player, this, 1, 'raise temperature 1 step');
    player.game.increaseTemperature(player, 1);
    return undefined;
  }
}

================
File: cards/promo/DiversitySupport.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class DiversitySupport extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.DIVERSITY_SUPPORT,
      tags: [],
      cost: 1,

      behavior: {
        tr: 1,
      },

      requirements: {resourceTypes: 9},
      metadata: {
        cardNumber: 'X20',
        description: 'Requires that you have 9 different types of resources. Gain 1 TR.',
        renderData: CardRenderer.builder((b) => b.tr(1)),
      },
    });
  }
}

================
File: cards/promo/DoubleDown.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {PreludesExpansion} from '../../preludes/PreludesExpansion';
import {IPreludeCard, isPreludeCard} from '../prelude/IPreludeCard';

export class DoubleDown extends PreludeCard {
  constructor() {
    super({
      name: CardName.DOUBLE_DOWN,

      metadata: {
        cardNumber: 'X40',
        description: '',
        renderData: CardRenderer.builder((b) => {
          b.text('Copy your other prelude\'s direct effect.', Size.SMALL, true);
        }),
      },
    });
  }

  private cloneablePreludes(player: IPlayer) {
    const cards = player.playedCards.filter(isPreludeCard)
      .filter((card) => card.name !== this.name)
      .filter((card) => card.canPlay(player));
    if (player.lastCardPlayed === CardName.NEW_PARTNER) {
      // This is a super unfortunate hack. See player.playCard for details.
      const newPartner = player.preludeCardsInHand.filter((card) => card.name === CardName.NEW_PARTNER)[0];
      if (newPartner !== undefined) {
        cards.push(newPartner as IPreludeCard);
      }
    }
    return cards;
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return this.cloneablePreludes(player).length> 0;
  }

  public override bespokePlay(player: IPlayer) {
    const preludes = this.cloneablePreludes(player);
    if (preludes.length === 0) {
      PreludesExpansion.fizzle(player, this);
      return undefined;
    }
    return PreludesExpansion.playPrelude(player, preludes, 'action-only');
  }
}

================
File: cards/promo/DuskLaserMining.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {digit} from '../Options';

export class DuskLaserMining extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DUSK_LASER_MINING,
      cost: 8,
      tags: [Tag.SPACE],

      behavior: {
        production: {energy: -1, titanium: 1},
        stock: {titanium: 4},
      },

      requirements: {tag: Tag.SCIENCE, count: 2},
      metadata: {
        cardNumber: 'X01',
        description: 'Requires 2 science tags. Decrease your energy production 1 step, and increase your titanium production 1 step. Gain 4 titanium.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().titanium(1);
          }).nbsp.titanium(4, {digit});
        }),
      },
    });
  }
}

================
File: cards/promo/EnergyMarket.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectAmount} from '../../inputs/SelectAmount';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../render/CardRenderer';

export class EnergyMarket extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ENERGY_MARKET,
      tags: [Tag.POWER],
      cost: 3,

      metadata: {
        cardNumber: 'X03',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2X M€ to gain X energy.', (eb) => {
            eb.megacredits(1, {text: '2x'}).startAction.text('x').energy(1);
          }).br;
          b.or().br;
          b.action('Decrease energy production 1 step to gain 8 M€.', (eb) => {
            eb.production((pb) => pb.energy(1)).startAction.megacredits(8);
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.canAfford(2) || player.production.energy >= 1;
  }

  private getEnergyOption(player: IPlayer, availableMC: number): SelectAmount {
    return new SelectAmount(
      'Select amount of energy to gain', 'Gain energy', 1, Math.floor(availableMC / 2))
      .andThen((amount) => {
        player.game.defer(new SelectPaymentDeferred(player, amount * 2))
          .andThen(() => player.stock.add(Resource.ENERGY, amount, {log: true}));
        return undefined;
      });
  }

  private getMegacreditsOption(player: IPlayer) {
    player.production.add(Resource.ENERGY, -1);
    player.stock.add(Resource.MEGACREDITS, 8);
    player.game.log('${0} decreased energy production 1 step to gain 8 M€', (b) => b.player(player));
    return undefined;
  }

  public action(player: IPlayer) {
    const availableMC = player.spendableMegacredits();
    if (availableMC >= 2 && player.production.energy >= 1) {
      return new OrOptions(
        new SelectOption('Spend 2X M€ to gain X energy', 'Spend M€').andThen(() => {
          return this.getEnergyOption(player, availableMC);
        }),
        new SelectOption('Decrease energy production 1 step to gain 8 M€', 'Decrease energy').andThen(() => {
          return this.getMegacreditsOption(player);
        }),
      );
    } else if (availableMC >= 2) {
      return this.getEnergyOption(player, availableMC);
    } else if (player.production.energy >= 1) {
      return this.getMegacreditsOption(player);
    }
    return undefined;
  }
}

================
File: cards/promo/Factorum.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {IActionCard} from '../ICard';
import {Resource} from '../../../common/Resource';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {TITLES} from '../../inputs/titles';

export class Factorum extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.FACTORUM,
      tags: [Tag.POWER, Tag.BUILDING],
      startingMegaCredits: 37,

      behavior: {
        production: {steel: 1},
      },

      metadata: {
        cardNumber: 'R22',
        description: 'You start with 37 M€. Increase your steel production 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(37).nbsp.production((pb) => pb.steel(1));
          b.corpBox('action', (ce) => {
            ce.vSpace(Size.LARGE);
            ce.action('Increase your energy production 1 step IF YOU HAVE NO ENERGY RESOURCES, or spend 3M€ to draw a building card.', (eb) => {
              eb.empty().arrow().production((pb) => pb.energy(1)).asterix();
              eb.or().megacredits(3).startAction.cards(1, {secondaryTag: Tag.BUILDING});
            });
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.energy === 0 || player.canAfford(3);
  }

  public action(player: IPlayer) {
    const increaseEnergy = new SelectOption(
      'Increase your energy production 1 step',
      'Increase production')
      .andThen(() => {
        player.production.add(Resource.ENERGY, 1, {log: true});
        return undefined;
      });

    const drawBuildingCard = new SelectOption('Spend 3 M€ to draw a building card', 'Draw card')
      .andThen(() => {
        player.game.defer(new SelectPaymentDeferred(player, 3, {title: TITLES.payForCardAction(this.name)}))
          .andThen(() => player.drawCard(1, {tag: Tag.BUILDING}));
        return undefined;
      });

    if (player.energy > 0) return drawBuildingCard;
    if (!player.canAfford(3)) return increaseEnergy;

    return new OrOptions(increaseEnergy, drawBuildingCard);
  }
}

================
File: cards/promo/FieldCappedCity.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class FieldCappedCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FIELD_CAPPED_CITY,
      tags: [Tag.CITY, Tag.BUILDING, Tag.POWER],
      cost: 29,

      behavior: {
        production: {energy: 1, megacredits: 2},
        stock: {plants: 3},
        city: {},
      },

      metadata: {
        cardNumber: 'X21',
        description: 'Increase your M€ production 2 steps, increase your energy production 1 step, gain 3 plants, and place a city tile.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(2).br;
            pb.energy(1);
          }).nbsp.city().br;
          b.plants(3);
        }),
      },
    });
  }
}

================
File: cards/promo/FloydContinuum.ts
================
import * as constants from '../../../common/constants';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {IActionCard} from '../ICard';

// Note: Floyd Continuum comes from the Dutch international open.
// https://boardgamegeek.com/thread/3120204/dutch-open-terraformingmars-international-4th-tour

export class FloydContinuum extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      cost: 4,
      name: CardName.FLOYD_CONTINUUM,
      tags: [Tag.SCIENCE],
      type: CardType.ACTIVE,

      metadata: {
        cardNumber: '',
        hasExternalHelp: true,
        renderData: CardRenderer.builder((b) => {
          b.action('Gain 3 M€ per completed terraforming parameter.', (eb) => {
            eb.empty().startAction.megacredits(3).slash().oceans(1).oxygen(1).temperature(1).asterix();
          });
        }),
      },
    });
  }

  public canAct() {
    return true;
  }

  public action(player: IPlayer) {
    let count = 0;
    const game = player.game;
    if (game.getTemperature() === constants.MAX_TEMPERATURE) {
      count++;
    }
    if (game.getOxygenLevel() === constants.MAX_OXYGEN_LEVEL) {
      count++;
    }
    if (!game.canAddOcean()) {
      count++;
    }
    if (game.getVenusScaleLevel() === constants.MAX_VENUS_SCALE) {
      count++;
    }
    player.stock.add(Resource.MEGACREDITS, 3 * count, {log: true});
    return undefined;
  }
}

================
File: cards/promo/GiantSolarCollector.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {PreludeCard} from '../prelude/PreludeCard';
import {Tag} from '../../../common/cards/Tag';

export class GiantSolarCollector extends PreludeCard {
  constructor() {
    super({
      name: CardName.GIANT_SOLAR_COLLECTOR,
      tags: [Tag.POWER, Tag.SPACE],

      behavior: {
        production: {energy: 2},
        global: {venus: 1},
      },

      metadata: {
        cardNumber: '',
        description: 'Increase your energy production 2 steps. Raise Venus 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2)).venus(1);
        }),
      },
    });
  }
}

================
File: cards/promo/GreatDamPromo.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';
import {Board} from '../../boards/Board';
import {Space} from '../../boards/Space';
import {SelectSpace} from '../../inputs/SelectSpace';
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {message} from '../../logs/MessageBuilder';

export class GreatDamPromo extends Card implements IProjectCard {
  constructor(
    name = CardName.GREAT_DAM_PROMO,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: 'X32',
      renderData: CardRenderer.builder((b) => {
        b.production((pb) => pb.energy(2)).tile(TileType.GREAT_DAM, true, false).asterix();
      }),
      description: 'Requires 4 ocean tiles. Increase your energy production 2 steps. Place this tile ADJACENT TO an ocean tile.',
    },
  ) {
    super({
      type: CardType.AUTOMATED,
      name,
      cost: 15,
      tags: [Tag.POWER, Tag.BUILDING],
      metadata,
      adjacencyBonus,

      behavior: {
        production: {energy: 2},
      },

      requirements: {oceans: 4},
      victoryPoints: 1,
    });
  }
  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions): boolean {
    return this.getAvailableSpaces(player, canAffordOptions).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    const availableSpaces = this.getAvailableSpaces(player);
    if (availableSpaces.length < 1) return undefined;

    return new SelectSpace(
      message('Select space for ${0}', (b) => b.card(this)),
      availableSpaces)
      .andThen((space) => {
        player.game.addTile(player, space, {tileType: TileType.GREAT_DAM});
        space.adjacency = this.adjacencyBonus;
        return undefined;
      });
  }

  private getAvailableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions): Array<Space> {
    return player.game.board.getAvailableSpacesOnLand(player, canAffordOptions)
      .filter(
        (space) => player.game.board.getAdjacentSpaces(space).filter(
          (adjacentSpace) => Board.isOceanSpace(adjacentSpace),
        ).length > 0,
      );
  }
}

================
File: cards/promo/Harvest.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Harvest extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.HARVEST,
      tags: [Tag.PLANT],
      cost: 4,
      requirements: {greeneries: 3},

      behavior: {
        stock: {megacredits: 12},
      },

      metadata: {
        cardNumber: 'X37',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(12);
        }),
        description: 'Requires that you have 3 greenery tiles in play. Gain 12 M€.',
      },
    });
  }
}

================
File: cards/promo/HeadStart.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {CardType} from '../../../common/cards/CardType';

export class HeadStart extends PreludeCard {
  constructor() {
    super({
      name: CardName.HEAD_START,

      behavior: {
        stock: {
          steel: 2,
        },
      },

      metadata: {
        cardNumber: 'X43',
        renderData: CardRenderer.builder((b) => {
          b.steel(2).br;
          b.text('GAIN 2 STEEL.', Size.TINY).br;
          b.megacredits(1, {text: '?'}).br;
          b.text('GAIN 2 M€ PER PROJECT CARD YOU HAVE IN HAND.', Size.TINY, true, false).br;
          b.arrow().arrow().br;
          b.text('IMMEDIATELY TAKE 2 ACTIONS.', Size.TINY, true, false).br;
        }),
      },
    });
  }

  private static PROJECT_CARD_TYPES = [CardType.ACTIVE, CardType.AUTOMATED, CardType.EVENT];

  public override bespokePlay(player: IPlayer) {
    const projectCardsInHand = player.cardsInHand.filter((card) => HeadStart.PROJECT_CARD_TYPES.includes(card.type));
    const megacredits = projectCardsInHand.length * 2;
    player.stock.add(Resource.MEGACREDITS, megacredits, {log: true});

    return undefined;
  }
}

================
File: cards/promo/HermeticOrderofMars.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {max} from '../Options';
import {IPlayer} from '../../IPlayer';
import {SpaceType} from '../../../common/boards/SpaceType';
import {isHazardTileType} from '../../../common/AresTileType';
import {Resource} from '../../../common/Resource';
import {Space} from '../../boards/Space';

export class HermeticOrderOfMars extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HERMETIC_ORDER_OF_MARS,
      cost: 10,

      requirements: {oxygen: 4, max},

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).nbsp.megacredits(1).slash().emptyTile().asterix();
        }),
        description: 'Oxygen must be 4% or lower. Increase your M€ production 2 steps. Gain 1 M€ per empty area adjacent to your tiles.',
      },
    });
  }

  private hasTile(space: Space): boolean {
    return space.tile !== undefined && !isHazardTileType(space.tile.tileType);
  }

  public override bespokePlay(player: IPlayer) {
    const board = player.game.board;
    const spaces = board.spaces.filter((space) => {
      if (space.spaceType === SpaceType.COLONY || space.spaceType === SpaceType.RESTRICTED || this.hasTile(space)) {
        return false;
      }
      return board.getAdjacentSpaces(space).some((s) => s.player === player && this.hasTile(s));
    }).length;

    player.stock.add(Resource.MEGACREDITS, spaces, {log: true});
    return undefined;
  }
}

================
File: cards/promo/HiTechLab.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {SelectAmount} from '../../inputs/SelectAmount';
import {CardRenderer} from '../render/CardRenderer';

export class HiTechLab extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.HI_TECH_LAB,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      cost: 17,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'X04',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend any amount of energy to draw the same number of cards. TAKE 1 INTO HAND AND DISCARD THE REST.', (eb) => {
            eb.text('X').energy(1).startAction.text('X').cards(1).asterix();
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.energy > 0 && player.game.projectDeck.canDraw(1);
  }

  public action(player: IPlayer) {
    const max = Math.min(player.energy, player.game.projectDeck.size());
    return new SelectAmount('Select amount of energy to spend', 'OK', 1, max)
      .andThen((amount) => {
        player.stock.deduct(Resource.ENERGY, amount);
        player.game.log('${0} spent ${1} energy', (b) => b.player(player).number(amount));
        if (amount === 1) {
          player.drawCard();
          return undefined;
        }
        player.drawCardKeepSome(amount, {keepMax: 1});
        return undefined;
      });
  }
}

================
File: cards/promo/HomeostasisBureau.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {GlobalParameter} from '../../../common/GlobalParameter';

export class HomeostasisBureau extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.HOMEOSTASIS_BUREAU,
      cost: 16,
      tags: [Tag.BUILDING],

      behavior: {
        production: {heat: 2},
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you raise the temperature, gain 3 M€.', (eb) => eb.temperature(1).startEffect.megacredits(3));
          b.br;
          b.production((b) => b.heat(2));
        }),
        description: 'Increase your heat production 2 steps.',
      },
    });
  }

  onGlobalParameterIncrease?(player: IPlayer, parameter: GlobalParameter, steps: number) {
    if (parameter === GlobalParameter.TEMPERATURE) {
      player.stock.add(Resource.MEGACREDITS, 3 * steps, {log: true});
    }
  }
}

================
File: cards/promo/IcyImpactors.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {message} from '../../logs/MessageBuilder';
import {CardResource} from '../../../common/CardResource';
import {PlaceOceanTile} from '../../deferredActions/PlaceOceanTile';

export class IcyImpactors extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.ICY_IMPACTORS,
      type: CardType.ACTIVE,
      tags: [Tag.SPACE],
      cost: 15,
      resourceType: CardResource.ASTEROID,

      metadata: {
        cardNumber: 'X47',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 10 M€ (titanium may be used) to add 2 asteroids here.', (ab) =>
            ab.megacredits(10).super((b) => b.titanium(1)).startAction.resource(CardResource.ASTEROID, 2));
          b.br;
          b.action('Spend 1 asteroid here to place an ocean tile. ' +
            'FIRST PLAYER CHOOSES WHERE YOU MUST PLACE IT.', (ab) =>
            ab.or().resource(CardResource.ASTEROID).startAction.oceans(1).asterix());
        }),
      },
    });
  }
  private canAffordToBuyAsteroids(player: IPlayer) {
    return player.canAfford({cost: 10, titanium: true});
  }
  private canAffordToPlaceOcean(player: IPlayer) {
    return this.resourceCount > 0 && player.canAfford({cost: 0, tr: {oceans: 1}});
  }

  canAct(player: IPlayer): boolean {
    if (this.canAffordToBuyAsteroids(player)) {
      return true;
    }
    if (this.canAffordToPlaceOcean(player)) {
      if (!player.game.canAddOcean()) {
        this.warnings.add('maxoceans');
      }
      return true;
    }
    return false;
  }

  action(player: IPlayer) {
    const options = new OrOptions();

    if (this.canAffordToPlaceOcean(player)) {
      const placeOceanOption = new SelectOption('Spend 1 asteroid here to place an ocean (first player chooses where to place it)').andThen(() => {
        player.removeResourceFrom(this, 1, {log: true});
        player.game.defer(
          new PlaceOceanTile(player.game.first, {
            creditedPlayer: player,
            title: message('Select space for ${0} to place an ocean', (b) => b.player(player)),
          }));
        return undefined;
      });
      if (!player.game.canAddOcean()) {
        placeOceanOption.warnings = ['maxoceans'];
      }
      options.options.push(placeOceanOption);
    }

    if (this.canAffordToBuyAsteroids(player)) {
      options.options.push(
        new SelectOption('Spend 10 M€ to add 2 asteroids here').andThen(() => {
          player.game.defer(new SelectPaymentDeferred(player, 10, {canUseTitanium: true})).andThen(() => {
            player.addResourceTo(this, {qty: 2, log: true});
          });
          return undefined;
        }));
    }

    if (options.options.length === 0) {
      return undefined;
    }
    if (options.options.length === 1) {
      return options.options[0].cb();
    }
    return options;
  }
}

================
File: cards/promo/ImportedNutrients.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class ImportedNutrients extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.IMPORTED_NUTRIENTS,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 14,

      behavior: {
        stock: {plants: 4},
        addResourcesToAnyCard: {count: 4, type: CardResource.MICROBE},
      },

      metadata: {
        cardNumber: 'X22',
        renderData: CardRenderer.builder((b) => {
          b.plants(4, {digit}).nbsp.resource(CardResource.MICROBE, {amount: 4, digit}).asterix();
        }),
        description: 'Gain 4 plants and add 4 microbes to ANOTHER CARD.',
      },
    });
  }
}

================
File: cards/promo/InterplanetaryTrade.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../../cards/render/CardRenderer';

export class InterplanetaryTrade extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.INTERPLANETARY_TRADE,
      tags: [Tag.SPACE],
      cost: 27,
      victoryPoints: 1,

      metadata: {
        cardNumber: 'X05',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1));
          b.slash().diverseTag();
        }),
        description: 'Increase your M€ production 1 step per different tag you have in play, including this.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const distinctTagCount = player.tags.distinctCount('default', Tag.SPACE);
    player.production.add(Resource.MEGACREDITS, distinctTagCount, {log: true});
    return undefined;
  }
}

================
File: cards/promo/JovianEmbassy.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class JovianEmbassy extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.JOVIAN_EMBASSY,
      tags: [Tag.JOVIAN, Tag.BUILDING],
      cost: 14,
      victoryPoints: 1,

      behavior: {
        tr: 1,
      },

      metadata: {
        cardNumber: 'X23',
        renderData: CardRenderer.builder((b) => {
          b.tr(1);
        }),
        description: 'Raise your TR 1 step.',
      },
    });
  }
}

================
File: cards/promo/KaguyaTech.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CanAffordOptions, IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {SelectSpace} from '../../inputs/SelectSpace';

export class KaguyaTech extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.KAGUYA_TECH,
      tags: [Tag.CITY, Tag.PLANT],
      cost: 10,

      behavior: {
        production: {megacredits: 2},
        drawCard: 1,
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).cards(1).br;
          b.minus().greenery({withO2: false}).plus().city().asterix().br;
          b.plainText('Increase M€ production 2 steps. Draw 1 card. ' +
          'Remove 1 of your greenery tiles (does not affect oxygen.) ' +
          'Place a city tile there, regardless of placement rules. ' +
          'Gain placement bonuses as usual.');
        }),
      },
    });
  }

  private availableSpaces(player: IPlayer, canAffordOptions?: CanAffordOptions) {
    const greeneries = player.game.board.getGreeneries(player);
    const filtered = greeneries.filter((space) => player.game.board.canAfford(player, space, canAffordOptions));
    return filtered;
  }

  public override bespokeCanPlay(player: IPlayer, canAffordOptions: CanAffordOptions): boolean {
    // TODO(kberg): Yes But, if the only greenery is Wetlands, warn the player.
    return this.availableSpaces(player, canAffordOptions).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    const greeneries = this.availableSpaces(player);
    return new SelectSpace('Select a greenery to convert to a city.', greeneries)
      .andThen((space) => {
        player.game.removeTile(space.id);
        player.game.addCity(player, space, this.name);
        return undefined;
      });
  }
}

================
File: cards/promo/KuiperCooperative.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {IActionCard} from '../ICard';
import {Size} from '../../../common/cards/render/Size';

export class KuiperCooperative extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.KUIPER_COOPERATIVE,
      tags: [Tag.SPACE, Tag.SPACE],
      startingMegaCredits: 33,
      resourceType: CardResource.ASTEROID,

      behavior: {
        production: {titanium: 1},
      },

      metadata: {
        cardNumber: '',
        description: 'You start with 33 M€. Increase titanium production 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(33).production((pb) => pb.titanium(1)).br;
          b.action('Add 1 asteroid here for every space tag you have.', (ab) => {
            ab.empty().startAction.resource(CardResource.ASTEROID).slash().tag(Tag.SPACE);
          }).br;
          b.effect('When you use the AQUIFER or ASTEROID standard projects, you can spend asteroids on card as 1M€ each.', (eb) => {
            eb.plate('Standard Project', {size: Size.SMALL}).asterix().startEffect.resource(CardResource.ASTEROID).equals().megacredits(1);
          });
        }),
      },
    });
  }

  public action(player: IPlayer) {
    player.addResourceTo(this, {qty: player.tags.count(Tag.SPACE), log: true});
    return undefined;
  }

  public canAct(): boolean {
    return true;
  }
}

================
File: cards/promo/LawSuit.ts
================
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {SelectPlayer} from '../../inputs/SelectPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';
import {all} from '../Options';

export class LawSuit extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.LAW_SUIT,
      tags: [Tag.EARTH],
      cost: 2,
      victoryPoints: 'special',

      metadata: {
        cardNumber: 'X06',
        renderData: CardRenderer.builder((b) => {
          b.text('steal', Size.SMALL, true).megacredits(3, {all}).asterix();
        }),
        description: 'Steal 3 M€ from a player that REMOVED YOUR RESOURCES OR DECREASED YOUR PRODUCTION this generation. Place this card face down in THAT PLAYER\'S EVENT PILE.',
        victoryPoints: CardRenderDynamicVictoryPoints.any(-1),
      },
    });
  }

  private targets(player: IPlayer) {
    return player.game.getPlayersById(player.removingPlayers);
  }

  public override bespokeCanPlay(player: IPlayer) {
    return this.targets(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectPlayer(this.targets(player), 'Select player to sue (steal 3 M€ from)', 'Steal M€')
      .andThen((suedPlayer: IPlayer) => {
        const amount = Math.min(3, suedPlayer.megaCredits);
        if (amount === 0) {
          player.game.log('${0} sued ${1} who had 0 MC.', (b) => b.player(player).player(suedPlayer));
        }
        suedPlayer.playedCards.push(this);
        suedPlayer.maybeBlockAttack(player, (proceed) => {
          if (proceed) {
            suedPlayer.stock.deduct(Resource.MEGACREDITS, amount, {log: true, from: player, stealing: true});
          }
          player.stock.add(Resource.MEGACREDITS, amount);
          return undefined;
        });
        return undefined;
      });
  }
  public override getVictoryPoints() {
    return -1;
  }

  public static resourceHook(player: IPlayer, _resource: Resource, amount: number, from: IPlayer) {
    if (from === player || amount >= 0) {
      return;
    }
    if (player.removingPlayers.includes(from.id) === false) {
      player.removingPlayers.push(from.id);
    }
  }
}

================
File: cards/promo/MagneticFieldGeneratorsPromo.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {TileType} from '../../../common/TileType';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {AdjacencyBonus} from '../../ares/AdjacencyBonus';

export class MagneticFieldGeneratorsPromo extends Card implements IProjectCard {
  constructor(
    name = CardName.MAGNETIC_FIELD_GENERATORS_PROMO,
    adjacencyBonus: AdjacencyBonus | undefined = undefined,
    metadata = {
      cardNumber: 'X33',
      renderData: CardRenderer.builder((b) => {
        b.production((pb) => {
          pb.minus().energy(4, {digit}).br;
          pb.plus().plants(2);
        }).br;
        b.tr(3, {digit}).tile(TileType.MAGNETIC_FIELD_GENERATORS, true).asterix();
      }),
      description: 'Decrease your energy production 4 steps and increase your plant production 2 steps. Raise your TR 3 steps. Place this tile.',
    },
  ) {
    super({
      type: CardType.AUTOMATED,
      name: name,
      tags: [Tag.BUILDING],
      cost: 22,
      behavior: {
        production: {energy: -4, plants: 2},
        tr: 3,
        tile: {
          type: TileType.MAGNETIC_FIELD_GENERATORS,
          on: 'land',
          adjacencyBonus: adjacencyBonus,
        },
      },
      metadata,
    });
  }
}

================
File: cards/promo/MagneticShield.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class MagneticShield extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MAGNETIC_SHIELD,
      tags: [Tag.SPACE],
      cost: 24,

      behavior: {
        tr: 4,
      },

      requirements: {tag: Tag.POWER, count: 3},
      metadata: {
        cardNumber: 'X24',
        renderData: CardRenderer.builder((b) => b.tr(4, {digit})),
        description: 'Requires 3 power tags. Raise your TR 4 steps.',
      },
    });
  }
}

================
File: cards/promo/MarsNomads.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {SelectSpace} from '../../inputs/SelectSpace';
import {IActionCard} from '../ICard';
import {Player} from '../../Player';
import {intersection} from '../../../common/utils/utils';
import {message} from '../../logs/MessageBuilder';
export class MarsNomads extends Card implements IActionCard {
  /*
   * A good page about this card: https://boardgamegeek.com/thread/3154812.
   *
   * 1. Arcadian Communities and Land Claim block Mars Nomads.
   *  1a. Even if it's your AC.
   * 2. Mining Guild and Philares cannot take advantage of it.
   * 3. Placing next to an ocean tile gives a placement bonus.
   *
   * Ares: Adjacency bonuses are not placement bonuses.
   */
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MARS_NOMADS,
      cost: 13,

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.action('MOVE THE NOMADS to an adjacent, non-reserved empty area and collect THE PLACEMENT BONUS ' +
            'as if placing a special tile there. No tiles may be placed on the Nomad area.', (ab) => {
            ab.empty().startAction.nomads().asterix();
          }).br;

          b.nomads().asterix().br;
          b.plainText('PLACE THE NOMADS on a non-reserved, empty area on the game board.');
        }),
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    const spaces = player.game.board.getNonReservedLandSpaces();
    return spaces.length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace(
      message('Select space for ${0}', (b) => b.card(this)),
      player.game.board.getNonReservedLandSpaces())
      .andThen((space) => {
        player.game.nomadSpace = space.id;
        return undefined;
      });
  }

  private eliglbleDestinationSpaces(player: IPlayer) {
    const game = player.game;
    const board = game.board;
    if (game.nomadSpace === undefined) {
      return [];
    }

    const availableSpaces = board.getAvailableSpacesOnLand(player);
    const currentNomadSpace = board.getSpaceOrThrow(game.nomadSpace);
    const adjacentSpaces = board.getAdjacentSpaces(currentNomadSpace);
    return intersection(availableSpaces, adjacentSpaces);
  }

  public canAct(player: IPlayer) {
    return this.eliglbleDestinationSpaces(player).length > 0;
  }

  public action(player: Player) {
    const spaces = this.eliglbleDestinationSpaces(player);

    return new SelectSpace(
      message('Select new space for ${0}', (b) => b.card(this)),
      spaces)
      .andThen((space) => {
        player.game.nomadSpace = space.id;
        player.game.grantPlacementBonuses(player, space, false);

        return undefined;
      });
  }
}

================
File: cards/promo/MartianLumberCorp.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';

export class MartianLumberCorp extends Card {
  constructor() {
    super({
      name: CardName.MARTIAN_LUMBER_CORP,
      type: CardType.ACTIVE,
      tags: [Tag.BUILDING, Tag.PLANT],
      cost: 6,

      behavior: {
        production: {plants: 1},
      },

      requirements: {greeneries: 2},

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.effect('When playing a building tag, plants may be used as 3 M€ each.',
            (eb) => eb.tag(Tag.BUILDING).startEffect.plants(1).equals().megacredits(3)).br;
          b.production((pb) => pb.plants(1)).br;
          b.plainText('(Requires that you have 2 greenery tiles. Increase plant production 1 step.)').br;
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.canUsePlantsAsMegacredits = true;
    return undefined;
  }

  public override onDiscard(player: IPlayer) {
    player.canUsePlantsAsMegacredits = false;
    return undefined;
  }
}

================
File: cards/promo/MeatIndustry.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';
import {ICard} from '../ICard';
import {CardResource} from '../../../common/CardResource';
import {Resource} from '../../../common/Resource';

export class MeatIndustry extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MEAT_INDUSTRY,
      tags: [Tag.BUILDING],
      cost: 5,

      metadata: {
        cardNumber: 'X25',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you gain an animal to ANY CARD, gain 2 M€.', (eb) => {
            eb.resource(CardResource.ANIMAL).asterix().startEffect.megacredits(2);
          });
        }),
      },
    });
  }

  public onResourceAdded(player: IPlayer, card: ICard, count: number) {
    if (card.resourceType === CardResource.ANIMAL) {
      player.stock.add(Resource.MEGACREDITS, count * 2, {log: true});
    }
  }
}

================
File: cards/promo/Meltworks.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {ActionCard} from '../ActionCard';

export class Meltworks extends ActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MELTWORKS,
      tags: [Tag.BUILDING],
      cost: 4,

      action: {
        spend: {heat: 5},
        stock: {steel: 3},
      },

      metadata: {
        cardNumber: 'X26',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 5 heat to gain 3 steel.', (eb) => {
            eb.heat(5, {digit}).startAction.steel(3);
          });
        }),
      },
    });
  }
}

================
File: cards/promo/MercurianAlloys.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class MercurianAlloys extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MERCURIAN_ALLOYS,
      tags: [Tag.SPACE],
      cost: 3,

      behavior: {
        titanumValue: 1,
      },

      requirements: {tag: Tag.SCIENCE, count: 2},
      metadata: {
        cardNumber: 'X07',
        renderData: CardRenderer.builder((b) => {
          b.effect('Your titanium resources are worth 1 M€ extra.', (eb) => {
            eb.titanium(1).startEffect.plus(Size.SMALL).megacredits(1);
          });
        }),
        description: 'Requires 2 science tags.',
      },
    });
  }
}

================
File: cards/promo/Merger.ts
================
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {SelectCard} from '../../inputs/SelectCard';
import {Size} from '../../../common/cards/render/Size';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {LogHelper} from '../../LogHelper';
import {ICorporationCard} from '../corporation/ICorporationCard';
import {CARD_COST} from '../../../common/constants';
import {CorporationDeck} from '../Deck';
import {Countable} from '../../behavior/Countable';
import {PreludesExpansion} from '../../preludes/PreludesExpansion';

export class Merger extends PreludeCard {
  constructor() {
    super({
      name: CardName.MERGER,

      metadata: {
        cardNumber: 'X41',
        renderData: CardRenderer.builder((b) => {
          b.corporation().asterix().nbsp.megacredits(-42, {size: Size.SMALL});
          b.br.br;
        }),
        description: 'Draw 4 corporation cards. Play one of them and discard the other 3. Then pay 42 M€.',
      },
    });
  }

  public static readonly mergerCost = 42;

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    const dealtCorps = Merger.dealCorporations(player, game.corporationDeck);
    const enabled = dealtCorps.map((corp) => {
      return player.canAfford(Merger.mergerCost - this.spendableMegacredits(player, corp));
    });
    if (enabled.some((v) => v === true) === false) {
      PreludesExpansion.fizzle(player, this);
      dealtCorps.forEach((corp) => game.corporationDeck.discard(corp));
      return undefined;
    }
    player.defer(() => {
      return new SelectCard('Choose corporation card to play', 'Play', dealtCorps, {enabled: enabled})
        .andThen(([card]) => {
          player.playAdditionalCorporationCard(card);
          dealtCorps.forEach((corp) => {
            if (corp.name !== card.name) {
              game.corporationDeck.discard(corp);
            }
          });
          game.defer(new SelectPaymentDeferred(player, Merger.mergerCost, {title: 'Select how to pay for Merger'}));
          return undefined;
        });
    });
    return undefined;
  }

  private static dealCorporations(player: IPlayer, corporationDeck: CorporationDeck) {
    const game = player.game;
    const cards = corporationDeck.drawN(game, 4);
    if (cards.length !== 4) {
      // Error will only occur if the deck is empty. That won't happen, but here we'll just do our best.
      game.log('Not enough corporations while resolving ${0}', (b) => b.cardName(CardName.MERGER));
    }
    LogHelper.logDrawnCards(player, cards, /* privateMessage= */true);
    return cards;
  }

  public static setCardCost(player: IPlayer) {
    return player.corporations
      .map((card) => (card.cardCost ?? CARD_COST) - CARD_COST) // Convert every card cost to delta from zero. (e.g. -2, 0, +2)
      .reduce((prev, curr) => prev + curr, CARD_COST); // Add them up, and add CARD_COST back.
  }


  // Returns the delta of spendable MC made avialable by a merged corporation.
  // Much of this code is similar to Player.spendableMegaCredits, but that can't
  // be used since corp is not yet part of player's tableau.
  //
  // Spendable Megacredits matter if:
  //
  // Player has Manutech and incoming cards add MC, heat, or titanium production
  // TO DO: Player has LTF and incoming card raises titanium value (e.g. Phobolog)
  // TO DO: Player has LTF and incoming card adds titanium
  // No use cases coded yet, but player has UNMO and incoming card raises TR.
  private spendableMegacredits(player: IPlayer, corp: ICorporationCard) {
    // short-circuit. No need for all the work below if the card
    // comes with enough MC.
    if (corp.startingMegaCredits >= Merger.mergerCost) {
      return corp.startingMegaCredits;
    }
    const behavior = corp.behavior;
    const stock = behavior?.stock;
    const production = behavior?.production;
    let sum = corp.startingMegaCredits;

    // Used to filter down anything of type Countable.
    const asNumber = (x: Countable | undefined) => typeof(x) === 'number' ? x : 0;

    let incomingTitanium = asNumber(stock?.titanium);
    // const titaniumValue = player.getTitaniumValue() + (behavior?.titanumValue ?? 0);
    const titaniumValue = player.getTitaniumValue();

    if (player.isCorporation(CardName.MANUTECH)) {
      sum += asNumber(production?.megacredits);
      incomingTitanium += asNumber(production?.titanium);
    }
    if (corp.name === CardName.LUNA_TRADE_FEDERATION || player.isCorporation(CardName.LUNA_TRADE_FEDERATION)) {
      sum += (player.titanium + incomingTitanium) * (titaniumValue - 1);
    }

    return sum;
  }
}

================
File: cards/promo/MoholeLake.ts
================
import {IActionCard} from '../ICard';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {SelectCard} from '../../inputs/SelectCard';
import {CardRenderer} from '../render/CardRenderer';

export class MoholeLake extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MOHOLE_LAKE,
      tags: [Tag.BUILDING],
      cost: 31,

      behavior: {
        stock: {plants: 3},
        global: {temperature: 1},
        ocean: {},
      },

      metadata: {
        cardNumber: 'X27',
        renderData: CardRenderer.builder((b) => {
          b.action('Add a microbe or animal to ANOTHER card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE).asterix();
            eb.nbsp.or().nbsp.resource(CardResource.ANIMAL).asterix();
          }).br;
          b.plants(3).temperature(1).oceans(1);
        }),
        description: 'Gain 3 plants. Raise temperature 1 step, and place 1 ocean tile.',
      },
    });
  }

  public canAct(): boolean {
    return true;
  }

  public action(player: IPlayer) {
    const availableCards = player.getResourceCards(CardResource.MICROBE).concat(player.getResourceCards(CardResource.ANIMAL));

    if (availableCards.length === 0) {
      return undefined;
    }

    if (availableCards.length === 1) {
      player.addResourceTo(availableCards[0], {log: true});
      return undefined;
    }

    return new SelectCard('Select card to add microbe or animal', 'Add resource', availableCards)
      .andThen(([card]) => {
        player.addResourceTo(card, {log: true});
        return undefined;
      });
  }
}

================
File: cards/promo/MonsInsurance.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';

export class MonsInsurance extends CorporationCard {
  constructor() {
    super({
      name: CardName.MONS_INSURANCE,
      startingMegaCredits: 48,

      behavior: {
        production: {megacredits: 4},
      },

      metadata: {
        cardNumber: 'R46',
        description: 'You start with 48 M€. Increase your M€ production 4 steps. ALL OPPONENTS DECREASE THEIR M€ production 2 STEPS. THIS DOES NOT TRIGGER THE EFFECT BELOW.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(48).production((pb) => {
            pb.megacredits(4).nbsp.megacredits(-2, {all}).asterix();
          });
          b.corpBox('effect', (cb) => {
            cb.vSpace(Size.SMALL);
            cb.effect('When a player causes another player to decrease production or lose resources, pay 3M€ to the victim, or as much as possible.', (eb) => {
              eb.production((pb) => pb.wild(1, {all})).or().minus().wild(1, {all});
              eb.startEffect.text('pay', Size.SMALL, true).megacredits(3);
            });
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    for (const p of player.getOpponents()) {
      p.production.add(Resource.MEGACREDITS, -2, {log: true});
    }
    player.game.monsInsuranceOwner = player.id;
    return undefined;
  }

  // When `insured` is undefined, it's the neutral player.
  public payDebt(player: IPlayer, claimant : IPlayer | undefined) {
    if (player !== claimant) {
      const retribution = Math.min(player.megaCredits, 3);
      if (claimant) claimant.megaCredits += retribution;
      player.stock.deduct(Resource.MEGACREDITS, retribution);
      if (retribution > 0) {
        if (claimant !== undefined) {
          player.game.log('${0} received ${1} M€ from ${2} owner (${3})', (b) =>
            b.player(claimant)
              .number(retribution)
              .cardName(CardName.MONS_INSURANCE)
              .player(player));
        } else {
          player.game.log('Neutral player received ${0} M€ from ${1} owner (${2})', (b) =>
            b.number(retribution)
              .cardName(CardName.MONS_INSURANCE)
              .player(player));
        }
      }
    }
  }
}

================
File: cards/promo/NeptunianPowerConsultants.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {all} from '../Options';
import {Resource} from '../../../common/Resource';
import {Board} from '../../boards/Board';
import {Space} from '../../boards/Space';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectPayment} from '../../inputs/SelectPayment';
import {Size} from '../../../common/cards/render/Size';

export class NeptunianPowerConsultants extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.NEPTUNIAN_POWER_CONSULTANTS,
      tags: [Tag.POWER],
      cost: 14,
      resourceType: CardResource.HYDROELECTRIC_RESOURCE,
      victoryPoints: {resourcesHere: {}},

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1, {all, size: Size.SMALL}).asterix()
            .colon()
            .minus().megacredits(5).super((b) => b.steel(1));
          b.br;
          b.nbsp.nbsp.plus().production((pb) => pb.energy(1)).plus().resource(CardResource.HYDROELECTRIC_RESOURCE);
          b.br;
          b.plainText('(Effect: When any ocean is placed, you MAY pay 5 M€ (steel may be used), to ' +
            'raise energy production 1 step and add 1 hydroelectric resource to this card.)');
        }),
        description: '1 VP per hydroelectric resource on this card',
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, _activePlayer: IPlayer, space: Space) {
    const game = cardOwner.game;
    if (Board.isUncoveredOceanSpace(space)) {
      if (cardOwner.canAfford({cost: 5, steel: true})) {
        const orOptions = new OrOptions();
        orOptions.options.push(new SelectPayment(
          'Spend 5 M€ for one energy production and hydroelectric resource',
          5, {steel: true})
          .andThen((payment) => {
            cardOwner.pay(payment);
            cardOwner.production.add(Resource.ENERGY, 1, {log: true});
            cardOwner.addResourceTo(this, {qty: 1, log: true});
            return undefined;
          }));
        orOptions.options.push(new SelectOption('Do not use card effect').andThen(() => {
          game.log('${0} declined to use the ${1} effect', (b) => b.player(cardOwner).card(this));
          return undefined;
        }));
        cardOwner.defer(orOptions);
      } else {
        game.log('${0} cannot afford to use the ${1} effect', (b) => b.player(cardOwner).card(this));
      }
    }
  }
}

================
File: cards/promo/NewPartner.ts
================
import {IPlayer} from '../../IPlayer';
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {PreludesExpansion} from '../../preludes/PreludesExpansion';

export class NewPartner extends PreludeCard {
  constructor() {
    super({
      name: CardName.NEW_PARTNER,

      behavior: {
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'P43',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1)).prelude().asterix();
        }),
        description: 'Raise your M€ production 1 step. Immediately draw 2 prelude cards. Play 1 of them, and discard the other.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    const game = player.game;
    if (!game.preludeDeck.canDraw(2)) {
      this.warnings.add('deckTooSmall');
    }
    return true;
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    const cards = game.preludeDeck.drawN(game, 2);
    return PreludesExpansion.playPrelude(player, cards);
  }
}

================
File: cards/promo/OrbitalCleanup.ts
================
import {IProjectCard} from '../IProjectCard';
import {ActionCard} from '../ActionCard';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';

export class OrbitalCleanup extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ORBITAL_CLEANUP,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 14,
      victoryPoints: 2,

      behavior: {
        production: {megacredits: -2},
      },

      action: {
        stock: {megacredits: {tag: Tag.SCIENCE}},
      },

      metadata: {
        cardNumber: 'X08',

        renderData: CardRenderer.builder((b) => {
          b.action('Gain 1 M€ per science tag you have.', (eb) => {
            eb.empty().startAction.megacredits(1).slash().tag(Tag.SCIENCE);
          }).br;
          b.production((pb) => {
            pb.megacredits(-2);
          });
        }),
        description: 'Decrease your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/promo/OutdoorSports.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all, nextTo} from '../Options';
import {Board} from '../../boards/Board';

export class OutdoorSports extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.OUTDOOR_SPORTS,
      cost: 8,
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 2},
      },

      requirements: [{cities: 1, all, nextTo}, {oceans: 1}],
      metadata: {
        cardNumber: 'X38',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(2);
          });
        }),
        description: 'Requires any city adjacent to an ocean. Increase your M€ production 2 steps.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    const board = player.game.board;
    const oceans = board.getOceanSpaces({upgradedOceans: true, wetlands: true});
    return oceans.some((ocean) => board.getAdjacentSpaces(ocean).some((space) => Board.isCitySpace(space)));
  }
}

================
File: cards/promo/Penguins.ts
================
import {IProjectCard} from '../IProjectCard';
import {ActionCard} from '../ActionCard';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';

export class Penguins extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PENGUINS,
      tags: [Tag.ANIMAL],
      cost: 7,
      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}},

      action: {
        addResources: 1,
      },

      requirements: {oceans: 8},
      metadata: {
        cardNumber: '212',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.vpText('1 VP for each animal on this card.');
        }),
        description: 'Requires 8 oceans.',
      },
    });
  }
}

================
File: cards/promo/PharmacyUnion.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CorporationCard} from '../corporation/CorporationCard';
import {ICorporationCard} from '../corporation/ICorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardResource} from '../../../common/CardResource';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {ICard} from '../ICard';
import {Priority} from '../../deferredActions/Priority';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {Resource} from '../../../common/Resource';
import {all, digit} from '../Options';
import {SerializedCard} from '../../SerializedCard';

export class PharmacyUnion extends CorporationCard {
  constructor() {
    super({
      name: CardName.PHARMACY_UNION,
      startingMegaCredits: 46, // 54 minus 8 for the 2 diseases
      resourceType: CardResource.DISEASE,

      behavior: {
        drawCard: {count: 1, tag: Tag.SCIENCE},
        addResources: 2,
      },

      metadata: {
        cardNumber: 'R39',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(54).cards(1, {secondaryTag: Tag.SCIENCE});
          // blank space after MC is on purpose
          b.text('(You start with 54 M€ . Draw a Science card.)', Size.TINY, false, false);
          b.corpBox('effect', (ce) => {
            ce.vSpace(Size.LARGE);
            ce.effect(undefined, (eb) => {
              eb.tag(Tag.MICROBE, {all}).startEffect.resource(CardResource.DISEASE).megacredits(-4);
            });
            ce.vSpace();
            ce.effect('When ANY microbe tag is played, add a disease here and lose 4 M€ or as much as possible. When you play a science tag, remove a disease here and gain 1 TR OR if there are no diseases here, you MAY put this card face down in your EVENTS PILE to gain 3 TR.', (eb) => {
              eb.tag(Tag.SCIENCE).startEffect.minus().resource(CardResource.DISEASE);
              eb.tr(1, {size: Size.SMALL}).slash().tr(3, {size: Size.SMALL, digit});
            });
          });
        }),
      },
    });
  }

  public isDisabled = false;

  public override get tags() {
    if (this.isDisabled) {
      return [];
    }
    return [Tag.MICROBE, Tag.MICROBE];
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    this.onCardPlayed(player, card);
  }

  private addDisease(player: IPlayer, count: number) {
    const megaCreditsLost = Math.min(player.megaCredits, count * 4);
    player.addResourceTo(this, count);
    player.stock.deduct(Resource.MEGACREDITS, megaCreditsLost);
    player.game.log('${0} added a disease to ${1} and lost ${2} M€', (b) => b.player(player).card(this).number(megaCreditsLost));
  }

  public onCardPlayed(player: IPlayer, card: ICard): void {
    if (this.isDisabled) {
      return;
    }

    const game = player.game;

    const hasScienceTag = player.tags.cardHasTag(card, Tag.SCIENCE);
    const hasMicrobesTag = card.tags.includes(Tag.MICROBE);
    const isPharmacyUnion = player.isCorporation(CardName.PHARMACY_UNION);

    // Edge case, let player pick order of resolution (see https://github.com/bafolts/terraforming-mars/issues/1286)
    if (isPharmacyUnion && hasScienceTag && hasMicrobesTag && this.resourceCount === 0) {
      // TODO (Lynesth): Modify this when https://github.com/bafolts/terraforming-mars/issues/1670 is fixed
      if (player.canAfford({cost: 0, tr: {tr: 3}})) {
        player.defer(() => {
          const orOptions = new OrOptions(
            new SelectOption('Turn it face down to gain 3 TR and lose up to 4 M€').andThen(() => {
              this.isDisabled = true;
              player.increaseTerraformRating(3);
              const megaCreditsLost = Math.min(player.megaCredits, 4);
              player.stock.deduct(Resource.MEGACREDITS, megaCreditsLost);
              game.log('${0} turned ${1} face down to gain 3 TR and lost ${2} M€', (b) => b.player(player).card(this).number(megaCreditsLost));
              return undefined;
            }),
            new SelectOption('Add a disease to it and lose up to 4 M€, then remove a disease to gain 1 TR').andThen(() => {
              const megaCreditsLost = Math.min(player.megaCredits, 4);
              player.increaseTerraformRating();
              player.stock.deduct(Resource.MEGACREDITS, megaCreditsLost);
              game.log('${0} added a disease to ${1} and lost ${2} M€', (b) => b.player(player).card(this).number(megaCreditsLost));
              game.log('${0} removed a disease from ${1} to gain 1 TR', (b) => b.player(player).card(this));
              return undefined;
            }),
          );
          orOptions.title = 'Choose the order of tag resolution for Pharmacy Union';
          return orOptions;
        }, Priority.PHARMACY_UNION);
        return undefined;
      }
    }

    if (isPharmacyUnion && hasScienceTag) {
      const scienceTags = player.tags.cardTagCount(card, Tag.SCIENCE);
      this.onScienceTagAdded(player, scienceTags);
    }


    if (hasMicrobesTag) {
      player.defer(() => {
        const microbeTagCount = card.tags.filter((cardTag) => cardTag === Tag.MICROBE).length;
        const player = game.getCardPlayerOrThrow(this.name);
        this.addDisease(player, microbeTagCount);
        return undefined;
      }, Priority.PHARMACY_UNION);
    }
  }

  public onColonyAddedToLeavitt(player: IPlayer) {
    this.onScienceTagAdded(player, 1);
  }
  public onScienceTagAdded(player: IPlayer, count: number) {
    const game = player.game;
    for (let i = 0; i < count; i++) {
      player.defer(() => {
        if (this.isDisabled) return undefined;

        if (this.resourceCount > 0) {
          if (player.canAfford({cost: 0, tr: {tr: 1}}) === false) {
            // TODO (Lynesth): Remove this when #1670 is fixed
            game.log('${0} cannot remove a disease from ${1} to gain 1 TR because of unaffordable Reds policy cost', (b) => b.player(player).card(this));
          } else {
            player.removeResourceFrom(this, 1);
            player.increaseTerraformRating();
            game.log('${0} removed a disease from ${1} to gain 1 TR', (b) => b.player(player).card(this));
          }
          return undefined;
        }

        if (player.canAfford({cost: 0, tr: {tr: 3}}) === false) {
          // TODO (Lynesth): Remove this when #1670 is fixed
          game.log('${0} cannot turn ${1} face down to gain 3 TR because of unaffordable Reds policy cost', (b) => b.player(player).card(this));
          return undefined;
        }

        return new OrOptions(
          new SelectOption('Turn this card face down and gain 3 TR', 'Gain TR').andThen(() => {
            this.isDisabled = true;
            player.increaseTerraformRating(3);
            game.log('${0} turned ${1} face down to gain 3 TR', (b) => b.player(player).card(this));
            return undefined;
          }),
          new SelectOption('Do nothing', 'Do nothing'),
        );
      }, Priority.SUPERPOWER); // Make it a priority
    }
  }

  public serialize(serialized: SerializedCard) {
    serialized.isDisabled = this.isDisabled;
  }

  public deserialize(serialized: SerializedCard) {
    this.isDisabled = Boolean(serialized.isDisabled);
  }
}

================
File: cards/promo/Philares.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {Space} from '../../boards/Space';
import {CardName} from '../../../common/cards/CardName';
import {Priority} from '../../deferredActions/Priority';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {BoardType} from '../../boards/BoardType';
import {all} from '../Options';
import {SelectResources} from '../../inputs/SelectResources';
import {message} from '../../logs/MessageBuilder';

export class Philares extends CorporationCard {
  constructor() {
    super({
      name: CardName.PHILARES,
      tags: [Tag.BUILDING],
      startingMegaCredits: 47,

      firstAction: {
        text: 'Place a greenery tile and raise the oxygen 1 step',
        greenery: {},
      },

      metadata: {
        cardNumber: 'R25',
        hasExternalHelp: true,
        description: 'You start with 47 M€. As your first action, place a greenery tile and raise the oxygen 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(47).nbsp.greenery();
          b.corpBox('effect', (ce) => {
            ce.effect('Each new adjacency between your tile and an opponent\'s tile gives you a standard resource of your choice [regardless of who just placed a tile].', (eb) => {
              eb.emptyTile('normal', {size: Size.SMALL, all}).nbsp;
              eb.emptyTile('normal', {size: Size.SMALL}).startEffect.wild(1);
            });
          });
        }),
      },
    });
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space, boardType: BoardType) {
    // Nerfing on The Moon.
    if (boardType !== BoardType.MARS) {
      return;
    }

    if (space.player === undefined) {
      return;
    }
    const adjacentSpaces = cardOwner.game.board.getAdjacentSpaces(space);
    const adjacentSpacesWithPlayerTiles = adjacentSpaces.filter((space) => space.tile !== undefined && space.player !== undefined);

    const eligibleTiles = (cardOwner.id === activePlayer.id) ?
      adjacentSpacesWithPlayerTiles.filter((space) => space.player?.id !== cardOwner.id) :
      adjacentSpacesWithPlayerTiles.filter((space) => space.player?.id === cardOwner.id);

    const count = eligibleTiles.length;
    if (count > 0) {
      cardOwner.defer(() => {
        cardOwner.game.log('${0} must select ${1} bonus resource(s) from ${2}\' ability', (b) => b.player(cardOwner).number(count).card(this));
        return new SelectResources(message('Gain ${0} standard resources', (b) => b.number(count)), count)
          .andThen((units) => {
            cardOwner.stock.addUnits(units, {log: true});
            return undefined;
          });
      },
      cardOwner.id !== activePlayer.id ? Priority.OPPONENT_TRIGGER : Priority.GAIN_RESOURCE_OR_PRODUCTION,
      );
    }
  }
}

================
File: cards/promo/Potatoes.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Potatoes extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.POTATOES,
      tags: [Tag.PLANT],
      cost: 2,

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'X28',
        renderData: CardRenderer.builder((b) => {
          b.minus().plants(2).nbsp.production((pb) => pb.megacredits(2));
        }),
        description: 'Lose 2 plants. Increase your M€ production 2 steps.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    const viralEnhancers = player.playedCards.find((card) => card.name === CardName.VIRAL_ENHANCERS);
    const hasEnoughPlants = player.plants >= 2 || player.plants >= 1 && viralEnhancers !== undefined;

    return hasEnoughPlants;
  }

  public override bespokePlay(player: IPlayer) {
    player.plants -= 2;
    return undefined;
  }
}

================
File: cards/promo/ProjectInspection.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {IActionCard, ICard, isIActionCard, isIHasCheckLoops} from '../ICard';
import {SelectCard} from '../../inputs/SelectCard';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class ProjectInspection extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.PROJECT_INSPECTION,
      cost: 0,

      metadata: {
        cardNumber: 'X02',
        renderData: CardRenderer.builder((b) => {
          b.text('Use a card action that has been used this generation.', Size.SMALL, true);
        }),
      },
    });
  }

  // This matches Viron.getActionCards.
  private getActionCards(player: IPlayer): Array<IActionCard & ICard> {
    const result = [];

    for (const playedCard of player.tableau) {
      if (playedCard === this) {
        continue;
      }
      if (!isIActionCard(playedCard)) {
        continue;
      }
      if (isIHasCheckLoops(playedCard) && playedCard.getCheckLoops() >= 2) {
        continue;
      }
      if (player.getActionsThisGeneration().has(playedCard.name) && playedCard.canAct(player)) {
        result.push(playedCard);
      }
    }
    return result;
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return this.getActionCards(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    const actionCards = this.getActionCards(player);
    if (actionCards.length === 0 ) {
      return undefined;
    }
    return new SelectCard<IActionCard & ICard>(
      'Perform an action from a played card again',
      'Take action',
      actionCards)
      .andThen(([card]) => {
        const foundCard = card;
        player.game.log('${0} used ${1} action with ${2}', (b) => b.player(player).card(foundCard).card(this));
        return foundCard.action(player);
      });
  }
}

================
File: cards/promo/PromoCardManifest.ts
================
import {CardName} from '../../../common/cards/CardName';
import {ModuleManifest} from '../ModuleManifest';
import {Advertising} from './Advertising';
import {AntidesertificationTechniques} from './AntidesertificationTechniques';
import {AqueductSystems} from './AqueductSystems';
import {ArcadianCommunities} from './ArcadianCommunities';
import {AsteroidDeflectionSystem} from './AsteroidDeflectionSystem';
import {AsteroidHollowing} from './AsteroidHollowing';
import {AsteroidRights} from './AsteroidRights';
import {AstraMechanica} from './AstraMechanica';
import {Astrodrill} from './Astrodrill';
import {BactoviralResearch} from './BactoviralResearch';
import {BioPrintingFacility} from './BioPrintingFacility';
import {CarbonNanosystems} from './CarbonNanosystems';
import {CityPark} from './CityPark';
import {CometAiming} from './CometAiming';
import {CorporateArchives} from './CorporateArchives';
import {CrashSiteCleanup} from './CrashSiteCleanup';
import {CuttingEdgeTechnology} from './CuttingEdgeTechnology';
import {CyberiaSystems} from './CyberiaSystems';
import {DeimosDownPromo} from './DeimosDownPromo';
import {DirectedHeatUsage} from './DirectedHeatUsage';
import {DirectedImpactors} from './DirectedImpactors';
import {DiversitySupport} from './DiversitySupport';
import {DoubleDown} from './DoubleDown';
import {DuskLaserMining} from './DuskLaserMining';
import {EnergyMarket} from './EnergyMarket';
import {Factorum} from './Factorum';
import {FieldCappedCity} from './FieldCappedCity';
import {FloydContinuum} from './FloydContinuum';
import {GiantSolarCollector} from './GiantSolarCollector';
import {GreatDamPromo} from './GreatDamPromo';
import {Harvest} from './Harvest';
// import {HeadStart} from './HeadStart';
import {HermeticOrderOfMars} from './HermeticOrderofMars';
import {HiTechLab} from './HiTechLab';
import {HomeostasisBureau} from './HomeostasisBureau';
import {IcyImpactors} from './IcyImpactors';
import {ImportedNutrients} from './ImportedNutrients';
import {InterplanetaryTrade} from './InterplanetaryTrade';
import {JovianEmbassy} from './JovianEmbassy';
import {KaguyaTech} from './KaguyaTech';
import {KuiperCooperative} from './KuiperCooperative';
import {LawSuit} from './LawSuit';
import {MagneticFieldGeneratorsPromo} from './MagneticFieldGeneratorsPromo';
import {MagneticShield} from './MagneticShield';
import {MarsNomads} from './MarsNomads';
import {MartianLumberCorp} from './MartianLumberCorp';
import {MeatIndustry} from './MeatIndustry';
import {Meltworks} from './Meltworks';
import {MercurianAlloys} from './MercurianAlloys';
import {Merger} from './Merger';
import {MoholeLake} from './MoholeLake';
import {MonsInsurance} from './MonsInsurance';
import {NeptunianPowerConsultants} from './NeptunianPowerConsultants';
import {NewPartner} from './NewPartner';
import {OrbitalCleanup} from './OrbitalCleanup';
import {OutdoorSports} from './OutdoorSports';
import {Penguins} from './Penguins';
import {PharmacyUnion} from './PharmacyUnion';
import {Philares} from './Philares';
import {Potatoes} from './Potatoes';
import {ProjectInspection} from './ProjectInspection';
import {Psyche} from './16Psyche';
import {Recyclon} from './Recyclon';
import {RedShips} from './RedShips';
import {RegoPlastics} from './RegoPlastics';
import {RobotPollinators} from './RobotPollinators';
import {SaturnSurfing} from './SaturnSurfing';
import {SelfReplicatingRobots} from './SelfReplicatingRobots';
import {SmallAsteroid} from './SmallAsteroid';
import {SnowAlgae} from './SnowAlgae';
import {SoilEnrichment} from './SoilEnrichment';
import {SolarLogistics} from './SolarLogistics';
import {Splice} from './Splice';
import {StanfordTorus} from './StanfordTorus';
import {StJosephOfCupertinoMission} from './StJosephOfCupertinoMission';
import {SubCrustMeasurements} from './SubCrustMeasurements';
import {Supercapacitors} from './Supercapacitors';
import {Supermarkets} from './Supermarkets';
import {Teslaract} from './Teslaract';
import {TopsoilContract} from './TopsoilContract';
import {TychoMagnetics} from './TychoMagnetics';

export const PROMO_CARD_MANIFEST = new ModuleManifest({
  module: 'promo',
  projectCards: {
    [CardName.PENGUINS]: {Factory: Penguins},
    [CardName.SELF_REPLICATING_ROBOTS]: {Factory: SelfReplicatingRobots},
    [CardName.SMALL_ASTEROID]: {Factory: SmallAsteroid},
    [CardName.SNOW_ALGAE]: {Factory: SnowAlgae},
    [CardName.DUSK_LASER_MINING]: {Factory: DuskLaserMining},
    [CardName.MERCURIAN_ALLOYS]: {Factory: MercurianAlloys},
    [CardName.REGO_PLASTICS]: {Factory: RegoPlastics},
    [CardName.INTERPLANETARY_TRADE]: {Factory: InterplanetaryTrade},
    [CardName.ORBITAL_CLEANUP]: {Factory: OrbitalCleanup},
    [CardName.PROJECT_INSPECTION]: {Factory: ProjectInspection},
    [CardName.HI_TECH_LAB]: {Factory: HiTechLab},
    [CardName.ENERGY_MARKET]: {Factory: EnergyMarket},
    [CardName.LAW_SUIT]: {Factory: LawSuit},
    [CardName.STANFORD_TORUS]: {Factory: StanfordTorus},
    [CardName.ASTEROID_HOLLOWING]: {Factory: AsteroidHollowing},
    [CardName.ASTEROID_RIGHTS]: {Factory: AsteroidRights},
    [CardName.COMET_AIMING]: {Factory: CometAiming},
    [CardName.CUTTING_EDGE_TECHNOLOGY]: {Factory: CuttingEdgeTechnology},
    [CardName.CRASH_SITE_CLEANUP]: {Factory: CrashSiteCleanup},
    [CardName.DIRECTED_IMPACTORS]: {Factory: DirectedImpactors},
    [CardName.FIELD_CAPPED_CITY]: {Factory: FieldCappedCity},
    [CardName.MAGNETIC_SHIELD]: {Factory: MagneticShield},
    [CardName.MELTWORKS]: {Factory: Meltworks},
    [CardName.MOHOLE_LAKE]: {Factory: MoholeLake},
    [CardName.DIVERSITY_SUPPORT]: {Factory: DiversitySupport},
    [CardName.JOVIAN_EMBASSY]: {Factory: JovianEmbassy},
    [CardName.TOPSOIL_CONTRACT]: {Factory: TopsoilContract},
    [CardName.IMPORTED_NUTRIENTS]: {Factory: ImportedNutrients},
    [CardName.ASTEROID_DEFLECTION_SYSTEM]: {Factory: AsteroidDeflectionSystem},
    [CardName.SUB_CRUST_MEASUREMENTS]: {Factory: SubCrustMeasurements},
    [CardName.POTATOES]: {Factory: Potatoes},
    [CardName.MEAT_INDUSTRY]: {Factory: MeatIndustry},
    [CardName.ADVERTISING]: {Factory: Advertising},
    [CardName.DEIMOS_DOWN_PROMO]: {Factory: DeimosDownPromo},
    [CardName.GREAT_DAM_PROMO]: {Factory: GreatDamPromo},
    [CardName.MAGNETIC_FIELD_GENERATORS_PROMO]: {Factory: MagneticFieldGeneratorsPromo},
    [CardName.SATURN_SURFING]: {Factory: SaturnSurfing},
    [CardName.BIO_PRINTING_FACILITY]: {Factory: BioPrintingFacility},
    [CardName.BACTOVIRAL_RESEARCH]: {Factory: BactoviralResearch},
    [CardName.HARVEST]: {Factory: Harvest},
    [CardName.OUTDOOR_SPORTS]: {Factory: OutdoorSports},
    [CardName.PSYCHE]: {Factory: Psyche},
    [CardName.ROBOT_POLLINATORS]: {Factory: RobotPollinators},
    [CardName.SUPERCAPACITORS]: {Factory: Supercapacitors},
    [CardName.FLOYD_CONTINUUM]: {Factory: FloydContinuum},
    [CardName.AQUEDUCT_SYSTEMS]: {Factory: AqueductSystems},
    [CardName.ASTRA_MECHANICA]: {Factory: AstraMechanica},
    [CardName.ST_JOSEPH_OF_CUPERTINO_MISSION]: {Factory: StJosephOfCupertinoMission},
    [CardName.CARBON_NANOSYSTEMS]: {Factory: CarbonNanosystems},
    [CardName.CYBERIA_SYSTEMS]: {Factory: CyberiaSystems},
    [CardName.HERMETIC_ORDER_OF_MARS]: {Factory: HermeticOrderOfMars},
    [CardName.HOMEOSTASIS_BUREAU]: {Factory: HomeostasisBureau},
    [CardName.KAGUYA_TECH]: {Factory: KaguyaTech},
    [CardName.MARS_NOMADS]: {Factory: MarsNomads},
    [CardName.NEPTUNIAN_POWER_CONSULTANTS]: {Factory: NeptunianPowerConsultants},
    [CardName.MARTIAN_LUMBER_CORP]: {Factory: MartianLumberCorp},
    [CardName.RED_SHIPS]: {Factory: RedShips},
    [CardName.SOLAR_LOGISTICS]: {Factory: SolarLogistics},
    [CardName.TESLARACT]: {Factory: Teslaract},
    [CardName.DIRECTED_HEAT_USAGE]: {Factory: DirectedHeatUsage},
    [CardName.ICY_IMPACTORS]: {Factory: IcyImpactors},
    [CardName.SOIL_ENRICHMENT]: {Factory: SoilEnrichment},
    [CardName.CITY_PARK]: {Factory: CityPark},
    [CardName.SUPERMARKETS]: {Factory: Supermarkets},
  },

  preludeCards: {
    [CardName.NEW_PARTNER]: {Factory: NewPartner},
    [CardName.MERGER]: {Factory: Merger},
    [CardName.CORPORATE_ARCHIVES]: {Factory: CorporateArchives},
    [CardName.DOUBLE_DOWN]: {Factory: DoubleDown, compatibility: 'prelude'},
    // [CardName.HEAD_START]: {Factory: HeadStart}, // Head Start is disabled because it's not working well.
    [CardName.ANTI_DESERTIFICATION_TECHNIQUES]: {Factory: AntidesertificationTechniques},
    // [CardName.ESTABLISHED_METHODS]: {Factory: EstablishedMethods},
    [CardName.GIANT_SOLAR_COLLECTOR]: {Factory: GiantSolarCollector, compatibility: 'venus'},
  },

  cardsToRemove: [
    CardName.DEIMOS_DOWN,
    CardName.GREAT_DAM,
    CardName.MAGNETIC_FIELD_GENERATORS],

  corporationCards: {
    [CardName.ARCADIAN_COMMUNITIES]: {Factory: ArcadianCommunities},
    [CardName.ASTRODRILL]: {Factory: Astrodrill},
    [CardName.FACTORUM]: {Factory: Factorum},
    [CardName.PHARMACY_UNION]: {Factory: PharmacyUnion},
    [CardName.PHILARES]: {Factory: Philares},
    [CardName.MONS_INSURANCE]: {Factory: MonsInsurance},
    [CardName.RECYCLON]: {Factory: Recyclon},
    [CardName.SPLICE]: {Factory: Splice},
    [CardName.TYCHO_MAGNETICS]: {Factory: TychoMagnetics},
    [CardName.KUIPER_COOPERATIVE]: {Factory: KuiperCooperative},
  },
});

================
File: cards/promo/Recyclon.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {CardResource} from '../../../common/CardResource';
import {ICorporationCard} from '../corporation/ICorporationCard';
import {ICard} from '../ICard';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class Recyclon extends CorporationCard {
  constructor() {
    super({
      name: CardName.RECYCLON,
      tags: [Tag.MICROBE, Tag.BUILDING],
      startingMegaCredits: 38,
      resourceType: CardResource.MICROBE,

      behavior: {
        production: {steel: 1},
        addResources: 1,
      },

      metadata: {
        cardNumber: 'R26',
        description: 'You start with 38 M€ and 1 steel production.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.megacredits(38).nbsp.production((pb) => pb.steel(1));
          b.corpBox('effect', (ce) => {
            ce.effect('When you play a building tag, including this, gain 1 microbe to this card, or remove 2 microbes here and raise your plant production 1 step.', (eb) => {
              eb.tag(Tag.BUILDING).colon().resource(CardResource.MICROBE).or();
              eb.resource(CardResource.MICROBE, {amount: 2, digit}).startEffect.production((pb) => pb.plants(1));
            });
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: ICard) {
    if (!player.isCorporation(this.name)) {
      return undefined;
    }

    if (card.tags.includes(Tag.BUILDING) === false || !player.isCorporation(this.name)) {
      return undefined;
    }
    if (this.resourceCount < 2) {
      player.addResourceTo(this);
      return undefined;
    }

    const addResource = new SelectOption('Add a microbe resource to this card', 'Add microbe').andThen(() => {
      player.addResourceTo(this);
      return undefined;
    });

    const spendResource = new SelectOption('Remove 2 microbes on this card and increase plant production 1 step', 'Remove microbes').andThen(() => {
      player.removeResourceFrom(this, 2);
      player.production.add(Resource.PLANTS, 1);
      return undefined;
    });
    return new OrOptions(spendResource, addResource);
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    return this.onCardPlayed(player, card);
  }
}

================
File: cards/promo/RedShips.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {Resource} from '../../../common/Resource';
import {Board, isSpecialTileSpace} from '../../boards/Board';
import {IActionCard} from '../ICard';

export class RedShips extends Card implements IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.RED_SHIPS,
      cost: 2,

      requirements: {oxygen: 4},

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.action('Gain 1 M€ for each CITY AND SPECIAL TILE adjacent to an ocean.',
            (ab) => ab.empty().startAction.megacredits(1).cityorSpecialTile({all}).oceans(1));
        }),
        description: 'Requires 4% oxygen.',
      },
    });
  }

  canAct(): boolean {
    return true;
  }

  action(player: IPlayer): undefined {
    const board = player.game.board;
    const candidates = board.spaces.filter((space) => {
      return Board.isCitySpace(space) || isSpecialTileSpace(space);
    });
    const included = candidates.filter(
      (space) => board.getAdjacentSpaces(space).some((adj) => Board.isOceanSpace(adj)));

    const megacredits = included.length;
    if (megacredits === 0) {
      player.game.log('${0} gained 0 M€ from ${1} action.', (b) => b.player(player).card(this));
    }
    player.stock.add(Resource.MEGACREDITS, megacredits, {log: true});

    return undefined;
  }
}

================
File: cards/promo/RegoPlastics.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class RegoPlastics extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.REGO_PLASTICS,
      tags: [Tag.BUILDING],
      cost: 10,
      victoryPoints: 1,

      behavior: {
        steelValue: 1,
      },

      metadata: {
        cardNumber: 'X10',
        renderData: CardRenderer.builder((b) => {
          b.effect('Your steel resources are worth 1 M€ extra.', (eb) => {
            eb.steel(1).startEffect.plus(Size.SMALL).megacredits(1);
          });
        }),
      },
    });
  }
}

================
File: cards/promo/RobotPollinators.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class RobotPollinators extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ROBOT_POLLINATORS,
      cost: 9,
      requirements: {oxygen: 4},
      behavior: {
        production: {plants: 1},
        stock: {plants: {tag: Tag.PLANT}},
      },

      metadata: {
        cardNumber: 'X45',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1)).br.plants(1).slash().tag(Tag.PLANT);
        }),
        description: 'Requires 4% oxygen. Increase your plant production 1 step. Gain 1 plant for every plant tag you have.',
      },
    });
  }
}

================
File: cards/promo/SaturnSurfing.ts
================
import {IProjectCard} from '../IProjectCard';
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';

export class SaturnSurfing extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SATURN_SURFING,
      cost: 13,
      tags: [Tag.JOVIAN, Tag.EARTH],
      resourceType: CardResource.FLOATER,
      victoryPoints: 1,

      behavior: {
        addResources: {tag: Tag.EARTH},
      },

      metadata: {
        cardNumber: 'X11',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 floater from here to gain 1 M€ from each floater here, INCLUDING THE PAID FLOATER. Max 5.', (eb) => {
            eb.resource(CardResource.FLOATER).startAction.megacredits(1).slash().resource(CardResource.FLOATER);
            eb.asterix().text('max 5');
          }).br;
          b.resource(CardResource.FLOATER).slash().tag(Tag.EARTH);
        }),
        description: 'Add 1 floater here for every Earth tag you have, including this.',
      },
    });
  }

  public canAct(): boolean {
    return this.resourceCount > 0;
  }

  public action(player: IPlayer) {
    player.stock.add(Resource.MEGACREDITS, Math.min(5, this.resourceCount--));
    return undefined;
  }
}

================
File: cards/promo/SelfReplicatingRobots.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {SelectCard} from '../../inputs/SelectCard';
import {OrOptions} from '../../inputs/OrOptions';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class SelfReplicatingRobots extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SELF_REPLICATING_ROBOTS,
      cost: 7,

      requirements: {tag: Tag.SCIENCE, count: 2},
      metadata: {
        cardNumber: '210',
        renderData: CardRenderer.builder((b) => {
          b.action('Reveal and place a SPACE OR BUILDING card here from hand, and place 2 resources on it, OR double the resources on a card here.', (eb) => {
            eb.empty().startAction.selfReplicatingRobots();
            eb.nbsp.or().nbsp.arrow().multiplierWhite().text('x2');
          }).br;
          b.text('Effect: Card here may be played as if from hand with its cost reduced by the number of resources on it.', Size.TINY, true);
        }),
        description: 'Requires 2 science tags.',
      },
    });
  }

  public targetCards: Array<IProjectCard> = [];

  public override getCardDiscount(_player: IPlayer, card: IProjectCard): number {
    return this.targetCards.find((c) => c.name === card.name)?.resourceCount ?? 0;
  }

  public canAct(player: IPlayer): boolean {
    return this.targetCards.length > 0 ||
             player.cardsInHand.some((card) => card.tags.some((tag) => tag === Tag.SPACE || tag === Tag.BUILDING));
  }

  public action(player: IPlayer) {
    const orOptions = new OrOptions();
    const selectableCards = player.cardsInHand.filter((card) => card.tags.some((tag) => tag === Tag.SPACE || tag === Tag.BUILDING));

    if (this.targetCards.length > 0) {
      orOptions.options.push(new SelectCard(
        'Select card to double robots resource', 'Double resource', this.targetCards, {played: CardName.SELF_REPLICATING_ROBOTS})
        .andThen(([card]) => {
          const resourceCount = card.resourceCount;
          card.resourceCount *= 2;
          player.game.log('${0} doubled resources on ${1} from ${2} to ${3}', (b) => {
            b.player(player).card(card).number(resourceCount).number(card.resourceCount);
          });
          return undefined;
        }));
    }

    if (selectableCards.length > 0) {
      orOptions.options.push(new SelectCard(
        'Select card to link with Self-replicating Robots',
        'Link card', selectableCards,
        {played: CardName.SELF_REPLICATING_ROBOTS}).andThen(
        ([card]) => {
          const projectCardIndex = player.cardsInHand.findIndex((c) => c.name === card.name);
          player.cardsInHand.splice(projectCardIndex, 1);
          this.targetCards.push(card);
          card.resourceCount = 2;
          player.game.log('${0} linked ${1} with ${2}', (b) => b.player(player).card(card).card(this));
          return undefined;
        }));
    }

    return orOptions;
  }
}

================
File: cards/promo/SmallAsteroid.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class SmallAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SMALL_ASTEROID,
      tags: [Tag.SPACE],
      cost: 10,

      behavior: {
        global: {temperature: 1},
        removeAnyPlants: 2,
      },

      metadata: {
        cardNumber: '209',
        renderData: CardRenderer.builder((b) => {
          b.temperature(1).br;
          b.minus().plants(2, {all});
        }),
        description: 'Increase temperature 1 step. Remove up to 2 plants from any player.',
      },
    });
  }
}

================
File: cards/promo/SnowAlgae.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class SnowAlgae extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SNOW_ALGAE,
      cost: 12,
      tags: [Tag.PLANT],

      behavior: {
        production: {plants: 1, heat: 1},
      },

      requirements: {oceans: 2},
      metadata: {
        cardNumber: '211',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.plants(1).heat(1);
          });
        }),
        description: 'Requires 2 oceans. Increase your plant production and your heat production 1 step each.',
      },
    });
  }
}

================
File: cards/promo/SoilEnrichment.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {SelectCard} from '../../inputs/SelectCard';
import {Resource} from '../../../common/Resource';

export class SoilEnrichment extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SOIL_ENRICHMENT,
      tags: [Tag.MICROBE, Tag.PLANT],
      cost: 6,

      metadata: {
        description: 'Spend 1 microbe from ANY of your cards to gain 5 plants',
        cardNumber: 'X67',
        renderData: CardRenderer.builder((b) => {
          b.minus().resource(CardResource.MICROBE).asterix().nbsp.plus().plants(5, {digit});
        }),
      },
    });
  }

  private eligibleCards(player: IPlayer) {
    return player.getCardsWithResources(CardResource.MICROBE);
  }

  public override bespokeCanPlay(player: IPlayer) {
    return this.eligibleCards(player).length > 0;
  }

  public override play(player: IPlayer) {
    return new SelectCard('Select card to remove 1 microbe from', 'Select', this.eligibleCards(player))
      .andThen(([card]) => {
        player.removeResourceFrom(card);
        player.stock.add(Resource.PLANTS, 5);
        player.game.log('${0} removed 1 microbe from ${1} to gain 5 plants', (b) => b.player(player).card(card));
        return undefined;
      });
  }
}

================
File: cards/promo/SolarLogistics.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {all} from '../Options';
import {IProjectCard} from '../IProjectCard';

export class SolarLogistics extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SOLAR_LOGISTICS,
      cost: 20,
      tags: [Tag.EARTH, Tag.SPACE],

      behavior: {
        stock: {titanium: 2},
      },
      victoryPoints: 1,
      cardDiscount: {tag: Tag.EARTH, amount: 2},

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play an Earth tag, you pay 2 M€ less.',
            (eb) => eb.tag(Tag.EARTH).startEffect.megacredits(-2));
          b.br;
          b.effect('When any player plays a space event, draw a card.',
            (eb) => eb.tag(Tag.SPACE, {all}).tag(Tag.EVENT, {all}).startEffect.cards(1));
          b.br;
          b.titanium(2);
        }),
        description: 'Gain 2 titanium.',
      },
    });
  }

  public onCardPlayedFromAnyPlayer(thisCardOwner: IPlayer, _playedCardOwner: IPlayer, card: IProjectCard) {
    if (card.type === CardType.EVENT && card.tags.includes(Tag.SPACE)) {
      thisCardOwner.drawCard(1);
    }
    return undefined;
  }
}

================
File: cards/promo/Splice.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {ICorporationCard} from '../corporation/ICorporationCard';
import {CorporationCard} from '../corporation/CorporationCard';
import {SelectOption} from '../../inputs/SelectOption';
import {OrOptions} from '../../inputs/OrOptions';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {Resource} from '../../../common/Resource';
import {all} from '../Options';
import {message} from '../../logs/MessageBuilder';
import {ICard} from '../ICard';
import {GainResources} from '../../deferredActions/GainResources';

export class Splice extends CorporationCard {
  constructor() {
    super({
      name: CardName.SPLICE,
      tags: [Tag.MICROBE],
      startingMegaCredits: 48, // 44 + 4 as card resolution when played

      firstAction: {
        text: 'Draw a card with a microbe tag',
        drawCard: {count: 1, tag: Tag.MICROBE},
      },

      metadata: {
        cardNumber: 'R28',
        description: 'You start with 44 M€. As your first action, reveal cards until you have revealed a microbe tag. Take it and discard the rest.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(44).nbsp.cards(1, {secondaryTag: Tag.MICROBE});
          b.corpBox('effect', (ce) => {
            ce.vSpace(Size.LARGE);
            ce.effect(undefined, (eb) => {
              eb.tag(Tag.MICROBE, {all}).startEffect;
              eb.megacredits(2, {all}).or().resource(CardResource.MICROBE, {all}).asterix();
            });
            ce.vSpace();
            ce.effect('when a microbe tag is played, incl. this, THAT PLAYER gains 2 M€, or adds a microbe to THAT card, and you gain 2 M€.', (eb) => {
              eb.tag(Tag.MICROBE, {all}).startEffect;
              eb.megacredits(2);
            });
          });
        }),
      },
    });
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    return this.onCardPlayed(player, card);
  }

  public onCardPlayed(player: IPlayer, card: ICard): undefined {
    const game = player.game;
    const microbeTags = player.tags.cardTagCount(card, Tag.MICROBE);
    if (microbeTags === 0) {
      return;
    }

    const gain = microbeTags * 2;

    const gainResource = new SelectOption('Add a microbe resource to this card', 'Add microbe').andThen(() => {
      player.addResourceTo(card);
      return undefined;
    });

    const gainMC = new SelectOption(
      message('Gain ${0} M€', (b) => b.number(gain)),
      'Gain M€')
      .andThen(() => {
        game.defer(new GainResources(player, Resource.MEGACREDITS, {count: gain, log: true, from: this}));
        return undefined;
      });

    // Splice owner gets 2M€ per microbe tag
    const cardPlayer = game.getCardPlayerOrThrow(this.name);
    game.defer(new GainResources(cardPlayer, Resource.MEGACREDITS, {count: gain, log: true, from: this}));

    if (card.resourceType === CardResource.MICROBE) {
      // Card player chooses between 2 M€ and a microbe on card, if possible
      player.defer(new OrOptions(gainResource, gainMC));
    } else {
      gainMC.cb(undefined);
    }
    return undefined;
  }
}

================
File: cards/promo/StanfordTorus.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {SpaceName} from '../../SpaceName';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class StanfordTorus extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.STANFORD_TORUS,
      tags: [Tag.SPACE, Tag.CITY],
      cost: 12,
      victoryPoints: 2,

      behavior: {
        city: {space: SpaceName.STANFORD_TORUS},
      },

      metadata: {
        cardNumber: 'X12',
        renderData: CardRenderer.builder((b) => {
          b.city().asterix();
        }),
        description: 'Place a city tile IN SPACE, outside and separate from the planet.',
      },
    });
  }
}

================
File: cards/promo/StJosephOfCupertinoMission.ts
================
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IActionCard} from '../ICard';
import {IPlayer} from '../../IPlayer';
import {IGame} from '../../IGame';
import {Space} from '../../boards/Space';
import {SelectSpace} from '../../inputs/SelectSpace';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectPayment} from '../../inputs/SelectPayment';
import {TITLES} from '../../inputs/titles';
import {message} from '../../logs/MessageBuilder';

export class StJosephOfCupertinoMission extends Card implements IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ST_JOSEPH_OF_CUPERTINO_MISSION,
      cost: 7,
      victoryPoints: 'special',

      metadata: {
        cardNumber: 'X29',
        renderData: CardRenderer.builder((b) => {
          b.action('Pay 5 M€ (STEEL MAY BE USED) to build  1 Cathedral in a city. Max 1 per city. City owner can pay 2 M€  to draw 1 card.', (eb) => {
            eb.megacredits(5).super((b) => b.steel(1)).startAction.cathedral().asterix();
          });
        }),
        description: '1 VP per City with a Cathedral in it.',
        victoryPoints: CardRenderDynamicVictoryPoints.cathedral(),
      },
    });
  }

  private getEligibleCities(game: IGame): Array<Space> {
    return game.board.getCities().filter((space) => !game.stJosephCathedrals.includes(space.id));
  }

  canAct(player: IPlayer): boolean {
    return this.getEligibleCities(player.game).length > 0 && player.canAfford({cost: 5, steel: true});
  }

  action(player: IPlayer): undefined {
    const cities = this.getEligibleCities(player.game);
    if (cities.length === 0) {
      return undefined;
    }

    player.game.defer(new SelectPaymentDeferred(player, 5, {canUseSteel: true, title: TITLES.payForCardAction(this.name)}))
      .andThen(() => {
        // TODO(kberg): get player.defer to return AndThen<Space>
        player.defer(new SelectSpace(
          message('Select new space for ${0}', (b) => b.card(this)),
          cities)
          .andThen((space) => {
            player.game.stJosephCathedrals.push(space.id);
            const spaceOwner = space.player;
            if (spaceOwner === undefined || spaceOwner.color === 'neutral') {
              return undefined;
            }
            if (spaceOwner.canAfford(2)) {
              spaceOwner.defer(
                new OrOptions(
                  new SelectPayment('Pay 2 M€ to draw a card', 2, {})
                    .andThen((payment) => {
                    // TODO(kberg): pay should have an afterPay for the heat / floaters costs.
                      spaceOwner.pay(payment);
                      spaceOwner.drawCard();
                      return undefined;
                    }),
                  new SelectOption('Do not buy a card'),
                ));
            }
            return undefined;
          }));
      });
    return undefined;
  }

  public override getVictoryPoints(player: IPlayer) {
    return player.game.stJosephCathedrals.length;
  }
}

================
File: cards/promo/SubCrustMeasurements.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class SubCrustMeasurements extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SUB_CRUST_MEASUREMENTS,
      tags: [Tag.SCIENCE, Tag.BUILDING, Tag.EARTH],
      cost: 20,
      requirements: {tag: Tag.SCIENCE, count: 2},
      victoryPoints: 2,

      action: {
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'X29',
        renderData: CardRenderer.builder((b) => {
          b.action('Draw a card.', (eb) => {
            eb.empty().startAction.cards(1);
          });
        }),
        description: 'Requires 2 science tags.',
      },
    });
  }
}

================
File: cards/promo/Supercapacitors.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class Supercapacitors extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SUPERCAPACITORS,
      tags: [Tag.POWER, Tag.BUILDING],
      cost: 4,

      behavior: {
        production: {megacredits: 1},
        optionalEnergyConversion: true,
      },

      metadata: {
        cardNumber: 'X46',
        renderData: CardRenderer.builder((b) => {
          b.text('EFFECT: CONVERTING ENERGY TO HEAT DURING PRODUCTION IS OPTIONAL FOR EACH ENERGY RESOURCE.');
          b.br;
          b.production((pb) => pb.megacredits(1));
        }),
        description: 'Increase M€ production 1 step.',
      },
    });
  }
}

================
File: cards/promo/Supermarkets.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class Supermarkets extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.SUPERMARKETS,
      cost: 9,
      victoryPoints: 1,

      behavior: {
        production: {megacredits: 2},
      },

      requirements: {cities: 2, all},
      metadata: {
        cardNumber: 'X68',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2));
        }),
        description: 'Requires two cities in play. Increase your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/promo/Teslaract.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IActionCard} from '../ICard';
import {Units} from '../../../common/Units';
import {Tag} from '../../../common/cards/Tag';

export class Teslaract extends Card implements IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TESLARACT,
      cost: 14,
      tags: [Tag.POWER, Tag.BUILDING],

      behavior: {
        tr: 1,
      },

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 energy production to gain 1 plant production.',
            (ab) => ab.production((pb) => pb.energy(1)).startAction.production((pb) => pb.plants(1)));
          b.br;
          b.tr(1);
        }),
        description: 'Raise your TR 1 step.',
      },
    });
  }

  canAct(player: IPlayer): boolean {
    return player.production.energy > 0;
  }

  action(player: IPlayer): undefined {
    player.production.adjust(Units.of({energy: -1, plants: 1}));
    return undefined;
  }
}

================
File: cards/promo/TopsoilContract.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardRenderer} from '../render/CardRenderer';
import {ICard} from '../ICard';
import {CardResource} from '../../../common/CardResource';
import {Resource} from '../../../common/Resource';

export class TopsoilContract extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TOPSOIL_CONTRACT,
      tags: [Tag.MICROBE, Tag.EARTH],
      cost: 8,

      behavior: {
        stock: {plants: 3},
      },

      metadata: {
        cardNumber: 'X30',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you gain a microbe to ANY CARD, also gain 1 M€.', (eb) => {
            eb.resource(CardResource.MICROBE).asterix().startEffect.megacredits(1);
          }).br;
          b.plants(3);
        }),
        description: 'Gain 3 plants.',
      },
    });
  }

  public onResourceAdded(player: IPlayer, card: ICard, count: number) {
    if (card.resourceType === CardResource.MICROBE) {
      player.stock.add(Resource.MEGACREDITS, count, {log: true});
    }
  }
}

================
File: cards/promo/TychoMagnetics.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CorporationCard} from '../corporation/CorporationCard';
import {Resource} from '../../../common/Resource';
import {IPlayer} from '../../IPlayer';
import {SelectAmount} from '../../inputs/SelectAmount';

export class TychoMagnetics extends CorporationCard {
  constructor() {
    super({
      name: CardName.TYCHO_MAGNETICS,
      tags: [Tag.POWER, Tag.SCIENCE],
      startingMegaCredits: 42,
      behavior: {
        production: {energy: 1},
      },

      metadata: {
        cardNumber: '',
        description: 'You start with 42 M€. Increase your energy production 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.production((pb) => pb.energy(1)).nbsp.megacredits(42);
          b.corpBox('action', (cb) => {
            cb.action('Spend any amount of energy to draw the that many cards. Keep 1 and discard the rest.', (ab) => {
              ab.text('X').energy(1).startAction.text('X').cards(1).text('KEEP 1');
            });
          });
        }),
      },
    });
  }

  // TODO(kberg): this is a direct copy from hi-tech lab.
  public canAct(player: IPlayer): boolean {
    return player.energy > 0 && player.game.projectDeck.canDraw(1);
  }

  public action(player: IPlayer) {
    const max = Math.min(player.energy, player.game.projectDeck.size());
    return new SelectAmount('Select amount of energy to spend', 'OK', 1, max)
      .andThen((amount) => {
        player.stock.deduct(Resource.ENERGY, amount);
        player.game.log('${0} spent ${1} energy', (b) => b.player(player).number(amount));
        if (amount === 1) {
          player.drawCard();
          return undefined;
        }
        player.drawCardKeepSome(amount, {keepMax: 1});
        return undefined;
      });
  }
}

================
File: cards/ProxyCard.ts
================
import {CardType} from '../../common/cards/CardType';
import {CardName} from '../../common/cards/CardName';
import {CardMetadata} from '../../common/cards/CardMetadata';
import {Tag} from '../../common/cards/Tag';
import {IProjectCard} from './IProjectCard';
import {IPlayer} from '../IPlayer';
import {GlobalParameter} from '../../common/GlobalParameter';
import {Warning} from '../../common/cards/Warning';

const EMPTY_SET: Readonly<Set<Warning>> = new Set();

export class ProxyCard implements IProjectCard {
  public readonly name: CardName;
  public constructor(name: CardName) {
    this.name = name;
  }
  public get cost() {
    return 0;
  }
  public get tags(): Array<Tag> {
    return [];
  }
  public get type() {
    return CardType.PROXY;
  }
  public canPlay() {
    return false;
  }
  public get metadata(): CardMetadata {
    throw new Error(this.name + ' is a proxy card, not a real card. Should not render');
  }
  public play() {
    return undefined;
  }
  public get resourceCount() {
    return 0;
  }
  public getVictoryPoints() {
    return 0;
  }
  public get requirements() {
    return [];
  }
  public getGlobalParameterRequirementBonus(_player: IPlayer, _parameter: GlobalParameter): number {
    return 0;
  }
  public get tilesBuilt() {
    return [];
  }
  public get warnings() {
    return EMPTY_SET;
  }
}

================
File: cards/render/CardRenderDynamicVictoryPoints.ts
================
import {CardRenderItemType} from '../../../common/cards/render/CardRenderItemType';
import {ICardRenderDynamicVictoryPoints} from '../../../common/cards/render/ICardRenderDynamicVictoryPoints';
import {CardRenderItem} from './CardRenderItem';
import {Size} from '../../../common/cards/render/Size';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';

export class CardRenderDynamicVictoryPoints implements ICardRenderDynamicVictoryPoints {
  public targetOneOrMore: boolean = false; // marking target to be one or more res (Search for Life)
  public anyPlayer: boolean = false; // Law Suit
  public asterisk: boolean | undefined = undefined;
  public asFraction: boolean | undefined = undefined;

  constructor(public item: CardRenderItem | undefined, public points: number, public target: number) {}

  public static resource(resource: CardResource, points: number, target: number): CardRenderDynamicVictoryPoints {
    return new CardRenderDynamicVictoryPoints(new CardRenderItem(CardRenderItemType.RESOURCE, 1, {resource: resource}), points, target);
  }
  public static tag(tag: Tag, points: number, target: number): CardRenderDynamicVictoryPoints {
    return new CardRenderDynamicVictoryPoints(new CardRenderItem(CardRenderItemType.TAG, 1, {tag: tag}), points, target);
  }
  public static oceans(points: number, target: number): CardRenderDynamicVictoryPoints {
    const inner = new CardRenderItem(CardRenderItemType.OCEANS, -1, {size: Size.SMALL});
    const item = new CardRenderDynamicVictoryPoints(inner, points, target);
    item.asterisk = true;
    return item;
  }
  public static cities(points: number, target: number, any: boolean = false, asterisk: boolean = false): CardRenderDynamicVictoryPoints {
    const item = new CardRenderItem(CardRenderItemType.CITY);
    item.size = Size.SMALL;
    item.anyPlayer = any;
    const vps = new CardRenderDynamicVictoryPoints(item, points, target);
    vps.asterisk = asterisk;
    return vps;
  }
  public static searchForLife(): CardRenderDynamicVictoryPoints {
    const item = new CardRenderDynamicVictoryPoints(new CardRenderItem(CardRenderItemType.RESOURCE, 1, {resource: CardResource.SCIENCE}), 3, 3);
    item.targetOneOrMore = true;
    return item;
  }
  public static colonies(points: number, target: number, any: boolean = false): CardRenderDynamicVictoryPoints {
    const item = new CardRenderItem(CardRenderItemType.COLONIES);
    item.size = Size.SMALL;
    item.anyPlayer = any;
    return new CardRenderDynamicVictoryPoints(item, points, target);
  }
  public static moonMiningTile(points: number, any: boolean = false): CardRenderDynamicVictoryPoints {
    const item = new CardRenderItem(CardRenderItemType.MOON_MINE);
    item.size = Size.SMALL;
    item.anyPlayer = any;
    return new CardRenderDynamicVictoryPoints(item, points, points);
  }
  public static moonHabitatTile(points: number): CardRenderDynamicVictoryPoints {
    const item = new CardRenderItem(CardRenderItemType.MOON_HABITAT);
    item.size = Size.SMALL;
    return new CardRenderDynamicVictoryPoints(item, points, 1);
  }
  public static moonRoadTile(points: number, any: boolean = false): CardRenderDynamicVictoryPoints {
    const item = new CardRenderItem(CardRenderItemType.MOON_ROAD);
    item.size = Size.SMALL;
    item.anyPlayer = any;
    return new CardRenderDynamicVictoryPoints(item, points, 1);
  }
  public static cathedral(): CardRenderDynamicVictoryPoints {
    const item = new CardRenderItem(CardRenderItemType.CATHEDRAL);
    return new CardRenderDynamicVictoryPoints(item, 1, 1);
  }
  public static questionmark(points: number = 0, per: number = 0): CardRenderDynamicVictoryPoints {
    return new CardRenderDynamicVictoryPoints(undefined, points, per);
  }
  public static any(points: number): CardRenderDynamicVictoryPoints {
    const item = new CardRenderDynamicVictoryPoints(undefined, points, points);
    item.anyPlayer = true;
    return item;
  }
  public static undergroundShelters(): CardRenderDynamicVictoryPoints {
    const item = new CardRenderDynamicVictoryPoints(new CardRenderItem(CardRenderItemType.UNDERGROUND_SHELTERS), 1, 3);
    item.asterisk = true;
    item.asFraction = true;
    return item;
  }
}

================
File: cards/render/CardRenderer.ts
================
import {CardRenderItem, ItemOptions} from './CardRenderItem';
import {CardRenderSymbol} from './CardRenderSymbol';
import {Size} from '../../../common/cards/render/Size';
import {CardRenderItemType} from '../../../common/cards/render/CardRenderItemType';
import {TileType} from '../../../common/TileType';
import {ICardRenderCorpBoxAction, ICardRenderCorpBoxEffect, ICardRenderEffect, ICardRenderProductionBox, ICardRenderRoot, ICardRenderTile, ItemType, isICardRenderItem} from '../../../common/cards/render/Types';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {CardResource} from '../../../common/CardResource';
import {Tag} from '../../../common/cards/Tag';

export class CardRenderer {
  public static builder(f: (builder: Builder<CardRenderRoot>) => void): ICardRenderRoot {
    const builder = new RootBuilder();
    f(builder);
    return builder.build();
  }
}

class CardRenderRoot implements ICardRenderRoot {
  public readonly is ='root';
  constructor(public rows: Array<Array<ItemType>> = [[]]) {}
}

class CardRenderProductionBox implements ICardRenderProductionBox {
  public readonly is = 'production-box';
  constructor(public rows: Array<Array<ItemType>>) {}

  public static builder(f: (builder: ProductionBoxBuilder) => void): CardRenderProductionBox {
    const builder = new ProductionBoxBuilder();
    f(builder);
    return builder.build();
  }
}

class CardRenderTile implements ICardRenderTile {
  public readonly is = 'tile';
  constructor(public tile: TileType, public hasSymbol: boolean, public isAres: boolean) { }
}

class CardRenderEffect implements ICardRenderEffect {
  public readonly is = 'effect';
  constructor(public rows: Array<Array<ItemType>>) {}

  public static builder(f: (builder: EffectBuilder) => void): CardRenderEffect {
    const builder = new EffectBuilder();
    f(builder);
    return builder.build().validate();
  }

  private validate(): this {
    if (this.rows.length !== 3) {
      throw new Error('Card effect must have 3 arrays representing cause, delimiter and effect. If there is no cause, start with `empty`.');
    }
    if (this.rows[1].length !== 1) {
      throw new Error('Card effect delimiter array must contain exactly 1 item');
    }
    if (!(this.rows[1][0] instanceof CardRenderSymbol)) {
      throw new Error('Effect delimiter must be a symbol');
    }
    return this;
  }

  public set description(content: ItemType) {
    this.rows[2].push(content);
  }
}

class CardRenderCorpBoxEffect implements ICardRenderCorpBoxEffect {
  public readonly is = 'corp-box-effect';
  constructor(public rows: Array<Array<ItemType>>) { }

  public static builder(f: (builder: CorpEffectBuilderEffect) => void): CardRenderCorpBoxEffect {
    const builder = new CorpEffectBuilderEffect();
    f(builder);
    return builder.build();
  }
}

class CardRenderCorpBoxAction implements ICardRenderCorpBoxAction {
  public readonly is = 'corp-box-action';
  constructor(public rows: Array<Array<ItemType>>) { }

  public static builder(f: (builder: CorpEffectBuilderAction) => void): CardRenderCorpBoxAction {
    const builder = new CorpEffectBuilderAction();
    f(builder);
    return builder.build();
  }
}


abstract class Builder<T> {
  protected _data: Array<Array<ItemType>> = [[]];

  public abstract build(): T;

  protected _currentRow(): Array<ItemType> {
    if (this._data.length === 0) {
      throw new Error('No items in builder data!');
    }
    return this._data[this._data.length - 1];
  }

  protected _appendToRow(thing: ItemType): this {
    if (this.superscript && isICardRenderItem(thing)) {
      thing.isSuperscript = true;
    }
    this._currentRow().push(thing);
    return this;
  }

  public temperature(amount: number, options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.TEMPERATURE, amount, options));
  }

  public oceans(amount: number, options?: ItemOptions): this {
    // Is this necessary?
    const opts = options ?? {size: Size.MEDIUM};
    opts.size = opts.size ?? Size.MEDIUM;
    const item = new CardRenderItem(CardRenderItemType.OCEANS, amount, options);
    return this._appendToRow(item);
  }

  public oxygen(amount: number, options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.OXYGEN, amount, options));
  }

  public venus(amount: number, options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.VENUS, amount, options));
  }

  public plants(amount: number, options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.PLANTS, amount, options));
  }

  public heat(amount: number, options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.HEAT, amount, options));
  }

  public energy(amount: number, options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.ENERGY, amount, options));
  }

  public titanium(amount: number, options?: ItemOptions): this {
    const item = new CardRenderItem(CardRenderItemType.TITANIUM, amount, options);
    return this._appendToRow(item);
  }

  public steel(amount: number, options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.STEEL, amount, options));
  }

  public tr(amount: number, options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.TR, amount, options));
  }

  public megacredits(amount: number, options?: ItemOptions): this {
    const item = new CardRenderItem(CardRenderItemType.MEGACREDITS, amount, options);
    item.amountInside = true;
    item.showDigit = false;
    item.size = options?.size ?? Size.MEDIUM;
    return this._appendToRow(item);
  }

  public cards(amount: number, options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.CARDS, amount, options));
  }

  public trade(options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.TRADE, -1, options));
  }
  public tradeFleet(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.TRADE_FLEET));
  }

  public colonies(amount: number = 1, options?: ItemOptions): this {
    const item = new CardRenderItem(CardRenderItemType.COLONIES, amount, options);
    item.size = options?.size ?? Size.MEDIUM;
    return this._appendToRow(item);
  }

  public tradeDiscount(amount: number): this {
    const item = new CardRenderItem(CardRenderItemType.TRADE_DISCOUNT, amount * -1);
    item.amountInside = true;
    return this._appendToRow(item);
  }

  public colonyTile(options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.COLONY_TILE, -1, options));
  }

  public influence(options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.INFLUENCE, 1, options));
  }

  public city(options?: ItemOptions) {
    const item = new CardRenderItem(CardRenderItemType.CITY, -1, options);
    item.size = options?.size ?? Size.MEDIUM;
    return this._appendToRow(item);
  }

  /**
   * Add a greenery.
   *
   * size: the tile size. Default is medium.
   * withO2: Show the superscript oxygen icon. Defualt is true.
   * any: for all players, Default is false.
   */
  public greenery(options?: {size?: Size, withO2?: boolean, any?: boolean}) {
    const item = new CardRenderItem(CardRenderItemType.GREENERY);
    item.size = options?.size ?? Size.MEDIUM;
    if (options?.withO2 !== false) {
      item.secondaryTag = AltSecondaryTag.OXYGEN;
    }
    if (options?.any === true) {
      item.anyPlayer = true;
    }
    return this._appendToRow(item);
  }

  public delegates(amount: number, options?: ItemOptions) {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.DELEGATES, amount, options));
  }

  public partyLeaders(amount: number = -1) {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.PARTY_LEADERS, amount));
  }

  public chairman(options?: ItemOptions) {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.CHAIRMAN, -1, options));
  }

  public policy() {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.POLICY));
  }

  public globalEvent() {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.GLOBAL_EVENT));
  }

  public noTags() {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.NO_TAGS, -1));
  }

  public emptyTag(count: number = 1) {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.EMPTY_TAG, count));
  }

  public wild(amount: number, options?: ItemOptions) {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.WILD, amount, options));
  }

  public diverseTag(amount: number = 1) {
    const item = new CardRenderItem(CardRenderItemType.DIVERSE_TAG, amount);
    return this._appendToRow(item);
  }

  public tag(tag: Tag, options?: number | ItemOptions) {
    const opts: ItemOptions = typeof(options) === 'number' ? {amount: options} : {...options};
    opts.tag = tag;
    return this._appendToRow(new CardRenderItem(CardRenderItemType.TAG, opts.amount, opts));
  }

  public resource(resource: CardResource, options?: number | ItemOptions) {
    let opts: ItemOptions;
    if (typeof(options) === 'number') {
      opts = {amount: options};
    } else {
      opts = {...options};
    }
    opts.resource = resource;
    return this._appendToRow(new CardRenderItem(CardRenderItemType.RESOURCE, -1, opts));
  }
  public selfReplicatingRobots() {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.SELF_REPLICATING));
  }

  public prelude(options?: ItemOptions) {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.PRELUDE, -1, options));
  }

  public award() {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.AWARD));
  }

  public milestone(options?: ItemOptions | undefined) {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.MILESTONE, 1, options));
  }

  public corporation() {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.CORPORATION));
  }

  public firstPlayer() {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.FIRST_PLAYER));
  }

  public rulingParty() {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.RULING_PARTY));
  }

  public vpIcon() {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.VP));
  }

  public community() {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.COMMUNITY));
  }

  public multiplierWhite() {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.MULTIPLIER_WHITE));
  }

  public description(description: string | undefined = undefined): this {
    return this._appendToRow(description);
  }

  public moonHabitat(options?: ItemOptions | undefined): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.MOON_HABITAT, 1, options));
  }

  public moonHabitatRate(options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.MOON_HABITAT_RATE, 1, options));
  }

  // TODO(kberg): Replace moon road image with JUST a road, and add an altsecondary tag to support it.
  public moonRoad(options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.MOON_ROAD, 1, options));
  }

  public moonLogisticsRate(options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.MOON_LOGISTICS_RATE, 1, options));
  }

  public moonMine(options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.MOON_MINE, 1, options));
  }

  public moonMiningRate(options?: ItemOptions): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.MOON_MINING_RATE, 1, options));
  }

  public planetaryTrack(): this {
    this._appendToRow(new CardRenderItem(CardRenderItemType.PLANETARY_TRACK, 1));
    return this;
  }

  public cathedral(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.CATHEDRAL, 1));
  }

  public nomads(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.NOMADS, 1));
  }

  public specialTile(options?: ItemOptions) {
    this._appendToRow(new CardRenderItem(CardRenderItemType.EMPTY_TILE_SPECIAL, 1, options));
    return this;
  }

  public cityorSpecialTile(options?: ItemOptions) {
    const item = new CardRenderItem(CardRenderItemType.CITY_OR_SPECIAL_TILE, -1, options);
    item.size = options?.size ?? Size.MEDIUM;
    return this._appendToRow(item);
  }

  // Underworld
  public neutralDelegate(amount: number, options?: ItemOptions) {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.NEUTRAL_DELEGATE, amount, options));
  }

  public identify(count: number = 1, options?: ItemOptions) {
    const item = new CardRenderItem(CardRenderItemType.IDENTIFY, count, options);
    return this._appendToRow(item);
  }

  public excavate(count: number = 1, options?: ItemOptions) {
    const item = new CardRenderItem(CardRenderItemType.EXCAVATE, count, options);
    return this._appendToRow(item);
  }

  public corruption(count: number = 1, options?: ItemOptions) {
    const item = new CardRenderItem(CardRenderItemType.CORRUPTION, count, options);
    return this._appendToRow(item);
  }

  public undergroundResources(count: number = 1, options?: ItemOptions) {
    const item = new CardRenderItem(CardRenderItemType.UNDERGROUND_RESOURCES, count, options);
    return this._appendToRow(item);
  }

  public corruptionShield() {
    const item = new CardRenderItem(CardRenderItemType.CORRUPTION_SHIELD);
    return this._appendToRow(item);
  }

  public geoscan() {
    const item = new CardRenderItem(CardRenderItemType.GEOSCAN_ICON, 1, {});
    return this._appendToRow(item);
  }

  public emptyTile(type: 'normal' | 'golden' = 'normal', options?: ItemOptions) {
    if (type === 'normal') {
      const normal = new CardRenderItem(CardRenderItemType.EMPTY_TILE, -1, options);
      normal.size = options?.size ?? Size.MEDIUM;
      this._appendToRow(normal);
    } else if (type === 'golden') {
      const golden = new CardRenderItem(CardRenderItemType.EMPTY_TILE_GOLDEN, -1, options);
      golden.size = options?.size ?? Size.MEDIUM;
      this._appendToRow(golden);
    }
    return this;
  }

  public production(pb: (builder: ProductionBoxBuilder) => void): this {
    return this._appendToRow(CardRenderProductionBox.builder(pb));
  }

  public standardProject(description: string, eb: (builder: EffectBuilder) => void): this {
    const builder = CardRenderEffect.builder(eb);
    builder.description = description;
    return this._appendToRow(builder);
  }

  public action(description: string | undefined, eb: (builder: EffectBuilder) => void): this {
    const builder = CardRenderEffect.builder(eb);
    builder.description = description !== undefined ? 'Action: ' + description : undefined;
    return this._appendToRow(builder);
  }

  public effect(description: string | undefined, eb: (builder: EffectBuilder) => void): this {
    const builder = CardRenderEffect.builder(eb);
    builder.description = description !== undefined ? 'Effect: ' + description : undefined;
    return this._appendToRow(builder);
  }

  public corpBox(type: 'action' | 'effect', eb: (builder: CorpEffectBuilderEffect | CorpEffectBuilderAction) => void): this {
    this.br;
    if (type === 'action') {
      return this._appendToRow(CardRenderCorpBoxAction.builder(eb));
    } else {
      return this._appendToRow(CardRenderCorpBoxEffect.builder(eb));
    }
  }

  public or(size: Size = Size.SMALL): this {
    return this._appendToRow(CardRenderSymbol.or(size));
  }

  public asterix(size: Size = Size.MEDIUM): this {
    return this._appendToRow(CardRenderSymbol.asterix(size));
  }

  public plus(size: Size = Size.MEDIUM): this {
    return this._appendToRow(CardRenderSymbol.plus(size));
  }

  public minus(size: Size = Size.MEDIUM): this {
    return this._appendToRow(CardRenderSymbol.minus(size));
  }

  public slash(size: Size = Size.MEDIUM): this {
    return this._appendToRow(CardRenderSymbol.slash(size));
  }

  public colon(size: Size = Size.MEDIUM): this {
    return this._appendToRow(CardRenderSymbol.colon(size));
  }

  public arrow(size: Size = Size.MEDIUM): this {
    return this._appendToRow(CardRenderSymbol.arrow(size));
  }

  public equals(size: Size = Size.MEDIUM): this {
    return this._appendToRow(CardRenderSymbol.equals(size));
  }

  public surveyMission(): this {
    return this._appendToRow(CardRenderSymbol.surveyMission());
  }

  public empty(): this {
    return this._appendToRow(CardRenderSymbol.empty());
  }

  public plate(text: string, options?: ItemOptions | undefined): this {
    const item = new CardRenderItem(CardRenderItemType.PLATE, 1, options);
    item.text = text;
    item.isPlate = true;
    item.isBold = true;
    return this._appendToRow(item);
  }

  public text(text: string, size: Size = Size.MEDIUM, uppercase: boolean = false, isBold: boolean = true): this {
    const item = new CardRenderItem(CardRenderItemType.TEXT);
    item.text = text;
    item.size = size;
    item.isUppercase = uppercase;
    item.isBold = isBold;
    return this._appendToRow(item);
  }

  public text2(text: string, options: {size?: Size, caps?: boolean, bold?: boolean, all?: boolean}) {
    const item = new CardRenderItem(CardRenderItemType.TEXT);
    item.text = text;
    item.size = options.size || Size.MEDIUM;
    item.isUppercase = options.caps || false;
    item.isBold = options.bold || true;
    item.anyPlayer = options.all;
    return this._appendToRow(item);
  }

  public plainText(text: string) {
    return this.text(text, Size.SMALL, false, false);
  }

  public vpText(text: string): this {
    return this.text(text, Size.TINY, true);
  }

  public get br(): this {
    this._data.push([]);
    return this;
  }

  public tile(tile: TileType, hasSymbol: boolean = false, isAres: boolean = false): this {
    return this._appendToRow(new CardRenderTile(tile, hasSymbol, isAres));
  }

  /*
   * A one off function to handle Project Requirements prelude card
   */
  public projectRequirements(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.IGNORE_GLOBAL_REQUIREMENTS));
  }

  /**
   * add non breakable space or simply empty space between items
   */
  public get nbsp(): this {
    return this._appendToRow(CardRenderSymbol.nbsp());
  }

  /*
   * add non breakable vertical space (a div with different pixels height)
   */
  public vSpace(size: Size = Size.MEDIUM): this {
    return this._appendToRow(CardRenderSymbol.vSpace(size));
  }

  private superscript = false;

  public super(sb: (builder: this) => void): this {
    this._appendToRow(CardRenderSymbol.bracketOpen());
    this.superscript = true;
    sb(this);
    this.superscript = false;
    this._appendToRow(CardRenderSymbol.bracketClose());
    return this;
  }

  /**
   * Used to start the effect for action(), effect() and standardProject(), also adds a delimiter symbol
   */
  public get startEffect(): this {
    this.br;
    this._appendToRow(CardRenderSymbol.colon());
    this.br;
    return this;
  }

  public get startAction(): this {
    this.br;
    this._appendToRow(CardRenderSymbol.arrow());
    this.br;
    return this;
  }

  /**
   * CEO Card Assets
   */
  public opgArrow(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.ARROW_OPG));
  }
  // Reds icons used by Zan
  public zanReds(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.ZAN_REDS));
  }
  public redsInactive(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.REDS_DEACTIVATED));
  }
  // Hazard tiles for Caesar
  public hazardTile(amount: number = 1, options?: ItemOptions | undefined): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.HAZARD_TILE, amount, options));
  }
  public adjacencyBonus(): this {
    this._appendToRow(new CardRenderItem(CardRenderItemType.ADJACENCY_BONUS));
    return this;
  }

  public marsFirst(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.MARS_FIRST));
  }
  public scientists(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.SCIENTISTS));
  }
  public unity(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.UNITY));
  }
  public greens(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.GREENS));
  }
  public reds(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.REDS));
  }
  public kelvinists(): this {
    return this._appendToRow(new CardRenderItem(CardRenderItemType.KELVINISTS));
  }
}

class RootBuilder extends Builder<CardRenderRoot> {
  public override build(): CardRenderRoot {
    return new CardRenderRoot(this._data);
  }
}

class ProductionBoxBuilder extends Builder<CardRenderProductionBox> {
  public override build(): CardRenderProductionBox {
    return new CardRenderProductionBox(this._data);
  }
}

class EffectBuilder extends Builder<CardRenderEffect> {
  public override build(): CardRenderEffect {
    return new CardRenderEffect(this._data);
  }
}

class CorpEffectBuilderEffect extends Builder<CardRenderCorpBoxEffect> {
  public override build(): CardRenderCorpBoxEffect {
    return new CardRenderCorpBoxEffect(this._data);
  }
}

class CorpEffectBuilderAction extends Builder<CardRenderCorpBoxAction> {
  public override build(): CardRenderCorpBoxAction {
    return new CardRenderCorpBoxAction(this._data);
  }
}

================
File: cards/render/CardRenderItem.ts
================
/*
  Describes any distinct item on a card and prepare it for rendering in Vue
  e.g. Any tag, tile, production cube, ocean, temperature, etc.
 */
import {CardRenderItemType} from '../../../common/cards/render/CardRenderItemType';
import {Size} from '../../../common/cards/render/Size';
import {Tag} from '../../../common/cards/Tag';
import {ICardRenderItem} from '../../../common/cards/render/Types';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {CardResource} from '../../../common/CardResource';

export type ItemOptions = Partial<{
  size: Size;
  amount: number;
  all: boolean;
  digit: boolean;
  played: boolean;
  secondaryTag: Tag | AltSecondaryTag;
  clone: boolean; /** Replace the amount with the clone tag */
  cancelled: boolean;
  over: number; /** Used for global events. */
  questionMark: boolean;
  text: string;
  superscript: boolean;
  resource: CardResource;
  tag: Tag;
}>

export class CardRenderItem implements ICardRenderItem {
  public readonly is = 'item';
  public anyPlayer?: boolean;
  public showDigit?: boolean;
  public amountInside?: boolean;
  public text?: string;
  public isUppercase?: boolean;
  public isBold?: boolean;
  public isPlate?: boolean;
  public size?: Size;
  public secondaryTag?: Tag | AltSecondaryTag;
  public clone?: boolean;
  public cancelled?: boolean;
  public innerText?: string;
  public isSuperscript?: boolean;
  public over?: number;
  public resource?: CardResource | undefined;
  public tag?: Tag | undefined;

  constructor(public type: CardRenderItemType, public amount: number = -1, options?: ItemOptions) {
    switch (options?.digit) {
    case true:
      this.showDigit = true;
      break;
    case false:
      break; // it's undefined
    default:
      this.showDigit = Math.abs(this.amount) > 5 ? true : undefined;
    }

    if (options === undefined) {
      return this;
    }
    this.size = options.size;
    if (options.amount !== undefined) {
      this.amount = options.amount;
    }
    this.anyPlayer = options.all;
    this.secondaryTag = options.secondaryTag;

    if (options.clone === true) {
      this.amountInside = false;
      this.clone = true;
    }

    this.cancelled = options.cancelled ?? false;
    this.over = options.over;
    if (options.text !== undefined) {
      this.innerText = options.text;
    }
    if (options.superscript === true) {
      this.isSuperscript = true;
    }
    if (options.resource !== undefined) {
      this.resource = options.resource;
    }
    if (options.tag !== undefined) {
      this.tag = options.tag;
    }

    return this;
  }
}

================
File: cards/render/CardRenderSymbol.ts
================
/*
  Used to describe any distinct symbol on a card and prepare it for rendering in Vue
  e.g. plus and minus sign, asterix, arrow, dash, slash, etc.
 */
import {CardRenderSymbolType} from '../../../common/cards/render/CardRenderSymbolType';
import {ICardRenderSymbol} from '../../../common/cards/render/Types';
import {Size} from '../../../common/cards/render/Size';

export class CardRenderSymbol implements ICardRenderSymbol {
  public readonly is = 'symbol';
  public readonly type: CardRenderSymbolType;
  public readonly size: Size;
  public readonly isIcon: boolean;
  public readonly isSuperscript: boolean;

  private constructor(type: CardRenderSymbolType, options: {size?: Size, isIcon?: boolean, isSuperscript?: boolean}) {
    this.type = type;
    this.size = options.size ?? Size.MEDIUM;
    this.isIcon = options.isIcon ?? false;
    this.isSuperscript = options.isSuperscript ?? false;
  }

  public static asterix(size?: Size): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.ASTERIX, {size});
  }
  public static or(size?: Size): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.OR, {size});
  }
  public static plus(size?: Size): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.PLUS, {size, isIcon: true});
  }
  public static minus(size?: Size): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.MINUS, {size, isIcon: true});
  }
  public static empty(size?: Size): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.EMPTY, {size});
  }
  public static slash(size?: Size): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.SLASH, {size});
  }
  public static colon(size?: Size): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.COLON, {size});
  }
  public static arrow(size?: Size): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.ARROW, {size, isIcon: true});
  }
  public static bracketOpen(): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.BRACKET_OPEN, {isSuperscript: true});
  }
  public static bracketClose(): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.BRACKET_CLOSE, {isSuperscript: true});
  }
  public static nbsp(size?: Size): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.NBSP, {size, isIcon: true});
  }
  public static vSpace(size?: Size): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.VSPACE, {size, isIcon: true});
  }
  public static equals(size?: Size): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.EQUALS, {size});
  }
  public static surveyMission(): CardRenderSymbol {
    return new CardRenderSymbol(CardRenderSymbolType.SURVEY_MISSION, {isIcon: true});
  }
}

================
File: cards/requirements/CardRequirement.ts
================
import {RequirementType} from '../../../common/cards/RequirementType';
import {IPlayer} from '../../IPlayer';

export type Options = {
  max: boolean,
  all: boolean,
  text: string | undefined,
  nextTo: boolean,
  count: number,
};

export type YesAnd = {
  thinkTankResources?: number,
  redsCost?: number,
}

/**
 * Information to evaluate a card requirement.
 *
 * This represents requirements such as global parameters and tags.
 *
 * This base class contains some common attributes, but subclasses will contain
 * new data.
 */
export abstract class CardRequirement {
  /** The type of requirement this represents, e.g. Oxygen. */
  public abstract readonly type: RequirementType;
  /** The count for this requirement (e.g. 5%) */
  public readonly count: number;
  /** When true, this requirement is a maximum vs minimum requirement (e.g. max 5%) */
  public readonly max: boolean;
  /**
   * When true, requirement applies to everyone's tiles or tags, etc.
   * (e.g. you have 2 cities vs all players have 2 cities.)
   */
  public readonly all: boolean;
  /** Used during card rendering. */
  public readonly text: string | undefined;
  /** Used during card rendering. */
  public readonly nextTo: boolean;

  constructor(options?: Partial<Options>) {
    this.count = options?.count ?? 1;
    this.max = options?.max ?? false;
    this.all = options?.all ?? false;
    this.nextTo = options?.nextTo ?? false;
    this.text = options?.text;
  }

  /**
   * Evaluate whether |player| satisfies this requirement. It takes into account any
   * player modifiers (e.g. Adaptation Technology, and fan-based Think Tank.)
   *
   * Returns true if |player| can satisfy the requirement, false if it cannot, and
   * YesAnd if it can only do that under certain conditions (e.g. spend 2 Think Tank
   * resources.)
   */
  public abstract satisfies(player: IPlayer, thinkTankResources?: number) : boolean | YesAnd;
}

================
File: cards/requirements/CardRequirements.ts
================
import {RequirementType} from '../../../common/cards/RequirementType';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRequirement, YesAnd} from './CardRequirement';
import {ChairmanRequirement} from './ChairmanRequirement';
import {CitiesRequirement} from './CitiesRequirement';
import {ColoniesRequirement} from './ColoniesRequirement';
import {FloatersRequirement} from './FloatersRequirement';
import {GreeneriesRequirement} from './GreeneriesRequirement';
import {HabitatRateRequirement} from './HabitatRateRequirement';
import {HabitatTilesRequirement} from './HabitatTilesRequirement';
import {LogisticsRateRequirement} from './LogisticsRateRequirement';
import {MiningRateRequirement} from './MiningRateRequirement';
import {MiningTilesRequirement} from './MiningTilesRequirement';
import {OceanRequirement} from './OceanRequirement';
import {OxygenRequirement} from './OxygenRequirement';
import {PartyLeadersRequirement} from './PartyLeadersRequirement';
import {PartyRequirement} from './PartyRequirement';
import {ProductionRequirement} from './ProductionRequirement';
import {RemovedPlantsRequirement} from './RemovedPlantsRequirement';
import {ResourceTypeRequirement} from './ResourceTypeRequirement';
import {RoadTilesRequirement} from './RoadTilesRequirement';
import {TRRequirement} from './TRRequirement';
import {TagCardRequirement} from './TagCardRequirement';
import {TemperatureRequirement} from './TemperatureRequirement';
import {VenusRequirement} from './VenusRequirement';
import {CardRequirementDescriptor} from '../../../common/cards/CardRequirementDescriptor';
import {CorruptionRequirement} from './CorruptionRequirement';
import {ExcavationRequirement} from './ExcavationRequirement';
import {SumTagsCardRequirement} from './SumTagsCardRequirement';
import {UniqueTagsCardRequirement} from './UniqueTagsCardRequirement';
import {RaisedTRRequirement} from './RaisedTRRequirement';

export class CardRequirements {
  constructor(public requirements: Array<CardRequirement>) {}

  public satisfies(player: IPlayer): boolean | YesAnd {
    if (this.requirements.length === 0) {
      return true;
    }
    // Process tags separately, though max & any tag criteria will be processed later.
    // This pre-computation takes the wild tag into account.
    const tags: Array<Tag> = [];
    this.requirements.forEach((requirement) => {
      if ((requirement.type === RequirementType.TAG) &&
      requirement.all !== true && requirement.max !== true) {
        tags.push((requirement as TagCardRequirement).tag);
      }
    });
    if (tags.length > 1 && !player.tags.playerHas(tags)) {
      return false;
    }
    const thinkTankResources = player.playedCards.find((c) => c.name === CardName.THINK_TANK)?.resourceCount;
    let result: boolean | YesAnd = true;
    for (const requirement of this.requirements) {
      const satisfies = requirement.satisfies(player, thinkTankResources);
      if (satisfies === false) {
        return false;
      }
      if (typeof(satisfies) === 'object') {
        result = satisfies;
      }
    }
    return result;
  }

  public static compile(descriptors: Array<CardRequirementDescriptor> | undefined): CardRequirements {
    if (descriptors === undefined) {
      return new CardRequirements([]);
    }
    return new CardRequirements(descriptors.map((descriptor) => CardRequirements.compileOne(descriptor)));
  }

  private static compileOne(descriptor: CardRequirementDescriptor): CardRequirement {
    if (descriptor.tag !== undefined) {
      return new TagCardRequirement(descriptor.tag, descriptor);
    } else if (descriptor.oceans !== undefined) {
      return new OceanRequirement({...descriptor, count: descriptor.oceans});
    } else if (descriptor.oxygen !== undefined) {
      return new OxygenRequirement({...descriptor, count: descriptor.oxygen});
    } else if (descriptor.temperature !== undefined) {
      return new TemperatureRequirement({...descriptor, count: descriptor.temperature});
    } else if (descriptor.venus !== undefined) {
      return new VenusRequirement({...descriptor, count: descriptor.venus});
    } else if (descriptor.tr !== undefined) {
      return new TRRequirement({...descriptor, count: descriptor.tr});
    } else if (descriptor.chairman !== undefined) {
      return new ChairmanRequirement();
    } else if (descriptor.resourceTypes !== undefined) {
      return new ResourceTypeRequirement({...descriptor, count: descriptor.resourceTypes});
    } else if (descriptor.greeneries !== undefined) {
      return new GreeneriesRequirement({...descriptor, count: descriptor.greeneries});
    } else if (descriptor.cities !== undefined) {
      return new CitiesRequirement({...descriptor, count: descriptor.cities});
    } else if (descriptor.colonies !== undefined) {
      return new ColoniesRequirement({...descriptor, count: descriptor.colonies});
    } else if (descriptor.floaters !== undefined) {
      return new FloatersRequirement({...descriptor, count: descriptor.floaters});
    } else if (descriptor.partyLeader !== undefined) {
      return new PartyLeadersRequirement(descriptor);
    } else if (descriptor.production !== undefined) {
      return new ProductionRequirement(descriptor.production, descriptor);
    } else if (descriptor.party !== undefined) {
      return new PartyRequirement(descriptor.party);
    } else if (descriptor.plantsRemoved !== undefined) {
      return new RemovedPlantsRequirement();
    } else if (descriptor.habitatRate !== undefined) {
      return new HabitatRateRequirement({...descriptor, count: descriptor.habitatRate});
    } else if (descriptor.miningRate !== undefined) {
      return new MiningRateRequirement({...descriptor, count: descriptor.miningRate});
    } else if (descriptor.logisticRate !== undefined) {
      return new LogisticsRateRequirement({...descriptor, count: descriptor.logisticRate});
    } else if (descriptor.habitatTiles !== undefined) {
      return new HabitatTilesRequirement({...descriptor, count: descriptor.habitatTiles});
    } else if (descriptor.miningTiles !== undefined) {
      return new MiningTilesRequirement({...descriptor, count: descriptor.miningTiles});
    } else if (descriptor.roadTiles !== undefined) {
      return new RoadTilesRequirement({...descriptor, count: descriptor.roadTiles});
    } else if (descriptor.excavation !== undefined) {
      return new ExcavationRequirement({...descriptor, count: descriptor.excavation});
    } else if (descriptor.corruption !== undefined) {
      return new CorruptionRequirement({...descriptor, count: descriptor.corruption});
    } else if (descriptor.sumTags !== undefined) {
      return new SumTagsCardRequirement(descriptor.sumTags, descriptor);
    } else if (descriptor.uniqueTags !== undefined) {
      return new UniqueTagsCardRequirement(descriptor);
    } else if (descriptor.raisedTR !== undefined) {
      return new RaisedTRRequirement();
    } else {
      throw new Error('Unknown requirement: ' + JSON.stringify(descriptor));
    }
  }
}

================
File: cards/requirements/ChairmanRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {Turmoil} from '../../turmoil/Turmoil';
import {CardRequirement} from './CardRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluates whether a player is the chairman.
 */
export class ChairmanRequirement extends CardRequirement {
  public readonly type = RequirementType.CHAIRMAN;
  constructor() {
    super({count: 1});
  }
  public satisfies(player: IPlayer) : boolean {
    return Turmoil.getTurmoil(player.game).chairman === player;
  }
}

================
File: cards/requirements/CitiesRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {InequalityRequirement} from './InequalityRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether the number of city tiles on Mars is at least (or at most) a given value.
 *
 * Can apply to a single player's tiles or all tiles.
 */
export class CitiesRequirement extends InequalityRequirement {
  public readonly type = RequirementType.CITIES;
  public override getScore(player: IPlayer): number {
    return player.game.board.getCities(this.all ? undefined : player).length;
  }
}

================
File: cards/requirements/ColoniesRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {InequalityRequirement} from './InequalityRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';
import {sum} from '../../../common/utils/utils';

/**
 * Evaluates whether this player has a given number of colonies all colony tiles.
 */
export class ColoniesRequirement extends InequalityRequirement {
  public readonly type = RequirementType.COLONIES;
  public override getScore(player: IPlayer): number {
    return sum(player.game.colonies
      .map((colony) => colony.colonies.filter((owner) => owner === player.id).length));
  }
}

================
File: cards/requirements/CorruptionRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {RequirementType} from '../../../common/cards/RequirementType';
import {InequalityRequirement} from './InequalityRequirement';

/**
 * Evaluates whether this player (or all players) has a given number of cities on Mars.
 */
export class CorruptionRequirement extends InequalityRequirement {
  public readonly type = RequirementType.CORRUPTION;

  public getScore(player: IPlayer): number {
    return player.underworldData.corruption;
  }
}

================
File: cards/requirements/ExcavationRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {RequirementType} from '../../../common/cards/RequirementType';
import {InequalityRequirement} from './InequalityRequirement';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';

/**
 * Evaluates whether this player has excavated a given number of tiles.
 */
export class ExcavationRequirement extends InequalityRequirement {
  public readonly type = RequirementType.EXCAVATION;

  public getScore(player: IPlayer): number {
    return UnderworldExpansion.excavationMarkerCount(player);
  }
}

================
File: cards/requirements/FloatersRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {InequalityRequirement} from './InequalityRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluates whether this player has a number of floaters on their played cards.
 */
export class FloatersRequirement extends InequalityRequirement {
  public readonly type = RequirementType.FLOATERS;
  public override getScore(player: IPlayer): number {
    return player.getResourceCount(CardResource.FLOATER);
  }
}

================
File: cards/requirements/GlobalParameterRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {InequalityRequirement} from './InequalityRequirement';
import {GlobalParameter} from '../../../common/GlobalParameter';
import {YesAnd} from './CardRequirement';


/**
 * Defines the class of requirements that compare against global parameters. Subclasses define
 * important attributes of how each global paramter functions (e.g. `OxygenRequirement`.)
 *
 * For the most part, this is not much different than `InequalityRequirement` but the
 * Pathfinders card Think Tank adds most of the complexity.
 */
export abstract class GlobalParameterRequirement extends InequalityRequirement {
  protected scale: number = 1;
  protected abstract parameter: GlobalParameter;

  public abstract getGlobalValue(player: IPlayer): number;

  public override satisfies(player: IPlayer, thinkTankResources: number): boolean | YesAnd {
    if (super.satisfies(player, thinkTankResources)) {
      return true;
    }
    if (thinkTankResources) {
      const distance = this.distance(player);
      if (distance <= thinkTankResources) {
        return {thinkTankResources: distance};
      }
    }
    return false;
  }

  public getScore(player: IPlayer): number {
    const playerRequirementsBonus = player.getGlobalParameterRequirementBonus(this.parameter) * this.scale;

    const level = this.getGlobalValue(player);

    if (this.max) {
      return level - playerRequirementsBonus;
    } else {
      return level + playerRequirementsBonus;
    }
  }

  public distance(player: IPlayer): number {
    return Math.floor(Math.abs(this.getScore(player) - this.count) / this.scale);
  }
}

================
File: cards/requirements/GreeneriesRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {InequalityRequirement} from './InequalityRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether the number of greenery tiles on Mars is at least (or at most) a given value.
 *
 * Can apply to a single player's tiles or all tiles.
 */
export class GreeneriesRequirement extends InequalityRequirement {
  public readonly type = RequirementType.GREENERIES;
  public override getScore(player: IPlayer): number {
    return player.game.board.getGreeneries(this.all ? undefined : player).length;
  }
}

================
File: cards/requirements/HabitatRateRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {GlobalParameterRequirement} from './GlobalParameterRequirement';
import {GlobalParameter} from '../../../common/GlobalParameter';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether the game's Moon habitat rate is at least (or at most) a given value.
 */
export class HabitatRateRequirement extends GlobalParameterRequirement {
  public readonly type = RequirementType.HABITAT_RATE;
  protected readonly parameter = GlobalParameter.MOON_HABITAT_RATE;

  public getGlobalValue(player: IPlayer) {
    return MoonExpansion.moonData(player.game).habitatRate;
  }
}

================
File: cards/requirements/HabitatTilesRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {TileType} from '../../../common/TileType';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {InequalityRequirement} from './InequalityRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether the number of habitat tiles on the Moon is at least (or at most) a given value.
 *
 * Can apply to a single player's tiles or all tiles.
 */
export class HabitatTilesRequirement extends InequalityRequirement {
  public readonly type = RequirementType.HABITAT_TILES;
  public override getScore(player: IPlayer): number {
    return MoonExpansion.spaces(player.game, TileType.MOON_HABITAT, {surfaceOnly: true, ownedBy: this.all ? undefined : player}).length;
  }
}

================
File: cards/requirements/InequalityRequirement.ts
================
import {CardRequirement, YesAnd} from './CardRequirement';
import {IPlayer} from '../../IPlayer';

/**
 * Defines a class of requirements that compare to a given value. Subclasses provide that value
 * with `getScore`.
 *
 * Normal behavior is that the requirement is met when the `getScore` is at least `count`
 * (e.g. requires 3 oceans.) When `max` is true, the requirement is met with `getScore` is at
 * most `count` (e.g. requires max 3 oceans.)
 */
export abstract class InequalityRequirement extends CardRequirement {
  public abstract getScore(player: IPlayer): number;

  public satisfies(player: IPlayer, _thinkTankResources: number): boolean | YesAnd {
    const score = this.getScore(player);
    if (this.max) {
      return score <= this.count;
    }
    return score >= this.count;
  }
}

================
File: cards/requirements/LogisticsRateRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {GlobalParameterRequirement} from './GlobalParameterRequirement';
import {GlobalParameter} from '../../../common/GlobalParameter';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether the game's Moon logistics rate is at least (or at most) a given value.
 */
export class LogisticsRateRequirement extends GlobalParameterRequirement {
  public readonly type = RequirementType.LOGISTIC_RATE;
  protected readonly parameter = GlobalParameter.MOON_LOGISTICS_RATE;

  public getGlobalValue(player: IPlayer) {
    return MoonExpansion.moonData(player.game).logisticRate;
  }
}

================
File: cards/requirements/MiningRateRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {GlobalParameterRequirement} from './GlobalParameterRequirement';
import {GlobalParameter} from '../../../common/GlobalParameter';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether the game's Moon mining rate is at least (or at most) a given value.
 */
export class MiningRateRequirement extends GlobalParameterRequirement {
  public readonly type = RequirementType.MINING_RATE;
  protected readonly parameter = GlobalParameter.MOON_MINING_RATE;

  public getGlobalValue(player: IPlayer) {
    return MoonExpansion.moonData(player.game).miningRate;
  }
}

================
File: cards/requirements/MiningTilesRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {TileType} from '../../../common/TileType';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {InequalityRequirement} from './InequalityRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether the number of mining tiles on the Moon is at least (or at most) a given value.
 *
 * Can apply to a single player's tiles or all tiles.
 */
export class MiningTilesRequirement extends InequalityRequirement {
  public readonly type = RequirementType.MINING_TILES;
  public override getScore(player: IPlayer): number {
    return MoonExpansion.spaces(player.game, TileType.MOON_MINE, {surfaceOnly: true, ownedBy: this.all ? undefined : player}).length;
  }
}

================
File: cards/requirements/OceanRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {GlobalParameterRequirement} from './GlobalParameterRequirement';
import {MAX_OCEAN_TILES} from '../../../common/constants';
import {GlobalParameter} from '../../../common/GlobalParameter';
import {RequirementType} from '../../../common/cards/RequirementType';
import {Options} from './CardRequirement';

/**
 * Evaluate whether the game's ocean tile count is at least (or at most) a given value.
 */
export class OceanRequirement extends GlobalParameterRequirement {
  public readonly type = RequirementType.OCEANS;
  protected readonly parameter = GlobalParameter.OCEANS;

  constructor(options?: Partial<Options>) {
    const count = options?.count ?? 1;
    if (count <= 0 || count > MAX_OCEAN_TILES) {
      throw new Error('Ocean tiles must be above 0 and below ' + MAX_OCEAN_TILES);
    }
    super(options);
  }

  public getGlobalValue(player: IPlayer) {
    return player.game.board.getOceanSpaces({upgradedOceans: true, wetlands: true}).length;
  }
}

================
File: cards/requirements/OxygenRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {Options} from './CardRequirement';
import {GlobalParameterRequirement} from './GlobalParameterRequirement';
import {GlobalParameter} from '../../../common/GlobalParameter';
import {RequirementType} from '../../../common/cards/RequirementType';
import {MAX_OXYGEN_LEVEL, MIN_OXYGEN_LEVEL} from '../../../common/constants';

/**
 * Evaluate whether the game's oxygel level is at least (or at most) a given value.
 */
export class OxygenRequirement extends GlobalParameterRequirement {
  public readonly type = RequirementType.OXYGEN;
  protected readonly parameter = GlobalParameter.OXYGEN;
  protected override readonly scale = 1;

  constructor(options?: Partial<Options>) {
    const count = options?.count ?? 1;
    if (count < MIN_OXYGEN_LEVEL || count > MAX_OXYGEN_LEVEL) {
      throw new Error('Oxygen must be above ' + MIN_OXYGEN_LEVEL + ' and below ' + MAX_OXYGEN_LEVEL);
    }
    super(options);
  }

  public getGlobalValue(player: IPlayer) {
    return player.game.getOxygenLevel();
  }
}

================
File: cards/requirements/PartyLeadersRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {Turmoil} from '../../turmoil/Turmoil';
import {InequalityRequirement} from './InequalityRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether the number of Turmoil parties a player leads is at least (or at most) a given value.
 */
export class PartyLeadersRequirement extends InequalityRequirement {
  public readonly type = RequirementType.PARTY_LEADERS;
  public override getScore(player: IPlayer): number {
    const turmoil = Turmoil.getTurmoil(player.game);
    return turmoil.parties.filter((party) => party.partyLeader === player).length;
  }
}

================
File: cards/requirements/PartyRequirement.ts
================
import {PartyName} from '../../../common/turmoil/PartyName';
import {IPlayer} from '../../IPlayer';
import {Turmoil} from '../../turmoil/Turmoil';
import {CardRequirement} from './CardRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';


/**
 * Evaluate whether a player can satisfy a Turmoil party requirement.
 *
 * A player satisfies a party requirement if the party is currently ruling, or if
 * contains two of the player's delegates, or if the player has Mars Frontier Alliance
 * in play and the party's policy tile on it
 */
export class PartyRequirement extends CardRequirement {
  public readonly type = RequirementType.PARTY;
  constructor(public readonly party: PartyName) {
    super();
  }

  public satisfies(player: IPlayer): boolean {
    const turmoil = Turmoil.getTurmoil(player.game);
    if (turmoil.rulingParty.name === this.party || player.alliedParty?.partyName === this.party ) {
      return true;
    }

    const party = turmoil.getPartyByName(this.party);
    return party.delegates.count(player) >= 2;
  }
}

================
File: cards/requirements/ProductionRequirement.ts
================
import {Resource} from '../../../common/Resource';
import {IPlayer} from '../../IPlayer';
import {InequalityRequirement} from './InequalityRequirement';
import {Options} from './CardRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether a player's resource production is at least (or at most) a given value.
 *
 * (e.g. player has 1 steel production.)
 */
export class ProductionRequirement extends InequalityRequirement {
  public readonly type = RequirementType.PRODUCTION;
  public readonly resource: Resource;
  constructor(resource: Resource, options?: Partial<Options>) {
    super(options);
    this.resource = resource;
  }
  public getScore(player: IPlayer): number {
    return player.production[this.resource];
  }
}

================
File: cards/requirements/RaisedTRRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {CardRequirement} from './CardRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

export class RaisedTRRequirement extends CardRequirement {
  public readonly type = RequirementType.RAISED_TR;
  public satisfies(player: IPlayer) : boolean {
    return player.generationData.hasRaisedTR;
  }
}

================
File: cards/requirements/RemovedPlantsRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {CardRequirement} from './CardRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether any player's plants have been removed this generation.
 */
export class RemovedPlantsRequirement extends CardRequirement {
  public readonly type = RequirementType.REMOVED_PLANTS;
  public satisfies(player: IPlayer): boolean {
    return player.game.someoneHasRemovedOtherPlayersPlants;
  }
}

================
File: cards/requirements/ResourceTypeRequirement.ts
================
import {ALL_RESOURCES} from '../../../common/Resource';
import {IPlayer} from '../../IPlayer';
import {InequalityRequirement} from './InequalityRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';


/**
 * Evaluate whether the number of different resource types a player has is at least (or at most) a given value.
 *
 * This applies (as of this time) exclusively to the card Diversity Support.
 */
export class ResourceTypeRequirement extends InequalityRequirement {
  public readonly type = RequirementType.RESOURCE_TYPES;
  public override getScore(player: IPlayer): number {
    const standardResources = ALL_RESOURCES.filter((res) => player.stock.get(res) > 0).length;
    const nonStandardResources = new Set(player.getCardsWithResources().map((card) => card.resourceType)).size;
    return standardResources + nonStandardResources;
  }
}

================
File: cards/requirements/RoadTilesRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {TileType} from '../../../common/TileType';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {InequalityRequirement} from './InequalityRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether the number of road tiles on The Moon is at least (or at most) a given value.
 *
 * Can apply to a single player's tiles or all tiles.
 */
export class RoadTilesRequirement extends InequalityRequirement {
  public readonly type = RequirementType.ROAD_TILES;
  public override getScore(player: IPlayer): number {
    return MoonExpansion.spaces(player.game, TileType.MOON_ROAD, {surfaceOnly: true, ownedBy: this.all ? undefined : player}).length;
  }
}

================
File: cards/requirements/SumTagsCardRequirement.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {InequalityRequirement} from './InequalityRequirement';
import {Options} from './CardRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

export class SumTagsCardRequirement extends InequalityRequirement {
  public readonly type = RequirementType.SUM_TAGS;
  public readonly tags: Array<Tag>;
  constructor(tags: Array<Tag>, options?: Partial<Options>) {
    super(options);
    this.tags = tags;
  }

  public getScore(player: IPlayer): number {
    let tagCount = player.tags.multipleCount(this.tags);

    // PoliticalAgendas Scientists P4 hook
    if (this.tags.includes(Tag.SCIENCE) && player.hasTurmoilScienceTagBonus) tagCount += 1;

    return tagCount;
  }
}

================
File: cards/requirements/TagCardRequirement.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {InequalityRequirement} from './InequalityRequirement';
import {Options} from './CardRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether a player (or all players) have played at least (or at most) a given number of tags.
 *
 * (e.g. Requires 2 energy tags, or requires at most 1 science tag.)
 */
export class TagCardRequirement extends InequalityRequirement {
  public readonly type = RequirementType.TAG;
  public readonly tag: Tag;
  constructor(tag: Tag, options?: Partial<Options>) {
    super(options);
    this.tag = tag;
  }

  public getScore(player: IPlayer): number {
    if (this.tag === Tag.EVENT) {
      return player.getPlayedEventsCount();
    }
    const mode = this.max !== true ? 'default' : 'raw';
    let tagCount = player.tags.count(this.tag, mode);

    if (this.all) {
      player.getOpponents().forEach((p) => {
        // Don't include opponents' wild tags because they are not performing the action.
        tagCount += p.tags.count(this.tag, 'raw');
      });
    }
    // PoliticalAgendas Scientists P4 hook
    if (this.tag === Tag.SCIENCE && player.hasTurmoilScienceTagBonus) tagCount += 1;

    return tagCount;
  }
}

================
File: cards/requirements/TemperatureRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {GlobalParameterRequirement} from './GlobalParameterRequirement';
import {GlobalParameter} from '../../../common/GlobalParameter';
import {RequirementType} from '../../../common/cards/RequirementType';
import {MAX_TEMPERATURE, MIN_TEMPERATURE} from '../../../common/constants';
import {Options} from './CardRequirement';

/**
 * Evaluate whether the game's temperature is at least (or at most) a given value.
 */
export class TemperatureRequirement extends GlobalParameterRequirement {
  public readonly type = RequirementType.TEMPERATURE;
  protected readonly parameter = GlobalParameter.TEMPERATURE;
  protected override readonly scale = 2;

  constructor(options?: Partial<Options>) {
    const count = options?.count ?? 1;
    if (count < MIN_TEMPERATURE || count > MAX_TEMPERATURE) {
      throw new Error('Temperature must be above ' + MIN_TEMPERATURE + ' and below ' + MAX_TEMPERATURE);
    }
    if (count % 2 !== 0) {
      throw new Error('Temperature must be even');
    }
    super(options);
  }

  public getGlobalValue(player: IPlayer) {
    return player.game.getTemperature();
  }
}

================
File: cards/requirements/TRRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {InequalityRequirement} from './InequalityRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

/**
 * Evaluate whether a player has least (or at most) a given TR.
 */
export class TRRequirement extends InequalityRequirement {
  public readonly type = RequirementType.TR;
  public override getScore(player: IPlayer): number {
    return player.getTerraformRating();
  }
}

================
File: cards/requirements/UniqueTagsCardRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {InequalityRequirement} from './InequalityRequirement';
import {Options} from './CardRequirement';
import {RequirementType} from '../../../common/cards/RequirementType';

export class UniqueTagsCardRequirement extends InequalityRequirement {
  public readonly type = RequirementType.SUM_TAGS;
  constructor(options?: Partial<Options>) {
    super(options);
  }

  public getScore(player: IPlayer): number {
    return player.tags.distinctCount('default');
  }
}

================
File: cards/requirements/VenusRequirement.ts
================
import {IPlayer} from '../../IPlayer';
import {GlobalParameterRequirement} from './GlobalParameterRequirement';
import {GlobalParameter} from '../../../common/GlobalParameter';
import {RequirementType} from '../../../common/cards/RequirementType';
import {MAX_VENUS_SCALE, MIN_VENUS_SCALE} from '../../../common/constants';
import {Options} from './CardRequirement';

/**
 * Evaluate whether the game's venus scale level is at least (or at most) a given value.
 */
export class VenusRequirement extends GlobalParameterRequirement {
  public readonly type = RequirementType.VENUS;
  protected readonly parameter = GlobalParameter.VENUS;
  protected override readonly scale = 2;

  constructor(options?: Partial<Options>) {
    const count = options?.count ?? 1;
    if (count < MIN_VENUS_SCALE || count > MAX_VENUS_SCALE) {
      throw new Error('Venus must be above ' + MIN_VENUS_SCALE + ' and below ' + MAX_VENUS_SCALE);
    }
    super(options);
  }

  public getGlobalValue(player: IPlayer) {
    return player.game.getVenusScaleLevel();
  }
}

================
File: cards/SerializedDeck.ts
================
import {CardName} from '../../common/cards/CardName';

export type SerializedDeck = {
  drawPile: Array<CardName>;
  discardPile: Array<CardName>;
}

================
File: cards/StandardActionCard.ts
================
import {CardType} from '../../common/cards/CardType';
import {CardMetadata} from '../../common/cards/CardMetadata';
import {CardName} from '../../common/cards/CardName';
import {Card} from './Card';
import {PlayerInput} from '../PlayerInput';
import {IPlayer} from '../IPlayer';
import {IStandardActionCard} from './IStandardActionCard';

interface StaticStandardActionCardProperties {
  name: CardName,
  metadata: CardMetadata,
}

export abstract class StandardActionCard extends Card implements IStandardActionCard {
  constructor(properties: StaticStandardActionCardProperties) {
    super({
      type: CardType.STANDARD_ACTION,
      ...properties,
    });
  }

  public override get type(): CardType.STANDARD_ACTION {
    return CardType.STANDARD_ACTION;
  }

  public abstract canAct(player: IPlayer): boolean

  public abstract action(player: IPlayer): PlayerInput | undefined

  protected actionUsed(player: IPlayer) {
    player.game.log('${0} used ${1} standard action', (b) => b.player(player).card(this));
  }
}

================
File: cards/StandardCardManifests.ts
================
import {CardName} from '../../common/cards/CardName';
import {AcquiredCompany} from './base/AcquiredCompany';
import {AdaptationTechnology} from './base/AdaptationTechnology';
import {AdaptedLichen} from './base/AdaptedLichen';
import {AdvancedAlloys} from './base/AdvancedAlloys';
import {AdvancedEcosystems} from './base/AdvancedEcosystems';
import {AerobrakedAmmoniaAsteroid} from './base/AerobrakedAmmoniaAsteroid';
import {AICentral} from './base/AICentral';
import {Algae} from './base/Algae';
import {AntiGravityTechnology} from './base/AntiGravityTechnology';
import {Ants} from './base/Ants';
import {AquiferPumping} from './base/AquiferPumping';
import {ArchaeBacteria} from './base/ArchaeBacteria';
import {ArcticAlgae} from './base/ArcticAlgae';
import {ArtificialLake} from './base/ArtificialLake';
import {ArtificialPhotosynthesis} from './base/ArtificialPhotosynthesis';
import {Asteroid} from './base/Asteroid';
import {AsteroidMining} from './base/AsteroidMining';
import {AsteroidMiningConsortium} from './base/AsteroidMiningConsortium';
import {BeamFromAThoriumAsteroid} from './base/BeamFromAThoriumAsteroid';
import {BeginnerCorporation} from './corporation/BeginnerCorporation';
import {BigAsteroid} from './base/BigAsteroid';
import {BiomassCombustors} from './base/BiomassCombustors';
import {Birds} from './base/Birds';
import {BlackPolarDust} from './base/BlackPolarDust';
import {BreathingFilters} from './base/BreathingFilters';
import {BribedCommittee} from './base/BribedCommittee';
import {BuildingIndustries} from './base/BuildingIndustries';
import {Bushes} from './base/Bushes';
import {BusinessContacts} from './base/BusinessContacts';
import {BusinessNetwork} from './base/BusinessNetwork';
import {CallistoPenalMines} from './base/CallistoPenalMines';
import {Capital} from './base/Capital';
import {CarbonateProcessing} from './base/CarbonateProcessing';
import {ModuleManifest} from './ModuleManifest';
import {CaretakerContract} from './base/CaretakerContract';
import {Cartel} from './base/Cartel';
import {CEOsFavoriteProject} from './base/CEOsFavoriteProject';
import {CloudSeeding} from './base/CloudSeeding';
import {ColonizerTrainingCamp} from './base/ColonizerTrainingCamp';
import {Comet} from './base/Comet';
import {CommercialDistrict} from './base/CommercialDistrict';
import {ConvoyFromEuropa} from './base/ConvoyFromEuropa';
import {CorporateStronghold} from './base/CorporateStronghold';
import {CrediCor} from './corporation/CrediCor';
import {EcoLine} from './corporation/EcoLine';
import {Helion} from './corporation/Helion';
import {InterplanetaryCinematics} from './corporation/InterplanetaryCinematics';
import {Inventrix} from './corporation/Inventrix';
import {MiningGuild} from './corporation/MiningGuild';
import {PhoboLog} from './corporation/PhoboLog';
import {SaturnSystems} from './corporation/SaturnSystems';
import {Teractor} from './corporation/Teractor';
import {TharsisRepublic} from './corporation/TharsisRepublic';
import {Thorgate} from './corporation/Thorgate';
import {UnitedNationsMarsInitiative} from './corporation/UnitedNationsMarsInitiative';
import {CupolaCity} from './base/CupolaCity';
import {Decomposers} from './base/Decomposers';
import {DeepWellHeating} from './base/DeepWellHeating';
import {DeimosDown} from './base/DeimosDown';
import {DesignedMicroOrganisms} from './base/DesignedMicroOrganisms';
import {DevelopmentCenter} from './base/DevelopmentCenter';
import {DomedCrater} from './base/DomedCrater';
import {DustSeals} from './base/DustSeals';
import {EarthCatapult} from './base/EarthCatapult';
import {EarthOffice} from './base/EarthOffice';
import {EcologicalZone} from './base/EcologicalZone';
import {ElectroCatapult} from './base/ElectroCatapult';
import {EnergySaving} from './base/EnergySaving';
import {EnergyTapping} from './base/EnergyTapping';
import {EosChasmaNationalPark} from './base/EOSChasmaNationalPark';
import {EquatorialMagnetizer} from './base/EquatorialMagnetizer';
import {ExtremeColdFungus} from './base/ExtremeColdFungus';
import {Farming} from './base/Farming';
import {Fish} from './base/Fish';
import {Flooding} from './base/Flooding';
import {FoodFactory} from './base/FoodFactory';
import {FueledGenerators} from './base/FueledGenerators';
import {FuelFactory} from './base/FuelFactory';
import {FusionPower} from './base/FusionPower';
import {GanymedeColony} from './base/GanymedeColony';
import {GeneRepair} from './base/GeneRepair';
import {GeothermalPower} from './base/GeothermalPower';
import {GHGFactories} from './base/GHGFactories';
import {GHGProducingBacteria} from './base/GHGProducingBacteria';
import {GiantIceAsteroid} from './base/GiantIceAsteroid';
import {GiantSpaceMirror} from './base/GiantSpaceMirror';
import {Grass} from './base/Grass';
import {GreatDam} from './base/GreatDam';
import {GreatEscarpmentConsortium} from './base/GreatEscarpmentConsortium';
import {Greenhouses} from './base/Greenhouses';
import {Hackers} from './base/Hackers';
import {Heather} from './base/Heather';
import {HeatTrappers} from './base/HeatTrappers';
import {Herbivores} from './base/Herbivores';
import {HiredRaiders} from './base/HiredRaiders';
import {IceAsteroid} from './base/IceAsteroid';
import {IceCapMelting} from './base/IceCapMelting';
import {ImmigrantCity} from './base/ImmigrantCity';
import {ImmigrationShuttles} from './base/ImmigrationShuttles';
import {ImportedGHG} from './base/ImportedGHG';
import {ImportedHydrogen} from './base/ImportedHydrogen';
import {ImportedNitrogen} from './base/ImportedNitrogen';
import {ImportOfAdvancedGHG} from './base/ImportOfAdvancedGHG';
import {IndenturedWorkers} from './base/IndenturedWorkers';
import {IndustrialCenter} from './base/IndustrialCenter';
import {IndustrialMicrobes} from './base/IndustrialMicrobes';
import {Insects} from './base/Insects';
import {Insulation} from './base/Insulation';
import {InterstellarColonyShip} from './base/InterstellarColonyShip';
import {InventionContest} from './base/InventionContest';
import {InventorsGuild} from './base/InventorsGuild';
import {InvestmentLoan} from './base/InvestmentLoan';
import {IoMiningIndustries} from './base/IoMiningIndustries';
import {Ironworks} from './base/Ironworks';
import {KelpFarming} from './base/KelpFarming';
import {LagrangeObservatory} from './base/LagrangeObservatory';
import {LakeMarineris} from './base/LakeMarineris';
import {LandClaim} from './base/LandClaim';
import {LargeConvoy} from './base/LargeConvoy';
import {LavaFlows} from './base/LavaFlows';
import {Lichen} from './base/Lichen';
import {LightningHarvest} from './base/LightningHarvest';
import {Livestock} from './base/Livestock';
import {LocalHeatTrapping} from './base/LocalHeatTrapping';
import {LunarBeam} from './base/LunarBeam';
import {MagneticFieldDome} from './base/MagneticFieldDome';
import {MagneticFieldGenerators} from './base/MagneticFieldGenerators';
import {Mangrove} from './base/Mangrove';
import {MarsUniversity} from './base/MarsUniversity';
import {MartianRails} from './base/MartianRails';
import {MassConverter} from './base/MassConverter';
import {MediaArchives} from './base/MediaArchives';
import {MediaGroup} from './base/MediaGroup';
import {MedicalLab} from './base/MedicalLab';
import {MethaneFromTitan} from './base/MethaneFromTitan';
import {MicroMills} from './base/MicroMills';
import {Mine} from './base/Mine';
import {MineralDeposit} from './base/MineralDeposit';
import {MiningArea} from './base/MiningArea';
import {MiningExpedition} from './base/MiningExpedition';
import {MiningRights} from './base/MiningRights';
import {MirandaResort} from './base/MirandaResort';
import {MoholeArea} from './base/MoholeArea';
import {Moss} from './base/Moss';
import {NaturalPreserve} from './base/NaturalPreserve';
import {NitriteReducingBacteria} from './base/NitriteReducingBacteria';
import {NitrogenRichAsteroid} from './base/NitrogenRichAsteroid';
import {NitrophilicMoss} from './base/NitrophilicMoss';
import {NoctisCity} from './base/NoctisCity';
import {NoctisFarming} from './base/NoctisFarming';
import {NuclearPower} from './base/NuclearPower';
import {NuclearZone} from './base/NuclearZone';
import {OlympusConference} from './base/OlympusConference';
import {OpenCity} from './base/OpenCity';
import {OptimalAerobraking} from './base/OptimalAerobraking';
import {OreProcessor} from './base/OreProcessor';
import {PermafrostExtraction} from './base/PermafrostExtraction';
import {PeroxidePower} from './base/PeroxidePower';
import {Pets} from './base/Pets';
import {PhobosSpaceHaven} from './base/PhobosSpaceHaven';
import {PhysicsComplex} from './base/PhysicsComplex';
import {Plantation} from './base/Plantation';
import {PowerGrid} from './base/PowerGrid';
import {PowerInfrastructure} from './base/PowerInfrastructure';
import {PowerPlant} from './base/PowerPlant';
import {PowerSupplyConsortium} from './base/PowerSupplyConsortium';
import {Predators} from './base/Predators';
import {ProtectedHabitats} from './base/ProtectedHabitats';
import {ProtectedValley} from './base/ProtectedValley';
import {QuantumExtractor} from './base/QuantumExtractor';
import {RadChemFactory} from './base/RadChemFactory';
import {RadSuits} from './base/RadSuits';
import {RegolithEaters} from './base/RegolithEaters';
import {ReleaseOfInertGases} from './base/ReleaseOfInertGases';
import {Research} from './base/Research';
import {ResearchOutpost} from './base/ResearchOutpost';
import {RestrictedArea} from './base/RestrictedArea';
import {RoboticWorkforce} from './base/RoboticWorkforce';
import {RoverConstruction} from './base/RoverConstruction';
import {Sabotage} from './base/Sabotage';
import {Satellites} from './base/Satellites';
import {SearchForLife} from './base/SearchForLife';
import {SecurityFleet} from './base/SecurityFleet';
import {Shuttles} from './base/Shuttles';
import {SmallAnimals} from './base/SmallAnimals';
import {SoilFactory} from './base/SoilFactory';
import {SolarPower} from './base/SolarPower';
import {SolarWindPower} from './base/SolarWindPower';
import {Soletta} from './base/Soletta';
import {SpaceElevator} from './base/SpaceElevator';
import {SpaceMirrors} from './base/SpaceMirrors';
import {SpaceStation} from './base/SpaceStation';
import {SpecialDesign} from './base/SpecialDesign';
import {Sponsors} from './base/Sponsors';
import {StandardTechnology} from './base/StandardTechnology';
import {Steelworks} from './base/Steelworks';
import {StripMine} from './base/StripMine';
import {SubterraneanReservoir} from './base/SubterraneanReservoir';
import {SymbioticFungus} from './base/SymbioticFungus';
import {Tardigrades} from './base/Tardigrades';
import {TechnologyDemonstration} from './base/TechnologyDemonstration';
import {TectonicStressPower} from './base/TectonicStressPower';
import {TerraformingGanymede} from './base/TerraformingGanymede';
import {TitaniumMine} from './base/TitaniumMine';
import {TollStation} from './base/TollStation';
import {TowingAComet} from './base/TowingAComet';
import {TransNeptuneProbe} from './base/TransNeptuneProbe';
import {Trees} from './base/Trees';
import {TropicalResort} from './base/TropicalResort';
import {TundraFarming} from './base/TundraFarming';
import {UndergroundCity} from './base/UndergroundCity';
import {UndergroundDetonations} from './base/UndergroundDetonations';
import {UrbanizedArea} from './base/UrbanizedArea';
import {VestaShipyard} from './base/VestaShipyard';
import {ViralEnhancers} from './base/ViralEnhancers';
import {Virus} from './base/Virus';
import {WaterImportFromEuropa} from './base/WaterImportFromEuropa';
import {WaterSplittingPlant} from './base/WaterSplittingPlant';
import {WavePower} from './base/WavePower';
import {Windmills} from './base/Windmills';
import {Worms} from './base/Worms';
import {Zeppelins} from './base/Zeppelins';
import {AquiferStandardProject} from './base/standardActions/standardProjects/AquiferStandardProject';
import {CityStandardProject} from './base/standardActions/standardProjects/CityStandardProject';
import {PowerPlantStandardProject} from './base/standardActions/standardProjects/PowerPlantStandardProject';
import {GreeneryStandardProject} from './base/standardActions/standardProjects/GreeneryStandardProject';
import {AsteroidStandardProject} from './base/standardActions/standardProjects/AsteroidStandardProject';
import {SellPatentsStandardProject} from './base/standardActions/standardProjects/SellPatentsStandardProject';
import {ConvertPlants} from './base/standardActions/ConvertPlants';
import {ConvertHeat} from './base/standardActions/ConvertHeat';
import {BufferGasStandardProject} from './prelude/BufferGasStandardProject';

export const BASE_CARD_MANIFEST = new ModuleManifest({
  module: 'base',
  projectCards: {
    [CardName.ADAPTATION_TECHNOLOGY]: {Factory: AdaptationTechnology},
    [CardName.ADAPTED_LICHEN]: {Factory: AdaptedLichen},
    [CardName.ADVANCED_ECOSYSTEMS]: {Factory: AdvancedEcosystems},
    [CardName.AEROBRAKED_AMMONIA_ASTEROID]: {Factory: AerobrakedAmmoniaAsteroid},
    [CardName.ANTS]: {Factory: Ants},
    [CardName.AQUIFER_PUMPING]: {Factory: AquiferPumping},
    [CardName.ALGAE]: {Factory: Algae},
    [CardName.ARCHAEBACTERIA]: {Factory: ArchaeBacteria},
    [CardName.ARCTIC_ALGAE]: {Factory: ArcticAlgae},
    [CardName.ARTIFICIAL_LAKE]: {Factory: ArtificialLake},
    [CardName.ARTIFICIAL_PHOTOSYNTHESIS]: {Factory: ArtificialPhotosynthesis},
    [CardName.ASTEROID]: {Factory: Asteroid},
    [CardName.ASTEROID_MINING]: {Factory: AsteroidMining},
    [CardName.BEAM_FROM_A_THORIUM_ASTEROID]: {Factory: BeamFromAThoriumAsteroid},
    [CardName.BIG_ASTEROID]: {Factory: BigAsteroid},
    [CardName.BIOMASS_COMBUSTORS]: {Factory: BiomassCombustors},
    [CardName.BIRDS]: {Factory: Birds},
    [CardName.BLACK_POLAR_DUST]: {Factory: BlackPolarDust},
    [CardName.BREATHING_FILTERS]: {Factory: BreathingFilters},
    [CardName.BUSHES]: {Factory: Bushes},
    [CardName.CAPITAL]: {Factory: Capital},
    [CardName.CARBONATE_PROCESSING]: {Factory: CarbonateProcessing},
    [CardName.CLOUD_SEEDING]: {Factory: CloudSeeding},
    [CardName.COLONIZER_TRAINING_CAMP]: {Factory: ColonizerTrainingCamp},
    [CardName.COMET]: {Factory: Comet},
    [CardName.CONVOY_FROM_EUROPA]: {Factory: ConvoyFromEuropa},
    [CardName.CUPOLA_CITY]: {Factory: CupolaCity},
    [CardName.DECOMPOSERS]: {Factory: Decomposers},
    [CardName.DEEP_WELL_HEATING]: {Factory: DeepWellHeating},
    [CardName.DEIMOS_DOWN]: {Factory: DeimosDown},
    [CardName.DESIGNED_MICROORGANISMS]: {Factory: DesignedMicroOrganisms},
    [CardName.DOMED_CRATER]: {Factory: DomedCrater},
    [CardName.DUST_SEALS]: {Factory: DustSeals},
    [CardName.ECOLOGICAL_ZONE]: {Factory: EcologicalZone},
    [CardName.ENERGY_SAVING]: {Factory: EnergySaving},
    [CardName.EOS_CHASMA_NATIONAL_PARK]: {Factory: EosChasmaNationalPark},
    [CardName.EQUATORIAL_MAGNETIZER]: {Factory: EquatorialMagnetizer},
    [CardName.EXTREME_COLD_FUNGUS]: {Factory: ExtremeColdFungus},
    [CardName.FARMING]: {Factory: Farming},
    [CardName.FISH]: {Factory: Fish},
    [CardName.FLOODING]: {Factory: Flooding},
    [CardName.FOOD_FACTORY]: {Factory: FoodFactory},
    [CardName.FUSION_POWER]: {Factory: FusionPower},
    [CardName.FUELED_GENERATORS]: {Factory: FueledGenerators},
    [CardName.GANYMEDE_COLONY]: {Factory: GanymedeColony},
    [CardName.GEOTHERMAL_POWER]: {Factory: GeothermalPower},
    [CardName.GHG_FACTORIES]: {Factory: GHGFactories},
    [CardName.GHG_PRODUCING_BACTERIA]: {Factory: GHGProducingBacteria},
    [CardName.GIANT_ICE_ASTEROID]: {Factory: GiantIceAsteroid},
    [CardName.GIANT_SPACE_MIRROR]: {Factory: GiantSpaceMirror},
    [CardName.GRASS]: {Factory: Grass},
    [CardName.GREAT_DAM]: {Factory: GreatDam},
    [CardName.GREENHOUSES]: {Factory: Greenhouses},
    [CardName.HEATHER]: {Factory: Heather},
    [CardName.HEAT_TRAPPERS]: {Factory: HeatTrappers},
    [CardName.HERBIVORES]: {Factory: Herbivores},
    [CardName.ICE_ASTEROID]: {Factory: IceAsteroid},
    [CardName.ICE_CAP_MELTING]: {Factory: IceCapMelting},
    [CardName.IMMIGRANT_CITY]: {Factory: ImmigrantCity},
    [CardName.IMMIGRATION_SHUTTLES]: {Factory: ImmigrationShuttles},
    [CardName.IMPORTED_GHG]: {Factory: ImportedGHG},
    [CardName.IMPORTED_HYDROGEN]: {Factory: ImportedHydrogen},
    [CardName.IMPORTED_NITROGEN]: {Factory: ImportedNitrogen},
    [CardName.IMPORT_OF_ADVANCED_GHG]: {Factory: ImportOfAdvancedGHG},
    [CardName.INDUSTRIAL_MICROBES]: {Factory: IndustrialMicrobes},
    [CardName.INSECTS]: {Factory: Insects},
    [CardName.INSULATION]: {Factory: Insulation},
    [CardName.IRONWORKS]: {Factory: Ironworks},
    [CardName.KELP_FARMING]: {Factory: KelpFarming},
    [CardName.LAKE_MARINERIS]: {Factory: LakeMarineris},
    [CardName.LARGE_CONVOY]: {Factory: LargeConvoy},
    [CardName.LAVA_FLOWS]: {Factory: LavaFlows},
    [CardName.LICHEN]: {Factory: Lichen},
    [CardName.LIVESTOCK]: {Factory: Livestock},
    [CardName.LOCAL_HEAT_TRAPPING]: {Factory: LocalHeatTrapping},
    [CardName.LUNAR_BEAM]: {Factory: LunarBeam},
    [CardName.MAGNETIC_FIELD_DOME]: {Factory: MagneticFieldDome},
    [CardName.MAGNETIC_FIELD_GENERATORS]: {Factory: MagneticFieldGenerators},
    [CardName.MANGROVE]: {Factory: Mangrove},
    [CardName.MARTIAN_RAILS]: {Factory: MartianRails},
    [CardName.METHANE_FROM_TITAN]: {Factory: MethaneFromTitan},
    [CardName.MICRO_MILLS]: {Factory: MicroMills},
    [CardName.MINING_EXPEDITION]: {Factory: MiningExpedition},
    [CardName.MINING_RIGHTS]: {Factory: MiningRights},
    [CardName.MOHOLE_AREA]: {Factory: MoholeArea},
    [CardName.MOSS]: {Factory: Moss},
    [CardName.NATURAL_PRESERVE]: {Factory: NaturalPreserve},
    [CardName.NITRITE_REDUCING_BACTERIA]: {Factory: NitriteReducingBacteria},
    [CardName.NITROGEN_RICH_ASTEROID]: {Factory: NitrogenRichAsteroid},
    [CardName.NITROPHILIC_MOSS]: {Factory: NitrophilicMoss},
    [CardName.NOCTIS_CITY]: {Factory: NoctisCity},
    [CardName.NOCTIS_FARMING]: {Factory: NoctisFarming},
    [CardName.NUCLEAR_POWER]: {Factory: NuclearPower},
    [CardName.NUCLEAR_ZONE]: {Factory: NuclearZone},
    [CardName.OPEN_CITY]: {Factory: OpenCity},
    [CardName.OPTIMAL_AEROBRAKING]: {Factory: OptimalAerobraking},
    [CardName.ORE_PROCESSOR]: {Factory: OreProcessor},
    [CardName.PERMAFROST_EXTRACTION]: {Factory: PermafrostExtraction},
    [CardName.PEROXIDE_POWER]: {Factory: PeroxidePower},
    [CardName.PETS]: {Factory: Pets},
    [CardName.PHOBOS_SPACE_HAVEN]: {Factory: PhobosSpaceHaven},
    [CardName.PLANTATION]: {Factory: Plantation},
    [CardName.POWER_GRID]: {Factory: PowerGrid},
    [CardName.POWER_PLANT]: {Factory: PowerPlant},
    [CardName.PREDATORS]: {Factory: Predators},
    [CardName.PROTECTED_VALLEY]: {Factory: ProtectedValley},
    [CardName.RAD_CHEM_FACTORY]: {Factory: RadChemFactory},
    [CardName.REGOLITH_EATERS]: {Factory: RegolithEaters},
    [CardName.RELEASE_OF_INERT_GASES]: {Factory: ReleaseOfInertGases},
    [CardName.RESEARCH_OUTPOST]: {Factory: ResearchOutpost},
    [CardName.ROVER_CONSTRUCTION]: {Factory: RoverConstruction},
    [CardName.SEARCH_FOR_LIFE]: {Factory: SearchForLife},
    [CardName.SHUTTLES]: {Factory: Shuttles},
    [CardName.SMALL_ANIMALS]: {Factory: SmallAnimals},
    [CardName.SOIL_FACTORY]: {Factory: SoilFactory},
    [CardName.SOLAR_POWER]: {Factory: SolarPower},
    [CardName.SOLAR_WIND_POWER]: {Factory: SolarWindPower},
    [CardName.SOLETTA]: {Factory: Soletta},
    [CardName.SPACE_MIRRORS]: {Factory: SpaceMirrors},
    [CardName.SPECIAL_DESIGN]: {Factory: SpecialDesign},
    [CardName.STEELWORKS]: {Factory: Steelworks},
    [CardName.STRIP_MINE]: {Factory: StripMine},
    [CardName.SUBTERRANEAN_RESERVOIR]: {Factory: SubterraneanReservoir},
    [CardName.SYMBIOTIC_FUNGUS]: {Factory: SymbioticFungus},
    [CardName.TECTONIC_STRESS_POWER]: {Factory: TectonicStressPower},
    [CardName.TOWING_A_COMET]: {Factory: TowingAComet},
    [CardName.TREES]: {Factory: Trees},
    [CardName.TUNDRA_FARMING]: {Factory: TundraFarming},
    [CardName.UNDERGROUND_CITY]: {Factory: UndergroundCity},
    [CardName.UNDERGROUND_DETONATIONS]: {Factory: UndergroundDetonations},
    [CardName.URBANIZED_AREA]: {Factory: UrbanizedArea},
    [CardName.WATER_IMPORT_FROM_EUROPA]: {Factory: WaterImportFromEuropa},
    [CardName.WATER_SPLITTING_PLANT]: {Factory: WaterSplittingPlant},
    [CardName.WAVE_POWER]: {Factory: WavePower},
    [CardName.WINDMILLS]: {Factory: Windmills},
    [CardName.WORMS]: {Factory: Worms},
    [CardName.ZEPPELINS]: {Factory: Zeppelins},
  },
  corporationCards: {
    [CardName.BEGINNER_CORPORATION]: {Factory: BeginnerCorporation},
    [CardName.CREDICOR]: {Factory: CrediCor},
    [CardName.ECOLINE]: {Factory: EcoLine},
    [CardName.HELION]: {Factory: Helion},
    [CardName.INTERPLANETARY_CINEMATICS]: {Factory: InterplanetaryCinematics},
    [CardName.INVENTRIX]: {Factory: Inventrix},
    [CardName.MINING_GUILD]: {Factory: MiningGuild},
    [CardName.PHOBOLOG]: {Factory: PhoboLog},
    [CardName.THARSIS_REPUBLIC]: {Factory: TharsisRepublic},
    [CardName.THORGATE]: {Factory: Thorgate},
    [CardName.UNITED_NATIONS_MARS_INITIATIVE]: {Factory: UnitedNationsMarsInitiative},
  },
  standardProjects: {
    [CardName.AQUIFER_STANDARD_PROJECT]: {Factory: AquiferStandardProject},
    [CardName.CITY_STANDARD_PROJECT]: {Factory: CityStandardProject},
    [CardName.POWER_PLANT_STANDARD_PROJECT]: {Factory: PowerPlantStandardProject},
    [CardName.GREENERY_STANDARD_PROJECT]: {Factory: GreeneryStandardProject},
    [CardName.ASTEROID_STANDARD_PROJECT]: {Factory: AsteroidStandardProject},
    [CardName.SELL_PATENTS_STANDARD_PROJECT]: {Factory: SellPatentsStandardProject},
    [CardName.BUFFER_GAS_STANDARD_PROJECT]: {Factory: BufferGasStandardProject},
  },
  standardActions: {
    [CardName.CONVERT_PLANTS]: {Factory: ConvertPlants},
    [CardName.CONVERT_HEAT]: {Factory: ConvertHeat},
  },
});


export const CORP_ERA_CARD_MANIFEST = new ModuleManifest({
  module: 'corpera',
  projectCards: {
    [CardName.ACQUIRED_COMPANY]: {Factory: AcquiredCompany},
    [CardName.ADVANCED_ALLOYS]: {Factory: AdvancedAlloys},
    [CardName.AI_CENTRAL]: {Factory: AICentral},
    [CardName.ANTI_GRAVITY_TECHNOLOGY]: {Factory: AntiGravityTechnology},
    [CardName.ASTEROID_MINING_CONSORTIUM]: {Factory: AsteroidMiningConsortium},
    [CardName.BRIBED_COMMITTEE]: {Factory: BribedCommittee},
    [CardName.BUILDING_INDUSTRIES]: {Factory: BuildingIndustries},
    [CardName.BUSINESS_CONTACTS]: {Factory: BusinessContacts},
    [CardName.BUSINESS_NETWORK]: {Factory: BusinessNetwork},
    [CardName.CALLISTO_PENAL_MINES]: {Factory: CallistoPenalMines},
    [CardName.CARETAKER_CONTRACT]: {Factory: CaretakerContract},
    [CardName.CARTEL]: {Factory: Cartel},
    [CardName.CEOS_FAVORITE_PROJECT]: {Factory: CEOsFavoriteProject},
    [CardName.COMMERCIAL_DISTRICT]: {Factory: CommercialDistrict},
    [CardName.CORPORATE_STRONGHOLD]: {Factory: CorporateStronghold},
    [CardName.DEVELOPMENT_CENTER]: {Factory: DevelopmentCenter},
    [CardName.EARTH_CATAPULT]: {Factory: EarthCatapult},
    [CardName.EARTH_OFFICE]: {Factory: EarthOffice},
    [CardName.ELECTRO_CATAPULT]: {Factory: ElectroCatapult},
    [CardName.ENERGY_TAPPING]: {Factory: EnergyTapping},
    [CardName.FUEL_FACTORY]: {Factory: FuelFactory},
    [CardName.GENE_REPAIR]: {Factory: GeneRepair},
    [CardName.GREAT_ESCARPMENT_CONSORTIUM]: {Factory: GreatEscarpmentConsortium},
    [CardName.HACKERS]: {Factory: Hackers},
    [CardName.HIRED_RAIDERS]: {Factory: HiredRaiders},
    [CardName.INDENTURED_WORKERS]: {Factory: IndenturedWorkers},
    [CardName.INDUSTRIAL_CENTER]: {Factory: IndustrialCenter},
    [CardName.INTERSTELLAR_COLONY_SHIP]: {Factory: InterstellarColonyShip},
    [CardName.INVENTION_CONTEST]: {Factory: InventionContest},
    [CardName.INVENTORS_GUILD]: {Factory: InventorsGuild},
    [CardName.INVESTMENT_LOAN]: {Factory: InvestmentLoan},
    [CardName.IO_MINING_INDUSTRIES]: {Factory: IoMiningIndustries},
    [CardName.LAGRANGE_OBSERVATORY]: {Factory: LagrangeObservatory},
    [CardName.LAND_CLAIM]: {Factory: LandClaim},
    [CardName.LIGHTNING_HARVEST]: {Factory: LightningHarvest},
    [CardName.MARS_UNIVERSITY]: {Factory: MarsUniversity},
    [CardName.MASS_CONVERTER]: {Factory: MassConverter},
    [CardName.MEDIA_ARCHIVES]: {Factory: MediaArchives},
    [CardName.MEDIA_GROUP]: {Factory: MediaGroup},
    [CardName.MEDICAL_LAB]: {Factory: MedicalLab},
    [CardName.MINE]: {Factory: Mine},
    [CardName.MINERAL_DEPOSIT]: {Factory: MineralDeposit},
    [CardName.MINING_AREA]: {Factory: MiningArea},
    [CardName.MIRANDA_RESORT]: {Factory: MirandaResort},
    [CardName.OLYMPUS_CONFERENCE]: {Factory: OlympusConference},
    [CardName.PHYSICS_COMPLEX]: {Factory: PhysicsComplex},
    [CardName.POWER_INFRASTRUCTURE]: {Factory: PowerInfrastructure},
    [CardName.POWER_SUPPLY_CONSORTIUM]: {Factory: PowerSupplyConsortium},
    [CardName.PROTECTED_HABITATS]: {Factory: ProtectedHabitats},
    [CardName.QUANTUM_EXTRACTOR]: {Factory: QuantumExtractor},
    [CardName.RAD_SUITS]: {Factory: RadSuits},
    [CardName.RESEARCH]: {Factory: Research},
    [CardName.RESTRICTED_AREA]: {Factory: RestrictedArea},
    [CardName.ROBOTIC_WORKFORCE]: {Factory: RoboticWorkforce},
    [CardName.SABOTAGE]: {Factory: Sabotage},
    [CardName.SATELLITES]: {Factory: Satellites},
    [CardName.SECURITY_FLEET]: {Factory: SecurityFleet},
    [CardName.SPACE_ELEVATOR]: {Factory: SpaceElevator},
    [CardName.SPACE_STATION]: {Factory: SpaceStation},
    [CardName.SPONSORS]: {Factory: Sponsors},
    [CardName.STANDARD_TECHNOLOGY]: {Factory: StandardTechnology},
    [CardName.TARDIGRADES]: {Factory: Tardigrades},
    [CardName.TECHNOLOGY_DEMONSTRATION]: {Factory: TechnologyDemonstration},
    [CardName.TERRAFORMING_GANYMEDE]: {Factory: TerraformingGanymede},
    [CardName.TITANIUM_MINE]: {Factory: TitaniumMine},
    [CardName.TOLL_STATION]: {Factory: TollStation},
    [CardName.TRANS_NEPTUNE_PROBE]: {Factory: TransNeptuneProbe},
    [CardName.TROPICAL_RESORT]: {Factory: TropicalResort},
    [CardName.VESTA_SHIPYARD]: {Factory: VestaShipyard},
    [CardName.VIRAL_ENHANCERS]: {Factory: ViralEnhancers},
    [CardName.VIRUS]: {Factory: Virus},
  },

  corporationCards: {
    [CardName.SATURN_SYSTEMS]: {Factory: SaturnSystems},
    [CardName.TERACTOR]: {Factory: Teractor},
  },
});

================
File: cards/StandardProjectCard.ts
================
import {CardType} from '../../common/cards/CardType';
import {IPlayer} from '../IPlayer';
import {TRSource} from '../../common/cards/TRSource';
import {PlayerInput} from '../PlayerInput';
import {CardMetadata} from '../../common/cards/CardMetadata';
import {CardName} from '../../common/cards/CardName';
import {SelectPaymentDeferred} from '../deferredActions/SelectPaymentDeferred';
import {Card} from './Card';
import {MoonExpansion} from '../moon/MoonExpansion';
import {Units} from '../../common/Units';
import {message} from '../logs/MessageBuilder';
import {IStandardProjectCard} from './IStandardProjectCard';
import {sum} from '../../common/utils/utils';

type StaticStandardProjectCardProperties = {
  name: CardName,
  cost: number,
  metadata: CardMetadata,
  reserveUnits?: Partial<Units>,
  tr?: TRSource,
}

export type StandardProjectCanPayWith = {
  steel?: boolean,
  titanium?: boolean,
  seeds?: boolean,
  kuiperAsteroids?: boolean,
  // tr?: TRSource,
}

export abstract class StandardProjectCard extends Card implements IStandardProjectCard {
  constructor(properties: StaticStandardProjectCardProperties) {
    super({
      type: CardType.STANDARD_PROJECT,
      ...properties,
    });
  }

  public override get type(): CardType.STANDARD_PROJECT {
    return CardType.STANDARD_PROJECT;
  }

  protected discount(_player: IPlayer) {
    return 0;
  }

  private adjustedCost(player: IPlayer) {
    const discountFromCards = sum(player.playedCards.map((card) => card.getStandardProjectDiscount?.(player, this) ?? 0));
    const discount = discountFromCards + this.discount(player);
    const adjusted = Math.max(0, this.cost - discount);
    return adjusted;
  }

  protected abstract actionEssence(player: IPlayer): void

  public onStandardProject(player: IPlayer): void {
    for (const playedCard of player.tableau) {
      playedCard.onStandardProject?.(player, this);
    }
  }

  protected canPlayOptions(player: IPlayer) {
    const canPayWith = this.canPayWith(player);
    return {
      ...canPayWith,
      cost: this.adjustedCost(player),
      tr: this.tr,
      auroraiData: true,
      spireScience: true,
      reserveUnits: MoonExpansion.adjustedReserveCosts(player, this),
    };
  }

  public canAct(player: IPlayer): boolean {
    return player.canAfford(this.canPlayOptions(player));
  }

  public canPayWith(_player: IPlayer): StandardProjectCanPayWith {
    return {};
  }

  protected projectPlayed(player: IPlayer) {
    player.game.log('${0} used ${1} standard project', (b) => b.player(player).card(this));
    this.onStandardProject(player);
  }

  public action(player: IPlayer): PlayerInput | undefined {
    const canPayWith = this.canPayWith(player);
    player.game.defer(new SelectPaymentDeferred(
      player,
      this.adjustedCost(player),
      {
        canUseSteel: canPayWith.steel || player.cardIsInEffect(CardName.STANDARD_ALLOYS),
        canUseTitanium: canPayWith.titanium,
        canUseSeeds: canPayWith.seeds,
        canUseAuroraiData: player.isCorporation(CardName.AURORAI),
        canUseSpireScience: player.isCorporation(CardName.SPIRE),
        canUseAsteroids: canPayWith.kuiperAsteroids && player.isCorporation(CardName.KUIPER_COOPERATIVE),
        title: message('Select how to pay for the ${0} standard project', (b) => b.cardName(this.name)),
      })).andThen(() => {
      this.projectPlayed(player);
      this.actionEssence(player);
    });
    return undefined;
  }
}

================
File: cards/starwars/BeholdTheEmperor.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Player} from '../../Player';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class BeholdTheEmperor extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.BEHOLD_THE_EMPEROR,
      tags: [Tag.EARTH],
      cost: 10,
      requirements: {chairman: 1},

      metadata: {
        cardNumber: 'SW03',
        renderData: CardRenderer.builder((b) => b.chairman().asterix()),
        description:
          'Requires that you are Chairman. The current ruling party will automatically be the ruling party during the next Solar phase, ' +
          'and you will remain the Chairman. (As if the current ruling party were dominant and you were its party leader.)',
      },
    });
  }

  public override bespokePlay(player: Player) {
    player.game.beholdTheEmperor = true;
    return undefined;
  }
}

================
File: cards/starwars/CloneTroopers.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IActionCard} from '../ICard';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Player} from '../../Player';
import {CardName} from '../../../common/cards/CardName';
import {ALL_RESOURCES} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {CardResource} from '../../../common/CardResource';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {Size} from '../../../common/cards/render/Size';
import {message} from '../../logs/MessageBuilder';
import {SelectResource} from '../../inputs/SelectResource';
import {Units} from '../../../common/Units';

export class CloneTroopers extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CLONE_TROOPERS,
      tags: [Tag.SCIENCE],
      cost: 12,
      resourceType: CardResource.CLONE_TROOPER,
      requirements: {oceans: 6},
      victoryPoints: {resourcesHere: {}},

      metadata: {
        cardNumber: 'SW02',
        renderData: CardRenderer.builder((b) => {
          b.arrow(Size.SMALL).resource(CardResource.CLONE_TROOPER).or().resource(CardResource.CLONE_TROOPER).arrow(Size.SMALL).text('STEAL', Size.SMALL).wild(1, {all});
          b.br;
          b.text('(Action: Add one Clone Trooper to this card OR remove one Clone Trooper from this card to steal one standard resource from any player.)', Size.TINY, false, false);
        }),
        description: 'Requires 6 ocean tiles. 1 VP per Clone Trooper on this card.',
      },
    });
  }

  public canAct(): boolean {
    return true;
  }

  public action(player: Player) {
    if (this.resourceCount > 0) {
      const options = new OrOptions();
      options.options.push(new SelectOption('Add a Clone Trooper to this card').andThen(() => {
        player.addResourceTo(this, {log: true});
        return undefined;
      }));
      if (player.game.isSoloMode()) {
        options.options.push(new SelectResource('Steal a resource')
          .andThen((resource) => {
            player.stock.add(Units.ResourceMap[resource], 1);
            player.removeResourceFrom(this, 1);
            return undefined;
          }));
      } else {
        const allPlayers = player.getOpponents();
        ALL_RESOURCES.forEach((resource) => {
          allPlayers.forEach((target) => {
            if (target.stock.get(resource) > 0) {
              // TODO(kberg): Included protected resources
              options.options.push(new SelectOption(
                message('Steal 1 ${0} from ${1}', (b) => b.string(resource).player(target)), 'steal').andThen(() => {
                target.maybeBlockAttack(player, (proceed) => {
                  if (proceed) {
                    target.stock.steal(resource, 1, player);
                    player.removeResourceFrom(this, 1);
                  }
                  return undefined;
                });
                return undefined;
              }));
            }
          });
        });
      }
      if (options.options.length > 1) {
        return options;
      }
    }

    // Fallback.
    player.addResourceTo(this, {log: true});
    return undefined;
  }
}

================
File: cards/starwars/CloudCity.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';

export class CloudCity extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CLOUD_CITY,
      tags: [Tag.VENUS],
      cost: 5,
      requirements: {venus: 6},

      behavior: {
        global: {venus: 1},
        addResourcesToAnyCard: {count: 2, type: CardResource.FLOATER},
      },

      metadata: {
        cardNumber: 'SW05',
        renderData: CardRenderer.builder((b) => b.venus(1).resource(CardResource.FLOATER, 2)),
        description: 'Requires Venus 6%. Raise Venus 1 step. Add 2 floaters to any card.',
      },
    });
  }
}

================
File: cards/starwars/ForestMoon.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {CardResource} from '../../../common/CardResource';
import {Resource} from '../../../common/Resource';

export class ForestMoon extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FOREST_MOON,
      tags: [Tag.PLANT, Tag.ANIMAL],
      cost: 15,
      requirements: {greeneries: 4, all},
      victoryPoints: 1,

      behavior: {
        decreaseAnyProduction: {count: 2, type: Resource.ENERGY},
        addResourcesToAnyCard: {count: 1, type: CardResource.ANIMAL},
      },

      metadata: {
        cardNumber: 'SW06',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().energy(2, {all})).resource(CardResource.ANIMAL);
        }),
        description: 'Requires any 4 greeneries on Mars. Decrease any energy production 2 steps. Add an animal to any card.',
      },
    });
  }
}

================
File: cards/starwars/ReySkywalker.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Player} from '../../Player';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {SelectSpace} from '../../inputs/SelectSpace';
import {TileType} from '../../../common/TileType';
import {message} from '../../logs/MessageBuilder';
import {CardResource} from '../../../common/CardResource';
import {AresHandler} from '../../ares/AresHandler';

export class ReySkywalker extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.REY_SKYWALKER,
      tags: [Tag.BUILDING],
      cost: 8,
      victoryPoints: -2,

      behavior: {
        production: {
          megacredits: 4,
        },
      },

      metadata: {
        cardNumber: 'SW09',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(4)).nbsp;
          b.emptyTile().resource(CardResource.RESOURCE_CUBE).asterix();
        }),
        description: 'Raise your M€ production 4 steps. Place a bronze cube on an empty unreserved space on Mars. No tile may be placed on that space for the rest of the game.',
      },
    });
  }

  public override bespokePlay(player: Player) {
    return new SelectSpace(
      message('Select space for ${0}', (b) => b.card(this)),
      player.game.board.getAvailableSpacesOnLand(player).filter((space) => !AresHandler.hasHazardTile(space)))
      .andThen((space) => {
        player.game.simpleAddTile(player, space, {tileType: TileType.REY_SKYWALKER});
        return undefined;
      });
  }
}

================
File: cards/starwars/StarwarsCardManifest.ts
================
import {CardName} from '../../../common/cards/CardName';
import {ModuleManifest} from '../ModuleManifest';
import {ToscheStation} from './ToscheStation';
import {CloudCity} from './CloudCity';
import {TradeEmbargo} from './TradeEmbargo';
import {CloneTroopers} from './CloneTroopers';
import {BeholdTheEmperor} from './BeholdTheEmperor';
import {ForestMoon} from './ForestMoon';
import {TakondaCastle} from './TakondaCastle';
import {ReySkywalker} from './ReySkywalker';
import {ToolWithTheFirstOrder} from './ToolWithTheFirstOrder';

export const STAR_WARS_CARD_MANIFEST = new ModuleManifest({
  module: 'starwars',
  projectCards: {
    [CardName.TRADE_EMBARGO]: {Factory: TradeEmbargo, compatibility: 'colonies'},
    [CardName.CLONE_TROOPERS]: {Factory: CloneTroopers},
    [CardName.BEHOLD_THE_EMPEROR]: {Factory: BeholdTheEmperor, compatibility: 'turmoil'},
    [CardName.TOSCHE_STATION]: {Factory: ToscheStation},
    [CardName.CLOUD_CITY]: {Factory: CloudCity, compatibility: 'venus'},
    [CardName.FOREST_MOON]: {Factory: ForestMoon},
    [CardName.TAKONDA_CASTLE]: {Factory: TakondaCastle},
    [CardName.TOOL_WITH_THE_FIRST_ORDER]: {Factory: ToolWithTheFirstOrder},
    [CardName.REY_SKYWALKER]: {Factory: ReySkywalker},
  },
});

================
File: cards/starwars/TakondaCastle.ts
================
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class TakondaCastle extends Card {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TAKONDA_CASTLE,
      tags: [Tag.POWER, Tag.PLANT],
      cost: 2,

      behavior: {
        stock: {megacredits: {tag: [Tag.MICROBE, Tag.ANIMAL]}},
      },

      metadata: {
        cardNumber: 'SW07',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(1).slash().tag(Tag.MICROBE).tag(Tag.ANIMAL);
        }),
        description: 'Gain 1 M€ for each of your microbe tags and animal tags.',
      },
    });
  }
}

================
File: cards/starwars/ToolWithTheFirstOrder.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Player} from '../../Player';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class ToolWithTheFirstOrder extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TOOL_WITH_THE_FIRST_ORDER,
      tags: [Tag.SPACE],
      cost: 5,

      behavior: {
        tr: 1,
      },

      metadata: {
        cardNumber: 'SW08',
        renderData: CardRenderer.builder((b) => {
          b.arrow().br.tr(1);
        }),
        description: 'Take another action this turn. Gain 1 TR.',
      },
    });
  }

  public override bespokePlay(player: Player) {
    player.availableActionsThisRound++;
    return undefined;
  }
}

================
File: cards/starwars/ToscheStation.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IActionCard} from '../ICard';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Player} from '../../Player';
import {SelectAmount} from '../../inputs/SelectAmount';
import {CardName} from '../../../common/cards/CardName';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';

export class ToscheStation extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TOSCHE_STATION,
      tags: [Tag.POWER, Tag.PLANT],
      cost: 5,

      metadata: {
        cardNumber: 'SW04',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend X Energy and gain X-1 plants (max 4.)', (ab) => {
            ab.text('x').energy(1).startAction.text('x-1').plants(1).text('max 4');
          });
        }),
      },
    });
  }

  public canAct(player: Player): boolean {
    return player.energy > 0;
  }

  public action(player: Player) {
    return new SelectAmount('Select amount of energy to spend', 'Spend energy', 1, Math.min(player.energy, 4))
      .andThen((amount) => {
        player.stock.deduct(Resource.ENERGY, amount);
        player.stock.add(Resource.PLANTS, amount - 1, {log: true});
        return undefined;
      });
  }
}

================
File: cards/starwars/TradeEmbargo.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Player} from '../../Player';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

export class TradeEmbargo extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.TRADE_EMBARGO,
      tags: [Tag.SPACE],
      cost: 4,

      metadata: {
        cardNumber: 'SW01',
        renderData: CardRenderer.builder((b) => {
          b.text('Nobody may trade for the rest of this generation.', Size.LARGE);
        }),
      },
    });
  }

  public override bespokePlay(player: Player) {
    player.game.tradeEmbargo = true;
    return undefined;
  }
}

================
File: cards/turmoil/AerialLenses.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class AerialLenses extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.AERIAL_LENSES,
      cost: 2,
      victoryPoints: -1,

      behavior: {
        production: {heat: 2},
        removeAnyPlants: 2,
      },

      requirements: {party: PartyName.KELVINISTS},
      metadata: {
        description: 'Requires that Kelvinists are ruling or that you have 2 delegates there. Remove up to 2 plants from any player. Increase your heat production 2 steps.',
        cardNumber: 'T01',
        renderData: CardRenderer.builder((b) => b.minus().plants(-2, {all}).production((pb) => pb.heat(2))),
      },
    });
  }
}

================
File: cards/turmoil/BannedDelegate.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectDelegate} from '../../inputs/SelectDelegate';
import {IParty} from '../../turmoil/parties/IParty';
import {CardRenderer} from '../render/CardRenderer';
import {NeutralPlayer, Turmoil} from '../../turmoil/Turmoil';
import {all} from '../Options';
import {MultiSet} from 'mnemonist';

export class BannedDelegate extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.BANNED_DELEGATE,
      cost: 0,

      requirements: {chairman: true},
      metadata: {
        cardNumber: 'T02',
        description: 'Requires that you are Chairman. Remove any NON-LEADER delegate.',
        renderData: CardRenderer.builder((b) => {
          b.minus().delegates(1, {all});
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer): OrOptions | SelectDelegate | undefined {
    const turmoil = Turmoil.getTurmoil(player.game);
    const orOptions: Array<SelectDelegate> = [];
    // Take each party having more than just the party leader in the area
    for (const party of turmoil.parties) {
      if (party.delegates.size > 1) {
        // Remove the party leader from available choices
        const copy = MultiSet.from(party.delegates);
        if (party.partyLeader !== undefined) {
          copy.remove(party.partyLeader);
        } else {
          // This wouldn't happen normally.
          throw new Error(`partyLeader not defined for ${player.game.id}`);
        }
        const players: Array<IPlayer | NeutralPlayer> = [];
        for (const entry of copy.multiplicities()) {
          if (entry[0] === 'NEUTRAL') {
            players.push('NEUTRAL');
          } else {
            players.push(entry[0]);
          }
        }

        if (players.length > 0) {
          const selectDelegate = new SelectDelegate(players, 'Select player delegate to remove from ' + party.name + ' party')
            .andThen((selectedPlayer) => {
              turmoil.removeDelegateFromParty(selectedPlayer, party.name, player.game);
              this.log(player, party, selectedPlayer);
              return undefined;
            });
          selectDelegate.buttonLabel = 'Remove delegate';
          orOptions.push(selectDelegate);
        }
      }
    }
    if (orOptions.length === 0) {
      return undefined;
    } else if (orOptions.length === 1) {
      return orOptions[0];
    } else {
      const options = new OrOptions(...orOptions);
      return options;
    }
  }

  private log(player: IPlayer, party: IParty, selectedPlayer: IPlayer | NeutralPlayer) {
    if (selectedPlayer === 'NEUTRAL') {
      player.game.log('${0} removed neutral delegate from ${1}', (b) => b.player(player).party(party));
    } else {
      player.game.log('${0} removed ${1}\'s delegate from ${2}', (b) => b.player(player).player(selectedPlayer).party(party));
    }
  }
}

================
File: cards/turmoil/CulturalMetropolis.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {PartyName} from '../../../common/turmoil/PartyName';
import {SendDelegateToArea} from '../../deferredActions/SendDelegateToArea';
import {CardRenderer} from '../render/CardRenderer';
import {Turmoil} from '../../turmoil/Turmoil';

export class CulturalMetropolis extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CULTURAL_METROPOLIS,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 20,

      behavior: {
        production: {energy: -1, megacredits: 3},
        city: {},
      },

      requirements: {party: PartyName.UNITY},
      metadata: {
        cardNumber: 'T03',
        description: 'Requires that Unity is ruling or that you have 2 delegates there. Decrease your energy production 1 step and increase your M€ production 3 steps. Place a city tile. Place 2 delegates in 1 party.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().megacredits(3);
          }).city().delegates(2);
        }),
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    const turmoil = Turmoil.getTurmoil(player.game);
    return turmoil.getAvailableDelegateCount(player) >= 2 && player.game.board.getAvailableSpacesForCity(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new SendDelegateToArea(player, 'Select where to send two delegates', {count: 2}));
    return undefined;
  }
}

================
File: cards/turmoil/DiasporaMovement.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class DiasporaMovement extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.DIASPORA_MOVEMENT,
      tags: [Tag.JOVIAN],
      cost: 7,
      requirements: {party: PartyName.REDS},
      victoryPoints: 1,

      behavior: {
        stock: {megacredits: {tag: Tag.JOVIAN, all: true}},
      },

      metadata: {
        cardNumber: 'TO4',
        description: 'Requires that Reds are ruling or that you have 2 delegates there. Gain 1M€ for each Jovian tag in play, including this.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(1).slash().tag(Tag.JOVIAN, {all});
        }),
      },
    });
  }
}

================
File: cards/turmoil/EventAnalysts.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardRenderer} from '../render/CardRenderer';

export class EventAnalysts extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.EVENT_ANALYSTS,
      tags: [Tag.SCIENCE],
      cost: 5,

      behavior: {
        turmoil: {influenceBonus: 1},
      },

      requirements: {party: PartyName.SCIENTISTS},
      metadata: {
        description: 'Requires that Scientists are ruling or that you have 2 delegates there.',
        cardNumber: 'T05',
        renderData: CardRenderer.builder((b) => b.effect('You have +1 influence.', (be) => {
          be.startEffect.influence();
        })),
      },
    });
  }
}

================
File: cards/turmoil/GMOContract.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {PartyName} from '../../../common/turmoil/PartyName';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';

export class GMOContract extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.GMO_CONTRACT,
      tags: [Tag.MICROBE, Tag.SCIENCE],
      cost: 3,

      requirements: {party: PartyName.GREENS},
      metadata: {
        description: 'Requires that Greens are ruling or that you have 2 delegates there.',
        cardNumber: 'T06',
        renderData: CardRenderer.builder((b) => {
          b.effect('Each time you play a plant, animal or microbe tag, including this, gain 2 M€.', (be) => {
            be.tag(Tag.ANIMAL).slash().tag(Tag.PLANT).slash().tag(Tag.MICROBE);
            be.startEffect.megacredits(2);
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const amount = player.tags.cardTagCount(card, [Tag.ANIMAL, Tag.PLANT, Tag.MICROBE]);
    if (amount > 0) {
      player.defer(() => player.stock.add(Resource.MEGACREDITS, amount * 2, {log: true}));
    }
  }
}

================
File: cards/turmoil/LakefrontResorts.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {Priority} from '../../deferredActions/Priority';
import {GainProduction} from '../../deferredActions/GainProduction';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';
import {Board} from '../../boards/Board';

export class LakefrontResorts extends CorporationCard {
  constructor() {
    super({
      name: CardName.LAKEFRONT_RESORTS,
      tags: [Tag.BUILDING],
      startingMegaCredits: 54,

      metadata: {
        cardNumber: 'R38',
        description: 'You start with 54 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(54);
          b.corpBox('effect', (ce) => {
            ce.vSpace(Size.MEDIUM);
            ce.effect('When any ocean tile is placed, increase your M€ production 1 step. Your bonus for placing adjacent to oceans is 3M€ instead of 2 M€.', (eb) => {
              eb.oceans(1, {size: Size.SMALL, all}).colon().production((pb) => pb.megacredits(1));
              eb.emptyTile('normal', {size: Size.SMALL}).oceans(1, {size: Size.SMALL});
              eb.startEffect.megacredits(3);
            });
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.oceanBonus += 1;
    return undefined;
  }

  public override onDiscard(player: IPlayer) {
    player.oceanBonus -= 1;
  }

  public onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space) {
    if (Board.isUncoveredOceanSpace(space)) {
      cardOwner.game.defer(
        new GainProduction(cardOwner, Resource.MEGACREDITS),
        cardOwner.id !== activePlayer.id ? Priority.OPPONENT_TRIGGER : undefined,
      );
    }
  }
}

================
File: cards/turmoil/MartianMediaCenter.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardRenderer} from '../render/CardRenderer';

export class MartianMediaCenter extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MARTIAN_MEDIA_CENTER,
      tags: [Tag.BUILDING],
      cost: 7,

      behavior: {
        production: {megacredits: 2},
      },

      action: {
        spend: {megacredits: 3},
        turmoil: {sendDelegates: {count: 1}},
      },

      requirements: {party: PartyName.MARS},
      metadata: {
        cardNumber: 'T07',
        renderData: CardRenderer.builder((b) => {
          b.action('Pay 3 M€ to add a delegate to any party.', (eb) => {
            eb.megacredits(3).startAction.delegates(1);
          }).br;
          b.production((pb) => {
            pb.megacredits(2);
          });
        }),
        description: 'Requires that Mars First is ruling or that you have 2 delegates there. Increase your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/turmoil/ParliamentHall.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardRenderer} from '../render/CardRenderer';

export class ParliamentHall extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PARLIAMENT_HALL,
      tags: [Tag.BUILDING],
      cost: 8,
      requirements: {party: PartyName.MARS},
      victoryPoints: 1,

      behavior: {
        production: {megacredits: {tag: Tag.BUILDING, per: 3}},
      },

      metadata: {
        cardNumber: 'T08',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(1).slash().tag(Tag.BUILDING, 3);
          });
        }),
        description: 'Requires that Mars First are ruling or that you have 2 delegates there. Increase your M€ production 1 step for every 3 building tags you have, including this.',
      },
    });
  }
}

================
File: cards/turmoil/PoliticalAlliance.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';

export class PoliticalAlliance extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.POLITICAL_ALLIANCE,
      cost: 4,

      behavior: {
        tr: 1,
      },

      requirements: {partyLeader: 2},
      metadata: {
        cardNumber: 'X09',
        renderData: CardRenderer.builder((b) => {
          b.tr(1);
        }),
        description: 'Requires that you have 2 party leaders. Gain 1 TR.',
      },
    });
  }
}

================
File: cards/turmoil/Pristar.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {Resource} from '../../../common/Resource';

export class Pristar extends CorporationCard {
  constructor() {
    super({
      name: CardName.PRISTAR,
      startingMegaCredits: 53,
      resourceType: CardResource.PRESERVATION,

      victoryPoints: {resourcesHere: {}},

      metadata: {
        cardNumber: 'R07',
        description: 'You start with 53 M€. Decrease your TR 2 steps. 1 VP per preservation resource here.',

        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(53).nbsp.nbsp.minus().tr(2, {size: Size.SMALL});
          b.corpBox('effect', (ce) => {
            ce.effect('During production phase, if you did not get TR so far this generation, add one preservation resource here and gain 6 M€.', (eb) => {
              eb.tr(1, {size: Size.SMALL, cancelled: true}).startEffect.resource(CardResource.PRESERVATION).megacredits(6);
            });
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.decreaseTerraformRating(2);
    return undefined;
  }

  public onProductionPhase(player: IPlayer) {
    if (!(player.generationData.hasRaisedTR)) {
      player.stock.add(Resource.MEGACREDITS, 6, {log: true, from: this});
      player.addResourceTo(this, 1);
    }
    return undefined;
  }
}

================
File: cards/turmoil/PROffice.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardRenderer} from '../render/CardRenderer';

export class PROffice extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.PR_OFFICE,
      tags: [Tag.EARTH],
      cost: 7,

      behavior: {
        tr: 1,
        stock: {megacredits: {tag: Tag.EARTH}},
      },

      requirements: {party: PartyName.UNITY},
      metadata: {
        cardNumber: 'T09',
        renderData: CardRenderer.builder((b) => {
          b.tr(1).br;
          b.megacredits(1).slash().tag(Tag.EARTH);
        }),
        description: 'Requires that Unity are ruling or that you have 2 delegates there. Gain 1 TR. Gain 1 M€ for each Earth tag you have, including this.',
      },
    });
  }
}

================
File: cards/turmoil/PublicCelebrations.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Card} from '../Card';

export class PublicCelebrations extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 8,
      tags: [],
      name: CardName.PUBLIC_CELEBRATIONS,
      type: CardType.EVENT,

      requirements: {chairman: true},
      victoryPoints: 2,

      metadata: {
        description: 'Requires that you are Chairman.',
        cardNumber: 'T10',
      },
    });
  }
}

================
File: cards/turmoil/Recruitment.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {SendDelegateToArea} from '../../deferredActions/SendDelegateToArea';
import {CardRenderer} from '../render/CardRenderer';
import {Turmoil} from '../../turmoil/Turmoil';
import {all} from '../Options';

export class Recruitment extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.RECRUITMENT,
      cost: 2,
      type: CardType.EVENT,

      metadata: {
        cardNumber: 'T11',
        renderData: CardRenderer.builder((b) => {
          b.minus().delegates(1, {all}).asterix().nbsp.plus().delegates(1);
        }),
        description: 'Exchange one NEUTRAL NON-LEADER delegate with one of your own from the reserve.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    const turmoil = Turmoil.getTurmoil(player.game);
    if (turmoil.hasDelegatesInReserve(player) === false) {
      return false;
    }

    return turmoil.parties.some((party) => {
      const neutralDelegates = party.delegates.count('NEUTRAL');
      return neutralDelegates > 1 || (neutralDelegates === 1 && party.partyLeader !== 'NEUTRAL');
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new SendDelegateToArea(player, 'Select which Neutral delegate to remove', {replace: 'NEUTRAL'}));
    return undefined;
  }
}

================
File: cards/turmoil/RedTourismWave.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {PartyName} from '../../../common/turmoil/PartyName';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {Card} from '../Card';
import {isHazardTileType} from '../../../common/AresTileType';
import {Space} from '../../../server/boards/Space';
import {SpaceType} from '../../../common/boards/SpaceType';

export class RedTourismWave extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 3,
      tags: [Tag.EARTH],
      name: CardName.RED_TOURISM_WAVE,
      type: CardType.EVENT,

      requirements: {party: PartyName.REDS},
      metadata: {
        cardNumber: 'T12',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(1).slash().emptyTile('normal', {size: Size.SMALL}).asterix();
        }),
        description: 'Requires that Reds are ruling or that you have 2 delegates there. Gain 1 M€ from each EMPTY AREA ADJACENT TO YOUR TILES',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const amount = RedTourismWave.getAdjacentEmptySpacesCount(player);
    player.stock.add(Resource.MEGACREDITS, amount, {log: true});
    return undefined;
  }

  private static hasRealTile(space: Space) {
    return space.tile !== undefined && !isHazardTileType(space.tile.tileType);
  }

  // This is static because it's shared with Tourist.
  public static getAdjacentEmptySpacesCount(player: IPlayer): number {
    const board = player.game.board;
    return board.spaces.filter((space) => {
      if (space.spaceType === SpaceType.COLONY) {
        return false;
      }
      if (this.hasRealTile(space)) {
        return false;
      }
      return board.getAdjacentSpaces(space).some((adj) => {
        return this.hasRealTile(adj) && adj.player === player;
      });
    }).length;
  }
}

================
File: cards/turmoil/SeptumTribus.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../../turmoil/Turmoil';

export class SeptumTribus extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.SEPTUM_TRIBUS,
      tags: [Tag.WILD],
      startingMegaCredits: 36,

      metadata: {
        cardNumber: 'R15',
        description: 'You start with 36 M€. When you perform an action, the wild tag counts as any tag of your choice.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(36);
          b.corpBox('action', (ce) => {
            ce.action('Gain 2 M€ for each party where you have at least 1 delegate.', (eb) => {
              eb.empty().startAction.megacredits(2).slash().delegates(1).asterix();
            });
          });
        }),
      },
    });
  }

  public canAct(): boolean {
    return true;
  }

  public action(player: IPlayer) {
    const turmoil = Turmoil.getTurmoil(player.game);
    const partiesWithPresence = turmoil.parties.filter((party) => party.delegates.has(player));
    player.stock.add(Resource.MEGACREDITS, partiesWithPresence.length * 2, {log: true});

    return undefined;
  }
}

================
File: cards/turmoil/SponsoredMohole.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class SponsoredMohole extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 5,
      tags: [Tag.BUILDING],
      name: CardName.SPONSORED_MOHOLE,
      type: CardType.AUTOMATED,

      behavior: {
        production: {heat: 2},
      },

      requirements: {party: PartyName.KELVINISTS},
      metadata: {
        cardNumber: 'T13',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(2));
        }),
        description: 'Requires that Kelvinists are ruling or that you have 2 delegates there. Increase your heat production 2 steps.',
      },
    });
  }
}

================
File: cards/turmoil/SupportedResearch.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class SupportedResearch extends Card implements IProjectCard {
  constructor() {
    super({
      cost: 3,
      tags: [Tag.SCIENCE],
      name: CardName.SUPPORTED_RESEARCH,
      type: CardType.AUTOMATED,

      behavior: {
        drawCard: 2,
      },

      requirements: {party: PartyName.SCIENTISTS},
      metadata: {
        cardNumber: 'T14',
        renderData: CardRenderer.builder((b) => {
          b.cards(2);
        }),
        description: 'Requires that Scientists are ruling or that you have 2 delegates there. Draw 2 cards.',
      },
    });
  }
}

================
File: cards/turmoil/TerralabsResearch.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class TerralabsResearch extends CorporationCard {
  constructor() {
    super({
      name: CardName.TERRALABS_RESEARCH,
      tags: [Tag.SCIENCE, Tag.EARTH],
      startingMegaCredits: 14,
      cardCost: 1,

      metadata: {
        cardNumber: 'R14',
        description: 'You start with 14 M€. Lower your TR 1 step.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(14).nbsp.minus().tr(1);
          b.corpBox('effect', (ce) => {
            ce.effect('Buying cards to hand costs 1 M€.', (eb) => {
              eb.cards(1).startEffect.megacredits(1);
            });
          });
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.decreaseTerraformRating();
    return undefined;
  }
}

================
File: cards/turmoil/TurmoilCardManifest.ts
================
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {CardName} from '../../../common/cards/CardName';
import {ModuleManifest} from '../ModuleManifest';
import {AerialLenses} from './AerialLenses';
import {BannedDelegate} from './BannedDelegate';
import {CulturalMetropolis} from './CulturalMetropolis';
import {DiasporaMovement} from './DiasporaMovement';
import {EventAnalysts} from './EventAnalysts';
import {GMOContract} from './GMOContract';
import {LakefrontResorts} from './LakefrontResorts';
import {MartianMediaCenter} from './MartianMediaCenter';
import {ParliamentHall} from './ParliamentHall';
import {PoliticalAlliance} from './PoliticalAlliance';
import {Pristar} from './Pristar';
import {PROffice} from './PROffice';
import {PublicCelebrations} from './PublicCelebrations';
import {Recruitment} from './Recruitment';
import {RedTourismWave} from './RedTourismWave';
import {SeptumTribus} from './SeptumTribus';
import {SponsoredMohole} from './SponsoredMohole';
import {SupportedResearch} from './SupportedResearch';
import {TerralabsResearch} from './TerralabsResearch';
import {UtopiaInvest} from './UtopiaInvest';
import {VoteOfNoConfidence} from './VoteOfNoConfidence';
import {WildlifeDome} from './WildlifeDome';
import {AquiferReleasedByPublicCouncil} from '../../turmoil/globalEvents/AquiferReleasedByPublicCouncil';
import {CelebrityLeaders} from '../../turmoil/globalEvents/CelebrityLeaders';
import {CloudSocieties} from '../../turmoil/globalEvents/CloudSocieties';
import {CorrosiveRain} from '../../turmoil/globalEvents/CorrosiveRain';
import {Diversity} from '../../turmoil/globalEvents/Diversity';
import {DryDeserts} from '../../turmoil/globalEvents/DryDeserts';
import {EcoSabotage} from '../../turmoil/globalEvents/EcoSabotage';
import {Election} from '../../turmoil/globalEvents/Election';
import {GenerousFunding} from '../../turmoil/globalEvents/GenerousFunding';
import {GlobalDustStorm} from '../../turmoil/globalEvents/GlobalDustStorm';
import {HomeworldSupport} from '../../turmoil/globalEvents/HomeworldSupport';
import {ImprovedEnergyTemplates} from '../../turmoil/globalEvents/ImprovedEnergyTemplates';
import {JovianTaxRights} from '../../turmoil/globalEvents/JovianTaxRights';
import {MicrogravityHealthProblems} from '../../turmoil/globalEvents/MicrogravityHealthProblems';
import {MinersOnStrike} from '../../turmoil/globalEvents/MinersOnStrike';
import {MudSlides} from '../../turmoil/globalEvents/MudSlides';
import {Pandemic} from '../../turmoil/globalEvents/Pandemic';
import {ParadigmBreakdown} from '../../turmoil/globalEvents/ParadigmBreakdown';
import {Productivity} from '../../turmoil/globalEvents/Productivity';
import {RedInfluence} from '../../turmoil/globalEvents/RedInfluence';
import {Revolution} from '../../turmoil/globalEvents/Revolution';
import {Riots} from '../../turmoil/globalEvents/Riots';
import {ScientificCommunity} from '../../turmoil/globalEvents/ScientificCommunity';
import {SnowCover} from '../../turmoil/globalEvents/SnowCover';
import {SolarFlare} from '../../turmoil/globalEvents/SolarFlare';
import {SolarnetShutdown} from '../../turmoil/globalEvents/SolarnetShutdown';
import {SpinoffProducts} from '../../turmoil/globalEvents/SpinoffProducts';
import {SponsoredProjects} from '../../turmoil/globalEvents/SponsoredProjects';
import {StrongSociety} from '../../turmoil/globalEvents/StrongSociety';
import {SuccessfulOrganisms} from '../../turmoil/globalEvents/SuccessfulOrganisms';
import {VenusInfrastructure} from '../../turmoil/globalEvents/VenusInfrastructure';
import {VolcanicEruptions} from '../../turmoil/globalEvents/VolcanicEruptions';
import {WarOnEarth} from '../../turmoil/globalEvents/WarOnEarth';
import {AsteroidMining} from '../../turmoil/globalEvents/AsteroidMining';
import {Sabotage} from '../../turmoil/globalEvents/Sabotage';
import {InterplanetaryTrade} from '../../turmoil/globalEvents/InterplanetaryTrade';

export const TURMOIL_CARD_MANIFEST = new ModuleManifest({
  module: 'turmoil',
  projectCards: {
    [CardName.AERIAL_LENSES]: {Factory: AerialLenses},
    [CardName.BANNED_DELEGATE]: {Factory: BannedDelegate},
    [CardName.CULTURAL_METROPOLIS]: {Factory: CulturalMetropolis},
    [CardName.DIASPORA_MOVEMENT]: {Factory: DiasporaMovement},
    [CardName.EVENT_ANALYSTS]: {Factory: EventAnalysts},
    [CardName.GMO_CONTRACT]: {Factory: GMOContract},
    [CardName.MARTIAN_MEDIA_CENTER]: {Factory: MartianMediaCenter},
    [CardName.PARLIAMENT_HALL]: {Factory: ParliamentHall},
    [CardName.PR_OFFICE]: {Factory: PROffice},
    [CardName.POLITICAL_ALLIANCE]: {Factory: PoliticalAlliance},
    [CardName.PUBLIC_CELEBRATIONS]: {Factory: PublicCelebrations},
    [CardName.RECRUITMENT]: {Factory: Recruitment},
    [CardName.RED_TOURISM_WAVE]: {Factory: RedTourismWave},
    [CardName.SPONSORED_MOHOLE]: {Factory: SponsoredMohole},
    [CardName.SUPPORTED_RESEARCH]: {Factory: SupportedResearch},
    [CardName.WILDLIFE_DOME]: {Factory: WildlifeDome},
    [CardName.VOTE_OF_NO_CONFIDENCE]: {Factory: VoteOfNoConfidence},
  },

  corporationCards: {
    [CardName.LAKEFRONT_RESORTS]: {Factory: LakefrontResorts},
    [CardName.PRISTAR]: {Factory: Pristar},
    [CardName.TERRALABS_RESEARCH]: {Factory: TerralabsResearch},
    [CardName.UTOPIA_INVEST]: {Factory: UtopiaInvest},
    [CardName.SEPTUM_TRIBUS]: {Factory: SeptumTribus, compatibility: 'turmoil'},
  },
  globalEvents: {
    [GlobalEventName.JOVIAN_TAX_RIGHTS]: {Factory: JovianTaxRights, compatibility: 'colonies'},
    [GlobalEventName.MICROGRAVITY_HEALTH_PROBLEMS]: {Factory: MicrogravityHealthProblems, compatibility: 'colonies', negative: true},
    [GlobalEventName.CLOUD_SOCIETIES]: {Factory: CloudSocieties, compatibility: ['venus', 'colonies']},
    [GlobalEventName.CORROSIVE_RAIN]: {Factory: CorrosiveRain, compatibility: ['venus', 'colonies'], negative: true},
    [GlobalEventName.VENUS_INFRASTRUCTURE]: {Factory: VenusInfrastructure, compatibility: 'venus'},
    [GlobalEventName.SPONSORED_PROJECTS]: {Factory: SponsoredProjects},
    [GlobalEventName.ASTEROID_MINING]: {Factory: AsteroidMining},
    [GlobalEventName.GENEROUS_FUNDING]: {Factory: GenerousFunding},
    [GlobalEventName.SUCCESSFUL_ORGANISMS]: {Factory: SuccessfulOrganisms},
    [GlobalEventName.PRODUCTIVITY]: {Factory: Productivity},
    [GlobalEventName.HOMEWORLD_SUPPORT]: {Factory: HomeworldSupport},
    [GlobalEventName.VOLCANIC_ERUPTIONS]: {Factory: VolcanicEruptions},
    [GlobalEventName.DIVERSITY]: {Factory: Diversity},
    [GlobalEventName.IMPROVED_ENERGY_TEMPLATES]: {Factory: ImprovedEnergyTemplates},
    [GlobalEventName.INTERPLANETARY_TRADE]: {Factory: InterplanetaryTrade},
    [GlobalEventName.CELEBRITY_LEADERS]: {Factory: CelebrityLeaders},
    [GlobalEventName.SPINOFF_PRODUCTS]: {Factory: SpinoffProducts},
    [GlobalEventName.ELECTION]: {Factory: Election},
    [GlobalEventName.AQUIFER_RELEASED_BY_PUBLIC_COUNCIL]: {Factory: AquiferReleasedByPublicCouncil},
    [GlobalEventName.SCIENTIFIC_COMMUNITY]: {Factory: ScientificCommunity},
    [GlobalEventName.STRONG_SOCIETY]: {Factory: StrongSociety},
    [GlobalEventName.GLOBAL_DUST_STORM]: {Factory: GlobalDustStorm, negative: true},
    [GlobalEventName.ECO_SABOTAGE]: {Factory: EcoSabotage, negative: true},
    [GlobalEventName.MINERS_ON_STRIKE]: {Factory: MinersOnStrike, negative: true},
    [GlobalEventName.MUD_SLIDES]: {Factory: MudSlides, negative: true},
    [GlobalEventName.REVOLUTION]: {Factory: Revolution, negative: true},
    [GlobalEventName.RIOTS]: {Factory: Riots, negative: true},
    [GlobalEventName.SABOTAGE]: {Factory: Sabotage, negative: true},
    [GlobalEventName.SNOW_COVER]: {Factory: SnowCover, negative: true},
    [GlobalEventName.PANDEMIC]: {Factory: Pandemic, negative: true},
    [GlobalEventName.WAR_ON_EARTH]: {Factory: WarOnEarth, negative: true},
    [GlobalEventName.PARADIGM_BREAKDOWN]: {Factory: ParadigmBreakdown, negative: true},
    [GlobalEventName.DRY_DESERTS]: {Factory: DryDeserts, negative: true},
    [GlobalEventName.RED_INFLUENCE]: {Factory: RedInfluence, negative: true},
    [GlobalEventName.SOLARNET_SHUTDOWN]: {Factory: SolarnetShutdown, negative: true},
    [GlobalEventName.SOLAR_FLARE]: {Factory: SolarFlare, negative: true},
  },
});

================
File: cards/turmoil/UtopiaInvest.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CorporationCard} from '../corporation/CorporationCard';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class UtopiaInvest extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.UTOPIA_INVEST,
      tags: [Tag.BUILDING],
      startingMegaCredits: 40,

      behavior: {
        production: {steel: 1, titanium: 1},
      },

      metadata: {
        cardNumber: 'R33',
        description: 'You start with 40 M€. Increase your steel and titanium production 1 step each.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(40).nbsp.production((pb) => pb.steel(1).titanium(1));
          b.corpBox('action', (ce) => {
            ce.action('Decrease any production to gain 4 resources of that kind.', (eb) => {
              eb.production((eb) => eb.wild(1)).startAction.wild(4, {digit});
            });
          });
        }),
      },
    });
  }
  public canAct(player: IPlayer): boolean {
    return player.production.megacredits +
                player.production.steel +
                player.production.titanium +
                player.production.plants +
                player.production.energy +
                player.production.heat > -5;
  }
  private log(player: IPlayer, type: string) {
    player.game.log('${0} decreased ${1} production 1 step to gain 4 ${2}', (b) => b.player(player).string(type).string(type));
  }
  public action(player: IPlayer) {
    const result = new OrOptions();
    result.title = 'Select production to decrease one step and gain 4 resources';

    const options = [];

    const reduceMegacredits = new SelectOption('Decrease M€ production', 'Decrease production').andThen(() => {
      player.production.add(Resource.MEGACREDITS, -1);
      player.megaCredits += 4;
      this.log(player, 'megacredit');
      return undefined;
    });

    const reduceSteel = new SelectOption('Decrease steel production', 'Decrease production').andThen(() => {
      player.production.add(Resource.STEEL, -1);
      player.steel += 4;
      this.log(player, 'steel');
      return undefined;
    });

    const reduceTitanium = new SelectOption('Decrease titanium production', 'Decrease production').andThen(() => {
      player.production.add(Resource.TITANIUM, -1);
      player.titanium += 4;
      this.log(player, 'titanium');
      return undefined;
    });

    const reducePlants = new SelectOption('Decrease plants production', 'Decrease production').andThen(() => {
      player.production.add(Resource.PLANTS, -1);
      player.plants += 4;
      this.log(player, 'plant');
      return undefined;
    });

    const reduceEnergy = new SelectOption('Decrease energy production', 'Decrease production').andThen(() => {
      player.production.add(Resource.ENERGY, -1);
      player.energy += 4;
      this.log(player, 'energy');
      return undefined;
    });

    const reduceHeat = new SelectOption('Decrease heat production', 'Decrease production').andThen(() => {
      player.production.add(Resource.HEAT, -1);
      player.heat += 4;
      this.log(player, 'heat');
      return undefined;
    });

    if (player.production.megacredits > -5) {
      options.push(reduceMegacredits);
    }
    if (player.production.steel > 0) {
      options.push(reduceSteel);
    }
    if (player.production.titanium > 0) {
      options.push(reduceTitanium);
    }
    if (player.production.plants > 0) {
      options.push(reducePlants);
    }
    if (player.production.energy > 0) {
      options.push(reduceEnergy);
    }
    if (player.production.heat > 0) {
      options.push(reduceHeat);
    }

    result.options = options;
    return result;
  }
}

================
File: cards/turmoil/VoteOfNoConfidence.ts
================
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardRenderer} from '../render/CardRenderer';
import {Turmoil} from '../../turmoil/Turmoil';
import {all} from '../Options';

export class VoteOfNoConfidence extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.VOTE_OF_NO_CONFIDENCE,
      type: CardType.EVENT,
      cost: 5,
      tr: {tr: 1},

      // TODO(kberg): this renders a delegate with a tie and a black background. On the physical card, there is
      // no black background.
      requirements: {partyLeader: 1},
      metadata: {
        cardNumber: 'T16',
        renderData: CardRenderer.builder((b) => {
          b.minus().chairman({all}).asterix();
          b.nbsp.plus().partyLeaders().br;
          b.tr(1);
        }),
        description: 'Requires that you have a Party Leader in any party and that the sitting Chairman is neutral. ' +
          'Remove the NEUTRAL Chairman and move your own delegate (from the reserve) there instead. Gain 1 TR.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    const turmoil = Turmoil.getTurmoil(player.game);
    if (!turmoil.hasDelegatesInReserve(player)) return false;

    return turmoil.chairman === 'NEUTRAL';
  }

  public override bespokePlay(player: IPlayer) {
    const turmoil = Turmoil.getTurmoil(player.game);
    turmoil.delegateReserve.remove(player);
    turmoil.setNewChairman(player, player.game, /* setAgenda */ false);
    return undefined;
  }
}

================
File: cards/turmoil/WildlifeDome.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardRenderer} from '../render/CardRenderer';

export class WildlifeDome extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.WILDLIFE_DOME,
      cost: 15,
      tags: [Tag.ANIMAL, Tag.PLANT, Tag.BUILDING],
      type: CardType.AUTOMATED,
      requirements: {party: PartyName.GREENS},

      behavior: {
        greenery: {},
      },

      metadata: {
        cardNumber: 'T15',
        renderData: CardRenderer.builder((b) => {
          b.greenery();
        }),
        description: 'Requires that Greens are ruling or that you have 2 delegates there. Place a greenery tile and raise oxygen 1 step.',
      },
    });
  }
}

================
File: cards/underworld/AeronGenomics.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActiveCorporationCard} from '../corporation/CorporationCard';
import {digit} from '../Options';
import {CardResource} from '../../../common/CardResource';
import {IPlayer} from '../../IPlayer';
import {SimpleDeferredAction} from '../../deferredActions/DeferredAction';
import {SelectCard} from '../../inputs/SelectCard';
import {Space} from '../../boards/Space';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';

export class AeronGenomics extends ActiveCorporationCard {
  constructor() {
    super({
      name: CardName.AERON_GENOMICS,
      tags: [Tag.ANIMAL],
      startingMegaCredits: 35,
      resourceType: CardResource.ANIMAL,

      victoryPoints: {resourcesHere: {}, per: 3},

      behavior: {
        stock: {steel: 5},
        addResources: 1,
      },

      metadata: {
        cardNumber: 'UC05',
        description: 'You start with 35 M€, 5 steel, and 1 animal resource on this card. 1 VP per 3 animals on this card.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(35).steel(5, {digit}).resource(CardResource.ANIMAL).br;
          b.effect('After you excavate an underground resource, put an animal on this card.', (eb) => {
            eb.excavate(1).startEffect.resource(CardResource.ANIMAL);
          }).br;
          b.action('Spend 1 M€ to move an animal from here to another card.', (ab) => {
            ab.megacredits(1).resource(CardResource.ANIMAL).startAction.resource(CardResource.ANIMAL).asterix();
          });
        }),
      },
    });
  }

  onExcavation(player: IPlayer, _space: Space) {
    player.addResourceTo(this, {qty: 1, log: true});
  }

  public override canAct(player: IPlayer): boolean {
    if (!player.canAfford(1)) {
      return false;
    }
    // >1 because this player already has Aeron Genomics.
    return this.resourceCount > 0 && player.getResourceCards(this.resourceType).length > 1;
  }

  public override action(player: IPlayer) {
    player.game.defer(new SimpleDeferredAction(
      player,
      () => {
        const resourceCards = player.getResourceCards(this.resourceType).filter((card) => card.name !== this.name);

        if (resourceCards.length === 0) {
          return undefined;
        }

        if (resourceCards.length === 1 && player.canAfford(1)) {
          player.game.defer(new SelectPaymentDeferred(player, 1, {title: 'Select how to pay for action'}))
            .andThen(() => {
              this.resourceCount--;
              player.addResourceTo(resourceCards[0], 1);
              player.game.log('${0} moved 1 animal from ${1} to ${2}.', (b) => b.player(player).card(this).card(resourceCards[0]));
            });
          return undefined;
        }

        return new SelectCard(
          'Select card to add 1 animal',
          'Add animal',
          resourceCards)
          .andThen(([card]) => {
            this.resourceCount--;
            player.addResourceTo(card, 1);
            player.game.log('${0} moved 1 animal from ${1} to ${2}.', (b) => b.player(player).card(this).card(resourceCards[0]));
            return undefined;
          });
      },
    ));
    return undefined;
  }
}

================
File: cards/underworld/AntiTrustCrackdown.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {all, max} from '../Options';
import {IPlayer} from '../../IPlayer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';

export class AntiTrustCrackdown extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.ANTI_TRUST_CRACKDOWN,
      type: CardType.EVENT,
      cost: 22,
      tags: [Tag.EARTH],
      victoryPoints: 2,

      requirements: {corruption: 0, max},

      metadata: {
        cardNumber: 'U64',
        renderData: CardRenderer.builder((b) => {
          b.text('-2').corruption(1, {all}).asterix().br;
          b.plainText('Requires that you have no more than 0 corruption. ALL players lose 2 corruption each.');
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.game.getPlayersInGenerationOrder().forEach((p) => {
      if (p !== player) {
        const loss = Math.min(p.underworldData.corruption, 2);
        if (loss > 0) {
          UnderworldExpansion.loseCorruption(p, loss, {log: true});
        }
      }
    });
    return undefined;
  }
}

================
File: cards/underworld/AnubisSecurities.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {PlayProjectCard} from '../../deferredActions/PlayProjectCard';
import {Resource} from '../../../common/Resource';
import {all} from '../Options';
import {Size} from '../../../common/cards/render/Size';
import {Priority} from '../../deferredActions/Priority';

export class AnubisSecurities extends CorporationCard {
  constructor() {
    super({
      name: CardName.ANUBIS_SECURITIES,
      tags: [Tag.MARS],
      startingMegaCredits: 42,
      initialActionText: 'Play a card, ignoring global requirements',

      metadata: {
        cardNumber: 'UC11',
        description: 'You start with 42 M€. As your first action, play a card ignoring global requirements.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(42).projectRequirements().br;
          b.effect('When any player increases their TR by 1, they gain 2 M€.', (eb) => {
            eb.tr(1, {all}).startEffect.megacredits(2, {all});
          }).br;
          b.text('-X').corruption(1).megacredits(1, {text: '6X'}).asterix().br;
          b.text('Y').corruption(1, {all}).colon().plainText('PAYS').megacredits(1, {text: 'Y'}).or(Size.TINY).tr(1, {size: Size.TINY}).asterix().br;
          b.plainText('(At the end of the production phase, discard all your corruption and gain 6 M€ for each unit discarded. ' +
            'Then, each player must pay you 1 M€ per unit of corruption they have. If no one has any, gain 1 TR instead.)').br;
        }),
      },
    });
  }

  private inInitialAction = false;

  public override getGlobalParameterRequirementBonus(_player: IPlayer): number {
    if (this.inInitialAction === true) {
      // Magic number high enough to always ignore requirements.
      return 50;
    }
    return 0;
  }

  public initialAction(player: IPlayer) {
    this.inInitialAction = true;
    player.game.defer(new PlayProjectCard(player).andThen(() => {
      this.inInitialAction = false;
    }));
    return undefined;
  }

  public onIncreaseTerraformRating(player: IPlayer, _cardOwner: IPlayer, steps: number) {
    const money = steps * 2;
    player.stock.add(Resource.MEGACREDITS, money);
    player.game.log('${0} gained ${1} M€ from the ${2} corp effect', (b) => b.player(player).number(money).card(this));
  }

  public onProductionPhase(player: IPlayer) {
    player.defer(() => {
      const corruption = player.underworldData.corruption;
      const money = corruption * 6;
      if (money > 0) {
        player.stock.megacredits += money;
        player.game.log('${0} discarded ${1} corruption and gained ${2} M€', (b) => b.player(player).number(corruption).number(money));
        player.underworldData.corruption = 0;
      }

      let anyCorruptOpponents = false;
      for (const opponent of player.game.getPlayersInGenerationOrder()) {
        if (opponent === player) {
          continue;
        }
        const corruption = opponent.underworldData.corruption;
        if (corruption > 0) {
          anyCorruptOpponents = true;
          opponent.stock.steal(Resource.MEGACREDITS, corruption, player, {log: false});
          player.game.log('${0} was paid ${1} M€ from ${2}', (b) => b.player(player).number(corruption).player(opponent));
        }
      }
      if (!anyCorruptOpponents) {
        player.increaseTerraformRating(1);
        player.game.log('${0} gained 1 TR since no opponent had any corruption', (b) => b.player(player));
      }
      return undefined;
    }, Priority.BACK_OF_THE_LINE);
  }
}

================
File: cards/underworld/ArboristCollective.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../render/CardRenderer';
import {ActiveCorporationCard} from '../corporation/CorporationCard';
import {digit} from '../Options';
import {CardResource} from '../../../common/CardResource';
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';

export class ArboristCollective extends ActiveCorporationCard {
  constructor() {
    super({
      name: CardName.ARBORIST_COLLECTIVE,
      tags: [Tag.PLANT],
      startingMegaCredits: 36,
      resourceType: CardResource.ACTIVIST,

      behavior: {
        production: {plants: 1},
        stock: {plants: 3},
      },

      action: {
        spend: {resourcesHere: 2},
        stock: {plants: 2},
        production: {plants: 1},
      },

      metadata: {
        cardNumber: 'UC05',
        description: 'You start with 36 M€, 3 plants and 1 plant production.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(36).plants(3, {digit}).production((pb) => pb.plants(1)).br;
          b.effect('After you play an event card with a base cost of 14 or less, put an activist resource on this card.', (eb) => {
            eb.text('≤').megacredits(14, {secondaryTag: Tag.EVENT}).startEffect.resource(CardResource.ACTIVIST);
          }).br;
          b.action('Spend 2 activists here to increase your plant production 1 step and gain 2 plants.', (ab) => {
            ab.text('2').resource(CardResource.ACTIVIST).startAction.plants(2).production((pb) => pb.plants(1));
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (!player.isCorporation(this.name)) {
      return;
    }
    if (card.type === CardType.EVENT && card.cost <= 14) {
      player.addResourceTo(this, {qty: 1, log: true});
    }
  }
}

================
File: cards/underworld/ArtesianAquifer.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {PlaceOceanTile} from '../../deferredActions/PlaceOceanTile';

export class ArtesianAquifer extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ARTESIAN_AQUIFER,
      tags: [Tag.BUILDING],
      cost: 16,

      metadata: {
        cardNumber: 'U59',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).excavate().asterix();
        }),
        description: 'Place an ocean, then excavate the underground resource in its space, if possible.',
      },
    });
  }

  private availableSpaces(player: IPlayer) {
    return player.game.board.getAvailableSpacesForOcean(player).filter((space) => space.excavator === undefined);
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.game.canAddOcean() && this.availableSpaces(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    const action = new PlaceOceanTile(player, {spaces: this.availableSpaces(player)})
      .andThen((space) => {
        UnderworldExpansion.excavate(player, space);
      });
    player.game.defer(action);
    return undefined;
  }
}

================
File: cards/underworld/BatteryFactory.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {ActionCard} from '../ActionCard';

export class BatteryFactory extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.BATTERY_FACTORY,
      cost: 8,
      tags: [Tag.POWER, Tag.BUILDING],

      action: {
        spend: {energy: 1},
        stock: {megacredits: {tag: Tag.POWER}},
      },

      metadata: {
        cardNumber: 'U75',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 energy to gain 1 M€ for each power tag you have.',
            (ab) => ab.energy(1).startAction.megacredits(1).slash().tag(Tag.POWER));
        }),
      },
    });
  }
}

================
File: cards/underworld/BatteryShipment.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class BatteryShipment extends PreludeCard {
  constructor() {
    super({
      name: CardName.BATTERY_SHIPMENT,
      tags: [Tag.POWER],

      behavior: {
        stock: {energy: 12},
        production: {energy: 2},
      },

      metadata: {
        cardNumber: 'UP10',
        renderData: CardRenderer.builder((b) => {
          b.energy(12).production((pb) => pb.energy(2));
        }),
        description: 'Gain 12 energy. Increase your energy production 2 steps.',
      },
    });
  }
}

================
File: cards/underworld/BehemothExcavator.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {digit} from '../Options';

export class BehemothExcavator extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.BEHEMOTH_EXCAVATOR,
      tags: [Tag.BUILDING],
      cost: 13,

      behavior: {
        underworld: {excavate: 3},
      },

      metadata: {
        cardNumber: 'U30',
        renderData: CardRenderer.builder((b) => {
          b.excavate(3, {digit});
        }),
        description: 'Excavate 3 underground resources.',
      },
    });
  }
}

================
File: cards/underworld/Casino.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {all} from '../Options';

export class Casino extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.CASINO,
      tags: [Tag.BUILDING],
      cost: 12,

      requirements: {cities: 1, all},

      behavior: {
        production: {megacredits: 2},
        underworld: {corruption: 1},
      },

      metadata: {
        cardNumber: 'U20',
        renderData: CardRenderer.builder((b) => {
          b.corruption();
          b.production((pb) => pb.megacredits(2));
        }),
        description: 'Requires at least 1 city tile in play. Gain 1 corruption. Increase your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/underworld/CaveCity.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Tag} from '../../../common/cards/Tag';

export class CaveCity extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.CAVE_CITY,
      type: CardType.AUTOMATED,
      cost: 14,
      tags: [Tag.MARS, Tag.BUILDING, Tag.CITY],

      requirements: {excavation: 1},

      behavior: {production: {megacredits: 1}},

      metadata: {
        cardNumber: 'U27',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1)).br;
          b.city().excavate().asterix();
        }),
        description: 'Requires 1 excavation marker. Increase your M€ production 1 step. ' +
        'Place a city in a space where YOU have an excavation marker. ' +
        'Regular placement restrictions still apply.',
      },
    });
  }

  private availableSpaces(player: IPlayer) {
    const availableSpaceForCity = player.game.board.getAvailableSpacesForCity(
      player, {cost: player.getCardCost(this)});
    return availableSpaceForCity.filter((space) => space.excavator === player);
  }

  public override bespokeCanPlay(player: IPlayer) {
    return this.availableSpaces(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace(
      'Select space for a city tile',
      this.availableSpaces(player))
      .andThen((space) => {
        player.game.addCity(player, space);
        return undefined;
      });
  }
}

================
File: cards/underworld/CentralReservoir.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {intersection} from '../../../common/utils/utils';
import {PlaceOceanTile} from '../../deferredActions/PlaceOceanTile';

export class CentralReservoir extends PreludeCard {
  constructor() {
    super({
      name: CardName.CENTRAL_RESERVOIR,
      tags: [Tag.BUILDING],

      behavior: {tr: 1},

      metadata: {
        cardNumber: 'UP09',
        renderData: CardRenderer.builder((b) => {
          b.tr(1).oceans(1).asterix().excavate().asterix();
        }),
        description: 'Gain 1 TR. Place an ocean tile ON AN AREA NOT RESERVED FOR OCEAN. ' +
          'Then excavate the underground resource in that space.',
      },
    });
  }

  private availableSpaces(player: IPlayer) {
    return intersection(
      player.game.board.getAvailableSpacesOnLand(player),
      UnderworldExpansion.excavatableSpaces(player));
  }

  public override bespokeCanPlay(player: IPlayer) {
    if (!player.game.canAddOcean()) {
      this.warnings.add('maxoceans');
    }
    return this.availableSpaces(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new PlaceOceanTile(player, {
      spaces: this.availableSpaces(player),
    })).andThen((space) => {
      UnderworldExpansion.excavate(player, space);
    });
    return undefined;
  }
}

================
File: cards/underworld/ChemicalFactory.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {ActionCard} from '../ActionCard';

export class ChemicalFactory extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.CHEMICAL_FACTORY,
      cost: 18,
      tags: [Tag.BUILDING],

      action: {
        spend: {plants: 1},
        underworld: {excavate: 1},
      },

      behavior: {
        underworld: {corruption: 2},
      },

      metadata: {
        cardNumber: 'U60',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 plant to excavate an underground resource.',
            (ab) => ab.plants(1).startAction.excavate(1));
          b.br;
          b.corruption(2);
        }),
        description: 'Gain 2 corruption.',
      },
    });
  }
}

================
File: cards/underworld/CloudVortexOutpost.ts
================
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {PreludeCard} from '../prelude/PreludeCard';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {IProjectCard, isIProjectCard} from '../IProjectCard';
import {CardResource} from '../../../common/CardResource';

export class CloudVortexOutpost extends PreludeCard {
  constructor() {
    super({
      name: CardName.CLOUD_VORTEX_OUTPOST,
      tags: [Tag.VENUS],

      behavior: {
        global: {venus: 2},
      },

      metadata: {
        cardNumber: 'UP15',
        renderData: CardRenderer.builder((b) => {
          b.venus(2).br;
          b.plainText('Raise Venus 2 steps').br;
          b.effect('After you play your FIRST project card that can hold floaters, put 3 floaters on it.',
            (eb) => eb.cards(1, {secondaryTag: AltSecondaryTag.FLOATER}).asterix().startEffect.resource(CardResource.FLOATER, 3));
        }),
      },
    });
  }

  public data: {isDisabled: boolean} = {isDisabled: false};

  onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (this.data.isDisabled) {
      return;
    }
    if (card.resourceType === CardResource.FLOATER && isIProjectCard(card)) {
      player.addResourceTo(card, {qty: 3, log: true});
      this.data.isDisabled = true;
    }
  }
}

================
File: cards/underworld/CollusionStandardProject.ts
================
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {StandardProjectCard} from '../StandardProjectCard';
import {Turmoil} from '../../turmoil/Turmoil';
import {SelectParty} from '../../inputs/SelectParty';
import {AndOptions} from '../../inputs/AndOptions';
import {PartyName} from '../../../common/turmoil/PartyName';
import {SelectAmount} from '../../inputs/SelectAmount';
import {all} from '../Options';

export class CollusionStandardProject extends StandardProjectCard {
  constructor(properties = {
    name: CardName.COLLUSION_STANDARD_PROJECT,
    cost: 0,

    metadata: {
      cardNumber: '',
      renderData: CardRenderer.builder((b) =>
        b.standardProject('Spend 1 corruption to convert 1 or 2 neutral delegates into your own delegates.',
          (eb) => {
            eb.corruption(1).startAction.text('-2').neutralDelegate(1, {all}).nbsp.text('+2').delegates(1);
          }),
      ),
    },
  }) {
    super(properties);
  }

  public override canAct(player: IPlayer): boolean {
    if (player.underworldData.corruption === 0) {
      return false;
    }
    const game = player.game;
    const turmoil = Turmoil.getTurmoil(game);
    if (!turmoil.hasDelegatesInReserve(player)) {
      return false;
    }
    if (this.getParties(turmoil).length === 0) {
      return false;
    }
    // return super.canAct(player); // Not necessary this time.
    return true;
  }

  actionEssence(player: IPlayer): void {
    player.underworldData.corruption--;
    player.defer(this.execute(player));
  }

  private getParties(turmoil: Turmoil) {
    return turmoil.parties.filter((party) => party.delegates.get('NEUTRAL') > 0).map((party) => party.name);
  }

  public execute(player: IPlayer) {
    const game = player.game;
    const turmoil = Turmoil.getTurmoil(game);
    const parties = this.getParties(turmoil);
    if (parties.length === 0) {
      return undefined;
    }

    const data = {
      partyName: PartyName.GREENS,
      amount: 0,
    };

    const andOptions = new AndOptions(
      new SelectAmount('Send 1 or 2 delegates', 'choose', 1, 2, true).andThen((amount) => {
        data.amount = amount;
        return undefined;
      }),
      new SelectParty('Choose a party', 'Send delegate', parties).andThen((partyName: PartyName) => {
        data.partyName = partyName;
        return undefined;
      }))
      .andThen(() => {
        const party = turmoil.getPartyByName(data.partyName);
        const available = party.delegates.get('NEUTRAL');
        if (available < data.amount) {
          throw new Error(`${data.partyName} does not have ${data.amount} neutral delegates.`);
        }
        if (turmoil.getAvailableDelegateCount(player) < data.amount) {
          throw new Error(`Player does not have ${data.amount} delegates in reserve`);
        }
        for (let i = 0; i < data.amount; i++) {
          turmoil.replaceDelegateFromParty('NEUTRAL', player, data.partyName, game);
        }

        player.totalDelegatesPlaced += data.amount;
        game.log('${0} replaced ${1} neutral delegate(s) in ${2} area', (b) =>
          b.player(player).number(data.amount).partyName(data.partyName));
        return undefined;
      });
    return andOptions;
  }
}

================
File: cards/underworld/ConcessionRights.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class ConcessionRights extends Card implements IProjectCard {
  public generationUsed: number = -1;

  constructor() {
    super({
      name: CardName.CONCESSION_RIGHTS,
      type: CardType.AUTOMATED,
      cost: 8,
      tags: [Tag.MARS],
      requirements: {tag: Tag.EARTH},
      victoryPoints: -1,

      behavior: {
        underworld: {
          markThisGeneration: {},
          excavate: 1,
          corruption: 1,
        },
      },

      metadata: {
        cardNumber: 'U32',
        renderData: CardRenderer.builder((b) => {
          b.excavate().emptyTile().asterix().nbsp.excavate().corruption();
        }),
        description: 'Requires 1 Earth tag. Until the end of this generation, ' +
        'you can excavate ignoring placement restrictions. Excavate 1 underground resource. Gain 1 corruption.',
      },
    });
  }
}

================
File: cards/underworld/CorporateBlackmail.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {SelectPlayer} from '../../inputs/SelectPlayer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {Resource} from '../../../common/Resource';
import {message} from '../../../server/logs/MessageBuilder';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';


export class CorporateBlackmail extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.CORPORATE_BLACKMAIL,
      type: CardType.EVENT,
      cost: 2,
      victoryPoints: -2,

      requirements: {corruption: 1},

      metadata: {
        cardNumber: 'U39',
        renderData: CardRenderer.builder((b) => {
          b.text('PAYS YOU', Size.SMALL).megacredits(10, {all}).or().minus().corruption(2).br;
          b.text('THIS CANNOT BE BLOCKED BY CORRUPTION', Size.SMALL).br;
        }),
        description: 'Requires 1 corruption. Target a player that has at least 2 corruption. ' +
          'Unless that player pays you 10 M€, they lose 2 corruption.',
      },
    });
  }


  private targets(player: IPlayer) {
    return player.getOpponents().filter((p) => p.underworldData.corruption >= 2);
  }

  public override bespokeCanPlay(player: IPlayer) {
    return player.game.isSoloMode() || this.targets(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    if (player.game.isSoloMode()) {
      player.stock.add(Resource.MEGACREDITS, 10);
      player.game.log('${0} blackmailed the neutral player and was paid 10 M€.', (b) => b.player(player));
      return undefined;
    }
    function corruptionConsequence(blackmailedPlayer: IPlayer) {
      UnderworldExpansion.loseCorruption(blackmailedPlayer, 2);
      player.game.log('${0} blackmailed ${1} who lost 2 corruption.', (b) => b.player(player).player(blackmailedPlayer));
    }

    return new SelectPlayer(this.targets(player), 'Select player to blackmail', 'blackmail')
      .andThen((blackmailedPlayer: IPlayer) => {
        if (blackmailedPlayer.megaCredits < 10) {
          corruptionConsequence(blackmailedPlayer);
          return undefined;
        } else {
          const orOptions = new OrOptions(
            new SelectOption(message('Pay ${0} 10 M€', (b) => b.player(player)), 'Pay 10 M€')
              .andThen(() => {
                blackmailedPlayer.stock.steal(Resource.MEGACREDITS, 10, player);
                player.game.log('${0} blackmailed ${1} and was paid 10 M€.', (b) => b.player(player).player(blackmailedPlayer));
                return undefined;
              }),
            new SelectOption('Lose 2 corruption', 'Lose 2 corruption')
              .andThen(() => {
                corruptionConsequence(blackmailedPlayer);
                return undefined;
              }));
          blackmailedPlayer.defer(orOptions);
        }
        return undefined;
      });
  }
}

================
File: cards/underworld/CorporateTheft.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {RemoveResourcesFromCard} from '../../deferredActions/RemoveResourcesFromCard';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';

export class CorporateTheft extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.CORPORATE_THEFT,
      type: CardType.EVENT,
      cost: 10,

      requirements: {corruption: 2},

      metadata: {
        cardNumber: 'U61',
        renderData: CardRenderer.builder((b) => {
          b.text('STEAL').wild(1).corruption().asterix();
        }),
        description: 'Requires 2 corruption. Remove 1 resource from a card belonging to a different player. ' +
          'Then, if you have a card that can hold it, put it on such a card. ' +
          // 'If target paid corruption to block this, you gain that corruption.',
          'If the target blocked this, you gain 1 corruption. ' +
          'NOTE: Do not use in single player games.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    if (player.game.isSoloMode()) {
      return false;
    }
    return RemoveResourcesFromCard.getAvailableTargetCards(player, undefined, 'opponents').length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    game.defer(new RemoveResourcesFromCard(player, undefined, 1, {source: 'opponents', blockable: true, autoselect: false})).andThen((response) => {
      if (response.proceed && response.card !== undefined) {
        const type = response.card.resourceType;
        if (player.getResourceCards(type).length > 0) {
          game.defer(new AddResourcesToCard(player, type, {log: true}));
        }
      } else {
        // This is almost right beacuse it's not clear the player used a fighter to block the steal.
        UnderworldExpansion.gainCorruption(player, 1, {log: true});
      }
    });
    return undefined;
  }
}

================
File: cards/underworld/CraterSurvey.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {digit} from '../Options';
import {CardResource} from '../../../common/CardResource';

export class CraterSurvey extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.CRATER_SURVEY,
      type: CardType.EVENT,
      cost: 5,
      tags: [Tag.MARS],

      behavior: {
        addResourcesToAnyCard: {count: 2, type: CardResource.DATA},
        underworld: {identify: 4},
      },

      metadata: {
        cardNumber: 'U71',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.DATA, 2).asterix().identify(4, {digit});
        }),
        description: 'Add 2 data resources to ANOTHER card. Identify 4 underground resources.',
      },
    });
  }
}

================
File: cards/underworld/CutThroatBudgeting.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class CutThroatBudgeting extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.CUT_THROAT_BUDGETING,
      type: CardType.EVENT,
      cost: 2,
      victoryPoints: -2,

      requirements: {corruption: 1},
      behavior: {
        production: {megacredits: 1, steel: 1, energy: 1},
      },

      metadata: {
        cardNumber: 'U80',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).steel(1).energy(1));
        }),
        description: 'Requires 1 corruption. Increase your M€, steel, and energy production 1 step each.',
      },
    });
  }
}

================
File: cards/underworld/Deepmining.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {SpaceBonus} from '../../../common/boards/SpaceBonus';
import {MiningCard} from '../base/MiningCard';

export class Deepmining extends MiningCard {
  protected readonly title = 'Select an identified space with a steel or titanium bonus';
  protected override readonly placeTile = false;

  constructor() {
    super(
      CardName.DEEPMINING,
      11,
      {
        cardNumber: 'U29',
        renderData: CardRenderer.builder((b) => {
          b.excavate(1).asterix().br;
          b.production((pb) => pb.steel(1).or().titanium(1)).asterix();
        }),
        description: 'Excavate an IDENTIFIED underground resource ANYWHERE ON MARS with a steel or titanium placement bonus. ' +
        'Increase that production 1 step.',
      });
  }

  public override getAvailableSpaces(player: IPlayer): ReadonlyArray<Space> {
    return UnderworldExpansion.identifiedSpaces(player.game)
      .filter((space) => space.excavator === undefined)
      .filter((space) => space.bonus.includes(SpaceBonus.STEEL) || space.bonus.includes(SpaceBonus.TITANIUM));
  }

  protected override spaceSelected(player: IPlayer, space: Space) {
    UnderworldExpansion.excavate(player, space);
    super.spaceSelected(player, space);
  }
}

================
File: cards/underworld/Deepnuking.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all} from '../Options';

export class Deepnuking extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.DEEPNUKING,
      cost: 8,
      victoryPoints: -1,

      behavior: {
        underworld: {excavate: 2},
        removeAnyPlants: 3,
      },

      metadata: {
        cardNumber: 'U06',
        renderData: CardRenderer.builder((b) => {
          b.excavate(2).minus().plants(3, {all});
        }),
        description: 'Excavate 2 underground resources. Remove up to 3 plants from any player.',
      },
    });
  }
}

================
File: cards/underworld/DeepwaterDome.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {intersection} from '../../../common/utils/utils';
import {PlaceOceanTile} from '../../deferredActions/PlaceOceanTile';
import {Space} from '../../boards/Space';
import {SelectSpace} from '../../inputs/SelectSpace';
import {LogHelper} from '../../LogHelper';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';

export class DeepwaterDome extends PreludeCard {
  constructor() {
    super({
      name: CardName.DEEPWATER_DOME,
      tags: [Tag.PLANT, Tag.BUILDING],

      behavior: {
        production: {plants: 1},
      },

      metadata: {
        cardNumber: 'UP11',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.plants(1));
          b.oceans(1).emptyTile().identify().asterix();
        }),
        description: 'Increase your plant production 1 step. Place an ocean. ' +
        'Then place a player cube on an adjacent unreserved space. ' +
        'Only you may place a tile there. Identify the underground resources in both spaces.',
      },
    });
  }

  public getAdjacentSpaces(player: IPlayer, oceanSpace: Space) {
    const board = player.game.board;
    const emptySpaces = board.getAvailableSpacesOnLand(player).filter((space) => {
      // Don't place a marker on a space where you already have a marker.
      return space.player === undefined;
    });
    return intersection(board.getAdjacentSpaces(oceanSpace), emptySpaces);
  }

  public getCandidateSpaces(player: IPlayer) {
    return player.game.board
      .getAvailableSpacesForOcean(player)
      .filter((space) => this.getAdjacentSpaces(player, space));
  }
  public override bespokeCanPlay(player: IPlayer): boolean {
    if (!player.game.canAddOcean()) {
      return false;
    }
    return this.getCandidateSpaces(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new PlaceOceanTile(player).andThen((oceanSpace) => {
      UnderworldExpansion.identify(player.game, oceanSpace, player);
      player.defer(new SelectSpace('Select space for claim', this.getAdjacentSpaces(player, oceanSpace))
        .andThen((claimedSpace) => {
          claimedSpace.player = player;
          LogHelper.logBoardTileAction(player, claimedSpace, 'land claim');
          UnderworldExpansion.identify(player.game, claimedSpace, player);
          return undefined;
        }));
    }));

    return undefined;
  }
}

================
File: cards/underworld/DemetronLabs.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {SpaceType} from '../../../common/boards/SpaceType';
import {IActionCard} from '../ICard';
import {SelectSpace} from '../../inputs/SelectSpace';
import {LogHelper} from '../../LogHelper';
import {digit} from '../Options';
import {sum} from '../../../common/utils/utils';
import {Space} from '../../boards/Space';
import {CardResource} from '../../../common/CardResource';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';

export class DemetronLabs extends CorporationCard implements IActionCard {
  constructor() {
    super({
      name: CardName.DEMETRON_LABS,
      tags: [Tag.SCIENCE],
      startingMegaCredits: 45,
      resourceType: CardResource.DATA,

      behavior: {
        addResources: 3,
      },

      metadata: {
        cardNumber: 'UC02',
        description: 'You start with 45 M€ and 3 data on this card.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(45).resource(CardResource.DATA, 3);
          b.br;
          b.effect('After you identify 1 or more underground resources in a single action ' +
            'EXCEPT BY EXCAVATING, put 1 data on ANY card',
          (eb) => eb.text('X').identify().asterix().startEffect.resource(CardResource.DATA).asterix());
          b.br;
          b.action('Spend 3 data here and pick a space on Mars with no tile. ' +
            'Gain its placement bonus, and no adjacency bonuses.',
          (ab) => ab.resource(CardResource.DATA, {amount: 3, digit}).startAction.text('Placement Bonus').asterix());
        }),
      },
    });
  }

  private availableSpaces(player: IPlayer) {
    return player.game.board.spaces
      .filter((space) => space.spaceType !== SpaceType.COLONY && space.tile === undefined);
  }

  public canAct(player: IPlayer) {
    return this.resourceCount >= 3 && this.availableSpaces(player).length > 0;
  }

  public action(player: IPlayer) {
    player.removeResourceFrom(this, 3);
    return new SelectSpace(
      'Select a space to gain its placement bonus',
      this.availableSpaces(player))
      .andThen((space) => {
        LogHelper.logBoardTileAction(player, space, 'selected');
        player.game.grantSpaceBonuses(player, space);
        return undefined;
      });
  }

  // Behavior is similar in Mining Market Insider.
  // This doesn't need to be serialized. It ensures this is only evaluated once per action.
  // When the server restarts, the player has to take an action anyway.
  private lastActionId = -1;
  public onIdentification(identifyingPlayer: IPlayer | undefined, cardOwner: IPlayer, _space: Space, fromExcavate: boolean) {
    if (identifyingPlayer !== cardOwner || fromExcavate === true) {
      return;
    }
    const actionId = sum(identifyingPlayer.game.getPlayers().map((p) => p.actionsTakenThisGame));
    if (this.lastActionId !== actionId) {
      cardOwner.game.defer(new AddResourcesToCard(cardOwner, CardResource.DATA));
      this.lastActionId = actionId;
    }
  }
}

================
File: cards/underworld/EarthquakeMachine.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../render/CardRenderer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {all} from '../Options';
import {ExcavateSpaceDeferred} from '../../underworld/ExcavateSpaceDeferred';

export class EarthquakeMachine extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.EARTHQUAKE_MACHINE,
      tags: [Tag.SCIENCE],
      cost: 15,
      requirements: {tag: Tag.SCIENCE, count: 2},

      behavior: {
        decreaseAnyProduction: {type: Resource.PLANTS, count: 1},
      },

      metadata: {
        cardNumber: 'U55',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 energy to excavate an underground resource on any space on Mars that has no tile on it.',
            (ab) => ab.energy(1).startAction.excavate(1).asterix());
          b.br;
          b.production((pb) => pb.minus().plants(1, {all})).br;
          b.plainText('Requires 2 science tags. Decrease any plant production 1 step');
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.energy > 0 && UnderworldExpansion.excavatableSpaces(player).length > 0;
  }

  public action(player: IPlayer) {
    player.stock.deduct(Resource.ENERGY, 1);
    const spaces = UnderworldExpansion.excavatableSpaces(player, true).filter((space) => space.tile === undefined);
    player.game.defer(new ExcavateSpaceDeferred(player, spaces));
    return undefined;
  }
}

================
File: cards/underworld/ElectionSponsorship.ts
================
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {PreludeCard} from '../prelude/PreludeCard';
import {digit} from '../Options';
import {ICard} from '../ICard';

export class ElectionSponsorship extends PreludeCard implements ICard {
  public isDisabled: boolean = false;

  constructor() {
    super({
      name: CardName.ELECTION_SPONSORSHIP,
      tags: [Tag.MARS],

      behavior: {
        underworld: {corruption: 1},
        turmoil: {sendDelegates: {count: 1}},
      },

      metadata: {
        cardNumber: 'UP14',
        renderData: CardRenderer.builder((b) => {
          b.corruption().delegates(1).br;
          b.plainText('Gain 1 corruption. Place 1 delegate in any party.').br;

          b.effect('For the first 4 generations, gain +2 influence',
            (eb) => eb.text('Gen 1-4').startEffect.plus().influence({amount: 2, digit}).asterix());
        }),
      },
    });
  }

  public getInfluenceBonus(player: IPlayer) {
    if (player.game.generation <= 4) {
      return 2;
    }
    return 0;
  }
}

================
File: cards/underworld/ExcavateStandardProject.ts
================
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {StandardProjectCanPayWith, StandardProjectCard} from '../StandardProjectCard';
import {ExcavateSpacesDeferred} from '../../underworld/ExcavateSpacesDeferred';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';

export class ExcavateStandardProject extends StandardProjectCard {
  constructor(properties = {
    name: CardName.EXCAVATE_STANDARD_PROJECT,
    cost: 7,

    metadata: {
      cardNumber: '',
      renderData: CardRenderer.builder((b) =>
        b.standardProject('Spend 7 M€ (steel may be used) to excavate a space.', (eb) => {
          eb.megacredits(7).super((b) => b.steel(1)).startAction.excavate();
        }),
      ),
    },
  }) {
    super(properties);
  }

  public override canPayWith(): StandardProjectCanPayWith {
    return {steel: true};
  }

  public override discount(player: IPlayer): number {
    if (player.game.getCardPlayerOrUndefined(CardName.EXCAVATOR_LEASING) !== undefined) {
      return 1;
    }
    return 0;
  }

  public override canAct(player: IPlayer): boolean {
    if (UnderworldExpansion.excavatableSpaces(player).length === 0) {
      return false;
    }
    return super.canAct(player);
  }

  actionEssence(player: IPlayer): void {
    player.game.defer(new ExcavateSpacesDeferred(player, 1));
  }
}

================
File: cards/underworld/ExcavatorLeasing.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {all} from '../Options';

export class ExcavatorLeasing extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.EXCAVATOR_LEASING,
      tags: [Tag.MARS, Tag.BUILDING],
      cost: 8,

      metadata: {
        cardNumber: 'U35',
        renderData: CardRenderer.builder((b) => {
          b.effect('The excavate standard project costs 1 M€ less for all players.',
            (eb) => eb.excavate(1, {all}).startEffect.minus().megacredits(1)).br;
          b.effect('When any player excavates underground resources, you gain 1 M€ per excavation.',
            (eb) => eb.excavate(1, {all}).startEffect.megacredits(1)).br;
        }),
      },
    });
  }
}

================
File: cards/underworld/ExpeditionVehicles.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {isHazardTileType} from '../../../common/AresTileType';
import {BoardType} from '../../boards/BoardType';
import {MoonExpansion} from '../../moon/MoonExpansion';

export class ExpeditionVehicles extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.EXPEDITION_VEHICLES,
      type: CardType.ACTIVE,
      cost: 10,
      tags: [Tag.SCIENCE],

      victoryPoints: 1,

      metadata: {
        cardNumber: 'U79',
        renderData: CardRenderer.builder((b) => {
          b.effect(
            'After you place a tile (on Mars or in space) that has no adjacent tiles, draw a card.',
            (eb) => eb.emptyTile().asterix().startEffect.cards(1)).br;
        }),
      },
    });
  }

  onTilePlaced(cardOwner: IPlayer, activePlayer: IPlayer, space: Space, boardType: BoardType) {
    if (cardOwner === activePlayer) {
      const game = activePlayer.game;
      const board = boardType === BoardType.MARS ? game.board : MoonExpansion.moonData(game).moon;
      const adjacentSpacesWithTiles = board.getAdjacentSpaces(space)
        .filter((space) => {
          return space.tile !== undefined && !isHazardTileType(space.tile.tileType);
        });
      if (adjacentSpacesWithTiles.length === 0) {
        cardOwner.drawCard(1);
      }
    }
  }
}

================
File: cards/underworld/FabricatedScandal.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all} from '../Options';
import {IPlayer} from '../../IPlayer';

export class FabricatedScandal extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.FABRICATED_SCANDAL,
      type: CardType.EVENT,
      cost: 15,

      behavior: {
        underworld: {corruption: 1},
      },

      metadata: {
        cardNumber: 'U13',
        renderData: CardRenderer.builder((b) => {
          b.corruption().br;
          b.text('most').tr(1, {all}).colon().minus().tr(1).br;
          b.text('least').tr(1, {all}).colon().plus().tr(1).br;
        }),
        description: 'Gain 1 corruption. The players with the highest TR lose 1 TR. ' +
          'Then the players with the lowest TR gain 1 TR, if possible.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    const highestTR = Math.max(...game.getPlayers().map(((p) => p.getTerraformRating())));
    game.getPlayers().forEach((p) => {
      if (p.getTerraformRating() === highestTR) {
        p.decreaseTerraformRating(1, {log: true});
      }
    });

    const lowestTR = Math.min(...game.getPlayers().map(((p) => p.getTerraformRating())));
    game.getPlayers().forEach((p) => {
      if (p.getTerraformRating() === lowestTR && player.canAfford({cost: 0, tr: {tr: 1}})) {
        p.increaseTerraformRating(1, {log: true});
      }
    });
    return undefined;
  }
}

================
File: cards/underworld/FairTradeComplaint.ts
================
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {Turmoil} from '../../turmoil/Turmoil';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {digit} from '../../cards/Options';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-1).slash().cards(1, {over: 6}).influence({size: Size.SMALL}).nbsp;
  b.text('MAX 6').cards(1).colon().cards(2, {digit});
});

export class FairTradeComplaint extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.FAIR_TRADE_COMPLAINT,
      description: 'Lose 1 M€ for each card in your hand over 6 (no limit) ' +
        'reduced by 2 M€ per influence (min 0M€). ' +
        'Draw 2 cards if your hand contains 6 cards or less.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const penalty = Math.max(0, (player.cardsInHand.length - 6));
      if (penalty === 0) {
        player.drawCard(2);
      }
      const savings = 2 * turmoil.getPlayerInfluence(player);
      const cost = Math.max(0, penalty - savings);
      if (cost > 0) {
        player.stock.deduct(Resource.MEGACREDITS, cost, {log: true, from: this.name});
      }
    });
  }
}

================
File: cards/underworld/ForestTunnels.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class ForestTunnels extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.FOREST_TUNNELS,
      tags: [Tag.PLANT],
      cost: 7,

      requirements: {excavation: 1},

      behavior: {
        stock: {plants: {underworld: {excavationMarkers: {}}}},
      },

      metadata: {
        cardNumber: 'U16',
        renderData: CardRenderer.builder((b) => {
          b.plants(1).slash().excavate(1);
        }),
        description: 'Requires an excavation marker. Gain 1 plant for every excavation marker you have.',
      },
    });
  }
}

================
File: cards/underworld/FreeTradePort.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class FreeTradePort extends PreludeCard {
  constructor() {
    super({
      name: CardName.FREE_TRADE_PORT,
      tags: [Tag.EARTH, Tag.SPACE],

      behavior: {
        colonies: {buildColony: {}},
        underworld: {corruption: 1},
      },

      metadata: {
        cardNumber: 'UP01',
        renderData: CardRenderer.builder((b) => {
          b.corruption().colonies();
        }),
        description: 'Gain 1 corruption. Place a colony.',
      },
    });
  }
}

================
File: cards/underworld/FriendsInHighPlaces.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {IPlayer} from '@/server/IPlayer';

export class FriendsInHighPlaces extends Card {
  constructor() {
    super({
      name: CardName.FRIENDS_IN_HIGH_PLACES,
      type: CardType.ACTIVE,
      tags: [Tag.EARTH],
      cost: 10,

      behavior: {
        underworld: {corruption: 1},
      },

      requirements: [{tag: Tag.EARTH, count: 1}, {corruption: 1}],

      metadata: {
        cardNumber: 'U41',
        description: 'Requires 1 corruption and 1 Earth tag. Gain 1 corruption.',
        renderData: CardRenderer.builder((b) => {
          b.effect('When paying for Earth cards, corruption resources may be spent as 10 M€ each.',
            (eb) => eb.tag(Tag.EARTH).startEffect.corruption().equals().megacredits(10)).br;

          b.corruption().br;
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.canUseCorruptionAsMegacredits = true;
    return undefined;
  }

  public override onDiscard(player: IPlayer) {
    player.canUseCorruptionAsMegacredits = false;
  }
}

================
File: cards/underworld/GaiaCity.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Tag} from '../../../common/cards/Tag';

export class GaiaCity extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.GAIA_CITY,
      type: CardType.AUTOMATED,
      cost: 18,
      tags: [Tag.MARS, Tag.BUILDING, Tag.CITY],

      behavior: {production: {energy: -1, megacredits: 2}},

      metadata: {
        cardNumber: 'U05',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().energy(1).megacredits(2)).br;
          b.city().super((b) => b.excavate(1)).asterix().text('Placement Bonus x2');
        }),
        description: 'Reduce your energy production one step and increase your M€ production 2 steps. ' +
        'Place a city in a space with ANY player\'s excavation marker. ' +
        'Its placement bonus is doubled (including adjacencies.)',
      },
    });
  }

  private availableSpaces(player: IPlayer) {
    const availableSpaceForCity = player.game.board.getAvailableSpacesForCity(
      player, {cost: player.getCardCost(this)});
    return availableSpaceForCity.filter((space) => space.excavator !== undefined);
  }

  public override bespokeCanPlay(player: IPlayer) {
    return this.availableSpaces(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace(
      'Select space for a city tile',
      this.availableSpaces(player))
      .andThen((space) => {
        player.game.addCity(player, space);
        player.game.grantPlacementBonuses(player, space, /* coveringExistingTile= */false);
        return undefined;
      });
  }
}

================
File: cards/underworld/GanymedeTradingCompany.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class GanymedeTradingCompany extends PreludeCard {
  constructor() {
    super({
      name: CardName.GANYMEDE_TRADING_COMPANY,
      tags: [Tag.JOVIAN, Tag.SPACE],

      behavior: {
        stock: {titanium: 3},
        colonies: {addTradeFleet: 1},
        underworld: {corruption: 1},
      },

      metadata: {
        cardNumber: 'UP02',
        renderData: CardRenderer.builder((b) => {
          b.corruption().titanium(3).tradeFleet();
        }),
        description: 'Gain 1 corruption, 3 titanium, and a trade fleet.',
      },
    });
  }
}

================
File: cards/underworld/GeologicalExpertise.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {digit} from '../Options';

export class GeologicalExpertise extends PreludeCard {
  constructor() {
    super({
      name: CardName.GEOLOGICAL_EXPERTISE,

      behavior: {
        drawCard: {tag: Tag.SCIENCE, count: 2},
        underworld: {identify: 4},
      },

      metadata: {
        cardNumber: 'UP06',
        renderData: CardRenderer.builder((b) => {
          b.identify(4, {digit}).cards(2, {secondaryTag: Tag.SCIENCE});
        }),
        description: 'Identify 4 underground resources. Draw 2 cards with science tags.',
      },
    });
  }
}

================
File: cards/underworld/GeologicalSurvey.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {digit} from '../Options';
import {CardResource} from '../../../common/CardResource';

export class GeologicalSurvey extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.GEOLOGICAL_SURVEY_UNDERWORLD,
      type: CardType.EVENT,
      cost: 2,
      tags: [Tag.MARS, Tag.SCIENCE],

      behavior: {
        addResourcesToAnyCard: {count: 1, type: CardResource.DATA},
        underworld: {identify: 2},
      },

      metadata: {
        cardNumber: 'U81',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.DATA).asterix().identify(2, {digit});
        }),
        description: 'Add 1 data resource to ANOTHER card. Identify any 2 underground resources on Mars.',
      },
    });
  }
}

================
File: cards/underworld/GeologistTeam.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {ActionCard} from '../ActionCard';
import {all} from '../Options';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';

export class GeologistTeam extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.GEOLOGIST_TEAM,
      cost: 6,
      tags: [Tag.MARS, Tag.SCIENCE],

      action: {
        underworld: {identify: 1},
      },

      metadata: {
        cardNumber: 'U01',
        renderData: CardRenderer.builder((b) => {
          b.action('Identify 1 underground resource.',
            (ab) => ab.empty().startAction.identify(1));
          b.br;
          b.effect('When ANY player identifies an underground resource that depicts an ocean, YOU gain 1 TR.',
            (eb) => eb.identify(1, {all}).oceans(1).asterix().startEffect.tr(1));
        }),
      },
    });
  }

  public onIdentification(_identifyingPlayer: IPlayer | undefined, cardOwner: IPlayer, space: Space) {
    if (space.undergroundResources === 'ocean') {
      if (cardOwner.canAfford({cost: 0, tr: {tr: 1}})) {
        cardOwner.increaseTerraformRating(1, {log: true});
      }
    }
  }
}

================
File: cards/underworld/GeoscanSatellite.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {IPlayer} from '../../IPlayer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {IdentifySpacesDeferred} from '../../underworld/IdentifySpacesDeferred';

export class GeoscanSatellite extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GEOSCAN_SATELLITE,
      cost: 6,
      tags: [Tag.SCIENCE, Tag.SPACE],

      behavior: {
        addResourcesToAnyCard: {count: 2, type: CardResource.DATA},
      },

      metadata: {
        cardNumber: 'U02',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.DATA, 2).geoscan();
        }),
        description: 'Place 2 data on any card. Pick a space on the board. Identify the underground resource in that space and in all adjacent spaces.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    return UnderworldExpansion.identifiableSpaces(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(
      new IdentifySpacesDeferred(player, 1).andThen(([space]) => {
        for (const adjacentSpace of player.game.board.getAdjacentSpaces(space)) {
          UnderworldExpansion.identify(player.game, adjacentSpace, player);
        }
      }),
    );
    return undefined;
  }
}

================
File: cards/underworld/GeothermalNetwork.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class GeothermalNetwork extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GEOTHERMAL_NETWORK,
      tags: [Tag.MARS, Tag.BUILDING],
      cost: 14,

      requirements: {excavation: 3},

      behavior: {
        production: {heat: 3},
      },

      victoryPoints: 1,

      metadata: {
        cardNumber: 'U24',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.heat(3));
        }),
        description: 'Requires 3 excavation markers. Increase your heat production 3 steps.',
      },
    });
  }
}

================
File: cards/underworld/GlobalAudit.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';

export class GlobalAudit extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.GLOBAL_AUDIT,
      type: CardType.EVENT,
      cost: 2,
      tags: [Tag.EARTH],

      metadata: {
        cardNumber: 'U25',
        renderData: CardRenderer.builder((b) => {
          b.text('0').corruption(1).colon().tr(1);
        }),
        description: 'Every player with 0 corruption gains 1 TR, if possible.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    for (const p of player.game.getPlayers()) {
      if (p.underworldData.corruption === 0 && player.canAfford({cost: 0, tr: {tr: 1}})) {
        p.increaseTerraformRating(1, {log: true});
      }
    }
    return undefined;
  }
}

================
File: cards/underworld/GreyMarketExploitation.ts
================
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {digit} from '../Options';

export class GreyMarketExploitation extends ActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.GREY_MARKET_EXPLOITATION,
      tags: [Tag.EARTH],
      cost: 4,

      requirements: {corruption: 2},

      action: {
        or: {
          behaviors: [
            {
              spend: {megacredits: 1},
              standardResource: 1,
              title: 'Spend 1 M€ to gain 1 standard resource.',
            },
            {
              spend: {corruption: 1},
              standardResource: 3,
              title: 'Spend 1 corruption to gain 3 of the same standard resource.',
            },
          ],
          autoSelect: true,
        },
      },

      metadata: {

        cardNumber: 'U34',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 M€ to gain 1 standard resource.',
            (ab) => ab.megacredits(1).startAction.wild(1).asterix()).br;
          b.action('Spend 1 corruption to gain 3 of the same standard resource.',
            (ab) => ab.or().corruption(1).startAction.wild(3, {digit}).asterix()).br;
        }),
        description: 'Requires 2 corruption.',
      },
    });
  }
}

================
File: cards/underworld/GuerillaEcologists.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {digit} from '../Options';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {SelectSpace} from '../../inputs/SelectSpace';

export class GuerillaEcologists extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.GUERILLA_ECOLOGISTS,
      cost: 9,
      tags: [Tag.PLANT],

      requirements: {corruption: 1},

      metadata: {
        cardNumber: 'U89',
        renderData: CardRenderer.builder((b) => {
          b.minus().plants(4, {digit}).greenery().asterix();
        }),
        // description: 'Requires 1 corruption and that you lose 4 plants. Place a greenery tile IGNORING ADJACENCY RESTRICTIONS.',
        description: 'Requires 1 corruption. Spend 4 plants to place a greenery tile IGNORING ADJACENCY RESTRICTIONS.',
      },
    });
  }

  private availableSpaces(player: IPlayer): ReadonlyArray<Space> {
    return player.game.board.getAvailableSpacesOnLand(player);
  }

  public override bespokeCanPlay(player: IPlayer) {
    if (player.plants >= 4 || (player.plants >= 3 && player.cardIsInEffect(CardName.VIRAL_ENHANCERS))) {
      return this.availableSpaces(player).length > 0;
    }
    return false;
  }

  public override bespokePlay(player: IPlayer) {
    const availableSpaces = this.availableSpaces(player);
    if (availableSpaces.length === 0) {
      return undefined;
    }

    player.plants -= 4; // This temporarily breaks things if the player only has 3, but Viral Enhancers makes up for it.
    return new SelectSpace('Select space for greenery tile', availableSpaces)
      .andThen((space) => {
        player.game.addGreenery(player, space);
        return undefined;
      });
  }
}

================
File: cards/underworld/Hackers.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {DecreaseAnyProduction} from '../../deferredActions/DecreaseAnyProduction';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class Hackers extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HACKERS_UNDERWORLD,
      cost: 3,
      victoryPoints: -1,

      requirements: {corruption: 2},

      behavior: {
        production: {megacredits: {underworld: {corruption: {}}}},
      },

      metadata: {
        cardNumber: '125',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().megacredits(2, {all}).br;
            pb.plus().megacredits(1).slash().corruption();
          });
        }),
        description: 'Requires 2 corruption. Decrease any M€ production 2 steps. Increase your M€ production 1 step for every unit of corruption you have.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(
      new DecreaseAnyProduction(player, Resource.MEGACREDITS, {count: 2, stealing: true}));
    return undefined;
  }
}

================
File: cards/underworld/Hadesphere.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActiveCorporationCard} from '../corporation/CorporationCard';
import {digit} from '../Options';

export class Hadesphere extends ActiveCorporationCard {
  constructor() {
    super({
      name: CardName.HADESPHERE,
      tags: [Tag.BUILDING],
      startingMegaCredits: 36,

      behavior: {
        stock: {steel: 5},
      },

      action: {
        underworld: {excavate: 1},
      },

      firstAction: {
        text: 'Identify any 3 underground resources on Mars.',
        underworld: {
          identify: 3,
        },
      },

      metadata: {
        cardNumber: 'UC01',
        description: 'You start with 36 M€ and 5 steel. As your first action, identify any 3 underground resources on Mars.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(36).steel(5, {digit}).identify(3, {digit}).br;
          b.corpBox('action', (ce) => {
            ce.action('Excavate an underground resource.', (ab) => {
              ab.empty().startAction.excavate(1);
            });
          });
        }),
      },
    });
  }
}

================
File: cards/underworld/HecateSpeditions.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ICorporationCard} from '../corporation/ICorporationCard';
import {IPlayer} from '../../IPlayer';
import {ActiveCorporationCard} from '../corporation/CorporationCard';
import {Size} from '../../../common/cards/render/Size';
import {ICard} from '../ICard';
import {isPlanetaryTag} from '../../pathfinders/PathfindersData';
import {IColonyTrader} from '../../colonies/IColonyTrader';
import {message} from '../../logs/MessageBuilder';
import {IColony} from '../../colonies/IColony';
import {CardResource} from '../../../common/CardResource';
import {digit} from '../Options';

function tradeCost(player: IPlayer) {
  return Math.max(1, 2 - player.colonies.tradeDiscount);
}

export class HecateSpeditions extends ActiveCorporationCard {
  constructor() {
    super({
      name: CardName.HECATE_SPEDITIONS,
      tags: [Tag.EARTH],
      startingMegaCredits: 38,
      resourceType: CardResource.SUPPLY_CHAIN,

      behavior: {
        addResources: 1,
      },

      firstAction: {
        colonies: {buildColony: {}},
        text: 'Place a colony',
      },

      action: {
        spend: {resourcesHere: 5},
        colonies: {addTradeFleet: 1},
      },

      metadata: {
        cardNumber: 'U12',
        description: 'You start with 38 M€. As your first action, place a colony.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.megacredits(38).colonies().br;
          b.effect('When you play an Earth, Mars, Venus, Moon, or Jovian tag, including this, put 1 supply chain resource on this card.',
            (eb) => eb.tag(Tag.EARTH).tag(Tag.MARS).tag(Tag.VENUS).tag(Tag.MOON).tag(Tag.JOVIAN).startEffect.resource(CardResource.SUPPLY_CHAIN));
          b.br;
          b.resource(CardResource.SUPPLY_CHAIN, {amount: 2, digit}).colon().trade({size: Size.SMALL}).nbsp;
          b.resource(CardResource.SUPPLY_CHAIN, {amount: 5, digit}).arrow(Size.SMALL).tradeFleet().br;
          b.plainText('(Effect: Spend 2 supply chain resources (min. 1) to trade.) ' +
            '(Action: Spend 5 supply chain resources to gain a trade fleet.)');
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: ICard) {
    if (!player.isCorporation(this.name)) {
      return;
    }
    const count = card.tags.filter((tag) => isPlanetaryTag(tag)).length;
    player.addResourceTo(this, {qty: count, log: true, logZero: false});
  }

  public onCorpCardPlayed(player: IPlayer, card: ICorporationCard) {
    this.onCardPlayed(player, card);
  }
}

// TODO(kberg): I this pattern has occurred enough times that this can be reduced.
export class TradeWithHectateSpeditions implements IColonyTrader {
  private hectateSpeditions: ICorporationCard | undefined;

  constructor(private player: IPlayer) {
    this.hectateSpeditions = player.getCorporation(CardName.HECATE_SPEDITIONS);
  }

  public canUse() {
    return (this.hectateSpeditions?.resourceCount ?? 0) >= tradeCost(this.player) &&
      !this.player.getActionsThisGeneration().has(CardName.HECATE_SPEDITIONS);
  }

  public optionText() {
    return message('Pay ${0} ${1} resources (use ${2} action)', (b) => b.number(tradeCost(this.player)).string('supply chain').cardName(CardName.HECATE_SPEDITIONS));
  }

  private tradeWithColony(card: ICorporationCard, player: IPlayer, colony: IColony) {
    const cost = tradeCost(player);
    card.resourceCount -= cost;
    player.game.log('${0} spent ${1} ${2} from ${3} to trade with ${4}',
      (b) => b.player(player).number(cost).string('supply chain resources').card(card).colony(colony));
    colony.trade(player);
  }

  public trade(colony: IColony) {
    if (this.hectateSpeditions !== undefined) {
      this.tradeWithColony(this.hectateSpeditions, this.player, colony);
    }
  }
}

================
File: cards/underworld/HenkeiGenetics.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActiveCorporationCard} from '../corporation/CorporationCard';
import {CardResource} from '../../../common/CardResource';
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';

export class HenkeiGenetics extends ActiveCorporationCard {
  constructor() {
    super({
      name: CardName.HENKEI_GENETICS,
      tags: [Tag.MICROBE],
      startingMegaCredits: 47,

      behavior: {
        underworld: {corruption: 1},
      },

      action: {
        spend: {corruption: 1},
        drawCard: {count: 1, tag: Tag.MICROBE},
      },

      metadata: {
        cardNumber: 'UC04',
        description: 'You start with 47 M€ and 1 corruption.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(47).corruption(1).br;
          b.effect('After you play a microbe card that can hold microbes, add 2 microbes to it.', (eb) => {
            eb.tag(Tag.MICROBE).startEffect.resource(CardResource.MICROBE, 2);
          }).br;
          b.action('Pay 1 corruption to draw a card with a microbe tag.', (ab) => {
            ab.corruption(1).startAction.cards(1, {secondaryTag: Tag.MICROBE});
          });
        }),
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (!player.isCorporation(this.name)) {
      return;
    }
    if (card.resourceType === CardResource.MICROBE && card.tags.includes(Tag.MICROBE)) {
      player.addResourceTo(card, {qty: 2, log: true});
    }
  }
}

================
File: cards/underworld/HiredRaiders.ts
================
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {all} from '../Options';
import {message} from '../../logs/MessageBuilder';

export class HiredRaiders extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.HIRED_RAIDERS_UNDERWORLD,
      cost: 1,

      metadata: {
        cardNumber: 'U00',
        renderData: CardRenderer.builder((b) => {
          b.text('steal', Size.MEDIUM, true).megacredits(3, {all})
            .plus().megacredits(2, {all}).slash().corruption();
        }),
        description: 'Steal 3 M€, plus 2 extra M€ for each corruption resource you have, from any player.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const amount = 3 + (2 * player.underworldData.corruption);
    if (player.game.isSoloMode()) {
      player.megaCredits += amount;
      player.game.log('${0} stole ${1} M€ from the neutral player', (b) =>
        b.player(player).number(amount),
      );
    }

    const availableActions = new OrOptions();

    player.getOpponents().forEach((target) => {
      if (target.megaCredits > 0) {
        const amountStolen = Math.min(amount, target.megaCredits);
        const optionTitle = message('Steal ${0} M€ from ${1}', (b) => b.number(amountStolen).player(target));

        availableActions.options.push(new SelectOption(optionTitle).andThen(() => {
          target.maybeBlockAttack(player, (proceed) => {
            if (proceed) {
              target.stock.steal(Resource.MEGACREDITS, amountStolen, player);
            }
            return undefined;
          });
          return undefined;
        }));
      }
    });

    if (availableActions.options.length > 0) {
      availableActions.options.push(new SelectOption('Do not steal'));
      return availableActions;
    }
    return undefined;
  }
}

================
File: cards/underworld/HyperspaceDrivePrototype.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';

export class HyperspaceDrivePrototype extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.HYPERSPACE_DRIVE_PROTOTYPE,
      cost: 11,
      tags: [Tag.SCIENCE, Tag.SPACE],

      requirements: {tag: Tag.SCIENCE, count: 3},

      metadata: {
        cardNumber: 'U52',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.FIGHTER).or().titanium(1).asterix().br;
          b.resource(CardResource.SCIENCE).or().tr(1).asterix().br;
        }),
        description: 'Requires that 3 science tags. ' +
        'Put a fighter resource on a card you own, or gain 1 titanium if you have no suitable card. ' +
        'Put a science resource on a card you own, or gain 1 TR if you have no suitable card.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const fighterCards = player.getResourceCards(CardResource.FIGHTER);
    if (fighterCards.length > 0) {
      player.game.defer(new AddResourcesToCard(player, CardResource.FIGHTER));
    } else {
      player.game.log('${0} has no fighter resource cards and gained 1 titanium.', (b) => b.player(player));
      player.stock.titanium += 1;
    }
    const scienceCards = player.getResourceCards(CardResource.SCIENCE);
    if (scienceCards.length > 0) {
      player.game.defer(new AddResourcesToCard(player, CardResource.SCIENCE));
    } else {
      player.game.log('${0} has no science cards and gained 1 TR.', (b) => b.player(player));
      player.increaseTerraformRating();
    }
    return undefined;
  }
}

================
File: cards/underworld/ImportedHeavyMachinery.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class ImportedHeavyMachinery extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.IMPORTED_HEAVY_MACHINERY,
      tags: [Tag.EARTH, Tag.SPACE],
      cost: 9,

      behavior: {
        underworld: {excavate: 2},
      },

      metadata: {
        cardNumber: 'U21',
        renderData: CardRenderer.builder((b) => {
          b.excavate(2);
        }),
        description: 'Excavate 2 underground resources.',
      },
    });
  }
}

================
File: cards/underworld/InducedTremor.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {cancelled} from '../Options';
import {ExcavateSpaceDeferred} from '../../underworld/ExcavateSpaceDeferred';
import {Space} from '../../boards/Space';
import {SelectSpace} from '../../inputs/SelectSpace';

export class InducedTremor extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.INDUCED_TREMOR,
      cost: 6,

      metadata: {
        cardNumber: 'U70',
        renderData: CardRenderer.builder((b) => {
          b.excavate().undergroundResources(1, {cancelled}).asterix();
        }),
        description: 'Excavate an underground resource, then pick an adjacent space with an unclaimed resource token. ' +
          'Remove that token. The space can be identified again.',
      },
    });
  }

  private availableSpaces(player: IPlayer) {
    return UnderworldExpansion.excavatableSpaces(player).filter((space) => {
      return player.game.board.getAdjacentSpaces(space).some((s) => this.eligibleNeighbor(s));
    });
  }

  private eligibleNeighbor(space: Space) {
    return space.undergroundResources === undefined || space.excavator === undefined;
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return this.availableSpaces(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    game.defer(
      new ExcavateSpaceDeferred(player, this.availableSpaces(player)).andThen((space) => {
        const eligibleNeighbors = game.board.getAdjacentSpaces(space).filter((s) => this.eligibleNeighbor(s));
        player.defer(new SelectSpace('Select unclaimed resource token to remove', eligibleNeighbors).andThen((s) => {
          UnderworldExpansion.removeUnclaimedToken(game, s);
          return undefined;
        }));
      }));
    return undefined;
  }
}

================
File: cards/underworld/InfrastructureOverload.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {all} from '../Options';
import {Resource} from '../../../common/Resource';

export class InfrastructureOverload extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.INFRASTRUCTURE_OVERLOAD,
      type: CardType.EVENT,
      cost: 3,
      tags: [Tag.POWER],

      requirements: {corruption: 2},

      victoryPoints: -1,

      behavior: {
        decreaseAnyProduction: {count: 2, type: Resource.ENERGY},
      },

      metadata: {
        cardNumber: 'U68',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.text('-2').energy(1, {all}));
        }),
        description: 'Requires 2 corruption. Reduce any energy production 2 steps.',
      },
    });
  }
}

================
File: cards/underworld/InheritedFortune.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class InheritedFortune extends PreludeCard {
  constructor() {
    super({
      name: CardName.INHERITED_FORTUNE,
      tags: [Tag.EARTH],

      behavior: {
        production: {megacredits: 1},
        stock: {megacredits: 10},
        underworld: {corruption: 1},
      },

      metadata: {
        cardNumber: 'UP02',
        renderData: CardRenderer.builder((b) => {
          b.corruption().megacredits(10).production((pb) => pb.megacredits(1));
        }),
        description: 'Gain 1 corruption and 10 M€. Increase your M€ production 1 step.',
      },
    });
  }
}

================
File: cards/underworld/InvestigativeJournalism.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {Card} from '../Card';
import {IActionCard} from '../ICard';
import {CardResource} from '../../../common/CardResource';
import {IPlayer} from '../../IPlayer';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {SelectPlayer} from '../../inputs/SelectPlayer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {TITLES} from '../../inputs/titles';

export class InvestigativeJournalism extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.INVESTIGATIVE_JOURNALISM,
      cost: 3,
      tags: [Tag.EARTH],
      resourceType: CardResource.JOURNALISM,
      victoryPoints: {resourcesHere: {}, per: 2},

      behavior: {
        production: {megacredits: -2},
      },

      metadata: {
        cardNumber: 'U87',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 5 M€ and remove 1 corruption from ANOTHER player with more corruption than you to add 1 journalism resource on this card.',
            (ab) => ab.megacredits(5).corruption(1).asterix().startAction.resource(CardResource.JOURNALISM)).br;
          b.production((pb) => pb.megacredits(-2));
        }),
        description: 'Decrease your M€ production 2 steps. 1 VP per 2 journalism resources on this card.',
      },
    });
  }

  public canAct(player: IPlayer) {
    return player.canAfford(5) && player.game.getPlayers().some((p) => p.underworldData.corruption > player.underworldData.corruption);
  }

  public action(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 5, {title: TITLES.payForCardAction(this.name)}))
      .andThen(() => {
        const moreCorruptPlayers = player.game.getPlayers().filter((p) => p.underworldData.corruption > player.underworldData.corruption);
        player.defer(new SelectPlayer(moreCorruptPlayers, 'Select player to lose 1 corruption', 'Select player')
          .andThen((target) => {
            UnderworldExpansion.loseCorruption(target, 1, {log: true});
            player.addResourceTo(this, 1);
            return undefined;
          }));
      });
    return undefined;
  }
}

================
File: cards/underworld/InvestorPlaza.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class InvestorPlaza extends PreludeCard {
  constructor() {
    super({
      name: CardName.INVESTOR_PLAZA,
      tags: [Tag.EARTH, Tag.CITY],

      behavior: {
        city: {},
        underworld: {corruption: 1},
      },

      metadata: {
        cardNumber: 'UP02',
        renderData: CardRenderer.builder((b) => {
          b.city().corruption();
        }),
        description: 'Place a city and gain 1 corruption.',
      },
    });
  }
}

================
File: cards/underworld/JensonBoyleCo.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';
import {ActiveCorporationCard} from '../corporation/CorporationCard';

export class JensonBoyleCo extends ActiveCorporationCard {
  constructor() {
    super({
      name: CardName.JENSON_BOYLE_CO,
      tags: [Tag.EARTH],
      startingMegaCredits: 46,

      behavior: {
        underworld: {corruption: 2},
      },

      action: {
        or: {
          behaviors: [
            {
              spend: {corruption: 1},
              stock: {steel: 4},
              title: 'Spend 1 corruption to gain 4 steel.',
            },
            {
              spend: {corruption: 1},
              stock: {titanium: 3},
              title: 'Spend 1 corruption to gain 3 titanium.',
            },
            {
              spend: {corruption: 1},
              stock: {plants: 3},
              title: 'Spend 1 corruption to gain 3 plants.',
            },
            {
              spend: {corruption: 1},
              stock: {heat: 6},
              title: 'Spend 1 corruption to gain 6 heat.',
            },
          ],
        },
      },

      metadata: {
        cardNumber: 'UC03',
        description: 'You start with 46 M€ and 2 corruption.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(46).corruption(2).br.br;
          b.corruption(1).arrow()
            .steel(4, {digit}).or()
            .titanium(3, {digit}).br;
          b.or()
            .plants(3, {digit}).or()
            .heat(6, {digit}).br;
          b.plainText('(Action: Pay 1 corruption to gain either 4 steel, 3 titanium, 3 plants or 6 heat.)').br;
        }),
      },
    });
  }
}

================
File: cards/underworld/Keplertec.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';
import {ActiveCorporationCard} from '../corporation/CorporationCard';
import {CardResource} from '../../../common/CardResource';
import {digit} from '../Options';
import {ICard} from '../ICard';
import {UndergroundResourceToken} from '../../../common/underworld/UndergroundResourceToken';
import {UnderworldExpansion} from '../../../server/underworld/UnderworldExpansion';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {SimpleDeferredAction} from '../../deferredActions/DeferredAction';

export class Keplertec extends ActiveCorporationCard {
  constructor() {
    super({
      name: CardName.KEPLERTEC,
      tags: [Tag.JOVIAN, Tag.SPACE],
      startingMegaCredits: 33,
      resourceType: CardResource.FIGHTER,

      behavior: {
        stock: {titanium: 3},
        production: {titanium: 1},
      },

      action: {
        spend: {titanium: 1},
        addResourcesToAnyCard: {
          count: 1,
          autoSelect: true,
          mustHaveCard: true,
          type: CardResource.FIGHTER,
        },
      },

      metadata: {
        cardNumber: 'UC08',
        description: 'You start with 33 M€, 3 titanium, and 1 titanium production.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(33).titanium(3, {digit}).production((pb) => pb.titanium(1)).br;
          b.action('Spend 1 titanium to put a fighter resource on ANY card.', (ab) => {
            ab.titanium(1).startAction.resource(CardResource.FIGHTER).asterix();
          }).br;
          b.effect('When you place a fighter resource on this card, draw 4 random underground resource tokens. ' +
            'Pick one of them and claim the reward on it. Then shuffle the tokens back into the pile.', (eb) => {
            eb.resource(CardResource.FIGHTER).startEffect.undergroundResources(1, {text: '?'}).asterix();
          }).br;
        }),
      },
    });
  }

  effect(player: IPlayer, idx: number) {
    const game = player.game;
    if (game.underworldData === undefined) {
      return;
    }
    const tokens: Array<UndergroundResourceToken> = [];
    for (let i = 0; i < 4; i++) {
      const token = game.underworldData.tokens.pop();
      if (token === undefined) {
        // TODO(kberg): handle
        break;
      }
      tokens.push(token);
    }
    if (tokens.length === 0) {
      // TODO(kberg): handle
      return;
    }

    const orOptions = new OrOptions();
    for (const token of tokens) {
      orOptions.options.push(new SelectOption(token).andThen(() => {
        UnderworldExpansion.grant(player, token);
        UnderworldExpansion.addTokens(game, tokens);
        if (idx > 1) {
          game.defer(new SimpleDeferredAction(player, () => {
            return this.effect(player, idx - 1);
          }));
        }
        return undefined;
      }));
    }
    return orOptions;
  }

  onResourceAdded(player: IPlayer, card: ICard, count: number) {
    if (card === this) {
      player.defer(this.effect(player, count));
    }
  }
}

================
File: cards/underworld/KingdomofTauraro.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {all} from '../Options';
import {Resource} from '../../../common/Resource';

export class KingdomofTauraro extends CorporationCard {
  constructor() {
    super({
      name: CardName.KINGDOM_OF_TAURARO,
      tags: [Tag.MARS],
      startingMegaCredits: 50,
      victoryPoints: -2,

      behavior: {
        production: {megacredits: 6},
      },

      firstAction: {
        text: 'Place a city.',
        city: {},
      },

      metadata: {
        cardNumber: 'UC06',
        description: 'You start with 50 M€ and 6 M€ production. All opponents gain 2 M€ production. As your first action, place a city.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(50).production((pb) => pb.megacredits(6)).production((pb) => pb.megacredits(2, {all})).city().br;
          b.plainText('(Effect: You may place cities adjacent to other cities. You must always place cities adjacent to tiles you already own, if possible.)');
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    for (const opponent of player.getOpponents()) {
      opponent.production.add(Resource.MEGACREDITS, 2, {log: true});
    }
    return undefined;
  }
}

================
File: cards/underworld/LaborTrafficking.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {ICard} from '../ICard';
import {IStandardProjectCard} from '../IStandardProjectCard';

export class LaborTrafficking extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LABOR_TRAFFICKING,
      type: CardType.ACTIVE,
      cost: 3,
      tags: [Tag.SPACE],
      victoryPoints: -2,

      metadata: {
        cardNumber: 'U14',
        renderData: CardRenderer.builder((b) => {
          b.effect('The first standard project action you take each generation, ' +
              'except selling patents, costs 6 M€ less.', (eb) =>
            eb.text('FIRST').plate('Standard projects').asterix().startEffect.megacredits(-6));
        }),
      },
    });
  }

  public data: {generation: number} = {generation: -1};

  onStandardProject(player: IPlayer, project: ICard): void {
    if (project.name !== CardName.SELL_PATENTS_STANDARD_PROJECT) {
      this.data.generation = player.game.generation;
    }
  }

  public getStandardProjectDiscount(player: IPlayer, card: IStandardProjectCard): number {
    if (card.name !== CardName.SELL_PATENTS_STANDARD_PROJECT) {
      if (this.data.generation !== player.game.generation) {
        return 6;
      }
    }
    return 0;
  }
}

================
File: cards/underworld/LaggingRegulation.ts
================
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {Turmoil} from '../../turmoil/Turmoil';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {MultiMap} from 'mnemonist';
import {IPlayer} from '../../IPlayer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.corruption().influence().colon();
  b.text('1st/2nd', Size.SMALL).corruption().production((pb) => pb.megacredits(3).slash().megacredits(1));
});

export class LaggingRegulation extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.LAGGING_REGULATION,
      description: 'Count corruption and ADD influence. Players with the most get 1 corruption and 3 M€ production. ' +
      'Players with 2nd most get 1 corruption and 1 M€ production. Min 1 to place. (SOLO: Place 1st with sum of 5 or more.)',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    const map: MultiMap<number, IPlayer> = new MultiMap();
    for (const player of game.getPlayers()) {
      map.set(player.underworldData.corruption + turmoil.getPlayerInfluence(player), player);
    }
    const totals = Array.from(map.keys());
    totals.sort(); // Largest value at the back.

    function reward(value: number | undefined, place: 1 | 2) {
      if (value === undefined || value === 0) {
        return;
      }
      const players = map.get(value);
      players?.forEach((player) => {
        UnderworldExpansion.gainCorruption(player, 1, {log: true});
        const mc = place === 1 ? 3 : 1;
        player.production.add(Resource.MEGACREDITS, mc, {log: true});
      });
    }
    reward(totals.pop(), 1);
    reward(totals.pop(), 2);
  }
}

================
File: cards/underworld/Landfill.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Units} from '../../../common/Units';

export class Landfill extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LANDFILL,
      tags: [Tag.BUILDING],
      cost: 2,

      victoryPoints: -2,

      metadata: {
        cardNumber: 'U36',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1, {text: '?'})).asterix();
        }),
        description: 'Increase your M€ production 1 step for each different TYPE of production ' +
          'you have at least 1 step of.',
      },
    });
  }

  public productionBox(player: IPlayer) {
    const count = Units.keys.filter((type) => player.production[type] > 0).length;
    return Units.of({megacredits: count});
  }


  override bespokePlay(player: IPlayer) {
    player.production.adjust(this.productionBox(player), {log: true});
    return undefined;
  }
}

================
File: cards/underworld/LobbyingNetwork.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class LobbyingNetwork extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.LOBBYING_NETWORK,
      tags: [Tag.EARTH],
      cost: 5,

      behavior: {
        underworld: {corruption: 1},
      },

      metadata: {
        cardNumber: 'U31',
        renderData: CardRenderer.builder((b) => {
          b.corruption(1);
        }),
        description: 'Gain 1 corruption.',
      },
    });
  }
}

================
File: cards/underworld/ManMadeVolcano.ts
================
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {TileType} from '../../../common/TileType';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {SelectSpace} from '../../inputs/SelectSpace';
import {message} from '../../logs/MessageBuilder';
import {digit} from '../Options';

export class ManMadeVolcano extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MAN_MADE_VOLCANO,
      tags: [Tag.POWER],
      cost: 26,
      tilesBuilt: [TileType.MAN_MADE_VOLCANO],

      behavior: {
        production: {
          energy: 2,
          heat: 4,
        },
      },

      metadata: {
        cardNumber: 'U17',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.energy(2, {digit}).heat(4, {digit})).br;
          b.plainText('Increase your energy production 2 steps and your heat production 4 steps.').br;
          b.tile(TileType.MAN_MADE_VOLCANO).super((b) => b.excavate(1)).br;
          b.plainText('Place this special tile on a NON-RESERVED space that has your excavation marker.').br;
        }),
      },
    });
  }

  private availableSpaces(player: IPlayer) {
    return player.game.board
      .getAvailableSpacesOnLand(player)
      .filter((space) => space.excavator === player);
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return this.availableSpaces(player).length > 0;
  }

  public override bespokePlay(player: IPlayer): PlayerInput | undefined {
    player.defer(new SelectSpace(
      message('Select space for ${0}', (b) => b.tileType(TileType.MAN_MADE_VOLCANO)),
      this.availableSpaces(player))
      .andThen((space) => {
        player.game.addTile(player, space, {
          tileType: TileType.MAN_MADE_VOLCANO,
          card: this.name,
        });
        return undefined;
      }));
    return undefined;
  }
}

================
File: cards/underworld/MartianExpress.ts
================
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Resource} from '../../../common/Resource';
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';

export class MartianExpress extends Card implements IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MARTIAN_EXPRESS,
      cost: 5,
      tags: [Tag.MARS],
      victoryPoints: 1,
      requirements: {cities: 1, all: true},
      resourceType: CardResource.WARE,

      metadata: {
        cardNumber: 'U78',
        renderData: CardRenderer.builder((b) => {
          b.effect('This card can receive any resource that can be placed on ANY card. Resources placed here get converted to wares resources.',
            (ab) => ab.wild(1).asterix().startEffect.resource(CardResource.WARE)).br;
          b.action('Remove all wares from here and gain 1 M€ for each ware removed.',
            (ab) => ab.text('x').resource(CardResource.WARE).startAction.text('x').megacredits(1));
        }),
        description: 'Requires 1 city in play.',
      },
    });
  }

  canAct(): boolean {
    return this.resourceCount > 0;
  }

  action(player: IPlayer): undefined {
    const count = this.resourceCount;
    player.stock.add(Resource.MEGACREDITS, count);
    this.resourceCount = 0;
    player.game.log('${0} used the ${1} action to convert ${2} wares into ${2} M€',
      (b) => b.player(player).card(this).number(count));
    return undefined;
  }
}

================
File: cards/underworld/MediaStir.ts
================
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {Turmoil} from '../../turmoil/Turmoil';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-3).slash().corruption().influence({size: Size.SMALL}).nbsp.text('0').corruption().colon().tr(1);
});

export class MediaStir extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.MEDIA_STIR,
      description: 'Lose 3 M€ per corruption resource you have (max 5), minus influence. Players with 0 corruption gain 1 TR.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const corruption = Math.min(player.underworldData.corruption, 5);
      const adjusted = Math.max(0, corruption - turmoil.getPlayerInfluence(player));
      if (adjusted > 0) {
        const cost = adjusted * 3;
        player.stock.deduct(Resource.MEGACREDITS, cost, {log: true, from: this.name});
      }
      if (player.underworldData.corruption === 0) {
        // TODO(kberg): Add "from"
        // player.increaseTerraformRating(1, {log: true, from: this.name});
        player.increaseTerraformRating(1, {log: true});
      }
    });
  }
}

================
File: cards/underworld/MicroGeodesics.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {digit} from '../Options';

export class MicroGeodesics extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MICRO_GEODESICS,
      tags: [Tag.PLANT, Tag.MICROBE],
      cost: 8,

      behavior: {
        spend: {resourceFromAnyCard: {type: CardResource.MICROBE}},
        underworld: {excavate: {count: 1}},
        stock: {plants: 3},
        addResourcesToAnyCard: {count: 1, type: CardResource.DATA},
      },

      metadata: {
        cardNumber: 'U56',
        renderData: CardRenderer.builder((b) => {
          b.minus().resource(CardResource.MICROBE).excavate().plants(3, {digit}).resource(CardResource.DATA).asterix();
        }),
        description: 'Spend 1 microbe from any card to excavate an underground resource and gain 3 plants. Add 1 data resource to ANOTHER card.',
      },
    });
  }
}

================
File: cards/underworld/Microgravimetry.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardName} from '../../../common/cards/CardName';
import {CardType} from '../../../common/cards/CardType';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';
import {SelectAmount} from '../../inputs/SelectAmount';
import {CardRenderer} from '../render/CardRenderer';
import {CardResource} from '../../../common/CardResource';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {IdentifySpacesDeferred} from '../../underworld/IdentifySpacesDeferred';

export class Microgravimetry extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MICROGRAVIMETRY,
      tags: [Tag.POWER, Tag.SCIENCE],
      cost: 5,
      resourceType: CardResource.DATA,
      victoryPoints: {resourcesHere: {}, per: 4},

      metadata: {
        cardNumber: 'X42',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend any amount of energy to identify that many underground resources on the board ' +
            'and put the same number of data on this card.', (eb) => {
            eb.text('X').energy(1).startAction.text('X').identify(1).resource(CardResource.DATA);
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    return player.energy > 0 && UnderworldExpansion.identifiableSpaces(player).length > 0;
  }

  public action(player: IPlayer) {
    return new SelectAmount(
      'Select amount of energy to spend', undefined, 1, player.energy)
      .andThen((amount) => {
        player.stock.deduct(Resource.ENERGY, amount);
        player.game.log('${0} spent ${1} energy', (b) => b.player(player).number(amount));
        player.addResourceTo(this, {qty: amount, log: true});
        player.game.defer(new IdentifySpacesDeferred(player, amount));
        return undefined;
      });
  }
}

================
File: cards/underworld/MicroprobingTechnology.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {digit} from '../Options';
import {CardResource} from '../../../common/CardResource';

export class MicroprobingTechnology extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.MICROPROBING_TECHNOLOGY,
      tags: [Tag.SCIENCE],
      cost: 7,

      requirements: {tag: Tag.SCIENCE, count: 1},

      behavior: {
        stock: {plants: 3},
        addResourcesToAnyCard: {count: 2, type: CardResource.DATA},
        underworld: {identify: 3},
      },

      metadata: {
        cardNumber: 'U22',
        renderData: CardRenderer.builder((b) => {
          b.plants(3, {digit}).resource(CardResource.DATA, {amount: 2, digit}).identify(3, {digit});
        }),
        description: 'Requires 1 science tag. Gain 3 plants. Add 2 data to any card. Identify 3 underground resources.',
      },
    });
  }
}

================
File: cards/underworld/MigrationUnderground.ts
================
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {Turmoil} from '../../turmoil/Turmoil';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {digit} from '../../cards/Options';
import {Size} from '../../../common/cards/render/Size';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.production((pb) => pb.megacredits(1)).slash().excavate(2, {digit}).influence({size: Size.SMALL});
});

export class MigrationUnderground extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.MIGRATION_UNDERGROUND,
      description: 'Gain 1 M€ production (max 5) for every 2 excavation markers you own. Each point of influence counts as an extra excavation marker.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const sum = UnderworldExpansion.excavationMarkerCount(player) + turmoil.getPlayerInfluence(player);
      const mc = Math.floor(sum / 2);
      const max = Math.min(mc, 5);
      player.production.add(Resource.MEGACREDITS, max, {log: true});
    });
  }
}

================
File: cards/underworld/MiningMarketInsider.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {ActionCard} from '../ActionCard';
import {all, digit} from '../Options';
import {IPlayer} from '../../IPlayer';
import {sum} from '../../../common/utils/utils';
import {CardResource} from '../../../common/CardResource';

export class MiningMarketInsider extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.MINING_MARKET_INSIDER,
      cost: 5,
      tags: [Tag.EARTH],
      resourceType: CardResource.DATA,

      action: {
        spend: {resourcesHere: 4},
        drawCard: 1,
      },

      metadata: {
        cardNumber: 'U46',
        renderData: CardRenderer.builder((b) => {
          b.effect('After any player identifies 1 or more underground spaces (at once), add 1 data resource to this card.',
            (ab) => ab.identify(1, {all}).startEffect.resource(CardResource.DATA)).br;
          b.action('Spend 4 data resources on this card to draw a card.',
            (ab) => ab.resource(CardResource.DATA, {amount: 4, digit}).startAction.cards(1));
        }),
      },
    });
  }

  // Behavior is similar in Demetron labs
  // This doesn't need to be serialized. It ensures this is only evaluated once per action.
  // When the server restarts, the player has to take an action anyway.
  private lastActionId = -1;
  public onIdentification(identifyingPlayer: IPlayer, cardOwner: IPlayer) {
    const actionId = sum(identifyingPlayer.game.getPlayers().map((p) => p.actionsTakenThisGame));
    if (this.lastActionId !== actionId) {
      cardOwner.addResourceTo(this);
      this.lastActionId = actionId;
    }
  }
}

================
File: cards/underworld/Monopoly.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {SelectResource} from '../../inputs/SelectResource';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';
import {Units} from '../../../common/Units';

export class Monopoly extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.MONOPOLY,
      cost: 12,
      requirements: {corruption: 3},
      victoryPoints: -2,

      metadata: {
        cardNumber: 'U65',
        renderData: CardRenderer.builder((b) => {
          b.text('STEAL').production((pb) => pb.wild(1, {all})).br;
        }),
        description: 'Requires 3 corruption. Choose a standard production type. ' +
          'Steal up to 1 unit of that production from EACH OTHER player. They can block this with corruption.',
      },
    });
  }

  private availableProductions(player: IPlayer): Array<keyof Units> {
    const targets = player.getOpponents();
    return Units.keys.filter((unit) => {
      const resource = Units.ResourceMap[unit];
      return targets.some((target) => target.canHaveProductionReduced(resource, 1, player));
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    return this.availableProductions(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectResource(
      'Select which resource type to steal from all other players.',
      this.availableProductions(player))
      .andThen((unitKey) => {
        const resource = Units.ResourceMap[unitKey];
        if (player.game.isSoloMode()) {
          player.production.add(resource, 1, {log: true});
          player.resolveInsuranceInSoloGame();
          return undefined;
        }
        for (const target of player.getOpponents()) {
          if (target.canHaveProductionReduced(resource, 1, player)) {
            target.maybeBlockAttack(player, (proceed: boolean) => {
              if (proceed) {
                target.production.add(resource, -1, {log: true, from: player, stealing: true});
                player.production.add(resource, 1, {log: false});
                target.resolveInsurance();
              }
              return undefined;
            });
          }
        }
        return undefined;
      });
  }
}

================
File: cards/underworld/Nanofoundry.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {digit} from '../Options';

export class Nanofoundry extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.NANOFOUNDRY,
      type: CardType.AUTOMATED,
      cost: 18,
      tags: [Tag.POWER, Tag.SCIENCE],
      victoryPoints: 2,

      requirements: {tag: Tag.SCIENCE, count: 2},

      behavior: {
        production: {energy: -5},
        drawCard: {count: {tag: Tag.POWER}},
      },

      metadata: {
        cardNumber: 'U74',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().energy(5, {digit})).cards(1).slash().tag(Tag.POWER);
        }),
        description: 'Requires 2 science tags. Reduce your energy production 5 steps. ' +
          'Draw 1 card for every power tag you have, including this.',
      },
    });
  }
}

================
File: cards/underworld/NarrativeSpin.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class NarrativeSpin extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.NARRATIVE_SPIN,
      type: CardType.EVENT,
      cost: 5,
      tags: [Tag.EARTH],

      behavior: {
        underworld: {corruption: 2},
      },

      requirements: {tag: Tag.EARTH, count: 1},
      victoryPoints: -1,

      metadata: {
        cardNumber: 'U37',
        renderData: CardRenderer.builder((b) => {
          b.corruption(2);
        }),
        description: 'Requires 1 Earth tag. Gain 2 corruption.',
      },
    });
  }
}

================
File: cards/underworld/Neutrinograph.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {cancelled, digit} from '../Options';

export class Neutrinograph extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.NEUTRINOGRAPH,
      tags: [Tag.SCIENCE],
      cost: 10,

      requirements: {tag: Tag.SCIENCE, count: 4},
      victoryPoints: 2,

      behavior: {
        underworld: {identify: 2},
      },

      metadata: {
        cardNumber: 'U57',
        renderData: CardRenderer.builder((b) => {
          b.effect('When identifying underground resources EXCEPT by placing a tile or excavating, ' +
          'you can re-identify spaces that already have an unclaimed token. ' +
          'When you do, replace that token with a new one.', (eb) => {
            eb.identify().startEffect.undergroundResources(1, {cancelled}).asterix();
          }).br;
          b.identify(2, {digit}).br;
        }),
        description: 'Requires 4 science tags. Identify 2 underground resources.',
      },
    });
  }
}

================
File: cards/underworld/Nightclubs.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class Nightclubs extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.NIGHTCLUBS,
      cost: 11,
      tags: [Tag.BUILDING],

      requirements: {cities: 1},

      behavior: {
        production: {megacredits: 2},
        underworld: {corruption: 1},
      },

      metadata: {
        cardNumber: 'U07',
        renderData: CardRenderer.builder((b) => {
          b.corruption(1).production((pb) => pb.megacredits(2));
        }),
        description: 'Requires that you own a city in play. Gain 1 corruption and increase your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/underworld/OffWorldTaxHaven.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class OffWorldTaxHaven extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.OFF_WORLD_TAX_HAVEN,
      cost: 8,
      tags: [Tag.EARTH, Tag.SPACE],

      victoryPoints: -1,
      requirements: {corruption: 2},

      behavior: {
        production: {megacredits: 5},
      },

      metadata: {
        cardNumber: 'U10',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(5));
        }),
        description: 'Requires 2 corruption. Increase your M€ production 5 steps.',
      },
    });
  }
}

================
File: cards/underworld/OldWorldMafia.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class OldWorldMafia extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.OLD_WORLD_MAFIA,
      cost: 11,
      tags: [Tag.EARTH],

      behavior: {
        underworld: {corruption: {tag: Tag.EARTH, per: 2}},
      },

      metadata: {
        cardNumber: 'U07',
        renderData: CardRenderer.builder((b) => {
          b.corruption(1).slash().tag(Tag.EARTH, 2);
        }),
        description: 'Gain 1 corruption for every 2 Earth tags you have, including this.',
      },
    });
  }
}

================
File: cards/underworld/OrbitalLaserDrill.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class OrbitalLaserDrill extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ORBITAL_LASER_DRILL,
      tags: [Tag.SCIENCE, Tag.SPACE],
      cost: 15,

      requirements: {tag: Tag.SCIENCE, count: 2},
      victoryPoints: 1,

      behavior: {
        underworld: {excavate: {count: 2, ignorePlacementRestrictions: true}},
      },

      metadata: {
        cardNumber: 'U33',
        renderData: CardRenderer.builder((b) => {
          b.excavate(2);
        }),
        description: 'Requires 2 science tags. Excavate 2 underground resources, IGNORING PLACEMENT RESTRICTIONS.',
      },
    });
  }
}

================
File: cards/underworld/PatentManipulation.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {SelectCard} from '../../inputs/SelectCard';
import {isSpecialTile} from '../../boards/Board';

export class PatentManipulation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.PATENT_MANIPULATION,
      cost: 7,

      requirements: {corruption: 1},
      victoryPoints: -2,

      metadata: {
        cardNumber: '',
        renderData: CardRenderer.builder((b) => {
          b.cards(1).asterix(); // TODO(kberg): add altsecondarytag.green, and show both blue and green tags.
        }),
        description: 'RETURN 1 OF YOUR PLAYED GREEN OR BLUE CARDS TO YOUR HAND. IT MAY NOT BE A CARD THAT PLACES SPECIAL TILES OR RETURNS PLAYED CARDS TO YOUR HAND.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer) {
    return this.getCards(player).length > 0;
  }

  private getCards(player: IPlayer): ReadonlyArray<IProjectCard> {
    return player.playedCards.filter((card) => {
      if (card.type !== CardType.AUTOMATED && card.type !== CardType.ACTIVE) {
        return false;
      }
      if (card.name === CardName.ASTRA_MECHANICA) {
        return false;
      }
      if (card.tilesBuilt.some(isSpecialTile)) {
        return false;
      }
      return true;
    });
  }

  // TODO(kberg): much of this card is a duplicate of Astra Mechanica.
  public override bespokePlay(player: IPlayer) {
    const candidates = this.getCards(player);
    if (candidates.length === 0) {
      player.game.log('${0} had no collectable green or blue project cards', (b) => b.player(player));
      return undefined;
    }
    return new SelectCard(
      'Select 1 card to return to your hand',
      'Select',
      candidates)
      .andThen(
        (cards) => {
          for (const card of cards) {
            player.playedCards = player.playedCards.filter((c) => c.name !== card.name);
            player.cardsInHand.push(card);
            card.onDiscard?.(player);
            player.game.log('${0} returned ${1} to their hand', (b) => b.player(player).card(card));
          }
          return undefined;
        });
  }
}

================
File: cards/underworld/PersonalSpacecruiser.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {CardResource} from '../../../common/CardResource';

export class PersonalSpacecruiser extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PERSONAL_SPACECRUISER,
      cost: 15,
      tags: [Tag.SPACE],
      resourceType: CardResource.FIGHTER,

      behavior: {
        addResources: 1,
        underworld: {corruption: 1},
      },

      metadata: {
        cardNumber: 'U51',
        renderData: CardRenderer.builder((b) => {
          b.effect('During the production phase, if there is at least 1 fighter resource on this card, ' +
            'gain 2 M€ for each corruption resource you have.',
          (eb) => eb.resource(CardResource.FIGHTER).startEffect.megacredits(2).slash().corruption().asterix).br;
          b.resource(CardResource.FIGHTER).corruption(1).br;
        }),
        description: 'Put 1 fighter resource on this card. Gain 1 corruption.',
      },
    });
  }
  public onProductionPhase(player: IPlayer) {
    if (this.resourceCount > 0) {
      player.megaCredits += (2 * player.underworldData.corruption);
    }
    return undefined;
  }
}

================
File: cards/underworld/PlanetaryRightsBuyout.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class PlanetaryRightsBuyout extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.PLANETARY_RIGHTS_BUYOUT,
      type: CardType.EVENT,
      cost: 28,

      requirements: {corruption: 5},
      behavior: {tr: 7},
      victoryPoints: -3,

      metadata: {
        cardNumber: 'U85',
        renderData: CardRenderer.builder((b) => {
          b.tr(7);
        }),
        description: 'Requires 5 corruption. Gain 7 TR',
      },
    });
  }
}

================
File: cards/underworld/PlantTax.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {RemoveResources} from '../../deferredActions/RemoveResources';
import {Resource} from '../../../common/Resource';
import {all} from '../Options';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {Tag} from '../../../common/cards/Tag';

export class PlantTax extends Card implements IProjectCard {
  public generationUsed: number = -1;

  constructor() {
    super({
      name: CardName.PLANT_TAX,
      type: CardType.EVENT,
      cost: 7,
      tags: [Tag.MARS],

      behavior: {
        underworld: {markThisGeneration: {}},
      },

      metadata: {
        cardNumber: 'U67',
        renderData: CardRenderer.builder((b) => {
          b.minus().plants(2, {all}).asterix().corruption().asterix();
        }),
        description: 'ALL players lose 2 plants. Players can block this with corruption. Gain 1 corruption DURING THE PRODUCTION PHASE OF THIS GENERATION.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    for (const target of game.getPlayers()) {
      game.defer(new RemoveResources(target, player, Resource.PLANTS, 2));
    }
    return undefined;
  }

  public onProductionPhase(player: IPlayer) {
    if (this.generationUsed === player.game.generation) {
      UnderworldExpansion.gainCorruption(player, 1, {log: true});
    }
    return undefined;
  }
}

================
File: cards/underworld/PriceWars.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {all} from '../Options';

export class PriceWars extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.PRICE_WARS,
      type: CardType.EVENT,
      cost: 1,

      requirements: {corruption: 2},
      victoryPoints: -1,

      behavior: {
        underworld: {markThisGeneration: {}},
      },

      metadata: {
        cardNumber: 'U63',
        hasExternalHelp: true,
        renderData: CardRenderer.builder((b) => {
          b.steel(1).titanium(1).colon().plus().megacredits(1).asterix().br;
          b.steel(1, {all}).titanium(1, {all}).colon().minus().megacredits(1, {all}).asterix().br;
        }),
        description: 'Requires 2 corruption. Until the end of this generation, ' +
          'your steel and titanium are worth 1 more M€ each, ' +
          'and steel and titanium for other players is worth 1 M€ less.',
      },
    });
  }

  public generationUsed: number | undefined = undefined;

  private increase(player: IPlayer) {
    for (const p of player.game.getPlayersInGenerationOrder()) {
      if (p === player) {
        p.increaseSteelValue();
        p.increaseTitaniumValue();
      } else {
        p.decreaseSteelValue();
        p.decreaseTitaniumValue();
      }
    }
  }

  private decrease(player: IPlayer) {
    for (const p of player.game.getPlayersInGenerationOrder()) {
      if (p === player) {
        p.decreaseSteelValue();
        p.decreaseTitaniumValue();
      } else {
        p.increaseSteelValue();
        p.increaseTitaniumValue();
      }
    }
  }

  public override bespokePlay(player: IPlayer) {
    this.increase(player);
    player.game.log('${0} is in effect for the rest of this generation.', (b) => b.card(this));
    player.game.log('Steel and titanium are worth 1 M€ less, except for ${0}, whose steel and titanium are worth 1 M€ more.', (b) => b.player(player));
    return undefined;
  }

  public onProductionPhase(player: IPlayer) {
    if (this.generationUsed === player.game.generation) {
      this.decrease(player);
    }
    return undefined;
  }

  // Warning: this is not Playwrights/Odyssey compatible because once the card is discarded, it's not effective anymore.
  // TODO(kberg): When making this card work with P/O, remove the code in those cards that disallows them.
  public override onDiscard(player: IPlayer) {
    this.decrease(player);
    this.generationUsed = undefined;
    return undefined;
  }
}

================
File: cards/underworld/PrivateInvestigator.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';
import {IPlayer} from '../../IPlayer';
import {SelectPlayer} from '../../inputs/SelectPlayer';
import {Size} from '../../../common/cards/render/Size';

export class PrivateInvestigator extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.PRIVATE_INVESTIGATOR,
      type: CardType.EVENT,
      cost: 8,
      victoryPoints: 'special',

      behavior: {
        tr: 1,
      },

      metadata: {
        cardNumber: 'U38',
        renderData: CardRenderer.builder((b) => {
          b.text('TARGET A PLAYER WITH MORE CORRUPTION THAN YOU.', Size.SMALL, true).br;
          b.text('PLACE THIS CARD FACE DOWN IN THAT PLAYER\'S PROJECT CARD PILE.', Size.SMALL, true).br;
          b.tr(1);
        }),
        description: 'Gain 1 TR.',
        victoryPoints: CardRenderDynamicVictoryPoints.any(-1),
      },
    });
  }

  private targets(player: IPlayer) {
    return player.game.getPlayers().filter((p) => p.underworldData.corruption > player.underworldData.corruption);
  }

  public override bespokeCanPlay(player: IPlayer) {
    return this.targets(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectPlayer(this.targets(player), 'Select player to investigate', 'investigate')
      .andThen((investigatedPlayer) => {
        investigatedPlayer.playedCards.push(this);
        return undefined;
      });
  }

  public override getVictoryPoints() {
    return -1;
  }
}

================
File: cards/underworld/PrivateMilitaryContractor.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardResource} from '../../../common/CardResource';
import {CardType} from '../../../common/cards/CardType';
import {ActionCard} from '../ActionCard';

export class PrivateMilitaryContractor extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PRIVATE_MILITARY_CONTRACTOR,
      cost: 18,
      tags: [Tag.JOVIAN, Tag.SPACE],
      resourceType: CardResource.FIGHTER,

      behavior: {
        addResources: 1,
      },

      action: {
        spend: {titanium: 1},
        addResources: 1,
      },

      metadata: {
        cardNumber: 'U49',
        renderData: CardRenderer.builder((b) => {
          b.effect(
            'When blocking damage from other players, you can use fighters here as if they were corruption ' +
            'resources. You cannot use them for score bribing or collusion.',
            (eb) => eb.corruptionShield().startEffect.resource(CardResource.FIGHTER).equals().corruption().asterix()).br;
          b.action('Spend 1 titanium to add 1 fighter resource to this card.',
            (ab) => ab.titanium(1).startAction.resource(CardResource.FIGHTER)).br;
          b.resource(CardResource.FIGHTER);
        }),
        description: 'Add 1 fighter resource to this card.',
      },
    });
  }
}

================
File: cards/underworld/PrivateResorts.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {Resource} from '../../../common/Resource';

export class PrivateResorts extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.PRIVATE_RESORTS,
      type: CardType.AUTOMATED,
      cost: 6,
      tags: [Tag.BUILDING],

      requirements: {oceans: 3},

      behavior: {
        production: {heat: -1},
        underworld: {markThisGeneration: {}},
      },

      metadata: {
        cardNumber: 'U54',
        renderData: CardRenderer.builder((b) => {
          b.minus().production((pb) => pb.heat(1)).br;
          b.megacredits(12).asterix().corruption(1).asterix();
        }),
        description: 'Requires 3 oceans. Reduce your heat production 1 step. ' +
          'At the end of this generation only, during the production phase, gain 12 M€ and 1 corruption.',
      },
    });
  }

  public generationUsed: number = -1;

  public onProductionPhase(player: IPlayer) {
    if (this.generationUsed === player.game.generation) {
      player.stock.add(Resource.MEGACREDITS, 12);
      UnderworldExpansion.gainCorruption(player, 1);
    }
    return undefined;
  }
}

================
File: cards/underworld/Prospecting.ts
================
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ColoniesHandler} from '../../colonies/ColoniesHandler';
import {PreludeCard} from '../prelude/PreludeCard';

export class Prospecting extends PreludeCard {
  constructor() {
    super({
      name: CardName.PROSPECTING,
      startingMegacredits: -4,
      tags: [Tag.SPACE],

      metadata: {
        cardNumber: 'UP13',
        description: 'Pay 4 M€. Put an additional colony tile of your choice into play. Then place a colony on it.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(-4).nbsp.colonyTile().colonies().asterix();
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    ColoniesHandler.addColonyTile(player, {
      activateableOnly: true,
      cb: (colony) => {
        if (colony.isActive) {
          colony.addColony(player);
        }
      }});
    return undefined;
  }
}

================
File: cards/underworld/PublicSpaceline.ts
================
import {IProjectCard} from '../IProjectCard';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class PublicSpaceline extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.PUBLIC_SPACELINE,
      cost: 18,
      tags: [Tag.EARTH, Tag.EARTH, Tag.JOVIAN, Tag.JOVIAN, Tag.VENUS, Tag.VENUS, Tag.MARS, Tag.MARS],

      requirements: {tag: Tag.SPACE, count: 5},

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: 'U77',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2)).br;
          b.plainText('Increase your M€ production 2 steps').br;
          b.tag(Tag.EARTH).tag(Tag.EARTH).tag(Tag.JOVIAN).tag(Tag.JOVIAN).br;
          b.tag(Tag.VENUS).tag(Tag.VENUS).tag(Tag.MARS).tag(Tag.MARS);
        }),
        description: 'Requires 5 space tags. This card has 2 Earth tags, 2 Jovian tags, 2 Venus tags, and 2 Mars tags.',
      },
    });
  }
}

================
File: cards/underworld/RecklessDetonation.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {all, digit} from '../Options';
import {IPlayer} from '../../IPlayer';
import {OrOptions} from '../../inputs/OrOptions';
import {Resource} from '../../../common/Resource';
import {SelectOption} from '../../inputs/SelectOption';
import {message} from '../../logs/MessageBuilder';

export class RecklessDetonation extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.RECKLESS_DETONATION,
      cost: 1,

      requirements: {corruption: 2},

      behavior: {
        underworld: {excavate: 1},
      },

      metadata: {
        cardNumber: 'U06',
        renderData: CardRenderer.builder((b) => {
          b.excavate(1).minus().steel(3, {digit, all}).asterix().or().titanium(2, {digit, all}).asterix();
        }),
        description: 'Requires 2 corruption. Excavate an underground resource. Remove up to 3 steel or 2 titanium from another player.',
      },
    });
  }

  private title(amount: number, type: string, target: IPlayer) {
    return message('Remove ${0} ${1} from ${2}', (b) => b.number(amount).string(type).player(target));
  }

  public override bespokePlay(player: IPlayer) {
    if (player.game.isSoloMode()) return undefined;

    const availablePlayerTargets = player.game.getPlayers().filter((p) => p.id !== player.id);
    const availableActions = new OrOptions();

    availablePlayerTargets.forEach((target) => {
      if (target.titanium > 0 && !target.alloysAreProtected()) {
        const amountRemoved = Math.min(2, target.titanium);
        const optionTitle = this.title(amountRemoved, 'titanium', target);
        availableActions.options.push(new SelectOption(optionTitle).andThen(() => {
          target.maybeBlockAttack(player, (proceed) => {
            if (proceed) {
              target.stock.deduct(Resource.TITANIUM, 2, {log: true, from: player});
            }
            return undefined;
          });
          return undefined;
        }));
      }

      if (target.steel > 0 && !target.alloysAreProtected()) {
        const amountRemoved = Math.min(3, target.steel);
        const optionTitle = this.title(amountRemoved, 'steel', target);
        availableActions.options.push(new SelectOption(optionTitle).andThen(() => {
          target.maybeBlockAttack(player, (proceed) => {
            if (proceed) {
              target.stock.deduct(Resource.STEEL, 3, {log: true, from: player});
            }
            return undefined;
          });
          return undefined;
        }));
      }
    });

    if (availableActions.options.length > 0) {
      availableActions.options.push(new SelectOption('Do not remove resource').andThen(() => {
        return undefined;
      }));
      return availableActions;
    }
    return undefined;
  }
}

================
File: cards/underworld/ResearchDevelopmentHub.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';

export class ResearchDevelopmentHub extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.RESEARCH_DEVELOPMENT_HUB,
      type: CardType.ACTIVE,
      cost: 14,
      tags: [Tag.SCIENCE, Tag.BUILDING],
      resourceType: CardResource.DATA,

      victoryPoints: {resourcesHere: {}, per: 3},

      metadata: {
        cardNumber: 'U84',
        renderData: CardRenderer.builder((b) => {
          // TODO(kberg): This is supposed to be at the START of each production phase.
          b.effect(
            'At the end of each production phase, ' +
            'add 1 data here for EACH OTHER PLAYER that has 7 or more cards in their hand.',
            (eb) => eb.text('7+').cards(1).asterix().startEffect.resource(CardResource.DATA));
        }),
        description: '1 VP for every 3 data resources on this card.',
      },
    });
  }

  public onProductionPhase(player: IPlayer) {
    for (const p of player.game.getPlayersInGenerationOrder()) {
      if (p !== player && p.cardsInHand.length >= 7) {
        player.addResourceTo(this);
      }
    }
    return undefined;
  }
}

================
File: cards/underworld/RobotMoles.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardResource} from '../../../common/CardResource';
import {CardType} from '../../../common/cards/CardType';
import {ActionCard} from '../ActionCard';

export class RobotMoles extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.ROBOT_MOLES,
      cost: 6,
      tags: [Tag.MARS],
      victoryPoints: {resourcesHere: {}, per: 3},
      resourceType: CardResource.DATA,

      action: {
        spend: {steel: 1},
        addResources: 1,
        underworld: {identify: 2},
      },

      metadata: {
        cardNumber: 'U45',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 steel to add 1 data to this card and identify 2 underground resources.',
            (ab) => ab.steel(1).startAction.resource(CardResource.DATA).identify(2));
        }),
        description: '1 VP per 3 data resources on this card.',
      },
    });
  }
}

================
File: cards/underworld/Scapegoat.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class Scapegoat extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.SCAPEGOAT,
      type: CardType.EVENT,
      cost: 5,

      behavior: {
        underworld: {corruption: 1},
      },

      metadata: {
        cardNumber: 'U40',
        renderData: CardRenderer.builder((b) => {
          b.corruption(1);
        }),
        description: 'Gain 1 corruption.',
      },
    });
  }
}

================
File: cards/underworld/SearchforLifeUnderground.ts
================
import {IActionCard} from '../ICard';
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../render/CardRenderer';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';
import {max} from '../Options';
import {IdentifySpacesDeferred} from '../../underworld/IdentifySpacesDeferred';
import {undergroundResourceTokenDescription} from '../../../common/underworld/UndergroundResourceToken';
import {TITLES} from '../../inputs/titles';

// TODO(kberg): Copies a lot of Search For Life.
export class SearchforLifeUnderground extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SEARCH_FOR_LIFE_UNDERGROUND,
      tags: [Tag.MARS, Tag.SCIENCE],
      cost: 6,

      resourceType: CardResource.SCIENCE,
      victoryPoints: 'special',

      requirements: {temperature: -18, max},
      metadata: {
        cardNumber: 'U23',
        description: 'Temperature must -18° C or colder.',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 M€ to identify an underground resource. If it depicts at least 1 microbe, add a science resource here.', (eb) => {
            eb.megacredits(1).startAction.identify().nbsp.text(',').resource(CardResource.MICROBE).asterix().colon().nbsp.resource(CardResource.SCIENCE);
          }).br;
          b.vpText('3 VPs if you have one or more science resources here.');
        }),
        victoryPoints: CardRenderDynamicVictoryPoints.searchForLife(),
      },
    });
  }

  public override getVictoryPoints() {
    if (this.resourceCount > 0) {
      return 3;
    }
    return 0;
  }
  public canAct(player: IPlayer): boolean {
    return player.canAfford(1);
  }
  public action(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 1, {title: TITLES.payForCardAction(this.name)}))
      .andThen(() => {
        const identify = new IdentifySpacesDeferred(player, 1);
        player.game.defer(identify);
        identify.andThen(([space]) => {
          const undergroundResources = space.undergroundResources;
          if (undergroundResources === undefined) {
            player.game.log('${0} had no underground resources to discard', (b) => b.player(player));
            return;
          }
          player.game.log('${0} revealed and discarded ${1}', (b) => b.player(player).string(undergroundResourceTokenDescription[undergroundResources]));
          if (['microbe1', 'microbe2', 'microbe1pertemp'].includes(undergroundResources)) {
            player.addResourceTo(this, 1);
            player.game.log('${0} found life!', (b) => b.player(player));
          }
        });
      });
    return undefined;
  }
}

================
File: cards/underworld/SecretResearch.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class SecretResearch extends PreludeCard {
  constructor() {
    super({
      name: CardName.SECRET_RESEARCH,
      tags: [Tag.SCIENCE],

      behavior: {
        drawCard: 3,
        underworld: {corruption: 1},
      },

      metadata: {
        cardNumber: 'UP12',
        renderData: CardRenderer.builder((b) => {
          b.corruption().cards(3);
        }),
        description: 'Gain 1 corruption and draw 3 cards.',
      },
    });
  }
}

================
File: cards/underworld/SeismicPredictions.ts
================
import {IGlobalEvent} from '../../turmoil/globalEvents/IGlobalEvent';
import {GlobalEvent} from '../../turmoil/globalEvents/GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../../turmoil/Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {isHazardTileType} from '../../../common/AresTileType';
import {Size} from '../../../common/cards/render/Size';
import {cancelled} from '../../cards/Options';
import {SpaceType} from '../../../common/boards/SpaceType';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.text('ALL').undergroundResources(1, {cancelled}).nbsp.megacredits(-2).slash().emptyTile().asterix().influence({size: Size.SMALL});
});

export class SeismicPredictions extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SEISMIC_PREDICTIONS,
      description: 'Discard all unclaimed underground resources. ' +
      'Lose 2 M€ for each tile on Mars you own WITHOUT excavation markers (max 5) minus influence.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    UnderworldExpansion.removeAllUnclaimedTokens(game);

    game.getPlayersInGenerationOrder().forEach((player) => {
      const playerSpaces = player.game.board.spaces.filter((space) => {
        if (space.spaceType === SpaceType.COLONY) {
          return false;
        }
        if (space.tile === undefined) {
          return false;
        }
        if (space.player !== player) {
          return false;
        }
        return !isHazardTileType(space.tile?.tileType);
      });
      const filtered = playerSpaces.filter(
        (space) => space.undergroundResources === undefined && space.excavator === undefined);
      const penalty = Math.min(5, filtered.length) - turmoil.getPlayerInfluence(player);
      const cost = penalty * 2;
      if (cost > 0) {
        player.stock.deduct(Resource.MEGACREDITS, cost, {log: true, from: this.name});
      }
    });
  }
}

================
File: cards/underworld/ServerSabotage.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {all, digit} from '../Options';
import {IPlayer} from '../../IPlayer';
import {Card} from '../Card';
import {RemoveResourcesFromCard} from '../../deferredActions/RemoveResourcesFromCard';
import {CardResource} from '../../../common/CardResource';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {cancelled} from '../Options';
export class ServerSabotage extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SERVER_SABOTAGE,
      cost: 7,

      behavior: {
        underworld: {corruption: 1},
      },

      metadata: {
        cardNumber: 'U47',
        renderData: CardRenderer.builder((b) => {
          // TODO(kberg): Use icon.
          b.corruption(1).minus().resource(CardResource.DATA, {amount: 2, digit, all}).br.text('ALL').undergroundResources(1, {cancelled});
        }),
        description: 'Gain 1 corruption. Remove up to 2 data fromany player. Remove all unclaimed underground resources ' +
          'from the board back into the pile. Their spaces can be identified again.',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    if (player.game.isSoloMode()) {
      return true;
    }
    return RemoveResourcesFromCard.getAvailableTargetCards(player, CardResource.DATA).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    game.defer(new RemoveResourcesFromCard(player, CardResource.DATA, 2));
    if (game.underworldData === undefined) {
      return;
    }
    UnderworldExpansion.removeAllUnclaimedTokens(player.game);
    return undefined;
  }
}

================
File: cards/underworld/SoilExport.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';

export class SoilExport extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.SOIL_EXPORT,
      type: CardType.EVENT,
      cost: 7,
      tags: [Tag.JOVIAN, Tag.VENUS, Tag.SPACE],
      victoryPoints: -1,

      behavior: {
        underworld: {
          excavate: 1,
          markThisGeneration: {},
        },
      },


      metadata: {
        cardNumber: 'U58',
        renderData: CardRenderer.builder((b) => {
          b.excavate().br;
          b.plainText('Excavate an underground resource.').br;
          b.megacredits(12).asterix().br;
          b.plainText('At the end of this generation only, during the production phase, gain 12 M€.');
        }),
      },
    });
  }

  public generationUsed: number = -1;

  public onProductionPhase(player: IPlayer) {
    if (this.generationUsed === player.game.generation) {
      player.stock.add(Resource.MEGACREDITS, 12);
    }
    return undefined;
  }
}

================
File: cards/underworld/SpacePrivateers.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardResource} from '../../../common/CardResource';
import {CardType} from '../../../common/cards/CardType';
import {Card} from '../Card';
import {all} from '../Options';
import {IActionCard} from '../ICard';
import {IPlayer} from '../../IPlayer';
import {PlayerInput} from '../../PlayerInput';
import {Resource} from '../../../common/Resource';

export class SpacePrivateers extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SPACE_PRIVATEERS,
      cost: 10,
      tags: [Tag.SPACE],
      resourceType: CardResource.FIGHTER,
      victoryPoints: -2,
      requirements: {corruption: 3},

      behavior: {
        addResources: 3,
      },

      metadata: {
        cardNumber: 'U50',
        renderData: CardRenderer.builder((b) => {
          b.action('If there is at least 1 fighter on this card, steal 2 M€ from EACH OTHER player.',
            (ab) => ab.empty().startAction.resource(CardResource.FIGHTER).asterix().colon().text('STEAL').megacredits(2, {all})).br;
          b.effect(
            'If 1 or more targets block this with corruption, remove 1 fighter from here.',
            (eb) => eb.corruptionShield().startEffect.minus().resource(CardResource.FIGHTER)).br;
          b.plainText('(Solo: Gain 2 M€ and remove 1 fighter from this card.)').br;
          b.resource(CardResource.FIGHTER, 3);
        }),
        description: 'Requires 3 corruption. Put 3 fighter resources on this card.',
      },
    });
  }
  public data = {
    action: 0,
    rejected: false,
  };

  canAct(): boolean {
    return this.resourceCount > 0;
  }
  action(player: IPlayer): PlayerInput | undefined {
    if (player.game.isSoloMode()) {
      player.stock.add(Resource.MEGACREDITS, 2, {log: true});
      this.resourceCount--;
      player.resolveInsuranceInSoloGame();
      return undefined;
    }

    // TODO(kberg): Attacker should decide attack order.

    // If a player is Mons Insurance, this probably won't go in preferred player order.
    // TODO(kberg): devise a Mons Insurance solution.
    let blocked = false;

    const targets = player.getOpponents();
    const waitingFor = new Set(targets);
    for (const target of targets) {
      target.maybeBlockAttack(player, (proceed) => {
        if (proceed) {
          target.stock.steal(Resource.MEGACREDITS, 2, player, {log: true});
          target.resolveInsurance();
        } else {
          blocked = true;
        }
        waitingFor.delete(target);
        if (waitingFor.size === 0 && blocked) {
          player.removeResourceFrom(this, 1, {log: true});
        }
        return undefined;
      });
    }
    return undefined;
  }
}

================
File: cards/underworld/SpaceWargames.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardResource} from '../../../common/CardResource';
import {CardType} from '../../../common/cards/CardType';
import {ActionCard} from '../ActionCard';
import {digit} from '../Options';

export class SpaceWargames extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.SPACE_WARGAMES,
      cost: 25,
      tags: [Tag.JOVIAN, Tag.SPACE],
      victoryPoints: {tag: Tag.JOVIAN},
      resourceType: CardResource.FIGHTER,

      behavior: {
        addResources: 1,
      },

      action: {
        or: {
          behaviors: [
            {
              spend: {titanium: 1},
              addResources: 1,
              title: 'Spend 1 titanium to add 1 fighter resource to this card.',
            },
            {
              spend: {resourcesHere: 1},
              stock: {megacredits: {start: 1, resourcesHere: {}, each: 3}},
              title: 'Spend 1 fighter resource on this card to gain 3 M€ for each fighter on this card, including the fighter.',
            },
          ],
          autoSelect: true,
        },
      },

      metadata: {
        cardNumber: 'U48',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to gain 1 fighter resource to this card.',
            (ab) => ab.titanium(1).startAction.resource(CardResource.FIGHTER)).br;
          b.action('Spend 1 fighter resource on this card to gain 3 M€ for each fighter resource on this card INCLUDING THE PAID FIGHTER.',
            (ab) => ab.or().resource(CardResource.FIGHTER).startAction.megacredits(3, {digit}).slash().resource(CardResource.FIGHTER).asterix()).br;
          b.resource(CardResource.FIGHTER);
        }),
        description: 'Put 1 fighter resource on this card. 1VP for each Jovian tag you have.',
      },
    });
  }
}

================
File: cards/underworld/StagedProtests.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class StagedProtests extends Card implements IProjectCard {
  public generationUsed: number = -1;

  constructor() {
    super({
      name: CardName.STAGED_PROTESTS,
      type: CardType.EVENT,
      cost: 6,

      requirements: {corruption: 1},

      behavior: {
        underworld: {
          corruption: 1,
          markThisGeneration: {},
        },
      },

      metadata: {
        cardNumber: 'U66',
        renderData: CardRenderer.builder((b) => {
          b.corruption(1).br;
          // TODO(kberg): replace with award().slash.milestone() when award and milestone can be stacked.
          b.plate('Awards and Milestones').colon().megacredits(8).asterix();
        }),
        description: 'Requires 1 corruption. Gain 1 corruption. Until the end of this generation, milestones and awards cost +8 M€.',
      },
    });
  }
}

================
File: cards/underworld/StandardTechnology.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {IActionCard, ICard} from '../ICard';
import {IStandardProjectCard} from '../IStandardProjectCard';

export class StandardTechnology extends Card implements IActionCard, IProjectCard {
  constructor() {
    super({
      name: CardName.STANDARD_TECHNOLOGY_UNDERWORLD,
      type: CardType.ACTIVE,
      cost: 6,
      tags: [Tag.SCIENCE],

      metadata: {
        cardNumber: 'U00',
        renderData: CardRenderer.builder((b) => {
          b.empty().startAction.text('REPEAT').br.plate('Standard projects').asterix().megacredits(-6);
          b.plainText('Action: Use a standard project that you\'ve already done this generation, with its cost reduced by 8 M€.').br;
        }),
      },
    });
  }
  public action(_player: IPlayer) {
    return undefined;
  }
  public canAct(_player: IPlayer): boolean {
    throw new Error('Method not implemented.');
  }

  public data: {gens: Partial<Record<CardName, number>>} = {gens: {}};

  onStandardProject(player: IPlayer, project: ICard): void {
    this.data.gens[project.name] = player.game.generation;
  }

  public getStandardProjectDiscount(player: IPlayer, card: IStandardProjectCard): number {
    if (card && this.data.gens[card.name] === player.game.generation) {
      return 8;
    }
    return 0;
  }
}

================
File: cards/underworld/StarVegas.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {SpaceName} from '../../SpaceName';
import {PlaceCityTile} from '../../deferredActions/PlaceCityTile';
import {Space} from '../../boards/Space';
import {Resource} from '../../../common/Resource';
import {all} from '../Options';

const SPACE_CITIES = [
  SpaceName.GANYMEDE_COLONY,
  SpaceName.PHOBOS_SPACE_HAVEN,
  SpaceName.STANFORD_TORUS,
  SpaceName.LUNA_METROPOLIS,
  SpaceName.DAWN_CITY,
  SpaceName.STRATOPOLIS,
  SpaceName.MAXWELL_BASE,
  SpaceName.CERES_SPACEPORT,
  SpaceName.DYSON_SCREENS,
  SpaceName.LUNAR_EMBASSY,
  SpaceName.VENERA_BASE,
  // MARTIAN_TRANSHIPMENT_STATION,
] as const;

type SpaceCity = typeof SPACE_CITIES[number];
const spaceCityNames: Record<SpaceCity, CardName> = {
  [SpaceName.GANYMEDE_COLONY]: CardName.GANYMEDE_COLONY,
  [SpaceName.PHOBOS_SPACE_HAVEN]: CardName.PHOBOS_SPACE_HAVEN,
  [SpaceName.STANFORD_TORUS]: CardName.STANFORD_TORUS,
  [SpaceName.LUNA_METROPOLIS]: CardName.LUNA_METROPOLIS,
  [SpaceName.DAWN_CITY]: CardName.DAWN_CITY,
  [SpaceName.STRATOPOLIS]: CardName.STRATOPOLIS,
  [SpaceName.MAXWELL_BASE]: CardName.MAXWELL_BASE,
  [SpaceName.CERES_SPACEPORT]: CardName.CERES_SPACEPORT,
  [SpaceName.DYSON_SCREENS]: CardName.DYSON_SCREENS,
  [SpaceName.LUNAR_EMBASSY]: CardName.LUNAR_EMBASSY,
  [SpaceName.VENERA_BASE]: CardName.VENERA_BASE,
} as const;


export class StarVegas extends Card {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.STAR_VEGAS,
      cost: 32,
      tags: [Tag.SPACE, Tag.CITY],
      requirements: {cities: 3, all: true},

      behavior: {
        underworld: {
          corruption: 2,
        },
      },

      metadata: {
        cardNumber: 'U53',
        renderData: CardRenderer.builder((b) => {
          b.city().asterix().corruption(2).br;
          b.production((pb) => pb.megacredits(1).slash().city({all}));
        }),
        description: 'Requires any 3 cities in play. Place a city on a space reserved for a different space city. ' +
        'Gain 2 corruption. Increase your M€ production one step for each city in play.',
      },
    });
  }

  private eligibleSpaces(player: IPlayer): ReadonlyArray<Space> {
    const spaces = [];
    for (const spaceId of SPACE_CITIES) {
      try {
        const space = player.game.board.getSpaceOrThrow(spaceId);
        if (space.tile === undefined) {
          spaces.push(space);
        }
      } catch (err) {
        // This occurs with invalid spaces.
      }
    }
    return spaces;
  }

  override bespokeCanPlay(player: IPlayer) {
    return this.eligibleSpaces(player).length > 0;
  }

  override bespokePlay(player: IPlayer) {
    const game = player.game;
    game.defer(new PlaceCityTile(player, {spaces: this.eligibleSpaces(player)})).andThen((space) => {
      if (space !== undefined) {
        const id = space.id as SpaceCity;
        game.log('${0} placed ${1} on ${2}', (b) => b.player(player).cardName(this.name).string(spaceCityNames[id] ?? 'unknown'));
        player.production.add(Resource.MEGACREDITS, (game.board.getCities()).length, {log: true});
        if (space.tile !== undefined) { // Should not happen
          space.tile.card = this.name;
        }
      }
    });
    return undefined;
  }
}

================
File: cards/underworld/StemFieldSubsidies.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';
import {CardResource} from '../../../common/CardResource';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {IdentifySpacesDeferred} from '../../underworld/IdentifySpacesDeferred';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';

export class StemFieldSubsidies extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.STEM_FIELD_SUBSIDIES,
      cost: 10,
      tags: [Tag.SCIENCE],
      victoryPoints: {resourcesHere: {}, per: 3},
      resourceType: CardResource.DATA,

      metadata: {
        cardNumber: 'U43',
        renderData: CardRenderer.builder((b) => {
          b.effect('Whenever you play a science tag (including this), add 1 data to ANY card and identify an underground resource.',
            (eb) => eb.tag(Tag.SCIENCE).startEffect.resource(CardResource.DATA).asterix().identify(1));
        }),
        description: '1 VP per 3 data resources on this card.',
      },
    });
  }

  public onCardPlayed(player: IPlayer, card: IProjectCard) {
    const count = player.tags.cardTagCount(card, Tag.SCIENCE);
    this.onScienceTagAdded(player, count);
  }
  public onColonyAddedToLeavitt(player: IPlayer): void {
    this.onScienceTagAdded(player, 1);
  }
  public onScienceTagAdded(player: IPlayer, count: number) {
    if (count > 0) {
      player.game.defer(new IdentifySpacesDeferred(player, count));
    }
    for (let idx = 0; idx < count; idx++) {
      player.game.defer(new AddResourcesToCard(player, CardResource.DATA));
    }
  }
}

================
File: cards/underworld/SubnauticPirates.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Resource} from '../../../common/Resource';

export class SubnauticPirates extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.SUBNAUTIC_PIRATES,
      type: CardType.EVENT,
      cost: 3,

      requirements: [{excavation: 1}, {corruption: 1}],
      victoryPoints: -1,

      metadata: {
        cardNumber: 'U11',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).excavate().asterix().colon().text('STEAL').megacredits(6);
        }),
        description: 'Requires 1 excavation marker and 1 corruption. Pick an ocean tile ' +
        'that has your excavation marker on it. Steal 6 M€ from each other player that ' +
        'owns a tile adjacent to that ocean. This can be blocked by corruption.',
      },
    });
  }

  private availableSpaces(player: IPlayer) {
    return player.game.board.getOceanSpaces().filter((space) => space.excavator === player);
  }

  public override bespokeCanPlay(player: IPlayer) {
    return this.availableSpaces(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select an ocean space you have excavated', this.availableSpaces(player))
      .andThen((space) => {
        const adjacentSpaces = player.game.board.getAdjacentSpaces(space);
        const set = new Set<IPlayer>();
        for (const space of adjacentSpaces) {
          if (space.player !== undefined && space.player !== player) {
            set.add(space.player);
          }
        }

        set.forEach((target) => {
          target.maybeBlockAttack(player, (proceed) => {
            if (proceed) {
              target.stock.steal(Resource.MEGACREDITS, 6, player);
            }
            return undefined;
          });
        });
        return undefined;
      });
  }
}

================
File: cards/underworld/SubterraneanSea.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {PlaceOceanTile} from '../../deferredActions/PlaceOceanTile';

export class SubterraneanSea extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.SUBTERRANEAN_SEA,
      type: CardType.AUTOMATED,
      cost: 10,
      tags: [Tag.BUILDING],

      tr: {oceans: 1},

      metadata: {
        cardNumber: 'U15',
        renderData: CardRenderer.builder((b) => {
          b.oceans(1).excavate().asterix();
        }),
        description: 'Place an ocean tile ON AN AREA NOT RESERVED FOR OCEAN where you have an excavation marker.',
      },
    });
  }

  private availableSpaces(player: IPlayer) {
    const availableSpcesOnLand = player.game.board.getAvailableSpacesOnLand(
      player, {
        cost: player.getCardCost(this),
        tr: {oceans: 1},
      });
    return availableSpcesOnLand.filter((space) => space.excavator === player);
  }

  public override bespokeCanPlay(player: IPlayer) {
    if (!player.game.canAddOcean()) {
      this.warnings.add('maxoceans');
    }
    return this.availableSpaces(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    player.game.defer(new PlaceOceanTile(player, {
      spaces: this.availableSpaces(player),
    }));
    return undefined;
  }
}

================
File: cards/underworld/ThiolavaVents.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {IPlayer} from '../../IPlayer';
import {Resource} from '../../../common/Resource';

export class ThiolavaVents extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.THIOLAVA_VENTS,
      cost: 13,
      tags: [Tag.MICROBE],
      resourceType: CardResource.MICROBE,

      requirements: {oceans: 1},

      victoryPoints: {resourcesHere: {}, per: 3},

      behavior: {
        production: {heat: 2},
        addResources: 2, // This is the "includes this".
      },

      metadata: {
        cardNumber: 'U90',
        renderData: CardRenderer.builder((b) => {
          b.effect('Each time you increase your heat production, including this, put 1 microbe on this card.',
            (eb) => eb.production((pb) => pb.heat(1)).startEffect.resource(CardResource.MICROBE));
          b.br;
          b.production((pb) => pb.heat(2));
        }),
        description: 'Requires an ocean. Increase your heat production 2 steps. ' +
          '1 VP per 3 microbes on this card.',
      },
    });
  }

  public onProductionGain(player: IPlayer, resource: Resource, amount: number) {
    if (amount <= 0 || resource !== Resource.HEAT) {
      return;
    }
    player.addResourceTo(this, {qty: amount, log: true});
  }
}

================
File: cards/underworld/TitanManufacturingColony.ts
================
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IProjectCard} from '../IProjectCard';
import {CardType} from '../../../common/cards/CardType';
import {ActionCard} from '../ActionCard';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';

export class TitanManufacturingColony extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TITAN_MANUFACTURING_COLONY,
      cost: 18,
      tags: [Tag.JOVIAN, Tag.SPACE, Tag.BUILDING],
      resourceType: CardResource.TOOL,

      action: {
        spend: {resourcesHere: 1},
        underworld: {excavate: 1},
      },

      metadata: {
        cardNumber: 'U44',
        renderData: CardRenderer.builder((b) => {
          b.effect('Whenever you play a Jovian tag, (including this one), add 1 tool resource on this card.',
            (ab) => ab.tag(Tag.JOVIAN).startEffect.resource(CardResource.TOOL)).br;
          b.action('Spend 1 tool resource on this card to excavate an underground resource.',
            (ab) => ab.resource(CardResource.TOOL).startAction.excavate(1));
        }),
      },
    });
  }

  onCardPlayed(player: IPlayer, card: IProjectCard): undefined {
    const count = card.tags.filter((tag) => tag === Tag.JOVIAN).length;
    player.addResourceTo(this, {qty: count, log: true});
    return undefined;
  }
}

================
File: cards/underworld/TunnelBoringMachine.ts
================
import {Tag} from '../../../common/cards/Tag';
import {ActionCard} from '../ActionCard';
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {digit} from '../Options';

export class TunnelBoringMachine extends ActionCard implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.TUNNEL_BORING_MACHINE,
      tags: [Tag.BUILDING],
      cost: 10,

      action: {
        spend: {energy: 3},
        underworld: {excavate: 2},
      },

      metadata: {
        cardNumber: 'U03',
        renderData: CardRenderer.builder((b) => {
          b.action('Pay 3 energy to excavate 2 underground resources',
            (ab) => ab.energy(3, {digit}).startAction.excavate(2));
        }),
      },
    });
  }
}

================
File: cards/underworld/TunnelingOperation.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';

export class TunnelingOperation extends PreludeCard {
  constructor() {
    super({
      name: CardName.TUNNELING_OPERATION,
      tags: [Tag.BUILDING],

      behavior: {
        underworld: {identify: 1, excavate: 2},
        production: {steel: 2},
      },

      metadata: {
        cardNumber: 'UP05',
        renderData: CardRenderer.builder((b) => {
          b.identify(1).excavate(2).production((pb) => pb.steel(2));
        }),
        description: 'Identify 1 underground resource. Then excavate 2 underground resources. Increase your steel production 2 steps.',
      },
    });
  }
}

================
File: cards/underworld/TunnelingSubcontractor.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class TunnelingSubcontractor extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TUNNELING_SUBCONTRACTOR,
      cost: 9,

      behavior: {
        underworld: {corruption: 1, excavate: 1},
      },

      metadata: {
        cardNumber: 'U07',
        renderData: CardRenderer.builder((b) => {
          b.corruption(1).excavate(1);
        }),
        description: 'Gain 1 corruption. Excavate an underground resource.',
      },
    });
  }
}

================
File: cards/underworld/UndergroundAmusementPark.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';

export class UndergroundAmusementPark extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.UNDERGROUND_AMUSEMENT_PARK,
      tags: [Tag.BUILDING],
      cost: 5,
      victoryPoints: 1,

      requirements: {excavation: 1},

      behavior: {
        production: {megacredits: 1},
      },

      metadata: {
        cardNumber: 'U19',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1));
        }),
        description: 'Requires an excavation marker. Increase your M€ production 1 step.',
      },
    });
  }
}

================
File: cards/underworld/UndergroundHabitat.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';

export class UndergroundHabitat extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.UNDERGROUND_HABITAT,
      cost: 12,
      tags: [Tag.MARS, Tag.BUILDING, Tag.PLANT],

      behavior: {
        production: {plants: 1},
        addResourcesToAnyCard: {count: 1, type: CardResource.ANIMAL, autoSelect: true},
        underworld: {excavate: 1},
      },

      metadata: {
        cardNumber: 'U71',
        renderData: CardRenderer.builder((b) => {
          b.excavate(1).production((pb) => pb.plants(1)).resource(CardResource.ANIMAL).asterix();
        }),
        description: 'Excavate an underground resource. Increase your plant production 1 step. Add 1 animal on another card.',
      },
    });
  }
}

================
File: cards/underworld/UndergroundRailway.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {digit} from '../Options';

export class UndergroundRailway extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.UNDERGROUND_RAILWAY,
      cost: 12,
      tags: [Tag.BUILDING],

      behavior: {
        production: {energy: -1},
        tr: {underworld: {excavationMarkers: {}}, per: 4},
      },

      metadata: {
        cardNumber: 'U04',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().energy(1)).br;
          b.tr(1).slash().excavate(4, {digit});
        }),
        description: 'Decrease your energy production 1 step. Gain 1 TR for every 4 excavation markers you own.',
      },
    });
  }
}

================
File: cards/underworld/UndergroundResearchCenter.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {ALL_TAGS, Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {SelectSpace} from '../../inputs/SelectSpace';
import {Units} from '../../../common/Units';
import {inplaceRemove} from '../../../common/utils/utils';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {Priority} from '../../deferredActions/Priority';

export class UndergroundResearchCenter extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.UNDERGROUND_RESEARCH_CENTER,
      tags: [Tag.BUILDING],
      cost: 18,

      requirements: {excavation: 5},

      metadata: {
        cardNumber: 'U62',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.minus().energy(1)).excavate().cards(2).asterix();
        }),

        description: 'Requires 5 excavation markers. Decrease your energy production 1 step. ' +
        'Excavate an underground resource. Choose a tag that is not the wild tag or clone tag. ' +
        'Draw 2 cards with that tag.',
      },
    });
  }

  private excavatableSpacesWithEnergyProduction(player: IPlayer) {
    return UnderworldExpansion.excavatableSpaces(player).filter(
      (space) => space.undergroundResources === 'energy1production');
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    if (player.production.energy > 0) {
      return true;
    }
    if (this.excavatableSpacesWithEnergyProduction(player).length > 0) {
      this.warnings.add('underworldMustExcavateEnergy');
      return true;
    }
    return false;
  }

  private chooseTagsAndDraw(player: IPlayer) {
    const tags = [...ALL_TAGS];
    inplaceRemove(tags, Tag.WILD);
    inplaceRemove(tags, Tag.CLONE);

    const options = tags.map((tag) => {
      return new SelectOption(tag).andThen(() => {
        player.drawCard(2, {tag: tag});
        return undefined;
      });
    });
    return new OrOptions(...options);
  }

  public override bespokePlay(player: IPlayer) {
    const spaces = player.production.energy > 0 ?
      UnderworldExpansion.excavatableSpaces(player) :
      this.excavatableSpacesWithEnergyProduction(player);

    return new SelectSpace('Select space to excavate', spaces)
      .andThen((space) => {
        UnderworldExpansion.excavate(player, space);
        // Energy production is granted immediately, so in case this player can only do this because there's energy production on the board, it's now theirs.
        player.production.adjust(Units.of({energy: -1}));
        player.defer(this.chooseTagsAndDraw(player), Priority.DRAW_CARDS);
        return undefined;
      });
  }
}

================
File: cards/underworld/UndergroundSettlement.ts
================
import {PreludeCard} from '../prelude/PreludeCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {SelectSpace} from '../../inputs/SelectSpace';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';
import {intersection} from '../../../common/utils/utils';

export class UndergroundSettlement extends PreludeCard {
  constructor() {
    super({
      name: CardName.UNDERGROUND_SETTLEMENT,
      tags: [Tag.CITY, Tag.BUILDING],

      metadata: {
        cardNumber: 'UP07',
        renderData: CardRenderer.builder((b) => {
          b.city().excavate().asterix();
        }),
        description: 'Place a city tile. Then excavate the underground resource in its space.',
      },
    });
  }

  private availableSpaces(player: IPlayer) {
    return intersection(
      player.game.board.getAvailableSpacesForCity(player),
      UnderworldExpansion.excavatableSpaces(player));
  }

  public override bespokeCanPlay(player: IPlayer) {
    return this.availableSpaces(player).length > 0;
  }

  public override bespokePlay(player: IPlayer) {
    return new SelectSpace('Select space for city tile', this.availableSpaces(player))
      .andThen((space) => {
        player.game.addCity(player, space);
        UnderworldExpansion.excavate(player, space);
        return undefined;
      });
  }
}

================
File: cards/underworld/UndergroundShelters.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderDynamicVictoryPoints} from '../render/CardRenderDynamicVictoryPoints';
import {IPlayer} from '../../IPlayer';
import {sum} from '../../../common/utils/utils';

export class UndergroundShelters extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.UNDERGROUND_SHELTERS,
      cost: 14,
      tags: [Tag.MARS, Tag.BUILDING],
      victoryPoints: 'special',

      behavior: {
        underworld: {excavate: 1},
      },

      metadata: {
        cardNumber: 'U72',
        // TODO(kberg): Custom VP icon.
        victoryPoints: CardRenderDynamicVictoryPoints.undergroundShelters(),
        renderData: CardRenderer.builder((b) => {
          b.excavate(1);
        }),
        description: 'Excavate an underground resource. At the end of the game, your cities score 1 VP per 3 excavation markers YOU have in that city space and adjacent spaces.',
      },
    });
  }

  public override getVictoryPoints(player: IPlayer): number {
    const cities = player.game.board.getCities(player);
    const counts = cities.map((city) => {
      return [city, ...player.game.board.getAdjacentSpaces(city)].filter((space) => space.excavator === player).length;
    });
    const vps = counts.map((count) => Math.floor(count / 3));
    return sum(vps);
  }
}

================
File: cards/underworld/UndergroundSmugglingRing.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {digit} from '../Options';

export class UndergroundSmugglingRing extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.UNDERGROUND_SMUGGLING_RING,
      cost: 8,

      requirements: {excavation: 1},

      behavior: {
        underworld: {corruption: 1},
        standardResource: 2,
      },

      metadata: {
        cardNumber: 'U28',
        renderData: CardRenderer.builder((b) => {
          b.corruption(1).wild(2, {digit}).asterix();
        }),
        description: 'Requires an excavation marker. Gain 1 corruption and 2 of the same standard resource.',
      },
    });
  }
}

================
File: cards/underworld/UnderworldCardManifest.ts
================
import {CardName} from '../../../common/cards/CardName';
import {ModuleManifest} from '../ModuleManifest';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';

import {AeronGenomics} from './AeronGenomics';
import {AntiTrustCrackdown} from './AntiTrustCrackdown';
import {AnubisSecurities} from './AnubisSecurities';
import {ArboristCollective} from './ArboristCollective';
// // import {AresMedia} from './AresMedia';
import {ArtesianAquifer} from './ArtesianAquifer';
import {BatteryFactory} from './BatteryFactory';
import {BatteryShipment} from './BatteryShipment';
import {BehemothExcavator} from './BehemothExcavator';
import {Casino} from './Casino';
import {CaveCity} from './CaveCity';
import {CentralReservoir} from './CentralReservoir';
import {ChemicalFactory} from './ChemicalFactory';
// import {ClassActionLawsuit} from './ClassActionLawsuit';
import {CloudVortexOutpost} from './CloudVortexOutpost';
import {CollusionStandardProject} from './CollusionStandardProject';
import {ConcessionRights} from './ConcessionRights';
import {CorporateBlackmail} from './CorporateBlackmail';
import {CorporateTheft} from './CorporateTheft';
import {CraterSurvey} from './CraterSurvey';
import {CutThroatBudgeting} from './CutThroatBudgeting';
import {Deepmining} from './Deepmining';
import {Deepnuking} from './Deepnuking';
import {DeepwaterDome} from './DeepwaterDome';
import {DemetronLabs} from './DemetronLabs';
import {EarthquakeMachine} from './EarthquakeMachine';
import {ElectionSponsorship} from './ElectionSponsorship';
import {ExcavateStandardProject} from './ExcavateStandardProject';
import {ExcavatorLeasing} from './ExcavatorLeasing';
import {ExpeditionVehicles} from './ExpeditionVehicles';
import {FairTradeComplaint} from './FairTradeComplaint';
import {FabricatedScandal} from './FabricatedScandal';
import {ForestTunnels} from './ForestTunnels';
import {FreeTradePort} from './FreeTradePort';
import {FriendsInHighPlaces} from './FriendsInHighPlaces';
import {GaiaCity} from './GaiaCity';
import {GanymedeTradingCompany} from './GanymedeTradingCompany';
import {GeologicalExpertise} from './GeologicalExpertise';
import {GeologicalSurvey} from './GeologicalSurvey';
import {GeologistTeam} from './GeologistTeam';
import {GeoscanSatellite} from './GeoscanSatellite';
import {GeothermalNetwork} from './GeothermalNetwork';
import {GlobalAudit} from './GlobalAudit';
import {GreyMarketExploitation} from './GreyMarketExploitation';
import {GuerillaEcologists} from './GuerillaEcologists';
import {Hackers} from './Hackers';
import {Hadesphere} from './Hadesphere';
import {HecateSpeditions} from './HecateSpeditions';
import {HenkeiGenetics} from './HenkeiGenetics';
import {HiredRaiders} from './HiredRaiders';
import {HyperspaceDrivePrototype} from './HyperspaceDrivePrototype';
import {ImportedHeavyMachinery} from './ImportedHeavyMachinery';
import {InducedTremor} from './InducedTremor';
import {InfrastructureOverload} from './InfrastructureOverload';
import {InheritedFortune} from './InheritedFortune';
// // import {IntellectualPropertyTheft} from './IntellectualPropertyTheft';
import {InvestigativeJournalism} from './InvestigativeJournalism';
import {InvestorPlaza} from './InvestorPlaza';
import {JensonBoyleCo} from './JensonBoyleCo';
import {Keplertec} from './Keplertec';
import {KingdomofTauraro} from './KingdomofTauraro';
import {LaborTrafficking} from './LaborTrafficking';
import {LaggingRegulation} from './LaggingRegulation';
import {Landfill} from './Landfill';
import {LobbyingNetwork} from './LobbyingNetwork';
import {ManMadeVolcano} from './ManMadeVolcano';
import {MartianExpress} from './MartianExpress';
// // import {MediaFrenzy} from './MediaFrenzy';
import {MediaStir} from './MediaStir';
// // import {MercenaryAssault} from './MercenaryAssault';
import {MicroGeodesics} from './MicroGeodesics';
import {Microgravimetry} from './Microgravimetry';
import {MicroprobingTechnology} from './MicroprobingTechnology';
import {MigrationUnderground} from './MigrationUnderground';
import {MiningMarketInsider} from './MiningMarketInsider';
import {Monopoly} from './Monopoly';
import {Nanofoundry} from './Nanofoundry';
import {NarrativeSpin} from './NarrativeSpin';
import {Neutrinograph} from './Neutrinograph';
import {Nightclubs} from './Nightclubs';
import {OffWorldTaxHaven} from './OffWorldTaxHaven';
import {OldWorldMafia} from './OldWorldMafia';
import {OrbitalLaserDrill} from './OrbitalLaserDrill';
import {PatentManipulation} from './PatentManipulation';
import {PersonalSpacecruiser} from './PersonalSpacecruiser';
import {PlanetaryRightsBuyout} from './PlanetaryRightsBuyout';
import {PlantTax} from './PlantTax';
import {PriceWars} from './PriceWars';
import {PrivateInvestigator} from './PrivateInvestigator';
import {PrivateMilitaryContractor} from './PrivateMilitaryContractor';
import {PrivateResorts} from './PrivateResorts';
import {Prospecting} from './Prospecting';
import {PublicSpaceline} from './PublicSpaceline';
import {RecklessDetonation} from './RecklessDetonation';
import {ResearchDevelopmentHub} from './ResearchDevelopmentHub';
import {RobotMoles} from './RobotMoles';
import {Scapegoat} from './Scapegoat';
import {SearchforLifeUnderground} from './SearchforLifeUnderground';
import {SecretResearch} from './SecretResearch';
import {SeismicPredictions} from './SeismicPredictions';
import {ServerSabotage} from './ServerSabotage';
// // import {SocialEngineering} from './SocialEngineering';
import {SoilExport} from './SoilExport';
import {SpacePrivateers} from './SpacePrivateers';
import {SpaceWargames} from './SpaceWargames';
import {StagedProtests} from './StagedProtests';
// import {StandardTechnology} from './StandardTechnology';
import {StarVegas} from './StarVegas';
import {StemFieldSubsidies} from './StemFieldSubsidies';
import {SubnauticPirates} from './SubnauticPirates';
import {SubterraneanSea} from './SubterraneanSea';
import {ThiolavaVents} from './ThiolavaVents';
import {TitanManufacturingColony} from './TitanManufacturingColony';
import {TunnelBoringMachine} from './TunnelBoringMachine';
import {TunnelingOperation} from './TunnelingOperation';
import {TunnelingSubcontractor} from './TunnelingSubcontractor';
import {UndergroundAmusementPark} from './UndergroundAmusementPark';
import {UndergroundHabitat} from './UndergroundHabitat';
import {UndergroundRailway} from './UndergroundRailway';
import {UndergroundResearchCenter} from './UndergroundResearchCenter';
import {UndergroundSettlement} from './UndergroundSettlement';
import {UndergroundShelters} from './UndergroundShelters';
import {UndergroundSmugglingRing} from './UndergroundSmugglingRing';
import {Voltagon} from './Voltagon';
import {VoltaicMetallurgy} from './VoltaicMetallurgy';
import {VolunteerMiningInitiative} from './VolunteerMiningInitiative';
import {Whales} from './Whales';

export const UNDERWORLD_CARD_MANIFEST = new ModuleManifest({
  module: 'underworld',
  projectCards: {
    // 1-9
    [CardName.GEOLOGIST_TEAM]: {Factory: GeologistTeam},
    [CardName.GEOSCAN_SATELLITE]: {Factory: GeoscanSatellite},
    [CardName.TUNNEL_BORING_MACHINE]: {Factory: TunnelBoringMachine},
    [CardName.UNDERGROUND_RAILWAY]: {Factory: UndergroundRailway},
    [CardName.GAIA_CITY]: {Factory: GaiaCity},
    [CardName.DEEPNUKING]: {Factory: Deepnuking},
    [CardName.OLD_WORLD_MAFIA]: {Factory: OldWorldMafia},
    [CardName.NIGHTCLUBS]: {Factory: Nightclubs},
    [CardName.RECKLESS_DETONATION]: {Factory: RecklessDetonation},
    // 10-18
    [CardName.OFF_WORLD_TAX_HAVEN]: {Factory: OffWorldTaxHaven},
    [CardName.SUBNAUTIC_PIRATES]: {Factory: SubnauticPirates},
    // // [CardName.SOCIAL_ENGINEERING]: {Factory: SocialEngineering}, // Use another player's action. Not right now.
    [CardName.FABRICATED_SCANDAL]: {Factory: FabricatedScandal},
    [CardName.LABOR_TRAFFICKING]: {Factory: LaborTrafficking},
    [CardName.SUBTERRANEAN_SEA]: {Factory: SubterraneanSea},
    [CardName.FOREST_TUNNELS]: {Factory: ForestTunnels},
    [CardName.MAN_MADE_VOLCANO]: {Factory: ManMadeVolcano},
    [CardName.TUNNELING_SUBCONTRACTOR]: {Factory: TunnelingSubcontractor},
    // 19-27
    [CardName.UNDERGROUND_AMUSEMENT_PARK]: {Factory: UndergroundAmusementPark},
    [CardName.CASINO]: {Factory: Casino},
    [CardName.IMPORTED_HEAVY_MACHINERY]: {Factory: ImportedHeavyMachinery},
    [CardName.MICROPROBING_TECHNOLOGY]: {Factory: MicroprobingTechnology},
    [CardName.SEARCH_FOR_LIFE_UNDERGROUND]: {Factory: SearchforLifeUnderground},
    [CardName.GEOTHERMAL_NETWORK]: {Factory: GeothermalNetwork},
    [CardName.GLOBAL_AUDIT]: {Factory: GlobalAudit},
    [CardName.PATENT_MANIPULATION]: {Factory: PatentManipulation},
    [CardName.CAVE_CITY]: {Factory: CaveCity},
    // 28-36
    [CardName.UNDERGROUND_SMUGGLING_RING]: {Factory: UndergroundSmugglingRing},
    [CardName.DEEPMINING]: {Factory: Deepmining},
    [CardName.BEHEMOTH_EXCAVATOR]: {Factory: BehemothExcavator},
    [CardName.LOBBYING_NETWORK]: {Factory: LobbyingNetwork},
    [CardName.CONCESSION_RIGHTS]: {Factory: ConcessionRights},
    [CardName.ORBITAL_LASER_DRILL]: {Factory: OrbitalLaserDrill},
    [CardName.GREY_MARKET_EXPLOITATION]: {Factory: GreyMarketExploitation},
    [CardName.EXCAVATOR_LEASING]: {Factory: ExcavatorLeasing},
    [CardName.LANDFILL]: {Factory: Landfill},
    // 37-45
    [CardName.NARRATIVE_SPIN]: {Factory: NarrativeSpin},
    [CardName.PRIVATE_INVESTIGATOR]: {Factory: PrivateInvestigator},
    [CardName.CORPORATE_BLACKMAIL]: {Factory: CorporateBlackmail},
    [CardName.SCAPEGOAT]: {Factory: Scapegoat},
    [CardName.FRIENDS_IN_HIGH_PLACES]: {Factory: FriendsInHighPlaces},
    [CardName.MICROGRAVIMETRY]: {Factory: Microgravimetry},
    [CardName.STEM_FIELD_SUBSIDIES]: {Factory: StemFieldSubsidies},
    [CardName.TITAN_MANUFACTURING_COLONY]: {Factory: TitanManufacturingColony},
    [CardName.ROBOT_MOLES]: {Factory: RobotMoles},
    // 46-54
    [CardName.MINING_MARKET_INSIDER]: {Factory: MiningMarketInsider},
    [CardName.SERVER_SABOTAGE]: {Factory: ServerSabotage},
    [CardName.SPACE_WARGAMES]: {Factory: SpaceWargames},
    [CardName.PRIVATE_MILITARY_CONTRACTOR]: {Factory: PrivateMilitaryContractor},
    [CardName.SPACE_PRIVATEERS]: {Factory: SpacePrivateers},
    [CardName.PERSONAL_SPACECRUISER]: {Factory: PersonalSpacecruiser},
    [CardName.HYPERSPACE_DRIVE_PROTOTYPE]: {Factory: HyperspaceDrivePrototype},
    [CardName.STAR_VEGAS]: {Factory: StarVegas},
    [CardName.PRIVATE_RESORTS]: {Factory: PrivateResorts},
    // 55-63
    [CardName.EARTHQUAKE_MACHINE]: {Factory: EarthquakeMachine},
    [CardName.MICRO_GEODESICS]: {Factory: MicroGeodesics},
    [CardName.NEUTRINOGRAPH]: {Factory: Neutrinograph},
    [CardName.SOIL_EXPORT]: {Factory: SoilExport},
    [CardName.ARTESIAN_AQUIFER]: {Factory: ArtesianAquifer},
    [CardName.CHEMICAL_FACTORY]: {Factory: ChemicalFactory},
    [CardName.CORPORATE_THEFT]: {Factory: CorporateTheft},
    [CardName.UNDERGROUND_RESEARCH_CENTER]: {Factory: UndergroundResearchCenter},
    [CardName.PRICE_WARS]: {Factory: PriceWars},
    // 64-72
    [CardName.ANTI_TRUST_CRACKDOWN]: {Factory: AntiTrustCrackdown},
    [CardName.MONOPOLY]: {Factory: Monopoly},
    [CardName.STAGED_PROTESTS]: {Factory: StagedProtests},
    [CardName.PLANT_TAX]: {Factory: PlantTax},
    [CardName.INFRASTRUCTURE_OVERLOAD]: {Factory: InfrastructureOverload},
    [CardName.CRATER_SURVEY]: {Factory: CraterSurvey},
    [CardName.INDUCED_TREMOR]: {Factory: InducedTremor},
    [CardName.UNDERGROUND_HABITAT]: {Factory: UndergroundHabitat},
    [CardName.UNDERGROUND_SHELTERS]: {Factory: UndergroundShelters},
    // 73-81
    [CardName.VOLUNTEER_MINING_INITIATIVE]: {Factory: VolunteerMiningInitiative},
    [CardName.NANOFOUNDRY]: {Factory: Nanofoundry},
    [CardName.BATTERY_FACTORY]: {Factory: BatteryFactory},
    [CardName.VOLTAIC_METALLURGY]: {Factory: VoltaicMetallurgy},
    [CardName.PUBLIC_SPACELINE]: {Factory: PublicSpaceline},
    [CardName.MARTIAN_EXPRESS]: {Factory: MartianExpress},
    [CardName.EXPEDITION_VEHICLES]: {Factory: ExpeditionVehicles},
    [CardName.CUT_THROAT_BUDGETING]: {Factory: CutThroatBudgeting},
    [CardName.GEOLOGICAL_SURVEY_UNDERWORLD]: {Factory: GeologicalSurvey},
    // 82-90
    // [CardName.CLASS_ACTION_LAWSUIT]: {Factory: ClassActionLawsuit},
    // // [CardName.MERCENARY_ASSAULT]: {Factory: MercenaryAssault}, // Blocking rules.
    [CardName.RESEARCH_DEVELOPMENT_HUB]: {Factory: ResearchDevelopmentHub},
    [CardName.PLANETARY_RIGHTS_BUYOUT]: {Factory: PlanetaryRightsBuyout},
    // // [CardName.MEDIA_FRENZY]: {Factory: MediaFrenzy}, // Scoops is not quite clear yet.
    [CardName.INVESTIGATIVE_JOURNALISM]: {Factory: InvestigativeJournalism},
    [CardName.WHALES]: {Factory: Whales},
    [CardName.GUERILLA_ECOLOGISTS]: {Factory: GuerillaEcologists},
    [CardName.THIOLAVA_VENTS]: {Factory: ThiolavaVents},

    // // Replacements
    // [CardName.STANDARD_TECHNOLOGY_UNDERWORLD]: {Factory: StandardTechnology},
    [CardName.HACKERS_UNDERWORLD]: {Factory: Hackers},
    [CardName.HIRED_RAIDERS_UNDERWORLD]: {Factory: HiredRaiders},
  },

  cardsToRemove: [
    // CardName.STANDARD_TECHNOLOGY,
    CardName.HACKERS,
    CardName.HIRED_RAIDERS,
  ],

  corporationCards: {
    [CardName.HADESPHERE]: {Factory: Hadesphere},
    [CardName.DEMETRON_LABS]: {Factory: DemetronLabs},
    [CardName.JENSON_BOYLE_CO]: {Factory: JensonBoyleCo},
    [CardName.HENKEI_GENETICS]: {Factory: HenkeiGenetics},
    [CardName.ARBORIST_COLLECTIVE]: {Factory: ArboristCollective},
    [CardName.KINGDOM_OF_TAURARO]: {Factory: KingdomofTauraro},
    [CardName.AERON_GENOMICS]: {Factory: AeronGenomics},
    [CardName.KEPLERTEC]: {Factory: Keplertec},
    [CardName.VOLTAGON]: {Factory: Voltagon, compatibility: 'venus'},
    // // [CardName.ARES_MEDIA]: {Factory: AresMedia}, // Not another events are up card.
    [CardName.ANUBIS_SECURITIES]: {Factory: AnubisSecurities},
    [CardName.HECATE_SPEDITIONS]: {Factory: HecateSpeditions, compatibility: 'colonies'},
  },

  preludeCards: {
    [CardName.FREE_TRADE_PORT]: {Factory: FreeTradePort, compatibility: 'colonies'},
    [CardName.INVESTOR_PLAZA]: {Factory: InvestorPlaza},
    [CardName.INHERITED_FORTUNE]: {Factory: InheritedFortune},
    // // [CardName.INTELLECTUAL_PROPERTY_THEFT]: {Factory: IntellectualPropertyTheft}, // Too tricky
    [CardName.TUNNELING_OPERATION]: {Factory: TunnelingOperation},
    [CardName.GEOLOGICAL_EXPERTISE]: {Factory: GeologicalExpertise},
    [CardName.UNDERGROUND_SETTLEMENT]: {Factory: UndergroundSettlement},
    [CardName.GANYMEDE_TRADING_COMPANY]: {Factory: GanymedeTradingCompany, compatibility: 'colonies'},
    [CardName.CENTRAL_RESERVOIR]: {Factory: CentralReservoir},
    [CardName.BATTERY_SHIPMENT]: {Factory: BatteryShipment},
    [CardName.DEEPWATER_DOME]: {Factory: DeepwaterDome},
    [CardName.SECRET_RESEARCH]: {Factory: SecretResearch},
    [CardName.PROSPECTING]: {Factory: Prospecting, compatibility: 'colonies'},
    [CardName.ELECTION_SPONSORSHIP]: {Factory: ElectionSponsorship, compatibility: 'turmoil'},
    [CardName.CLOUD_VORTEX_OUTPOST]: {Factory: CloudVortexOutpost, compatibility: 'venus'},
  },

  standardProjects: {
    [CardName.EXCAVATE_STANDARD_PROJECT]: {Factory: ExcavateStandardProject},
    [CardName.COLLUSION_STANDARD_PROJECT]: {Factory: CollusionStandardProject},
  },

  globalEvents: {
    [GlobalEventName.LAGGING_REGULATION]: {Factory: LaggingRegulation},
    [GlobalEventName.MIGRATION_UNDERGROUND]: {Factory: MigrationUnderground},
    [GlobalEventName.FAIR_TRADE_COMPLAINT]: {Factory: FairTradeComplaint, negative: true},
    [GlobalEventName.SEISMIC_PREDICTIONS]: {Factory: SeismicPredictions, negative: true},
    [GlobalEventName.MEDIA_STIR]: {Factory: MediaStir, negative: true},
  },
});

================
File: cards/underworld/Voltagon.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {IPlayer} from '../../IPlayer';
import {Space} from '../../boards/Space';
import {ActiveCorporationCard} from '../corporation/CorporationCard';
import {Resource} from '../../../common/Resource';

export class Voltagon extends ActiveCorporationCard {
  constructor() {
    super({
      name: CardName.VOLTAGON,
      tags: [Tag.SCIENCE, Tag.POWER],
      startingMegaCredits: 38,

      behavior: {
        production: {energy: 1},
      },

      action: {
        or: {
          behaviors: [
            {
              spend: {energy: 8},
              global: {oxygen: 1},
              title: 'Spend 8 energy to increase oxygen 1 step.',
              log: '${player} spent 8 energy to increase oxygen 1 step.',
            },
            {
              spend: {energy: 8},
              global: {venus: 1},
              title: 'Spend 8 energy to increase Venus 1 step.',
              log: '${player} spent 8 energy to increase Venus 1 step.',
            },
          ],
        },
      },

      metadata: {
        cardNumber: 'UC09',
        description: 'You start with 38 M€ and 1 energy production.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(38).production((pb) => pb.energy(1)).br;
          b.effect('After you excavate an underground resource, gain 2 energy.', (eb) => {
            eb.excavate(1).startEffect.energy(2);
          }).br;
          b.action('Spend 8 energy to increase oxygen or Venus 1 step.', (ab) => {
            ab.energy(8).startAction.oxygen(1).or().venus(1);
          });
        }),
      },
    });
  }

  onExcavation(player: IPlayer, _space: Space) {
    player.stock.add(Resource.ENERGY, 2, {log: true});
  }
}

================
File: cards/underworld/VoltaicMetallurgy.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {IActionCard} from '../ICard';
import {SelectAmount} from '../../inputs/SelectAmount';
import {message} from '../../logs/MessageBuilder';
import {Resource} from '../../../common/Resource';

export class VoltaicMetallurgy extends Card implements IProjectCard, IActionCard {
  constructor() {
    super({
      name: CardName.VOLTAIC_METALLURGY,
      type: CardType.ACTIVE,
      cost: 8,
      tags: [Tag.SCIENCE, Tag.POWER],

      requirements: {tag: Tag.SCIENCE, count: 1},

      metadata: {
        cardNumber: 'U76',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend any number of steel to gain the same amount of titanium (max is the number of power tags you have.)', (ab) => {
            ab.text('X').steel(1, {secondaryTag: Tag.POWER}).startAction.text('X').titanium(1);
          });
        }),
        description: 'Requires 1 science tag.',
      },
    });
  }

  public canAct(player: IPlayer) {
    return player.tags.count(Tag.POWER) > 0 && player.stock.steel > 0;
  }

  public action(player: IPlayer) {
    const max = Math.min(player.tags.count(Tag.POWER), player.stock.steel);
    return new SelectAmount(
      message('Select up to ${1} steel to convert to titanium', (b) => b.number(max)),
      'Convert Steel', 1, max, false)
      .andThen((amount) => {
        player.stock.deduct(Resource.STEEL, amount);
        player.stock.add(Resource.TITANIUM, amount);
        player.game.log('${0} converted ${1} units of steel to titanium.', (b) => b.player(player).number(amount));
        return undefined;
      });
  }
}

================
File: cards/underworld/VolunteerMiningInitiative.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {all} from '../Options';

export class VolunteerMiningInitiative extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.VOLUNTEER_MINING_INITIATIVE,
      type: CardType.EVENT,
      cost: 12,
      tags: [Tag.MARS],

      behavior: {
        underworld: {excavate: {count: {cities: {}, all: true, per: 3}}},
      },

      metadata: {
        cardNumber: 'U73',
        renderData: CardRenderer.builder((b) => {
          b.excavate(1).slash().text('3').city({all});
        }),
        description: 'Excavate 1 underground resource for every 3 cities in play.',
      },
    });
  }
}

================
File: cards/underworld/Whales.ts
================
import {CardType} from '../../../common/cards/CardType';
import {IProjectCard} from '../IProjectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {Size} from '../../../common/cards/render/Size';

export class Whales extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.ACTIVE,
      name: CardName.WHALES,
      cost: 10,
      tags: [Tag.ANIMAL],
      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: 1},
      requirements: {oceans: 6},

      metadata: {
        cardNumber: 'U88',
        renderData: CardRenderer.builder((b) => {
          b.effect('Whenever you would gain an ocean when there are already 9 oceans on the board, add an animal to this card',
            (b) => b.oceans(1).text('(9)', Size.SMALL, true).startEffect.resource(CardResource.ANIMAL));
        }),
        description: 'Requires 6 oceans. 1 VP for each animal on this card.',
      },
    });
  }
}

================
File: cards/venusNext/AerialMappers.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {ActionCard} from '../ActionCard';

export class AerialMappers extends ActionCard {
  constructor() {
    super({
      name: CardName.AERIAL_MAPPERS,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 11,
      resourceType: CardResource.FLOATER,
      victoryPoints: 1,

      action: {
        or: {
          autoSelect: true,
          behaviors: [
            {
              spend: {resourcesHere: 1},
              drawCard: 1,
              title: 'Remove 1 floater on this card and draw a card',
            },
            {
              addResourcesToAnyCard: {
                type: CardResource.FLOATER,
                count: 1,
              },
              title: 'Add 1 floater to ANY card',
            },
          ],
        },
      },

      metadata: {
        cardNumber: '213',
        renderData: CardRenderer.builder((b) => {
          b.action('Add floater to ANY card.', (be) => {
            be.empty().startAction.resource(CardResource.FLOATER).asterix();
          }).br;
          b.or(Size.SMALL).br;
          b.action('Spend one floater here to draw 1 card.', (be) => {
            be.resource(CardResource.FLOATER).startAction.cards(1);
          });
        }),
      },
    });
  }
}

================
File: cards/venusNext/AerosportTournament.ts
================
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {Card} from '../Card';
import {all} from '../Options';
import {IProjectCard} from '../IProjectCard';


export class AerosportTournament extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.AEROSPORT_TOURNAMENT,
      type: CardType.EVENT,
      cost: 7,

      requirements: {floaters: 5},
      victoryPoints: 1,

      behavior: {
        stock: {megacredits: {cities: {}}},
      },

      metadata: {
        cardNumber: '214',
        description: 'Requires that you have 5 floaters. Gain 1 M€ per each city tile in play.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(1).slash().city({size: Size.SMALL, all});
        }),
      },
    });
  }
}

================
File: cards/venusNext/AirScrappingExpedition.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {SelectCard} from '../../inputs/SelectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class AirScrappingExpedition extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.AIR_SCRAPPING_EXPEDITION,
      type: CardType.EVENT,
      tags: [Tag.VENUS],
      cost: 13,

      behavior: {
        global: {venus: 1},
      },

      metadata: {
        cardNumber: '215',
        description: 'Raise Venus 1 step. Add 3 floaters to ANY Venus CARD.',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).resource(CardResource.FLOATER, {amount: 3, secondaryTag: Tag.VENUS});
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    let floaterCards = player.getResourceCards(CardResource.FLOATER);
    floaterCards = floaterCards.filter((card) => card.tags.some((cardTag) => cardTag === Tag.VENUS));
    if (floaterCards.length === 0) {
      return undefined;
    }

    if (floaterCards.length === 1) {
      player.addResourceTo(floaterCards[0], {qty: 3, log: true});
      return;
    }

    return new SelectCard('Select card to add 3 floaters', 'Add floaters', floaterCards)
      .andThen(([card]) => {
        player.addResourceTo(card, {qty: 3, log: true});
        return undefined;
      });
  }
}

================
File: cards/venusNext/AirScrappingStandardProject.ts
================
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {StandardProjectCard} from '../StandardProjectCard';
import * as constants from '../../../common/constants';

export class AirScrappingStandardProject extends StandardProjectCard {
  constructor(properties = {
    name: CardName.AIR_SCRAPPING_STANDARD_PROJECT,
    cost: 15,
    tr: {venus: 1},
    metadata: {
      cardNumber: 'SP1',
      renderData: CardRenderer.builder((b) =>
        b.standardProject('Spend 15 M€ to raise Venus 1 step.', (eb) => {
          eb.megacredits(15).startAction.venus(1);
        }),
      ),
    },
  }) {
    super(properties);
  }

  public override canAct(player: IPlayer): boolean {
    if (player.game.getVenusScaleLevel() >= constants.MAX_VENUS_SCALE) {
      this.warnings.add('maxvenus');
    }
    return super.canAct(player);
  }
  protected override discount(player: IPlayer): number {
    let discount = 0;
    if (player.cardIsInEffect(CardName.AIR_SCRAPPING_OPERATIONS)) {
      discount += 3;
    }
    return discount;
  }
  actionEssence(player: IPlayer): void {
    player.game.increaseVenusScaleLevel(player, 1);
  }
}

================
File: cards/venusNext/AirScrappingStandardProjectVariant.ts
================
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Tag} from '../../../common/cards/Tag';
import {AirScrappingStandardProject} from './AirScrappingStandardProject';
import {Size} from '../../../common/cards/render/Size';

export class AirScrappingStandardProjectVariant extends AirScrappingStandardProject {
  constructor() {
    super({
      name: CardName.AIR_SCRAPPING_STANDARD_PROJECT_VARIANT,
      cost: 15,
      tr: {venus: 1},
      metadata: {
        cardNumber: 'SP1a',
        renderData: CardRenderer.builder((b) => {
          b.standardProject('Spend 15M€, less 1M€ per Venus tag you have, to raise Venus 1 step.', (eb) => {
            eb.megacredits(15).text('(').megacredits(-1).slash().tag(Tag.VENUS).text(')').startAction.venus(1);
          });
          b.br.text('(max -5M€)', Size.SMALL);
        }),
      },
    });
  }

  protected override discount(player: IPlayer): number {
    const tagCount = player.tags.count(Tag.VENUS);
    let discount = Math.min(tagCount, 5);
    if (player.cardIsInEffect(CardName.AIR_SCRAPPING_OPERATIONS)) {
      discount += 3;
    }
    return discount + super.discount(player);
  }
}

================
File: cards/venusNext/Aphrodite.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {all} from '../Options';

export class Aphrodite extends CorporationCard {
  constructor() {
    super({
      name: CardName.APHRODITE,
      tags: [Tag.PLANT, Tag.VENUS],
      startingMegaCredits: 47,

      behavior: {
        production: {plants: 1},
      },

      metadata: {
        cardNumber: 'R01',
        description: 'You start with 1 plant production and 47 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br;
          b.production((pb) => pb.plants(1)).nbsp.megacredits(47);
          b.corpBox('effect', (ce) => {
            ce.effect('Whenever Venus is terraformed 1 step, you gain 2 M€.', (eb) => {
              eb.venus(1, {all}).startEffect.megacredits(2);
            });
          });
        }),
      },
    });
  }
}

================
File: cards/venusNext/AtalantaPlanitiaLab.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class AtalantaPlanitiaLab extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.ATALANTA_PLANITIA_LAB,
      type: CardType.AUTOMATED,
      tags: [Tag.VENUS, Tag.SCIENCE],
      cost: 10,

      requirements: {tag: Tag.SCIENCE, count: 3},
      victoryPoints: 2,

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: '216',
        description: 'Requires 3 science tags. Draw 2 cards.',
        renderData: CardRenderer.builder((b) => b.cards(2)),
      },
    });
  }
}

================
File: cards/venusNext/Atmoscoop.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {IGame} from '../../IGame';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import * as constants from '../../../common/constants';
import {PartyHooks} from '../../turmoil/parties/PartyHooks';
import {PartyName} from '../../../common/turmoil/PartyName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {Card} from '../Card';

export class Atmoscoop extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.ATMOSCOOP,
      cost: 22,
      tags: [Tag.JOVIAN, Tag.SPACE],

      requirements: {tag: Tag.SCIENCE, count: 3},
      victoryPoints: 1,

      behavior: {
        addResourcesToAnyCard: {count: 2, type: CardResource.FLOATER},
      },

      metadata: {
        cardNumber: '217',
        description: 'Requires 3 science tags. Either raise the temperature 2 steps, or raise Venus 2 steps. Add 2 floaters to ANY card.',
        renderData: CardRenderer.builder((b) => {
          b.temperature(2).or(Size.SMALL).venus(2).br;
          b.resource(CardResource.FLOATER, 2).asterix();
        }),
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    const remainingTemperatureSteps = (constants.MAX_TEMPERATURE - player.game.getTemperature()) / 2;
    const remainingVenusSteps = (constants.MAX_VENUS_SCALE - player.game.getVenusScaleLevel()) / 2;
    const stepsRaised = Math.min(remainingTemperatureSteps, remainingVenusSteps, 2);

    if (PartyHooks.shouldApplyPolicy(player, PartyName.REDS, 'rp01')) {
      // TODO(kberg): this is not correct, because the titanium can't be used for the reds cost.
      // TODO(kberg): this.cost does not take the card discount into account.
      return player.canAfford({
        cost: this.cost + constants.REDS_RULING_POLICY_COST * stepsRaised,
        titanium: true,
      });
    }

    return true;
  }

  public override bespokePlay(player: IPlayer) {
    const game = player.game;
    if (this.temperatureIsMaxed(game) && this.venusIsMaxed(game)) {
      return undefined;
    }

    const increaseTemp = new SelectOption('Raise temperature 2 steps', 'Raise temperature').andThen(() => {
      game.increaseTemperature(player, 2);
      return undefined;
    });
    const increaseVenus = new SelectOption('Raise Venus 2 steps', 'Raise Venus').andThen(() => {
      game.increaseVenusScaleLevel(player, 2);
      return undefined;
    });
    const increaseTempOrVenus = new OrOptions(increaseTemp, increaseVenus);
    increaseTempOrVenus.title = 'Choose global parameter to raise';

    if (!this.temperatureIsMaxed(game) && this.venusIsMaxed(game)) {
      player.game.increaseTemperature(player, 2);
    } else if (this.temperatureIsMaxed(game) && !this.venusIsMaxed(game)) {
      player.game.increaseVenusScaleLevel(player, 2);
    } else {
      return increaseTempOrVenus;
    }
    return undefined;
  }

  private temperatureIsMaxed(game: IGame) {
    return game.getTemperature() === constants.MAX_TEMPERATURE;
  }

  private venusIsMaxed(game: IGame) {
    return game.getVenusScaleLevel() === constants.MAX_VENUS_SCALE;
  }
}

================
File: cards/venusNext/Celestic.ts
================
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {CardResource} from '../../../common/CardResource';
import {ActiveCorporationCard} from '../corporation/CorporationCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';
import {floaterCards} from './floaterCards';

export class Celestic extends ActiveCorporationCard {
  constructor() {
    super({
      name: CardName.CELESTIC,
      tags: [Tag.VENUS],
      startingMegaCredits: 42,
      resourceType: CardResource.FLOATER,
      initialActionText: 'Draw 2 cards with a floater icon on it',
      victoryPoints: {resourcesHere: {}, per: 3},

      action: {
        addResourcesToAnyCard: {
          type: CardResource.FLOATER,
          count: 1,
          autoSelect: true,
        },
      },

      metadata: {
        cardNumber: 'R05',
        description: 'You start with 42 M€. As your first action, reveal cards from the deck until you have revealed 2 cards with a floater icon on it. Take them into hand and discard the rest.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(42).nbsp.cards(2, {secondaryTag: AltSecondaryTag.FLOATER});
          b.corpBox('action', (ce) => {
            ce.action('Add a floater to ANY card. 1 VP per 3 floaters on this card.', (eb) => {
              eb.empty().startAction.resource(CardResource.FLOATER).asterix();
            });
            ce.vSpace(); // to offset the description to the top a bit so it can be readable
          });
        }),
      },
    });
  }


  public initialAction(player: IPlayer) {
    player.drawCard(2, {
      include: (card) => floaterCards.has(card.name) || card.resourceType === CardResource.FLOATER,
    });
    return undefined;
  }
}

================
File: cards/venusNext/CometForVenus.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {SelectPlayer} from '../../inputs/SelectPlayer';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {all} from '../Options';
import {IProjectCard} from '../IProjectCard';

export class CometForVenus extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.COMET_FOR_VENUS,
      type: CardType.EVENT,
      tags: [Tag.SPACE],
      cost: 11,

      behavior: {
        global: {venus: 1},
      },

      metadata: {
        description: 'Raise Venus 1 step. Remove up to 4M€ from any player WITH A VENUS TAG IN PLAY.',
        cardNumber: '218',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).nbsp.nbsp.minus().megacredits(4, {all, secondaryTag: Tag.VENUS});
        }),
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const venusTagPlayers = player.getOpponents().filter((opponent) => opponent.tags.count(Tag.VENUS, 'raw') > 0);

    if (player.game.isSoloMode()|| venusTagPlayers.length === 0) {
      return undefined;
    }

    if (venusTagPlayers.length > 0) {
      return new OrOptions(
        new SelectPlayer(
          Array.from(venusTagPlayers),
          'Select player to remove up to 4 M€ from',
          'Remove M€')
          .andThen((target) => {
            target.maybeBlockAttack(player, (proceed) => {
              if (proceed) {
                target.stock.deduct(Resource.MEGACREDITS, 4, {log: true, from: player});
              }
              return undefined;
            });
            return undefined;
          }),
        new SelectOption('Do not remove M€'));
    }

    return undefined;
  }
}

================
File: cards/venusNext/CorroderSuits.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class CorroderSuits extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.CORRODER_SUITS,
      type: CardType.AUTOMATED,
      tags: [Tag.VENUS],
      cost: 8,

      behavior: {
        production: {megacredits: 2},
        addResourcesToAnyCard: {count: 1, tag: Tag.VENUS},
      },

      metadata: {
        cardNumber: '219',
        description: 'Increase your M€ production 2 steps. Add 1 resource to ANY Venus CARD.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.megacredits(2);
          }).wild(1, {secondaryTag: Tag.VENUS});
        }),
      },
    });
  }
}

================
File: cards/venusNext/DawnCity.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {SpaceName} from '../../SpaceName';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class DawnCity extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.DAWN_CITY,
      type: CardType.AUTOMATED,
      tags: [Tag.CITY, Tag.SPACE],
      cost: 15,

      requirements: {tag: Tag.SCIENCE, count: 4},
      victoryPoints: 3,
      behavior: {
        production: {energy: -1, titanium: 1},
        city: {space: SpaceName.DAWN_CITY},
      },

      metadata: {
        cardNumber: '220',
        description: 'Requires 4 science tags. Decrease your energy production 1 step. Increase your titanium production 1 step. Place a city tile on the RESERVED AREA.',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(1).br;
            pb.plus().titanium(1);
          }).nbsp.city().asterix();
        }),
      },
    });
  }
}

================
File: cards/venusNext/DeuteriumExport.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {ActionCard} from '../ActionCard';

export class DeuteriumExport extends ActionCard {
  constructor() {
    super({
      name: CardName.DEUTERIUM_EXPORT,
      type: CardType.ACTIVE,
      tags: [Tag.SPACE, Tag.VENUS, Tag.POWER],
      cost: 11,
      resourceType: CardResource.FLOATER,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Remove 1 floater to raise energy production 1 step',
            spend: {resourcesHere: 1},
            production: {energy: 1},
          },
          {
            title: 'Add 1 floater to this card',
            addResources: 1,
          }],
        },
      },

      metadata: {
        cardNumber: '221',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER);
          }).br;
          b.or(Size.SMALL).br;
          b.action('Spend 1 floater here to increase your energy production 1 step.', (be) => {
            be.resource(CardResource.FLOATER).startAction.production((pb) => pb.energy(1));
          });
        }),
      },
    });
  }
}

================
File: cards/venusNext/Dirigibles.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class Dirigibles extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.DIRIGIBLES,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 11,
      resourceType: CardResource.FLOATER,

      action: {
        addResourcesToAnyCard: {count: 1, type: CardResource.FLOATER, mustHaveCard: true},
      },

      metadata: {
        cardNumber: '222',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to ANY card', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER).asterix();
          }).br;
          b.effect('When playing a Venus tag, Floaters here may be used as payment, and are worth 3M€ each.', (eb) => {
            eb.tag(Tag.VENUS).startEffect.resource(CardResource.FLOATER).equals().megacredits(3);
          });
        }),
      },
    });
  }
}

================
File: cards/venusNext/ExtractorBalloons.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {CardName} from '../../../common/cards/CardName';
import {MAX_VENUS_SCALE} from '../../../common/constants';
import {LogHelper} from '../../LogHelper';
import {CardRenderer} from '../render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {Card} from '../Card';

export class ExtractorBalloons extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.EXTRACTOR_BALLOONS,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 21,
      resourceType: CardResource.FLOATER,

      behavior: {
        addResources: 3,
      },

      // action: {
      //   or: {
      //     autoSelect: true,
      //     behaviors: [{
      //       title: 'Remove 2 floaters here to raise Venus 1 step.',
      //       spend: {resourcesHere: 2},
      //       global: {venus: 1},
      //       // Don't offer this if Venus isn't maximized?
      //       // // // LogHelper.logRemoveResource(player, this, 2, 'raise oxygen 1 step');
      //     },
      //     {
      //       title: 'Add 1 floater to this card.',
      //       addResources: 1,
      //     }],
      //   },
      // },

      metadata: {
        cardNumber: '223',
        description: 'Add 3 floaters to this card',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER);
          }).br;
          b.action('Remove 2 floaters here to raise Venus 1 step.', (eb) => {
            eb.or(Size.SMALL).resource(CardResource.FLOATER, 2).startAction.venus(1);
          }).br.resource(CardResource.FLOATER, 3);
        }),
      },
    });
  }

  public canAct(): boolean {
    return true;
  }
  public action(player: IPlayer) {
    const venusMaxed = player.game.getVenusScaleLevel() === MAX_VENUS_SCALE;
    const canAffordReds = player.canAfford({cost: 0, tr: {venus: 1}});
    if (this.resourceCount < 2 || venusMaxed || !canAffordReds) {
      player.addResourceTo(this, {log: true});
      return undefined;
    }
    return new OrOptions(
      new SelectOption('Remove 2 floaters to raise Venus scale 1 step',
        'Remove floaters').andThen(() => {
        player.removeResourceFrom(this, 2);
        const actual = player.game.increaseVenusScaleLevel(player, 1);
        LogHelper.logVenusIncrease(player, actual);
        return undefined;
      }),
      new SelectOption('Add 1 floater to this card', 'Add floater').andThen(() => {
        player.addResourceTo(this, {log: true});
        return undefined;
      }),
    );
  }
}

================
File: cards/venusNext/Extremophiles.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class Extremophiles extends ActionCard {
  constructor() {
    super({
      name: CardName.EXTREMOPHILES,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS, Tag.MICROBE],
      cost: 3,
      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 3},

      action: {
        addResourcesToAnyCard: {type: CardResource.MICROBE, count: 1},
      },

      requirements: {tag: Tag.SCIENCE, count: 2},
      metadata: {
        cardNumber: '224',
        description: 'Requires 2 science tags.',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe to ANY card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE).asterix();
          }).br;
          b.vpText('1 VP for every 3rd Microbe on this card.');
        }),
      },
    });
  }
}

================
File: cards/venusNext/floaterCards.ts
================
import {CardName} from '../../../common/cards/CardName';

export const floaterCards: ReadonlySet<CardName> = new Set([
  // Venus
  CardName.AEROSPORT_TOURNAMENT,
  CardName.AIR_SCRAPPING_EXPEDITION,
  CardName.ATMOSCOOP,
  CardName.HYDROGEN_TO_VENUS,
  CardName.STRATOSPHERIC_BIRDS,

  // Colonies
  CardName.AIRLINERS,
  CardName.AIR_RAID,
  CardName.FLOATER_LEASING,
  CardName.FLOATER_PROTOTYPES,
  CardName.FLOATER_TECHNOLOGY,
  CardName.NITROGEN_FROM_TITAN,

  // Prelude 2
  CardName.GHG_SHIPMENT,

  // Pathfinders
  CardName.CASSINI_STATION,
  CardName.FLOATER_URBANISM,
  CardName.NOBEL_LABS,
  CardName.SECRET_LABS,
  CardName.VENERA_BASE,

  // Star Wars
  CardName.CLOUD_CITY,
]);

================
File: cards/venusNext/FloatingHabs.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class FloatingHabs extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.FLOATING_HABS,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 5,

      resourceType: CardResource.FLOATER,
      victoryPoints: {resourcesHere: {}, per: 2},

      action: {
        spend: {megacredits: 2},
        addResourcesToAnyCard: {type: CardResource.FLOATER, count: 1, autoSelect: true},
      },

      requirements: {tag: Tag.SCIENCE, count: 2},
      metadata: {
        cardNumber: '225',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 M€ to add 1 floater to ANY card', (eb) => {
            eb.megacredits(2).startAction.resource(CardResource.FLOATER).asterix();
          }).br;
          b.vpText('1 VP for every 2nd Floater on this card.');
        }),
        description: 'Requires 2 science tags.',
      },
    });
  }
}

================
File: cards/venusNext/ForcedPrecipitation.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {MAX_VENUS_SCALE} from '../../../common/constants';
import {CardName} from '../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {LogHelper} from '../../LogHelper';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {TITLES} from '../../inputs/titles';

export class ForcedPrecipitation extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.FORCED_PRECIPITATION,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 8,
      resourceType: CardResource.FLOATER,

      metadata: {
        cardNumber: '226',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 2 M€ to add 1 floater to THIS card.', (eb) => {
            eb.megacredits(2).startAction.resource(CardResource.FLOATER);
          }).br;
          b.or().br;
          b.action('Spend 2 floaters here to increase Venus 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.venus(1);
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    if (player.canAfford(2)) {
      return true;
    }
    if (this.resourceCount > 1 && player.canAfford({cost: 0, tr: {venus: 1}})) {
      if (player.game.getVenusScaleLevel() === MAX_VENUS_SCALE) {
        this.warnings.add('maxvenus');
      }
      return true;
    }
    return false;
  }

  public action(player: IPlayer) {
    const opts = [];

    const addResource = new SelectOption('Pay 2 M€ to add 1 floater to this card', 'Pay').andThen(() => this.addResource(player));
    const spendResource = new SelectOption('Remove 2 floaters to raise Venus 1 step', 'Remove floaters').andThen(() => this.spendResource(player));
    if (player.game.getVenusScaleLevel() === MAX_VENUS_SCALE) {
      spendResource.warnings = ['maxvenus'];
    }
    if (this.resourceCount > 1 && player.canAfford({cost: 0, tr: {venus: 1}})) {
      opts.push(spendResource);
    } else {
      return this.addResource(player);
    }

    if (player.canAfford(2)) {
      opts.push(addResource);
    } else {
      return this.spendResource(player);
    }

    return new OrOptions(...opts);
  }

  private addResource(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 2, {title: TITLES.payForCardAction(this.name)}))
      .andThen(() => player.addResourceTo(this, {log: true}));
    return undefined;
  }

  private spendResource(player: IPlayer) {
    player.removeResourceFrom(this, 2);
    const actual = player.game.increaseVenusScaleLevel(player, 1);
    LogHelper.logVenusIncrease(player, actual);
    return undefined;
  }
}

================
File: cards/venusNext/FreyjaBiodomes.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {SelectCard} from '../../inputs/SelectCard';
import {ICard} from '../ICard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class FreyjaBiodomes extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.FREYJA_BIODOMES,
      type: CardType.AUTOMATED,
      tags: [Tag.PLANT, Tag.VENUS],
      cost: 14,

      requirements: {venus: 10},
      victoryPoints: 2,

      behavior: {
        production: {energy: -1, megacredits: 2},
      },

      metadata: {
        cardNumber: '227',
        renderData: CardRenderer.builder((b) => {
          b.resource(CardResource.MICROBE, {amount: 2, secondaryTag: Tag.VENUS}).or().resource(CardResource.ANIMAL, {amount: 2, secondaryTag: Tag.VENUS}).br;
          b.production((pb) => pb.minus().energy(1).nbsp.plus().megacredits(2));
        }),
        description: {
          text: 'Requires 10% on the Venus track. Add 2 microbes or 2 animals to another Venus card. Production: energy -1, M€ +2.',
          align: 'left',
        },
      },
    });
  }
  public getResCards(player: IPlayer): ICard[] {
    let resourceCards = player.getResourceCards(CardResource.ANIMAL);
    resourceCards = resourceCards.concat(player.getResourceCards(CardResource.MICROBE));
    return resourceCards.filter((card) => card.tags.includes(Tag.VENUS));
  }

  public override bespokePlay(player: IPlayer) {
    const cards = this.getResCards(player);

    if (cards.length > 1) {
      return new SelectCard(
        'Select card to add 2 resources',
        'Add resources',
        cards)
        .andThen(([card]) => {
          player.addResourceTo(card, {qty: 2, log: true});
          return undefined;
        });
    }

    if (cards.length === 1) {
      player.addResourceTo(cards[0], {qty: 2, log: true});
    }
    return undefined;
  }
}

================
File: cards/venusNext/GHGImportFromVenus.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class GHGImportFromVenus extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.GHG_IMPORT_FROM_VENUS,
      type: CardType.EVENT,
      tags: [Tag.SPACE, Tag.VENUS],
      cost: 23,

      behavior: {
        production: {heat: 3},
        global: {venus: 1},
      },

      metadata: {
        description: 'Raise Venus 1 step. Increase your heat production 3 steps.',
        cardNumber: '228',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).production((pb) => {
            pb.heat(3);
          });
        }),
      },
    });
  }
}

================
File: cards/venusNext/GiantSolarShade.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class GiantSolarShade extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.GIANT_SOLAR_SHADE,
      type: CardType.AUTOMATED,
      tags: [Tag.SPACE, Tag.VENUS],
      cost: 27,

      behavior: {
        global: {venus: 3},
      },

      metadata: {
        cardNumber: '229',
        renderData: CardRenderer.builder((b) => b.venus(3)),
        description: 'Raise Venus 3 steps.',
      },
    });
  }
}

================
File: cards/venusNext/Gyropolis.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class Gyropolis extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.GYROPOLIS,
      type: CardType.AUTOMATED,
      tags: [Tag.CITY, Tag.BUILDING],
      cost: 20,

      behavior: {
        city: {},
        production: {energy: -2, megacredits: {tag: [Tag.VENUS, Tag.EARTH]}},
      },

      metadata: {
        cardNumber: '230',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => {
            pb.minus().energy(2).br;
            pb.plus().megacredits(1).slash().tag(Tag.VENUS).br;
            pb.plus().megacredits(1).slash().tag(Tag.EARTH).br;
          }).nbsp.city();
        }),
        description: 'Decrease your energy production 2 steps. Increase your M€ production 1 step for each Venus and Earth tag you have. Place a city tile.',
      },
    });
  }
}

================
File: cards/venusNext/HydrogenToVenus.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class HydrogenToVenus extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.HYDROGEN_TO_VENUS,
      type: CardType.EVENT,
      tags: [Tag.SPACE],
      cost: 11,

      behavior: {
        global: {venus: 1},
        addResourcesToAnyCard: {count: {tag: Tag.JOVIAN}, type: CardResource.FLOATER, tag: Tag.VENUS},
      },

      metadata: {
        cardNumber: '231',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).br.br; // double br is intentional for visual appeal
          b.resource(CardResource.FLOATER, {secondaryTag: Tag.VENUS}).slash().tag(Tag.JOVIAN);
        }),
        description: 'Raise Venus 1 step. Add 1 floater to A VENUS CARD for each Jovian tag you have.',
      },
    });
  }
}

================
File: cards/venusNext/IoSulphurResearch.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {digit} from '../Options';
import {IProjectCard} from '../IProjectCard';

export class IoSulphurResearch extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.IO_SULPHUR_RESEARCH,
      type: CardType.AUTOMATED,
      tags: [Tag.SCIENCE, Tag.JOVIAN],
      cost: 17,

      victoryPoints: 2,

      metadata: {
        cardNumber: '232',
        renderData: CardRenderer.builder((b) => {
          b.cards(1).br;
          b.or().br;
          b.tag(Tag.VENUS, {amount: 3, digit}).colon().cards(3);
        }),
        description: 'Draw 1 card, or draw 3 if you have at least 3 Venus tags.',
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    player.drawCard(player.tags.count(Tag.VENUS) >= 3 ? 3 : 1);
    return undefined;
  }
}

================
File: cards/venusNext/IshtarMining.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class IshtarMining extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.ISHTAR_MINING,
      type: CardType.AUTOMATED,
      tags: [Tag.VENUS],
      cost: 5,

      behavior: {
        production: {titanium: 1},
      },

      requirements: {venus: 8},
      metadata: {
        cardNumber: '233',
        renderData: CardRenderer.builder((b) => b.production((pb) => pb.titanium(1))),
        description: 'Requires Venus 8%. Increase your titanium production 1 step.',
      },
    });
  }
}

================
File: cards/venusNext/JetStreamMicroscrappers.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {MAX_VENUS_SCALE} from '../../../common/constants';
import {CardName} from '../../../common/cards/CardName';
import {LogHelper} from '../../LogHelper';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {Payment} from '../../../common/inputs/Payment';

export class JetStreamMicroscrappers extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.JET_STREAM_MICROSCRAPPERS,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 12,
      resourceType: CardResource.FLOATER,

      metadata: {
        cardNumber: '234',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 1 titanium to add 2 floaters here', (eb) => {
            eb.titanium(1).startAction.resource(CardResource.FLOATER, 2);
          }).br;
          b.or().br;
          b.action('Spend 2 floaters here to raise Venus 1 step', (eb) => {
            eb.resource(CardResource.FLOATER, 2).startAction.venus(1);
          });
        }),
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    const venusMaxed = player.game.getVenusScaleLevel() === MAX_VENUS_SCALE;
    const canSpendResource = this.resourceCount > 1 && !venusMaxed;

    return player.titanium > 0 || (canSpendResource && player.canAfford({cost: 0, tr: {venus: 1}}));
  }

  public action(player: IPlayer) {
    const opts = [];

    const addResource = new SelectOption('Spend one titanium to add 2 floaters to this card', 'Spend titanium').andThen(() => this.addResource(player));
    const spendResource = new SelectOption('Remove 2 floaters to raise Venus 1 step', 'Remove floaters').andThen(() => this.spendResource(player));

    if (this.resourceCount > 1 && player.game.getVenusScaleLevel() < MAX_VENUS_SCALE) {
      opts.push(spendResource);
    } else {
      return this.addResource(player);
    }

    if (player.titanium > 0) {
      opts.push(addResource);
    } else {
      return this.spendResource(player);
    }

    return new OrOptions(...opts);
  }

  private addResource(player: IPlayer) {
    player.addResourceTo(this, {qty: 2, log: true});
    player.pay(Payment.of({titanium: 1}));
    return undefined;
  }

  private spendResource(player: IPlayer) {
    player.removeResourceFrom(this, 2);
    const actual = player.game.increaseVenusScaleLevel(player, 1);
    LogHelper.logVenusIncrease(player, actual);
    return undefined;
  }
}

================
File: cards/venusNext/LocalShading.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class LocalShading extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.LOCAL_SHADING,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 4,
      resourceType: CardResource.FLOATER,

      action: {
        or: {
          behaviors: [
            {
              spend: {resourcesHere: 1},
              production: {megacredits: 1},
              title: 'Remove 1 floater to increase M€ production 1 step',
            },
            {
              addResources: 1,
              title: 'Add 1 floater to this card',
            },
          ],
          autoSelect: true,
        },
      },

      metadata: {
        cardNumber: '235',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 floater to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER);
          }).br;
          b.or().br;
          b.action('Spend 1 floater here to raise your M€ production 1 step.', (eb) => {
            eb.resource(CardResource.FLOATER).startAction.production((pb) => pb.megacredits(1));
          });
        }),
      },
    });
  }
}

================
File: cards/venusNext/LunaMetropolis.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {SpaceName} from '../../SpaceName';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class LunaMetropolis extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUNA_METROPOLIS,
      type: CardType.AUTOMATED,
      tags: [Tag.CITY, Tag.SPACE, Tag.EARTH],
      cost: 21,

      victoryPoints: 2,
      behavior: {
        production: {megacredits: {tag: Tag.EARTH}},
        city: {space: SpaceName.LUNA_METROPOLIS},
      },

      metadata: {
        cardNumber: '236',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(1).slash().tag(Tag.EARTH)).br;
          b.city().asterix();
        }),
        description: 'Increase your M€ production 1 step for each Earth tag you have, including this. Place a city tile on the RESERVED AREA.',
      },
    });
  }
}

================
File: cards/venusNext/LuxuryFoods.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class LuxuryFoods extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.LUXURY_FOODS,
      type: CardType.AUTOMATED,
      cost: 8,

      victoryPoints: 2,

      requirements: [{tag: Tag.VENUS}, {tag: Tag.EARTH}, {tag: Tag.JOVIAN}],
      metadata: {
        description: 'Requires that you have a Venus tag, an Earth tag and a Jovian tag.',
        cardNumber: 'T10',
      },
    });
  }

  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.tags.playerHas([Tag.VENUS, Tag.EARTH, Tag.JOVIAN]);
  }
}

================
File: cards/venusNext/Manutech.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Manutech extends CorporationCard {
  constructor() {
    super({
      name: CardName.MANUTECH,
      tags: [Tag.BUILDING],
      startingMegaCredits: 35,

      behavior: {
        production: {steel: 1},
      },

      metadata: {
        cardNumber: 'R23',
        description: 'You start with 1 steel production, and 35 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br;
          b.production((pb) => pb.steel(1)).nbsp.megacredits(35);
          b.corpBox('effect', (ce) => {
            ce.effect('For each step you increase the production of a resource, including this, you also gain that resource.', (eb) => {
              eb.production((pb) => pb.wild(1)).startEffect.wild(1);
            });
          });
        }),
      },
    });
  }

  public onProductionGain(player: IPlayer, resource: Resource, amount: number) {
    if (amount > 0) {
      player.stock.add(resource, amount);
    }
  }
}

================
File: cards/venusNext/MaxwellBase.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {SpaceName} from '../../SpaceName';
import {IActionCard} from '../ICard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class MaxwellBase extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.MAXWELL_BASE,
      type: CardType.ACTIVE,
      tags: [Tag.CITY, Tag.VENUS],
      cost: 18,

      action: {
        addResourcesToAnyCard: {
          tag: Tag.VENUS,
          count: 1,
          autoSelect: true,
          mustHaveCard: true,
        },
      },

      requirements: {venus: 12},
      victoryPoints: 3,
      behavior: {
        production: {energy: -1},
        city: {space: SpaceName.MAXWELL_BASE},
      },

      metadata: {
        cardNumber: '238',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 resource to ANOTHER VENUS CARD.', (eb) => {
            eb.empty().startAction.wild(1, {secondaryTag: Tag.VENUS});
          }).br;
          b.production((pb) => pb.minus().energy(1)).nbsp.city().asterix();
        }),
        description: {
          text: 'Requires Venus 12%. Decrease your energy production 1 step. Place a city tile ON THE RESERVED AREA.',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/venusNext/MiningQuota.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class MiningQuota extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.MINING_QUOTA,
      type: CardType.AUTOMATED,
      tags: [Tag.BUILDING],
      cost: 5,

      behavior: {
        production: {steel: 2},
      },

      requirements: [{tag: Tag.VENUS}, {tag: Tag.EARTH}, {tag: Tag.JOVIAN}],
      metadata: {
        cardNumber: '239',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.steel(2));
        }),
        description: 'Requires Venus, Earth and Jovian tags. Increase your steel production 2 steps.',
      },
    });
  }
}

================
File: cards/venusNext/MorningStarInc.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {Tag} from '../../../common/cards/Tag';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {GlobalParameter} from '../../../common/GlobalParameter';

export class MorningStarInc extends CorporationCard {
  constructor() {
    super({
      name: CardName.MORNING_STAR_INC,
      tags: [Tag.VENUS],
      startingMegaCredits: 50,
      globalParameterRequirementBonus: {steps: 2, parameter: GlobalParameter.VENUS},

      firstAction: {
        text: 'Draw 3 cards with a Venus tag',
        drawCard: {count: 3, tag: Tag.VENUS},
      },

      metadata: {
        cardNumber: 'R06',
        description: 'You start with 50 M€. As your first action, reveal cards from the deck until you have revealed 3 Venus-tag cards. Take those into hand and discard the rest.',
        renderData: CardRenderer.builder((b) => {
          b.megacredits(50).nbsp.cards(3, {secondaryTag: Tag.VENUS});
          b.corpBox('effect', (ce) => {
            ce.effect('Your Venus requirements are +/- 2 steps, your choice in each case.', (eb) => {
              eb.plate('Venus requirements').startEffect.text('+/- 2');
            });
          });
        }),
      },
    });
  }
}

================
File: cards/venusNext/NeutralizerFactory.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class NeutralizerFactory extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.NEUTRALIZER_FACTORY,
      type: CardType.AUTOMATED,
      tags: [Tag.VENUS],
      cost: 7,

      behavior: {
        global: {venus: 1},
      },

      requirements: {venus: 10},
      metadata: {
        cardNumber: '240',
        renderData: CardRenderer.builder((b) => {
          b.venus(1);
        }),
        description: 'Requires Venus 10%. Increase the Venus track 1 step.',
      },
    });
  }
}

================
File: cards/venusNext/Omnicourt.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class Omnicourt extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.OMNICOURT,
      type: CardType.AUTOMATED,
      tags: [Tag.BUILDING],
      cost: 11,

      behavior: {
        tr: 2,
      },

      requirements: [{tag: Tag.VENUS}, {tag: Tag.EARTH}, {tag: Tag.JOVIAN}],
      metadata: {
        cardNumber: '241',
        renderData: CardRenderer.builder((b) => {
          b.tr(2);
        }),
        description: 'Requires Venus, Earth and Jovian tags. Increase your TR 2 steps.',
      },
    });
  }
}

================
File: cards/venusNext/OrbitalReflectors.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class OrbitalReflectors extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.ORBITAL_REFLECTORS,
      type: CardType.AUTOMATED,
      tags: [Tag.VENUS, Tag.SPACE],
      cost: 26,

      behavior: {
        production: {heat: 2},
        global: {venus: 2},
      },

      metadata: {
        cardNumber: '242',
        renderData: CardRenderer.builder((b) => {
          b.venus(2).br;
          b.production((pb) => {
            pb.heat(2);
          });
        }),
        description: 'Raise Venus 2 steps. Increase your heat production 2 steps.',
      },
    });
  }
}

================
File: cards/venusNext/RotatorImpacts.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {MAX_VENUS_SCALE} from '../../../common/constants';
import {CardName} from '../../../common/cards/CardName';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {max} from '../Options';
import {TITLES} from '../../inputs/titles';

export class RotatorImpacts extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.ROTATOR_IMPACTS,
      type: CardType.ACTIVE,
      tags: [Tag.SPACE],
      cost: 6,
      resourceType: CardResource.ASTEROID,

      requirements: {venus: 14, max},
      metadata: {
        cardNumber: '243',
        renderData: CardRenderer.builder((b) => {
          b.action('Spend 6 M€ to add an asteroid resource to this card [TITANIUM MAY BE USED].', (eb) => {
            eb.megacredits(6).super((b) => b.titanium(1)).startAction.resource(CardResource.ASTEROID);
          }).br;
          b.action('Spend 1 resource from this card to increase Venus 1 step.', (eb) => {
            eb.or().resource(CardResource.ASTEROID).startAction.venus(1);
          });
        }),
        description: 'Venus must be 14% or lower',
      },
    });
  }

  public canAct(player: IPlayer): boolean {
    const venusMaxed = player.game.getVenusScaleLevel() === MAX_VENUS_SCALE;
    const canSpendResource = this.resourceCount > 0 && !venusMaxed;

    return player.canAfford({cost: 6, titanium: true}) || (canSpendResource && player.canAfford({cost: 0, tr: {venus: 1}}));
  }

  public action(player: IPlayer) {
    const opts = [];

    const addResource = new SelectOption('Pay 6 M€ to add 1 asteroid to this card', 'Pay').andThen(() => this.addResource(player));
    const spendResource = new SelectOption('Remove 1 asteroid to raise Venus 1 step', 'Remove asteroid').andThen(() => this.spendResource(player));

    if (this.resourceCount > 0 && player.game.getVenusScaleLevel() < MAX_VENUS_SCALE) {
      opts.push(spendResource);
    } else {
      return this.addResource(player);
    }

    if (player.canAfford({cost: 6, titanium: true})) {
      opts.push(addResource);
    } else {
      return this.spendResource(player);
    }

    return new OrOptions(...opts);
  }

  private addResource(player: IPlayer) {
    player.game.defer(new SelectPaymentDeferred(player, 6, {canUseTitanium: true, title: TITLES.payForCardAction(this.name)}));
    player.addResourceTo(this, {log: true});
    return undefined;
  }

  private spendResource(player: IPlayer) {
    player.removeResourceFrom(this);
    player.game.increaseVenusScaleLevel(player, 1);
    player.game.log('${0} removed an asteroid resource to increase Venus scale 1 step', (b) => b.player(player));
    return undefined;
  }
}

================
File: cards/venusNext/SisterPlanetSupport.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class SisterPlanetSupport extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.SISTER_PLANET_SUPPORT,
      type: CardType.AUTOMATED,
      tags: [Tag.VENUS, Tag.EARTH],
      cost: 7,

      behavior: {
        production: {megacredits: 3},
      },

      requirements: [{tag: Tag.VENUS}, {tag: Tag.EARTH}],
      metadata: {
        cardNumber: '244',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(3));
        }),
        description: 'Requires Venus and Earth tags. Increase your M€ production 3 steps.',
      },
    });
  }
}

================
File: cards/venusNext/Solarnet.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class Solarnet extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.SOLARNET,
      type: CardType.AUTOMATED,
      cost: 7,

      requirements: [{tag: Tag.VENUS}, {tag: Tag.EARTH}, {tag: Tag.JOVIAN}],
      victoryPoints: 1,

      behavior: {
        drawCard: 2,
      },

      metadata: {
        cardNumber: '245',
        renderData: CardRenderer.builder((b) => {
          b.cards(2);
        }),
        description: 'Requires Venus, Earth and Jovian tags. Draw 2 cards.',
      },
    });
  }
}

================
File: cards/venusNext/SpinInducingAsteroid.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {max} from '../Options';

export class SpinInducingAsteroid extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.EVENT,
      name: CardName.SPIN_INDUCING_ASTEROID,
      cost: 16,
      tags: [Tag.SPACE],

      behavior: {
        global: {venus: 2},
      },

      requirements: {venus: 10, max},
      metadata: {
        cardNumber: '246',
        renderData: CardRenderer.builder((b) => {
          b.venus(2);
        }),
        description: 'Venus must be 10% or lower. Raise Venus 2 steps.',
      },
    });
  }
}

================
File: cards/venusNext/SponsoredAcademies.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {Priority} from '../../deferredActions/Priority';
import {DiscardCards} from '../../deferredActions/DiscardCards';
import {CardRenderer} from '../render/CardRenderer';
import {DrawCards} from '../../deferredActions/DrawCards';
import {Card} from '../Card';
import {all, digit} from '../Options';
import {IProjectCard} from '../IProjectCard';

export class SponsoredAcademies extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.SPONSORED_ACADEMIES,
      type: CardType.AUTOMATED,
      tags: [Tag.EARTH, Tag.SCIENCE],
      cost: 9,

      victoryPoints: 1,

      metadata: {
        cardNumber: '247',
        renderData: CardRenderer.builder((b) => {
          b.minus().cards(1).br;
          b.plus().cards(3, {digit}).asterix().nbsp.plus().cards(1, {all}).asterix();
        }),
        description: 'Discard 1 card from your hand and THEN draw 3 cards. All OPPONENTS draw 1 card.',
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer): boolean {
    return player.cardsInHand.length > 1; // this card and at least another
  }

  public override bespokePlay(player: IPlayer) {
    // TODO(kberg): Use DiscardCards.andThen().
    player.game.defer(new DiscardCards(player), Priority.SPONSORED_ACADEMIES);
    player.game.defer(DrawCards.keepAll(player, 3), Priority.SPONSORED_ACADEMIES);
    for (const p of player.getOpponents()) {
      player.game.defer(DrawCards.keepAll(p));
    }
    return undefined;
  }
}

================
File: cards/venusNext/Stratopolis.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {SpaceName} from '../../SpaceName';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class Stratopolis extends ActionCard {
  constructor() {
    super({
      name: CardName.STRATOPOLIS,
      type: CardType.ACTIVE,
      tags: [Tag.CITY, Tag.VENUS],
      cost: 22,

      resourceType: CardResource.FLOATER,
      victoryPoints: {resourcesHere: {}, per: 3},
      requirements: {tag: Tag.SCIENCE, count: 2},

      behavior: {
        production: {megacredits: 2},
        city: {space: SpaceName.STRATOPOLIS},
      },

      action: {
        addResourcesToAnyCard: {
          count: 2,
          tag: Tag.VENUS,
          type: CardResource.FLOATER,
          autoSelect: true,
        },
      },

      metadata: {
        cardNumber: '248',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 2 floaters to ANY VENUS CARD.', (eb) => {
            eb.empty().startAction.resource(CardResource.FLOATER, {amount: 2, secondaryTag: Tag.VENUS});
          }).br;
          b.production((pb) => pb.megacredits(2)).city().asterix();
          b.vpText('1 VP for every 3rd Floater on this card.');
        }),
        description: {
          text: 'Requires 2 science tags. Increase your M€ production 2 steps. Place a city tile ON THE RESERVED AREA',
          align: 'left',
        },
      },
    });
  }
}

================
File: cards/venusNext/StratosphericBirds.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {RemoveResourcesFromCard} from '../../deferredActions/RemoveResourcesFromCard';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class StratosphericBirds extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.STRATOSPHERIC_BIRDS,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS, Tag.ANIMAL],
      cost: 12,
      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}},
      requirements: {venus: 12},

      action: {
        addResources: 1,
      },

      metadata: {
        cardNumber: '249',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 animal to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.ANIMAL);
          }).br;
          b.minus().resource(CardResource.FLOATER).br;
          b.vpText('1 VP for each animal on this card.');
        }),
        description: {
          text: 'Requires Venus 12% and that you spend 1 floater from any card.',
          align: 'left',
        },
      },
    });
  }
  public override bespokeCanPlay(player: IPlayer): boolean {
    const cardsWithFloater = player.getCardsWithResources(CardResource.FLOATER);
    if (cardsWithFloater.length === 0) return false;

    if (cardsWithFloater.length > 1) {
      return true;
    } else {
      const floaterCard = cardsWithFloater[0];
      if (floaterCard.name !== CardName.DIRIGIBLES) return true;

      const canPayForFloater = ((floaterCard.resourceCount - 1) * 3 + player.megaCredits) >= player.getCardCost(this);
      return canPayForFloater;
    }
  }
  public override bespokePlay(player: IPlayer) {
    player.game.defer(new RemoveResourcesFromCard(player, CardResource.FLOATER, 1, {source: 'self', blockable: false}));
    return undefined;
  }
}

================
File: cards/venusNext/SulphurEatingBacteria.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {SelectAmount} from '../../inputs/SelectAmount';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class SulphurEatingBacteria extends Card implements IActionCard {
  constructor() {
    super({
      name: CardName.SULPHUR_EATING_BACTERIA,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS, Tag.MICROBE],
      cost: 6,
      resourceType: CardResource.MICROBE,

      requirements: {venus: 6},
      metadata: {
        cardNumber: '251',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe to this card.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.or().br;
          b.action('Spend any number of microbes here to gain triple amount of M€.', (eb) => {
            eb.text('x').resource(CardResource.MICROBE).startAction.megacredits(1, {text: '3x'});
          });
        }),
        description: 'Requires Venus 6%',
      },
    });
  }
  public canAct(): boolean {
    return true;
  }
  public action(player: IPlayer) {
    const opts = [];

    const addResource = new SelectOption('Add 1 microbe to this card', 'Add microbe').andThen(() => {
      player.addResourceTo(this, {log: true});
      return undefined;
    });
    const spendResource = new SelectAmount('Remove any number of microbes to gain 3 M€ per microbe removed', 'Remove microbes', 1, this.resourceCount, true)
      .andThen((amount) => this.spendResource(player, amount));

    opts.push(addResource);

    if (this.resourceCount > 0) {
      opts.push(spendResource);
    } else {
      player.addResourceTo(this, {log: true});
      return undefined;
    }

    return new OrOptions(...opts);
  }

  private spendResource(player: IPlayer, amount: number) {
    player.removeResourceFrom(this, amount, {log: false});

    const megaCreditsGained = 3 * amount;
    player.megaCredits += megaCreditsGained;

    player.game.log('${0} removed ${1} microbes from ${2} to gain ${3} M€', (b) =>
      b.player(player).number(amount).card(this).number(megaCreditsGained));

    return undefined;
  }
}

================
File: cards/venusNext/SulphurExports.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class SulphurExports extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.SULPHUR_EXPORTS,
      type: CardType.AUTOMATED,
      tags: [Tag.VENUS, Tag.SPACE],
      cost: 21,

      behavior: {
        global: {venus: 1},
        production: {megacredits: {tag: Tag.VENUS}},
      },

      metadata: {
        cardNumber: '250',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).br;
          b.production((pb) => pb.megacredits(1).slash().tag(Tag.VENUS));
        }),
        description: 'Increase Venus 1 step. Increase your M€ production 1 step for each Venus tag you have, including this.',
      },
    });
  }
}

================
File: cards/venusNext/TerraformingContract.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class TerraformingContract extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.TERRAFORMING_CONTRACT,
      cost: 8,
      tags: [Tag.EARTH],

      behavior: {
        production: {megacredits: 4},
      },

      requirements: {tr: 25},
      metadata: {
        cardNumber: '252',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(4));
        }),
        description: 'Requires that you have at least 25 TR. Increase your M€ production 4 steps.',
      },
    });
  }
}

================
File: cards/venusNext/Thermophiles.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class Thermophiles extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.THERMOPHILES,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS, Tag.MICROBE],
      cost: 9,
      resourceType: CardResource.MICROBE,

      action: {
        or: {
          autoSelect: true,
          behaviors: [{
            title: 'Spend 2 microbes here to raise Venus 1 step.',
            spend: {resourcesHere: 2},
            global: {venus: 1},
            // LogHelper.logRemoveResource(player, this, 2, 'raise oxygen 1 step');
          },
          {
            // Remove "Add a microbe to this card"
            title: 'Select a Venus card to add 1 microbe',
            addResourcesToAnyCard: {
              count: 1,
              tag: Tag.VENUS,
              type: CardResource.MICROBE,
              autoSelect: true,
            },
          }],
        },
      },

      requirements: {venus: 6},
      metadata: {
        cardNumber: '253',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe to ANY Venus CARD.', (eb) => {
            eb.empty().startAction.resource(CardResource.MICROBE, {secondaryTag: Tag.VENUS});
          }).br;
          b.or().br;
          b.action('Remove 2 microbes to raise Venus 1 step', (eb) => {
            eb.resource(CardResource.MICROBE, 2).startAction.venus(1);
          });
        }),
        description: 'Requires Venus 6%',
      },
    });
  }
}

================
File: cards/venusNext/VenusCardManifest.ts
================
import {CardName} from '../../../common/cards/CardName';
import {ModuleManifest} from '../ModuleManifest';
import {AerialMappers} from './AerialMappers';
import {AerosportTournament} from './AerosportTournament';
import {AirScrappingStandardProject} from './AirScrappingStandardProject';
import {AirScrappingExpedition} from './AirScrappingExpedition';
import {Aphrodite} from './Aphrodite';
import {AtalantaPlanitiaLab} from './AtalantaPlanitiaLab';
import {Atmoscoop} from './Atmoscoop';
import {Celestic} from './Celestic';
import {CometForVenus} from './CometForVenus';
import {CorroderSuits} from './CorroderSuits';
import {DawnCity} from './DawnCity';
import {DeuteriumExport} from './DeuteriumExport';
import {Dirigibles} from './Dirigibles';
import {ExtractorBalloons} from './ExtractorBalloons';
import {Extremophiles} from './Extremophiles';
import {FloatingHabs} from './FloatingHabs';
import {ForcedPrecipitation} from './ForcedPrecipitation';
import {FreyjaBiodomes} from './FreyjaBiodomes';
import {GHGImportFromVenus} from './GHGImportFromVenus';
import {GiantSolarShade} from './GiantSolarShade';
import {Gyropolis} from './Gyropolis';
import {HydrogenToVenus} from './HydrogenToVenus';
import {IoSulphurResearch} from './IoSulphurResearch';
import {IshtarMining} from './IshtarMining';
import {JetStreamMicroscrappers} from './JetStreamMicroscrappers';
import {LocalShading} from './LocalShading';
import {LunaMetropolis} from './LunaMetropolis';
import {LuxuryFoods} from './LuxuryFoods';
import {Manutech} from './Manutech';
import {MaxwellBase} from './MaxwellBase';
import {MiningQuota} from './MiningQuota';
import {MorningStarInc} from './MorningStarInc';
import {NeutralizerFactory} from './NeutralizerFactory';
import {Omnicourt} from './Omnicourt';
import {OrbitalReflectors} from './OrbitalReflectors';
import {RotatorImpacts} from './RotatorImpacts';
import {SisterPlanetSupport} from './SisterPlanetSupport';
import {Solarnet} from './Solarnet';
import {SpinInducingAsteroid} from './SpinInducingAsteroid';
import {SponsoredAcademies} from './SponsoredAcademies';
import {Stratopolis} from './Stratopolis';
import {StratosphericBirds} from './StratosphericBirds';
import {SulphurEatingBacteria} from './SulphurEatingBacteria';
import {SulphurExports} from './SulphurExports';
import {TerraformingContract} from './TerraformingContract';
import {Thermophiles} from './Thermophiles';
import {VenusGovernor} from './VenusGovernor';
import {VenusianAnimals} from './VenusianAnimals';
import {VenusianInsects} from './VenusianInsects';
import {VenusianPlants} from './VenusianPlants';
import {VenusMagnetizer} from './VenusMagnetizer';
import {VenusSoils} from './VenusSoils';
import {VenusWaystation} from './VenusWaystation';
import {Viron} from './Viron';
import {WaterToVenus} from './WaterToVenus';
import {AirScrappingStandardProjectVariant} from './AirScrappingStandardProjectVariant';

export const VENUS_CARD_MANIFEST = new ModuleManifest({
  module: 'venus',
  projectCards: {
    [CardName.AERIAL_MAPPERS]: {Factory: AerialMappers},
    [CardName.AEROSPORT_TOURNAMENT]: {Factory: AerosportTournament},
    [CardName.AIR_SCRAPPING_EXPEDITION]: {Factory: AirScrappingExpedition},
    [CardName.ATALANTA_PLANITIA_LAB]: {Factory: AtalantaPlanitiaLab},
    [CardName.ATMOSCOOP]: {Factory: Atmoscoop},
    [CardName.COMET_FOR_VENUS]: {Factory: CometForVenus},
    [CardName.CORRODER_SUITS]: {Factory: CorroderSuits},
    [CardName.DAWN_CITY]: {Factory: DawnCity},
    [CardName.DEUTERIUM_EXPORT]: {Factory: DeuteriumExport},
    [CardName.DIRIGIBLES]: {Factory: Dirigibles},
    [CardName.EXTRACTOR_BALLOONS]: {Factory: ExtractorBalloons},
    [CardName.EXTREMOPHILES]: {Factory: Extremophiles},
    [CardName.FLOATING_HABS]: {Factory: FloatingHabs},
    [CardName.FORCED_PRECIPITATION]: {Factory: ForcedPrecipitation},
    [CardName.FREYJA_BIODOMES]: {Factory: FreyjaBiodomes},
    [CardName.GIANT_SOLAR_SHADE]: {Factory: GiantSolarShade},
    [CardName.GHG_IMPORT_FROM_VENUS]: {Factory: GHGImportFromVenus},
    [CardName.GYROPOLIS]: {Factory: Gyropolis},
    [CardName.HYDROGEN_TO_VENUS]: {Factory: HydrogenToVenus},
    [CardName.IO_SULPHUR_RESEARCH]: {Factory: IoSulphurResearch},
    [CardName.ISHTAR_MINING]: {Factory: IshtarMining},
    [CardName.JET_STREAM_MICROSCRAPPERS]: {Factory: JetStreamMicroscrappers},
    [CardName.LUNA_METROPOLIS]: {Factory: LunaMetropolis},
    [CardName.LOCAL_SHADING]: {Factory: LocalShading},
    [CardName.MAXWELL_BASE]: {Factory: MaxwellBase},
    [CardName.ROTATOR_IMPACTS]: {Factory: RotatorImpacts},
    [CardName.SISTER_PLANET_SUPPORT]: {Factory: SisterPlanetSupport},
    [CardName.SOLARNET]: {Factory: Solarnet},
    [CardName.SPIN_INDUCING_ASTEROID]: {Factory: SpinInducingAsteroid},
    [CardName.SPONSORED_ACADEMIES]: {Factory: SponsoredAcademies},
    [CardName.STRATOPOLIS]: {Factory: Stratopolis},
    [CardName.STRATOSPHERIC_BIRDS]: {Factory: StratosphericBirds},
    [CardName.SULPHUR_EATING_BACTERIA]: {Factory: SulphurEatingBacteria},
    [CardName.SULPHUR_EXPORTS]: {Factory: SulphurExports},
    [CardName.TERRAFORMING_CONTRACT]: {Factory: TerraformingContract},
    [CardName.THERMOPHILES]: {Factory: Thermophiles},
    [CardName.VENUS_GOVERNOR]: {Factory: VenusGovernor},
    [CardName.VENUSIAN_ANIMALS]: {Factory: VenusianAnimals},
    [CardName.VENUSIAN_INSECTS]: {Factory: VenusianInsects},
    [CardName.VENUSIAN_PLANTS]: {Factory: VenusianPlants},
    [CardName.VENUS_MAGNETIZER]: {Factory: VenusMagnetizer},
    [CardName.VENUS_SOILS]: {Factory: VenusSoils},
    [CardName.VENUS_WAYSTATION]: {Factory: VenusWaystation},
    [CardName.WATER_TO_VENUS]: {Factory: WaterToVenus},
    [CardName.LUXURY_FOODS]: {Factory: LuxuryFoods},
    [CardName.NEUTRALIZER_FACTORY]: {Factory: NeutralizerFactory},
    [CardName.ORBITAL_REFLECTORS]: {Factory: OrbitalReflectors},
    [CardName.OMNICOURT]: {Factory: Omnicourt},
    [CardName.MINING_QUOTA]: {Factory: MiningQuota},
  },
  standardProjects: {
    [CardName.AIR_SCRAPPING_STANDARD_PROJECT]: {Factory: AirScrappingStandardProject},
    [CardName.AIR_SCRAPPING_STANDARD_PROJECT_VARIANT]: {Factory: AirScrappingStandardProjectVariant},
  },

  corporationCards: {
    [CardName.APHRODITE]: {Factory: Aphrodite, compatibility: 'venus'},
    [CardName.CELESTIC]: {Factory: Celestic, compatibility: 'venus'},
    [CardName.MANUTECH]: {Factory: Manutech},
    [CardName.MORNING_STAR_INC]: {Factory: MorningStarInc, compatibility: 'venus'},
    [CardName.VIRON]: {Factory: Viron},
  },
});

================
File: cards/venusNext/VenusGovernor.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class VenusGovernor extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.VENUS_GOVERNOR,
      type: CardType.AUTOMATED,
      tags: [Tag.VENUS, Tag.VENUS],
      cost: 4,

      requirements: {tag: Tag.VENUS, count: 2},

      behavior: {
        production: {megacredits: 2},
      },

      metadata: {
        cardNumber: '255',
        renderData: CardRenderer.builder((b) => {
          b.production((pb) => pb.megacredits(2));
        }),
        description: 'Requires 2 Venus tags. Increase your M€ production 2 steps.',
      },
    });
  }
}

================
File: cards/venusNext/VenusianAnimals.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class VenusianAnimals extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.VENUSIAN_ANIMALS,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS, Tag.ANIMAL, Tag.SCIENCE],
      cost: 15,
      resourceType: CardResource.ANIMAL,
      victoryPoints: {resourcesHere: {}},

      requirements: {venus: 18},
      metadata: {
        cardNumber: '259',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a science tag, including this, add 1 animal to this card.', (eb)=> {
            eb.tag(Tag.SCIENCE).startEffect.resource(CardResource.ANIMAL);
          }).br;
          b.vpText('1 VP per animal on this card.');
        }),
        description: 'Requires Venus 18%',
      },
    });
  }
  public onCardPlayed(player: IPlayer, card: IProjectCard): void {
    const qty = player.tags.cardTagCount(card, Tag.SCIENCE);
    player.addResourceTo(this, {qty, log: true});
  }
  public onColonyAddedToLeavitt(player: IPlayer): void {
    player.addResourceTo(this, {qty: 1, log: true});
  }
}

================
File: cards/venusNext/VenusianInsects.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class VenusianInsects extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.VENUSIAN_INSECTS,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS, Tag.MICROBE],
      cost: 5,
      resourceType: CardResource.MICROBE,
      victoryPoints: {resourcesHere: {}, per: 2},

      action: {
        addResources: 1,
      },

      requirements: {venus: 12},
      metadata: {
        cardNumber: '260',
        renderData: CardRenderer.builder((b) => {
          b.action('Add 1 microbe to this card.', (eb)=> {
            eb.empty().startAction.resource(CardResource.MICROBE);
          }).br;
          b.vpText('1 VP for every 2nd Microbe on this card.');
        }),
        description: 'Requires Venus 12%.',
      },
    });
  }
}

================
File: cards/venusNext/VenusianPlants.ts
================
import {IProjectCard} from '../IProjectCard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {IPlayer} from '../../IPlayer';
import {CardResource} from '../../../common/CardResource';
import {SelectCard} from '../../inputs/SelectCard';
import {ICard} from '../ICard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';

export class VenusianPlants extends Card implements IProjectCard {
  constructor() {
    super({
      type: CardType.AUTOMATED,
      name: CardName.VENUSIAN_PLANTS,
      cost: 13,
      tags: [Tag.VENUS, Tag.PLANT],

      requirements: {venus: 16},
      victoryPoints: 1,

      behavior: {
        global: {venus: 1},
      },

      metadata: {
        cardNumber: '261',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).br.br; // intentional double br
          b.resource(CardResource.MICROBE, {secondaryTag: Tag.VENUS}).nbsp;
          b.or().nbsp.resource(CardResource.ANIMAL, {secondaryTag: Tag.VENUS});
        }),
        description: {
          text: 'Requires Venus 16%. Raise Venus 1 step. Add 1 microbe or 1 animal to ANOTHER VENUS CARD',
          align: 'left',
        },
      },
    });
  }

  public override bespokePlay(player: IPlayer) {
    const cards = this.getResCards(player);
    if (cards.length === 0) return undefined;

    if (cards.length === 1) {
      player.addResourceTo(cards[0], {log: true});
      return undefined;
    }

    return new SelectCard(
      'Select card to add 1 resource',
      'Add resource',
      cards)
      .andThen(([card]) => {
        player.addResourceTo(card, {log: true});
        return undefined;
      });
  }

  public getResCards(player: IPlayer): ICard[] {
    let resourceCards = player.getResourceCards(CardResource.MICROBE);
    resourceCards = resourceCards.concat(player.getResourceCards(CardResource.ANIMAL));
    return resourceCards.filter((card) => card.tags.includes(Tag.VENUS));
  }
}

================
File: cards/venusNext/VenusMagnetizer.ts
================
import {IActionCard} from '../ICard';
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {ActionCard} from '../ActionCard';

export class VenusMagnetizer extends ActionCard implements IActionCard {
  constructor() {
    super({
      name: CardName.VENUS_MAGNETIZER,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS],
      cost: 7,

      action: {
        production: {energy: -1},
        global: {venus: 1},
      },

      requirements: {venus: 10},
      metadata: {
        cardNumber: '256',
        renderData: CardRenderer.builder((b) => {
          b.action('Decrease your energy production 1 step to raise Venus 1 step.', (eb) => {
            eb.production((pb) => pb.energy(1)).startAction.venus(1);
          });
        }),
        description: 'Requires Venus 10%.',
      },
    });
  }
}

================
File: cards/venusNext/VenusSoils.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardResource} from '../../../common/CardResource';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class VenusSoils extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.VENUS_SOILS,
      type: CardType.AUTOMATED,
      tags: [Tag.VENUS, Tag.PLANT],
      cost: 20,

      behavior: {
        production: {plants: 1},
        global: {venus: 1},
        addResourcesToAnyCard: {count: 2, type: CardResource.MICROBE},
      },

      metadata: {
        cardNumber: '257',
        renderData: CardRenderer.builder((b) => {
          b.venus(1).br;
          b.production((pb) => pb.plants(1)).resource(CardResource.MICROBE, 2).asterix();
        }),
        description: 'Raise Venus 1 step. Increase your plant production 1 step. Add 2 microbes to ANOTHER card',
      },
    });
  }
}

================
File: cards/venusNext/VenusWaystation.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class VenusWaystation extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.VENUS_WAYSTATION,
      type: CardType.ACTIVE,
      tags: [Tag.VENUS, Tag.SPACE],
      cost: 9,
      victoryPoints: 1,

      cardDiscount: {tag: Tag.VENUS, amount: 2},
      metadata: {
        cardNumber: '258',
        renderData: CardRenderer.builder((b) => {
          b.effect('When you play a Venus tag, you pay 2 M€ less for it.', (eb)=> {
            eb.tag(Tag.VENUS).startEffect.megacredits(-2);
          });
        }),
      },
    });
  }
}

================
File: cards/venusNext/Viron.ts
================
import {CorporationCard} from '../corporation/CorporationCard';
import {IPlayer} from '../../IPlayer';
import {Tag} from '../../../common/cards/Tag';
import {IActionCard, ICard, isIActionCard, isIHasCheckLoops} from '../ICard';
import {SelectCard} from '../../inputs/SelectCard';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';

export class Viron extends CorporationCard {
  constructor() {
    super({
      name: CardName.VIRON,
      tags: [Tag.MICROBE],
      startingMegaCredits: 48,

      metadata: {
        cardNumber: 'R12',
        description: 'You start with 48 M€.',
        renderData: CardRenderer.builder((b) => {
          b.br.br.br;
          b.megacredits(48);
          b.corpBox('action', (ce) => {
            ce.action('Use a blue card action that has already been used this generation.', (eb) => {
              eb.empty().startAction.empty();
            });
          });
        }),
      },
    });
  }

  // This matches Viron.getActionCards.
  private getActionCards(player: IPlayer): Array<IActionCard & ICard> {
    const result = [];
    for (const playedCard of player.tableau) {
      if (playedCard === this) {
        continue;
      }
      if (!isIActionCard(playedCard)) {
        continue;
      }
      if (isIHasCheckLoops(playedCard) && playedCard.getCheckLoops() >= 2) {
        continue;
      }
      if (player.getActionsThisGeneration().has(playedCard.name) && playedCard.canAct(player)) {
        result.push(playedCard);
      }
    }
    return result;
  }

  public canAct(player: IPlayer): boolean {
    return this.getActionCards(player).length > 0 && !player.getActionsThisGeneration().has(this.name);
  }

  public action(player: IPlayer) {
    if (this.getActionCards(player).length === 0 ) {
      return undefined;
    }

    return new SelectCard(
      'Perform again an action from a played card',
      'Take action',
      this.getActionCards(player))
      .andThen(([card]) => {
        player.game.log('${0} used ${1} action with ${2}', (b) => b.player(player).card(card).card(this));
        return card.action(player);
      });
  }
}

================
File: cards/venusNext/WaterToVenus.ts
================
import {Tag} from '../../../common/cards/Tag';
import {CardType} from '../../../common/cards/CardType';
import {CardName} from '../../../common/cards/CardName';
import {CardRenderer} from '../render/CardRenderer';
import {Card} from '../Card';
import {IProjectCard} from '../IProjectCard';

export class WaterToVenus extends Card implements IProjectCard {
  constructor() {
    super({
      name: CardName.WATER_TO_VENUS,
      type: CardType.EVENT,
      tags: [Tag.SPACE],
      cost: 9,

      behavior: {
        global: {venus: 1},
      },

      metadata: {
        cardNumber: '254',
        renderData: CardRenderer.builder((b) => b.venus(1)),
        description: 'Raise Venus 1 step.',
      },
    });
  }
}

================
File: CeoExtension.ts
================
import {IPlayer} from './IPlayer';
import {isCeoCard} from './cards/ceos/ICeoCard';

export class CeoExtension {
  public static ceoActionIsUsable(player: IPlayer): boolean {
    // If _at least_ one CEO has usable actions, return true
    return player.playedCards.some((card) => isCeoCard(card) && card.canAct(player));
  }
}

================
File: colonies/Callisto.ts
================
import {Colony} from './Colony';
import {Resource} from '../../common/Resource';
import {ColonyName} from '../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';

export class Callisto extends Colony {
  constructor() {
    super({
      name: ColonyName.CALLISTO,
      description: [
        'Gain 1 energy production',
        'Gain n energy',
        'Gain 3 energy',
      ],

      buildType: ColonyBenefit.GAIN_PRODUCTION,
      buildResource: Resource.ENERGY,
      tradeType: ColonyBenefit.GAIN_RESOURCES,
      tradeQuantity: [0, 2, 3, 5, 7, 10, 13],
      tradeResource: Resource.ENERGY,
      colonyBonusType: ColonyBenefit.GAIN_RESOURCES,
      colonyBonusQuantity: 3,
      colonyBonusResource: Resource.ENERGY,
    });
  }
}

================
File: colonies/Ceres.ts
================
import {Colony} from './Colony';
import {ColonyName} from '../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';
import {Resource} from '../../common/Resource';

export class Ceres extends Colony {
  constructor() {
    super({
      name: ColonyName.CERES,
      description: [
        'Gain 1 steel production',
        'Gain n steel',
        'Gain 2 steel',
      ],

      buildType: ColonyBenefit.GAIN_PRODUCTION,
      buildResource: Resource.STEEL,
      tradeType: ColonyBenefit.GAIN_RESOURCES,
      tradeQuantity: [1, 2, 3, 4, 6, 8, 10],
      tradeResource: Resource.STEEL,
      colonyBonusType: ColonyBenefit.GAIN_RESOURCES,
      colonyBonusQuantity: 2,
      colonyBonusResource: Resource.STEEL,
    });
  }
}

================
File: colonies/ColoniesHandler.ts
================
import {IGame} from '../IGame';
import {IColony} from './IColony';
import {ColonyName} from '../../common/colonies/ColonyName';
import {ICard} from '../cards/ICard';
import {Tag} from '../../common/cards/Tag';
import {SelectColony} from '../inputs/SelectColony';
import {IPlayer} from '../IPlayer';
import {inplaceRemove} from '../../common/utils/utils';

export class ColoniesHandler {
  public static getColony(game: IGame, colonyName: ColonyName, includeDiscardedColonies: boolean = false): IColony {
    let colony: IColony | undefined = game.colonies.find((c) => c.name === colonyName);
    if (colony !== undefined) return colony;
    if (includeDiscardedColonies === true) {
      colony = game.discardedColonies.find((c) => c.name === colonyName);
      if (colony !== undefined) return colony;
    }
    throw new Error(`Unknown colony '${colonyName}'`);
  }

  public static tradeableColonies(game: IGame) {
    return game.colonies.filter((colony) => colony.isActive && colony.visitor === undefined);
  }

  public static maybeActivateColonies(game: IGame, card: ICard) {
    if (!game.gameOptions.coloniesExtension) return;
    game.colonies.forEach((colony) => {
      if (colony.isActive === false && ColoniesHandler.cardActivatesColony(colony, card)) {
        colony.isActive = true;
      }
    });
  }

  /*
   * Return true if the colony is active, or will be activated by this card.
   *
   * Returns `true` if the colony is already active, or becomes active from this
   * call.
   */
  public static cardActivatesColony(colony: IColony, card: ICard): boolean {
    if (colony.isActive) {
      return true;
    }
    if (colony.metadata.cardResource !== undefined && colony.metadata.cardResource === card.resourceType) {
      return true;
    }
    if (colony.name === ColonyName.VENUS && card.tags.includes(Tag.VENUS) && card.resourceType !== undefined) {
      return true;
    }
    return false;
  }

  /**
   * Add a discarded colony tile back into the game, e.g. with Aridor.
   */
  public static addColonyTile(player: IPlayer, options?: {
    title?: string,
    colonies?: Array<IColony>,
    activateableOnly?: boolean,
    cb?: (colony: IColony) => void,
  }): void {
    const game = player.game;
    let colonyTiles = options?.colonies ?? game.discardedColonies;
    if (options?.activateableOnly === true) {
      colonyTiles = colonyTiles.filter((colonyTile) => colonyTileWillEnterActive(colonyTile, game));
    }
    if (colonyTiles.length === 0) {
      game.log('No availble colony tiles for ${0} to choose from', (b) => b.player(player));
      return;
    }

    const title = options?.title ?? 'Select colony tile to add';

    function colonyTileWillEnterActive(colony: IColony, game: IGame): boolean {
      if (colony.isActive) {
        return true;
      }
      for (const player of game.getPlayers()) {
        for (const card of player.tableau) {
          if (ColoniesHandler.cardActivatesColony(colony, card)) {
            return true;
          }
        }
      }
      return false;
    }

    const selectColonyTile = new SelectColony(title, 'Add colony tile', [...colonyTiles])
      .andThen((colonyTile) => {
        game.colonies.push(colonyTile);
        game.colonies.sort((a, b) => (a.name > b.name) ? 1 : -1);
        game.log('${0} added a new Colony tile: ${1}', (b) => b.player(player).colony(colonyTile));
        if (!colonyTile.isActive && colonyTileWillEnterActive(colonyTile, game)) {
          colonyTile.isActive = true;
        }
        inplaceRemove(game.discardedColonies, colonyTile);
        options?.cb?.(colonyTile);
        return undefined;
      });
    selectColonyTile.showTileOnly = true;
    player.defer(selectColonyTile);
  }
}

================
File: colonies/Colony.ts
================
import {AddResourcesToCard} from '../deferredActions/AddResourcesToCard';
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';
import {DeferredAction, SimpleDeferredAction} from '../deferredActions/DeferredAction';
import {Priority} from '../deferredActions/Priority';
import {DiscardCards} from '../deferredActions/DiscardCards';
import {DrawCards} from '../deferredActions/DrawCards';
import {GiveColonyBonus} from '../deferredActions/GiveColonyBonus';
import {IncreaseColonyTrack} from '../deferredActions/IncreaseColonyTrack';
import {LogHelper} from '../LogHelper';
import {MAX_COLONIES_PER_TILE, MAX_COLONY_TRACK_POSITION} from '../../common/constants';
import {PlaceOceanTile} from '../deferredActions/PlaceOceanTile';
import {IPlayer} from '../IPlayer';
import {PlayerId} from '../../common/Types';
import {PlayerInput} from '../PlayerInput';
import {Resource} from '../../common/Resource';
import {ScienceTagCard} from '../cards/community/ScienceTagCard';
import {SelectColony} from '../inputs/SelectColony';
import {SelectPlayer} from '../inputs/SelectPlayer';
import {StealResources} from '../deferredActions/StealResources';
import {Tag} from '../../common/cards/Tag';
import {SendDelegateToArea} from '../deferredActions/SendDelegateToArea';
import {IGame} from '../IGame';
import {Turmoil} from '../turmoil/Turmoil';
import {SerializedColony} from '../SerializedColony';
import {IColony, TradeOptions} from './IColony';
import {colonyMetadata, IColonyMetadata, IInputColonyMetadata} from '../../common/colonies/IColonyMetadata';
import {ColonyName} from '../../common/colonies/ColonyName';
import {sum} from '../../common/utils/utils';
import {message} from '../logs/MessageBuilder';
import {PlaceHazardTile} from '../deferredActions/PlaceHazardTile';
import {TileType} from '../../../src/common/TileType';
import {ErodeSpacesDeferred} from '../underworld/ErodeSpacesDeferred';

export enum ShouldIncreaseTrack { YES, NO, ASK }
export abstract class Colony implements IColony {
  // Players can't build colonies on Miranda until someone has played an Animal card.
  // isActive is the gateway for that action and any other card with that type of constraint
  // also isActive represents when the colony is part of the game, or "back in the box", as it were.
  public isActive: boolean = true;
  public visitor: undefined | PlayerId = undefined;
  public colonies: Array<PlayerId> = [];
  public trackPosition: number = 1;

  public metadata: IColonyMetadata;

  protected constructor(metadata: IInputColonyMetadata) {
    this.metadata = colonyMetadata(metadata);
  }

  public get name(): ColonyName {
    return this.metadata.name;
  }

  public endGeneration(game: IGame): void {
    if (this.isActive) {
      this.increaseTrack();
    }
    // Syndicate Pirate Raids hook. If it is in effect, then only the syndicate pirate raider will
    // retrieve their fleets.
    // See Player.ts for the other half of this effect, and Game.ts which disables it.
    if (game.syndicatePirateRaider) {
      if (game.syndicatePirateRaider === this.visitor) {
        this.visitor = undefined;
      }
    } else {
      this.visitor = undefined;
    }
  }

  public increaseTrack(value: number = 1): void {
    this.trackPosition = Math.min(this.trackPosition + value, MAX_COLONY_TRACK_POSITION);
  }

  public decreaseTrack(value: number = 1): void {
    this.trackPosition = Math.max(this.trackPosition - value, this.colonies.length);
  }

  public isFull(): boolean {
    return this.colonies.length >= MAX_COLONIES_PER_TILE;
  }

  public addColony(player: IPlayer, options?: {giveBonusTwice: boolean}): void {
    player.game.log('${0} built a colony on ${1}', (b) => b.player(player).colony(this));

    this.giveBonus(player, this.metadata.buildType, this.metadata.buildQuantity[this.colonies.length], this.metadata.buildResource);
    if (options?.giveBonusTwice === true) { // Vital Colony hook.
      this.giveBonus(player, this.metadata.buildType, this.metadata.buildQuantity[this.colonies.length], this.metadata.buildResource);
    }

    this.colonies.push(player.id);
    if (this.trackPosition < this.colonies.length) {
      this.trackPosition = this.colonies.length;
    }

    for (const cardOwner of player.game.getPlayers()) {
      for (const card of cardOwner.tableau) {
        card.onColonyAdded?.(player, cardOwner);
      }
    }

    if (this.name === ColonyName.LEAVITT) {
      for (const card of player.tableau) {
        card.onColonyAddedToLeavitt?.(player);
      }
    }
  }

  /*
    * Trade with this colony.
    *
    * Before passing off the trade, this determines whether the track should advance prior to trading, and then
    * hands off the real work to `handleTrade`.
    *
    * @param bonusTradeOffset an offset that allows a player to increase the colony tile track marker before trading.
    * @param usesTradeFleet when false, the player can trade without an available trade fleet.
    * @param decreaseTrackAfterTrade when false, the track does not decrease after trading.
    */
  public trade(player: IPlayer, tradeOptions: TradeOptions = {}, bonusTradeOffset = 0): void {

    console.log('trade method called');
    console.log('chemicalExpansion:', player.game.gameOptions.chemicalExpansion);
    console.log('hasTraded before:', player.hasTraded);

    const tradeOffset = player.colonies.tradeOffset + bonusTradeOffset;
    const maxTrackPosition = Math.min(this.trackPosition + tradeOffset, MAX_COLONY_TRACK_POSITION);
    const steps = maxTrackPosition - this.trackPosition;

    // Set the hasTraded flag if chemical expansion is active - andy one trade
    if (player.game.gameOptions.chemicalExpansion) {
      player.hasTraded = true;
      console.log('Set hasTraded to true');
    }
    console.log('hasTraded after:', player.hasTraded);
    
    for (const p of player.game.getPlayers()) {
      for (const playedCard of p.tableau) {
        playedCard.onTrade?.(p, player, this);
      }
    }

    if (steps === 0 ||
        this.metadata.shouldIncreaseTrack === 'no' ||
        tradeOptions.selfishTrade === true) {
      // Don't increase
      this.handleTrade(player, tradeOptions);
      return;
    }

    if (this.metadata.shouldIncreaseTrack === 'yes' || (this.metadata.tradeResource !== undefined && this.metadata.tradeResource[this.trackPosition] === this.metadata.tradeResource[maxTrackPosition])) {
      // No point in asking the player, just increase it
      this.increaseTrack(steps);
      LogHelper.logColonyTrackIncrease(player, this, steps);
      this.handleTrade(player, tradeOptions);
      return;
    }

    // Ask the player if they want to increase the track
    player.game.defer(new IncreaseColonyTrack(player, this, steps))
      .andThen(() => this.handleTrade(player, tradeOptions));


  }

  private handleTrade(player: IPlayer, options: TradeOptions) {   
    const resource = Array.isArray(this.metadata.tradeResource) ? this.metadata.tradeResource[this.trackPosition] : this.metadata.tradeResource;

    this.giveBonus(player, this.metadata.tradeType, this.metadata.tradeQuantity[this.trackPosition], resource);

    // !== false because default is true.
    if (options.giveColonyBonuses !== false) {
      player.game.defer(new GiveColonyBonus(player, this, options.selfishTrade));
    }

    // !== false because default is true.
    if (options.usesTradeFleet !== false) {
      this.visitor = player.id;
      player.colonies.tradesThisGeneration++;
    }

    // !== false because default is true.
    if (options.decreaseTrackAfterTrade !== false) {
      player.defer(() => {
        this.trackPosition = this.colonies.length;
      }, Priority.DECREASE_COLONY_TRACK_AFTER_TRADE);
    }
  }

  public giveColonyBonus(player: IPlayer, isGiveColonyBonus: boolean = false): undefined | PlayerInput {
    return this.giveBonus(player, this.metadata.colonyBonusType, this.metadata.colonyBonusQuantity, this.metadata.colonyBonusResource, isGiveColonyBonus);
  }

  private giveBonus(player: IPlayer, bonusType: ColonyBenefit, quantity: number, resource: Resource | undefined, isGiveColonyBonus: boolean = false): undefined | PlayerInput {
    const game = player.game;

    let action: undefined | DeferredAction<any> = undefined;
    switch (bonusType) {
    case ColonyBenefit.ADD_RESOURCES_TO_CARD:
      const cardResource = this.metadata.cardResource;
      action = new AddResourcesToCard(player, cardResource, {count: quantity});
      break;

    case ColonyBenefit.ADD_RESOURCES_TO_VENUS_CARD:
      action = new AddResourcesToCard(
        player,
        undefined,
        {
          count: quantity,
          restrictedTag: Tag.VENUS,
          title: message('Select Venus card to add ${0} resource(s)', (b) => b.number(quantity)),
        });
      break;

    case ColonyBenefit.COPY_TRADE:
      const openColonies = game.colonies.filter((colony) => colony.isActive);
      action = new SimpleDeferredAction(
        player,
        () => new SelectColony('Select colony to gain trade income from', 'Select', openColonies)
          .andThen((colony) => {
            game.log('${0} gained ${1} trade bonus', (b) => b.player(player).colony(colony));
            (colony as Colony).handleTrade(player, {
              usesTradeFleet: false,
              decreaseTrackAfterTrade: false,
              giveColonyBonuses: false,
            });
            return undefined;
          }),
      );
      break;

    case ColonyBenefit.DRAW_CARDS:
      action = DrawCards.keepAll(player, quantity);
      break;

    case ColonyBenefit.DRAW_CARDS_AND_BUY_ONE:
      action = DrawCards.keepSome(player, 1, {paying: true, logDrawnCard: true});
      break;

    case ColonyBenefit.DRAW_CARDS_AND_DISCARD_ONE:
      player.defer(() => {
        player.drawCard();
        player.game.defer(new DiscardCards(player, 1, 1, this.name + ' colony bonus. Select a card to discard'), Priority.SUPERPOWER);
      });
      break;

    case ColonyBenefit.DRAW_CARDS_AND_KEEP_ONE:
      action = DrawCards.keepSome(player, quantity, {keepMax: 1});
      break;

    case ColonyBenefit.GAIN_CARD_DISCOUNT:
      player.colonies.cardDiscount += 1;
      game.log('Cards played by ${0} cost 1 M€ less this generation', (b) => b.player(player));
      break;

    case ColonyBenefit.GAIN_PRODUCTION:
      if (resource === undefined) throw new Error('Resource cannot be undefined');
      player.production.add(resource, quantity, {log: true});
      break;

    case ColonyBenefit.GAIN_RESOURCES:
      if (resource === undefined) throw new Error('Resource cannot be undefined');
      player.stock.add(resource, quantity, {log: true});
      break;

    case ColonyBenefit.GAIN_SCIENCE_TAG:
      player.tags.gainScienceTag(1);
      player.playCard(new ScienceTagCard(), undefined, 'nothing');
      game.log('${0} gained 1 Science tag', (b) => b.player(player));
      break;

    case ColonyBenefit.GAIN_SCIENCE_TAGS_AND_CLONE_TAG:
      player.tags.gainScienceTag(2);
      player.playCard(new ScienceTagCard(), undefined, 'nothing');
      game.log('${0} gained 2 Science tags', (b) => b.player(player));
      break;

    case ColonyBenefit.GAIN_INFLUENCE:
      Turmoil.ifTurmoil(game, (turmoil) => {
        turmoil.addInfluenceBonus(player);
        game.log('${0} gained 1 influence', (b) => b.player(player));
      });
      break;

    case ColonyBenefit.PLACE_DELEGATES:
      Turmoil.ifTurmoil(game, (turmoil) => {
        const availablePlayerDelegates = turmoil.getAvailableDelegateCount(player);
        const qty = Math.min(quantity, availablePlayerDelegates);
        for (let i = 0; i < qty; i++) {
          game.defer(new SendDelegateToArea(player));
        }
      });
      break;

    case ColonyBenefit.GIVE_MC_PER_DELEGATE:
      Turmoil.ifTurmoil(game, (turmoil) => {
        const partyDelegateCount = sum(turmoil.parties.map((party) => party.delegates.get(player)));
        player.stock.add(Resource.MEGACREDITS, partyDelegateCount, {log: true});
      });
      break;

    case ColonyBenefit.PLACE_HAZARD_TILE:
      const spaces = game.board.getAvailableSpacesOnLand(player)
        .filter(((space) => space.tile === undefined))
        .filter((space) => {
          const adjacentSpaces = game.board.getAdjacentSpaces(space);
          return adjacentSpaces.filter((space) => space.tile !== undefined).length === 0;
        });

      game.defer(new PlaceHazardTile(player, TileType.EROSION_MILD, {title: 'Select space next to no other tile for hazard', spaces}));
      break;

    case ColonyBenefit.ERODE_SPACES_ADJACENT_TO_HAZARDS:
      game.defer(new ErodeSpacesDeferred(player, quantity));
      break;

    case ColonyBenefit.GAIN_MC_PER_HAZARD_TILE:
      player.stock.megacredits += game.board.getHazards().length;
      break;

    case ColonyBenefit.GAIN_TR:
      if (quantity > 0) {
        player.increaseTerraformRating(quantity, {log: true});
      }
      break;

    case ColonyBenefit.GAIN_VP:
      if (quantity > 0) {
        player.colonies.victoryPoints += quantity;
        game.log('${0} gained ${1} VP', (b) => b.player(player).number(quantity));
      }
      break;

    case ColonyBenefit.INCREASE_VENUS_SCALE:
      game.increaseVenusScaleLevel(player, quantity as 3|2|1);
      game.log('${0} increased Venus scale ${1} step(s)', (b) => b.player(player).number(quantity));
      break;

    case ColonyBenefit.LOSE_RESOURCES:
      if (resource === undefined) throw new Error('Resource cannot be undefined');
      player.stock.deduct(resource, quantity);
      break;

    case ColonyBenefit.OPPONENT_DISCARD:
      if (game.isSoloMode()) break;
      action = new SimpleDeferredAction(
        player,
        () => {
          const playersWithCards = game.getPlayers().filter((p) => p.cardsInHand.length > 0);
          if (playersWithCards.length === 0) return undefined;
          return new SelectPlayer(playersWithCards, 'Select player to discard a card', 'Select')
            .andThen((selectedPlayer) => {
              game.defer(new DiscardCards(selectedPlayer, 1, 1, this.name + ' colony effect. Select a card to discard'));
              return undefined;
            });
        });
      break;

    case ColonyBenefit.PLACE_OCEAN_TILE:
      action = new PlaceOceanTile(player);
      break;

    case ColonyBenefit.STEAL_RESOURCES:
      if (resource === undefined) throw new Error('Resource cannot be undefined');
      action = new StealResources(player, resource, quantity);
      break;

    default:
      throw new Error('Unsupported benefit type');
    }

    if (action !== undefined) {
      if (isGiveColonyBonus) {
        /*
         * When this method is called from within the GiveColonyBonus deferred action
         * we return the player input directly instead of deferring it.
         *
         * TODO(kberg): why?
         */
        return action.execute();
      } else {
        game.defer(action);
        return undefined;
      }
    } else {
      return undefined;
    }
  }

  public serialize(): SerializedColony {
    return {
      name: this.name,
      colonies: this.colonies,
      isActive: this.isActive,
      trackPosition: this.trackPosition,
      visitor: this.visitor,
    };
  }
}

================
File: colonies/ColonyDealer.ts
================
import {IColony} from './IColony';
import {ColonyName} from '../../common/colonies/ColonyName';
import {Random} from '../../common/utils/Random';
import {BASE_COLONIES_TILES, COMMUNITY_COLONIES_TILES, PATHFINDERS_COLONIES_TILES} from './ColonyManifest';
import {GameOptions} from '../game/GameOptions';

// TODO(kberg): Add ability to hard-code chosen colonies, separate from customColoniesList, so as to not be
// forced to rely on the RNG.
// TODO(kberg): Add ability to disable initial action that removes a colony in the solo game. (Or come up with
// a simple line of code to deal with solo games.)

export class ColonyDealer {
  private readonly gameColonies: ReadonlyArray<IColony>;
  public colonies: Array<IColony> = [];
  public discardedColonies: Array<IColony> = [];

  constructor(private rng: Random, private gameOptions: GameOptions) {
    let colonyTiles = BASE_COLONIES_TILES;

    if (ColonyDealer.includesCommunityColonies(gameOptions)) colonyTiles = colonyTiles.concat(COMMUNITY_COLONIES_TILES);
    if (gameOptions.pathfindersExpansion || gameOptions.moonExpansion) colonyTiles = colonyTiles.concat(PATHFINDERS_COLONIES_TILES);
    if (gameOptions.moonExpansion && !this.gameOptions.pathfindersExpansion) colonyTiles.filter((c) => c.colonyName !== ColonyName.LEAVITT_II); // Leavitt II isn't built yet but this is pre-emptive
    if (!gameOptions.venusNextExtension) colonyTiles = colonyTiles.filter((c) => c.colonyName !== ColonyName.VENUS);
    if (!gameOptions.turmoilExtension) colonyTiles = colonyTiles.filter((c) => c.colonyName !== ColonyName.PALLAS);
    if (!gameOptions.aresExtension) colonyTiles = colonyTiles.filter((c) => c.colonyName !== ColonyName.DEIMOS);
    this.gameColonies = colonyTiles.map((cf) => new cf.Factory());
  }

  private static includesCommunityColonies(gameOptions: GameOptions) : boolean {
    if (gameOptions.communityCardsOption) return true;
    const communityColonyNames = COMMUNITY_COLONIES_TILES.map((cf) => cf.colonyName);
    return gameOptions.customColoniesList.some((colonyName) => communityColonyNames.includes(colonyName));
  }

  private shuffle(cards: Array<IColony> | ReadonlyArray<IColony>): Array<IColony> {
    const deck: Array<IColony> = [];
    const copy = cards.slice();
    while (copy.length) {
      deck.push(copy.splice(Math.floor(this.rng.nextInt(copy.length)), 1)[0]);
    }
    return deck;
  }

  public drawColonies(players: number): void {
    const customColonies = this.gameOptions.customColoniesList;
    const colonies = customColonies.length === 0 ? this.gameColonies : this.gameColonies.filter((c) => customColonies.includes(c.name));

    const count = (players + 2) +
      (players <= 2 ? 1 : 0); // Two-player games and solo games get one more colony.

    if (colonies.length < count) {
      throw new Error(`Not enough valid colonies to choose from (want ${count}, has ${colonies.length}.) Remember that colonies like Venus and Pallas are invalid without Venus or Turmoil.`);
    }

    const tempDeck = this.shuffle(colonies);
    for (let i = 0; i < count; i++) {
      const colony = tempDeck.pop();
      if (colony === undefined) {
        throw new Error('Not enough colonies');
      }
      this.colonies.push(colony);
    }

    this.discardedColonies.push(...tempDeck);
    this.discardedColonies.sort((a, b) => (a.name > b.name) ? 1 : -1);
    this.colonies.sort((a, b) => (a.name > b.name) ? 1 : -1);
  }

  public restore(activeColonies: Array<IColony>): void {
    this.colonies = [...activeColonies];
    this.discardedColonies = this.gameColonies.filter((c) => {
      return !activeColonies.some((ac) => ac.name === c.name);
    });
  }
}

================
File: colonies/ColonyDeserializer.ts
================
import {ColonyName} from '../../common/colonies/ColonyName';
import {SerializedColony} from '../SerializedColony';
import {ALL_COLONIES_TILES} from './ColonyManifest';
import {IColony} from './IColony';

export class ColonyDeserializer {
  public static deserialize(serialized: SerializedColony | ColonyName): IColony | undefined {
    const name = typeof(serialized) === 'string' ? serialized : serialized.name;
    const factory = ALL_COLONIES_TILES.find((cf) => cf.colonyName === name);
    if (factory === undefined) {
      console.warn(`colony ${name} not found`);
      return undefined;
    }

    const colony = new factory.Factory();
    if (typeof(serialized) !== 'string') {
      colony.colonies = serialized.colonies;
      colony.isActive = serialized.isActive;
      colony.trackPosition = serialized.trackPosition;
      colony.visitor = serialized.visitor;
    }
    return colony;
  }

  public static deserializeAndFilter(serialized: Array<SerializedColony | ColonyName>): Array<IColony> {
    const colonies: Array<IColony | undefined> = serialized.map((c) => this.deserialize(c)).filter((c) => c !== undefined);
    // as Array<Colony> is safe because filter removes the undefined colonies
    return colonies as Array<IColony>;
  }
}

================
File: colonies/ColonyManifest.ts
================
import {Colony} from './Colony';
import {Europa} from './Europa';
import {Ganymede} from './Ganymede';
import {Titan} from './Titan';
import {Callisto} from './Callisto';
import {Triton} from './Triton';
import {Ceres} from './Ceres';
import {Luna} from './Luna';
import {Io} from './Io';
import {Miranda} from './Miranda';
import {Pluto} from './Pluto';
import {Enceladus} from './Enceladus';
import {ColonyName} from '../../common/colonies/ColonyName';
import {Iapetus} from '../cards/community/Iapetus';
import {Mercury} from '../cards/community/Mercury';
import {Hygiea} from '../cards/community/Hygiea';
import {Titania} from '../cards/community/Titania';
import {Venus} from '../cards/community/Venus';
import {Leavitt} from '../cards/community/Leavitt';
import {Pallas} from '../cards/community/Pallas';
import {GameModule} from '../../common/cards/GameModule';
import {IapetusII} from '../cards/pathfinders/IapetusII';
import {Deimos} from './Deimos';
// import {LeavittII} from '../cards/pathfinders/LeavittII';

export interface IColonyFactory<T> {
  colonyName: ColonyName;
  Factory: new () => T;
}

export const BASE_COLONIES_TILES: Array<IColonyFactory<Colony>> = [
  {colonyName: ColonyName.CERES, Factory: Ceres},
  {colonyName: ColonyName.ENCELADUS, Factory: Enceladus},
  {colonyName: ColonyName.EUROPA, Factory: Europa},
  {colonyName: ColonyName.GANYMEDE, Factory: Ganymede},
  {colonyName: ColonyName.IO, Factory: Io},
  {colonyName: ColonyName.LUNA, Factory: Luna},
  {colonyName: ColonyName.MIRANDA, Factory: Miranda},
  {colonyName: ColonyName.TITAN, Factory: Titan},
  {colonyName: ColonyName.CALLISTO, Factory: Callisto},
  {colonyName: ColonyName.PLUTO, Factory: Pluto},
  {colonyName: ColonyName.TRITON, Factory: Triton},
];

export const COMMUNITY_COLONIES_TILES: Array<IColonyFactory<Colony>> = [
  {colonyName: ColonyName.IAPETUS, Factory: Iapetus},
  {colonyName: ColonyName.MERCURY, Factory: Mercury},
  {colonyName: ColonyName.HYGIEA, Factory: Hygiea},
  {colonyName: ColonyName.TITANIA, Factory: Titania},
  {colonyName: ColonyName.VENUS, Factory: Venus},
  {colonyName: ColonyName.LEAVITT, Factory: Leavitt},
  {colonyName: ColonyName.PALLAS, Factory: Pallas},
  {colonyName: ColonyName.DEIMOS, Factory: Deimos},
];

export const PATHFINDERS_COLONIES_TILES: Array<IColonyFactory<Colony>> = [
  // {colonyName: ColonyName.LEAVITT_II, Factory: LeavittII},
  {colonyName: ColonyName.IAPETUS_II, Factory: IapetusII},
];

export const ALL_COLONIES_TILES = [...BASE_COLONIES_TILES, ...COMMUNITY_COLONIES_TILES, ...PATHFINDERS_COLONIES_TILES];

export function getColonyModule(name: ColonyName): GameModule {
  if (COMMUNITY_COLONIES_TILES.some((f) => f.colonyName === name)) return 'community';
  if (PATHFINDERS_COLONIES_TILES.some((f) => f.colonyName === name)) return 'pathfinders';
  return 'colonies';
}

================
File: colonies/Deimos.ts
================
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';
import {ColonyName} from '../../common/colonies/ColonyName';
import {Colony} from './Colony';

export class Deimos extends Colony {
  constructor() {
    super({
      description: [
        'Place a hazard tile next to no other tile',
        'Erode n spaces adjacent to hazard tiles',
        'Gain 1 M€ per hazard tile on Mars',
      ],
      //  public description = 'Hazards';
      name: ColonyName.DEIMOS,
      buildType: ColonyBenefit.PLACE_HAZARD_TILE,
      buildQuantity: [3, 3, 3],
      tradeType: ColonyBenefit.ERODE_SPACES_ADJACENT_TO_HAZARDS,
      tradeQuantity: [0, 0, 1, 1, 2, 2, 3],
      colonyBonusType: ColonyBenefit.GAIN_MC_PER_HAZARD_TILE,
    });
  }
}

================
File: colonies/Enceladus.ts
================
import {Colony} from './Colony';
import {ColonyName} from '../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';
import {CardResource} from '../../common/CardResource';

export class Enceladus extends Colony {
  public override isActive = false;
  constructor() {
    super({
      name: ColonyName.ENCELADUS,
      description: [
        'Add 3 microbes to ANY card',
        'Add n microbes to ANY card',
        'Add 1 microbe to ANY card',
      ],

      cardResource: CardResource.MICROBE,
      buildType: ColonyBenefit.ADD_RESOURCES_TO_CARD,
      buildQuantity: [3, 3, 3],
      tradeType: ColonyBenefit.ADD_RESOURCES_TO_CARD,
      tradeQuantity: [0, 1, 2, 3, 4, 4, 5],
      colonyBonusType: ColonyBenefit.ADD_RESOURCES_TO_CARD,
    });
  }
}

================
File: colonies/Europa.ts
================
import {Colony} from './Colony';
import {Resource} from '../../common/Resource';
import {ColonyName} from '../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';

export class Europa extends Colony {
  constructor() {
    super({
      name: ColonyName.EUROPA,
      description: [
        'Place an ocean tile',
        'Gain 1 unit of production of the type under the track marker',
        'Gain 1 M€',
      ],
      buildType: ColonyBenefit.PLACE_OCEAN_TILE,
      tradeType: ColonyBenefit.GAIN_PRODUCTION,
      tradeResource: [
        Resource.MEGACREDITS, Resource.MEGACREDITS,
        Resource.ENERGY, Resource.ENERGY,
        Resource.PLANTS, Resource.PLANTS, Resource.PLANTS,
      ],
      colonyBonusType: ColonyBenefit.GAIN_RESOURCES,
      colonyBonusResource: Resource.MEGACREDITS,
      shouldIncreaseTrack: 'ask',
    });
  }
}

================
File: colonies/Ganymede.ts
================
import {Colony} from './Colony';
import {Resource} from '../../common/Resource';
import {ColonyName} from '../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';

export class Ganymede extends Colony {
  constructor() {
    super({
      name: ColonyName.GANYMEDE,
      description: [
        'Gain 1 plant production',
        'Gain n plants',
        'Gain 1 plant',
      ],

      buildType: ColonyBenefit.GAIN_PRODUCTION,
      buildResource: Resource.PLANTS,
      tradeType: ColonyBenefit.GAIN_RESOURCES,
      tradeQuantity: [0, 1, 2, 3, 4, 5, 6],
      tradeResource: Resource.PLANTS,
      colonyBonusType: ColonyBenefit.GAIN_RESOURCES,
      colonyBonusResource: Resource.PLANTS,
    });
  }
}

================
File: colonies/IColony.ts
================
import {IPlayer} from '../IPlayer';
import {PlayerInput} from '../PlayerInput';
import {PlayerId} from '../../common/Types';
import {IGame} from '../IGame';
import {SerializedColony} from '../SerializedColony';
import {IColonyMetadata} from '../../common/colonies/IColonyMetadata';
import {ColonyName} from '../../common/colonies/ColonyName';

export type TradeOptions = {
  usesTradeFleet?: boolean;
  decreaseTrackAfterTrade?: boolean;
  giveColonyBonuses?: boolean;
  selfishTrade?: boolean;
};

export interface IColony {
  readonly name: ColonyName;
  readonly metadata: IColonyMetadata;

  isActive: boolean;
  colonies: Array<PlayerId>;
  trackPosition: number;
  visitor: PlayerId | undefined;

  endGeneration(game: IGame): void;
  increaseTrack(steps?: number): void;
  decreaseTrack(steps?: number): void;
  isFull(): boolean;
  addColony(player: IPlayer, options?: {giveBonusTwice: boolean}): void;
  trade(player: IPlayer, tradeOptions?: TradeOptions, bonusTradeOffset?: number): void;
  giveColonyBonus(player: IPlayer, isGiveColonyBonus?: boolean): undefined | PlayerInput;
  serialize(): SerializedColony;
}

================
File: colonies/IColonyTrader.ts
================
import {Message} from '@/common/logs/Message';
import {IColony} from './IColony';

// Something that can pay for trading with colonies.
export interface IColonyTrader {
  canUse(): boolean;
  optionText(): string | Message;
  trade(colony: IColony): void;
}

================
File: colonies/Io.ts
================
import {Colony} from './Colony';
import {ColonyName} from '../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';
import {Resource} from '../../common/Resource';

export class Io extends Colony {
  constructor() {
    super({
      name: ColonyName.IO,
      description: [
        'Gain 1 heat production',
        'Gain n heat',
        'Gain 2 heat',
      ],

      buildType: ColonyBenefit.GAIN_PRODUCTION,
      buildResource: Resource.HEAT,
      tradeType: ColonyBenefit.GAIN_RESOURCES,
      tradeQuantity: [2, 3, 4, 6, 8, 10, 13],
      tradeResource: Resource.HEAT,
      colonyBonusType: ColonyBenefit.GAIN_RESOURCES,
      colonyBonusQuantity: 2,
      colonyBonusResource: Resource.HEAT,
    });
  }
}

================
File: colonies/Luna.ts
================
import {Colony} from './Colony';
import {ColonyName} from '../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';
import {Resource} from '../../common/Resource';

export class Luna extends Colony {
  constructor() {
    super({
      name: ColonyName.LUNA,
      description: [
        'Gain 2 M€ production',
        'Gain n M€',
        'Gain 2 M€',
      ],
      buildType: ColonyBenefit.GAIN_PRODUCTION,
      buildQuantity: [2, 2, 2],
      buildResource: Resource.MEGACREDITS,
      tradeType: ColonyBenefit.GAIN_RESOURCES,
      tradeQuantity: [1, 2, 4, 7, 10, 13, 17],
      tradeResource: Resource.MEGACREDITS,
      colonyBonusType: ColonyBenefit.GAIN_RESOURCES,
      colonyBonusQuantity: 2,
      colonyBonusResource: Resource.MEGACREDITS,
    });
  }
}

================
File: colonies/Miranda.ts
================
import {Colony} from './Colony';
import {ColonyName} from '../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';
import {CardResource} from '../../common/CardResource';

export class Miranda extends Colony {
  public override isActive = false;
  constructor() {
    super({
      name: ColonyName.MIRANDA,
      description: [
        'Add 1 animal to ANY card',
        'Add n animals to ANY card',
        'Draw 1 card',
      ],

      cardResource: CardResource.ANIMAL,
      buildType: ColonyBenefit.ADD_RESOURCES_TO_CARD,
      tradeType: ColonyBenefit.ADD_RESOURCES_TO_CARD,
      tradeQuantity: [0, 1, 1, 2, 2, 3, 3],
      colonyBonusType: ColonyBenefit.DRAW_CARDS,
    });
  }
}

================
File: colonies/Pluto.ts
================
import {Colony} from './Colony';
import {ColonyName} from '../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';

export class Pluto extends Colony {
  constructor() {
    super({
      name: ColonyName.PLUTO,
      description: [
        'Draw 2 cards',
        'Draw n cards',
        'Draw 1 card and then discard 1 card',
      ],

      buildType: ColonyBenefit.DRAW_CARDS,
      buildQuantity: [2, 2, 2],
      tradeType: ColonyBenefit.DRAW_CARDS,
      tradeQuantity: [0, 1, 2, 2, 3, 3, 4],
      colonyBonusType: ColonyBenefit.DRAW_CARDS_AND_DISCARD_ONE,
    });
  }
}

================
File: colonies/Titan.ts
================
import {Colony} from './Colony';
import {ColonyName} from '../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';
import {CardResource} from '../../common/CardResource';

export class Titan extends Colony {
  public override isActive = false;
  constructor() {
    super({
      description: [
        'Add 3 floaters to ANY card',
        'Add n floaters to ANY card',
        'Add 1 floater to ANY card',
      ],

      name: ColonyName.TITAN,
      cardResource: CardResource.FLOATER,
      buildType: ColonyBenefit.ADD_RESOURCES_TO_CARD,
      buildQuantity: [3, 3, 3],
      tradeType: ColonyBenefit.ADD_RESOURCES_TO_CARD,
      tradeQuantity: [0, 1, 1, 2, 3, 3, 4],
      colonyBonusType: ColonyBenefit.ADD_RESOURCES_TO_CARD,
    });
  }
}

================
File: colonies/Triton.ts
================
import {Colony} from './Colony';
import {ColonyName} from '../../common/colonies/ColonyName';
import {ColonyBenefit} from '../../common/colonies/ColonyBenefit';
import {Resource} from '../../common/Resource';

export class Triton extends Colony {
  constructor() {
    super({
      name: ColonyName.TRITON,
      description: [
        'Gain 3 titanium',
        'Gain n titanium',
        'Gain 1 titanium',
      ],

      buildType: ColonyBenefit.GAIN_RESOURCES,
      buildQuantity: [3, 3, 3],
      buildResource: Resource.TITANIUM,
      tradeType: ColonyBenefit.GAIN_RESOURCES,
      tradeQuantity: [0, 1, 1, 2, 3, 4, 5],
      tradeResource: Resource.TITANIUM,
      colonyBonusType: ColonyBenefit.GAIN_RESOURCES,
      colonyBonusResource: Resource.TITANIUM,
    });
  }
}

================
File: createCard.ts
================
import {ICard} from './cards/ICard';
import {IProjectCard} from './cards/IProjectCard';
import {CardManifest, ModuleManifest} from './cards/ModuleManifest';
import {CardName} from '../common/cards/CardName';
import {ICorporationCard} from './cards/corporation/ICorporationCard';
import {IPreludeCard} from './cards/prelude/IPreludeCard';
import {ICeoCard} from './cards/ceos/ICeoCard';
import {ALL_MODULE_MANIFESTS} from './cards/AllManifests';

const CARD_RENAMES = new Map<string, CardName>([
  // When renaming a card, add the old name here (like the example below), and add a TODO (like the example below)
  // And remember to add a test in spec.ts.

  // TODO(yournamehere): remove after 2021-04-05
]);

function _createCard<T extends ICard>(cardName: CardName, cardManifestNames: Array<keyof ModuleManifest>): T | undefined {
  const standardizedCardName = CARD_RENAMES.get(cardName) || cardName;

  for (const moduleManifest of ALL_MODULE_MANIFESTS) {
    for (const manifestName of cardManifestNames) {
      const cardManifest = <CardManifest<T>> moduleManifest[manifestName];
      const factory = cardManifest[standardizedCardName];
      if (factory !== undefined) {
        return new factory.Factory();
      }
    }
  }
  console.warn(`card not found ${cardName}`);
  return undefined;
}

export function newCard(cardName: CardName): ICard | undefined {
  return _createCard(cardName, ['corporationCards', 'projectCards', 'preludeCards', 'ceoCards']);
}

export function newCorporationCard(cardName: CardName): ICorporationCard | undefined {
  return _createCard(cardName, ['corporationCards']);
}

// Function to return a card object by its name
// NOTE(kberg): This replaces a larger function which searched for both Prelude cards amidst project cards
// TODO(kberg+dl): Find the use cases where this is used to find Prelude+CEO cards and filter them out to
//              another function, perhaps?
export function newProjectCard(cardName: CardName): IProjectCard | undefined {
  return _createCard(cardName, ['projectCards', 'preludeCards', 'ceoCards']);
}

export function newPrelude(cardName: CardName): IPreludeCard | undefined {
  return _createCard(cardName, ['preludeCards']);
}

export function newCeo(cardName: CardName): ICeoCard | undefined {
  return _createCard(cardName, ['ceoCards']);
}

export function preludesFromJSON(cards: Array<CardName>): Array<IPreludeCard> {
  if (cards === undefined) {
    console.warn('missing cards calling preludesFromJSON');
    return [];
  }
  const result: Array<IPreludeCard> = [];
  cards.forEach((element: CardName) => {
    const card = newPrelude(element);
    if (card !== undefined) {
      result.push(card);
    } else {
      console.warn(`card ${element} not found while loading game.`);
    }
  });
  return result;
}

export function ceosFromJSON(cards: Array<CardName>): Array<ICeoCard> {
  if (cards === undefined) {
    console.warn('missing cards calling ceosFromJSON');
    return [];
  }
  const result: Array<ICeoCard> = [];
  cards.forEach((element: CardName) => {
    const card = newCeo(element);
    if (card !== undefined) {
      result.push(card);
    } else {
      console.warn(`card ${element} not found while loading game.`);
    }
  });
  return result;
}

export function cardsFromJSON(cards: Array<CardName>): Array<IProjectCard> {
  if (cards === undefined) {
    console.warn('missing cards calling cardsFromJSON');
    return [];
  }
  const result: Array<IProjectCard> = [];
  cards.forEach((element: CardName) => {
    const card = newProjectCard(element);
    if (card !== undefined) {
      result.push(card);
    } else {
      console.warn(`card ${element} not found while loading game.`);
    }
  });
  return result;
}

export function corporationCardsFromJSON(cards: Array<CardName>): Array<ICorporationCard> {
  if (cards === undefined) {
    console.warn('missing cards calling corporationCardsFromJSON');
    return [];
  }
  const result: Array<ICorporationCard> = [];
  cards.forEach((element: CardName) => {
    const card = newCorporationCard(element);
    if (card !== undefined) {
      result.push(card);
    } else {
      console.warn(`corporation ${element} not found while loading game.`);
    }
  });
  return result;
}

================
File: database/Cache.ts
================
import {IGame} from '../IGame';
import {GameId, ParticipantId} from '../../common/Types';
import {once} from 'events';
import {EventEmitter} from 'events';
import {Database} from './Database';
import {CacheConfig} from './CacheConfig';
import {Clock} from '../../common/Timer';

export class Cache extends EventEmitter {
  private loaded = false;
  private readonly games = new Map<GameId, IGame | undefined>();
  private readonly participantIds = new Map<ParticipantId, GameId>();
  private readonly db = Database.getInstance();

  /** Map of game IDs and the time they were scheduled for eviction */
  private readonly evictionSchedule: Map<GameId, number> = new Map();
  private readonly config: CacheConfig;
  private readonly clock: Clock;

  constructor(config: CacheConfig, clock: Clock) {
    super();
    this.config = config;
    this.clock = clock;
  }

  public async load(): Promise<void> {
    try {
      console.log('Preloading IDs.');
      const entries = await this.db.getParticipants();
      for (const entry of entries) {
        const gameId = entry.gameId;
        if (this.games.get(gameId) === undefined) {
          this.games.set(gameId, undefined);
          entry.participantIds.forEach((participant) => this.participantIds.set(participant, gameId));
        }
      }
      console.log(`Preloaded ${entries.length} IDs.`);
    } catch (err) {
      console.error('error loading all games', err);
    }
    this.loaded = true;
    this.emit('loaded');
    if (this.config.sweep === 'auto') {
      scheduleSweep(this, this.config.sleepMillis);
    }
  }

  public async getGames(): Promise<{games:Map<GameId, IGame | undefined>, participantIds:Map<ParticipantId, GameId>}> {
    if (!this.loaded) {
      await once(this, 'loaded');
    }
    return {games: this.games, participantIds: this.participantIds};
  }

  public mark(gameId: GameId) {
    console.log(`Marking ${gameId} to be evicted in ${this.config.evictMillis}ms`);
    this.evictionSchedule.set(gameId, this.clock.now() + this.config.evictMillis);
  }

  public sweep() {
    console.log('Starting sweep');
    const now = this.clock.now();
    for (const entry of this.evictionSchedule.entries()) {
      if (entry[1] <= now) {
        const gameId = entry[0];
        console.log(`evicting ${gameId}`);
        this.evict(gameId);
        this.evictionSchedule.delete(gameId);
      }
    }
    console.log('Finished sweep');
  }

  private evict(gameId: GameId) {
    const game = this.games.get(gameId);
    if (game === undefined) return;
    game.getPlayers().forEach((p) => p.tearDown());
    this.games.set(gameId, undefined); // Setting to undefied is the same as "not yet loaded."
  }
}

function scheduleSweep(cache: Cache, sleepMillis: number) {
  console.log(`Sweeper sleeping for ${sleepMillis}ms`);
  setTimeout(() => {
    try {
      cache.sweep();
    } catch (err) {
      console.error(err);
    }
    scheduleSweep(cache, sleepMillis);
  }, sleepMillis);
}

================
File: database/CacheConfig.ts
================
export type CacheConfig = {
  sweep: 'auto' | 'manual',
  evictMillis: number,
  sleepMillis: number,
}

================
File: database/Cloner.ts
================
import {Game} from '../Game';
import {IGame} from '../IGame';
import {GameId, isPlayerId} from '../../common/Types';
import {GameSetup} from '../GameSetup';
import {IPlayer} from '../IPlayer';
import {PlayerId} from '../../common/Types';
import {SerializedGame} from '../SerializedGame';
import {SerializedPlayer} from '../SerializedPlayer';

export class Cloner {
  public static clone(
    newGameId: GameId,
    players: Array<IPlayer>,
    firstPlayerIndex: number,
    serialized: SerializedGame): IGame {
    const serializedGameId: GameId = serialized.id;
    const serializedPlayerIds: Array<PlayerId> = serialized.players.map((player) => player.id);
    const playerIds: Array<PlayerId> = players.map((player) => player.id);
    if (serializedPlayerIds.length !== playerIds.length) {
      throw new Error(`Failing to clone from a ${serializedPlayerIds.length} game ${serializedGameId} to a ${playerIds.length} game.`);
    }
    Cloner.replacePlayerIds(serialized, serializedPlayerIds, playerIds);
    if (serializedPlayerIds.length === 1) {
      // The neutral player has a different ID in different games, and yet, it isn't serialized. So it gets a special case.
      Cloner.replacePlayerIds(
        serialized,
        [GameSetup.neutralPlayerFor(serializedGameId).id],
        [GameSetup.neutralPlayerFor(newGameId).id]);
    }
    serialized.id = newGameId;

    for (let idx = 0; idx < players.length; idx++) {
      this.updatePlayer(players[idx], serialized.players[idx]);
    }
    serialized.first = serialized.players[firstPlayerIndex].id;
    serialized.clonedGamedId = '#' + serializedGameId;
    serialized.createdTimeMs = new Date().getTime();
    const game = Game.deserialize(serialized);
    return game;
  }

  private static replacePlayerIds(obj: any, oldPlayerIds:Array<PlayerId>, newPlayerIds: Array<PlayerId>) {
    if (obj === undefined || obj === null) {
      return;
    }
    const keys = Object.entries(obj);
    keys.forEach(([key, val]) => {
      if (obj.hasOwnProperty(key)) {
        if (isPlayerId(val)) {
          const idx = oldPlayerIds.indexOf(val);
          if (idx > -1) {
            obj[key] = newPlayerIds[idx];
          }
        } else if (typeof val === 'object') {
          Cloner.replacePlayerIds(val, oldPlayerIds, newPlayerIds);
        }
      }
    });
  }

  private static updatePlayer(from: IPlayer, to: SerializedPlayer) {
    // id is already copied over.
    to.color = from.color;
    to.name = from.name;

    // Handicap updates are only done during game set-up. So when cloning, adjust the
    // terraforming rating to the difference between the two handicaps.
    const terraformRatingDelta = Number(from.handicap) - Number(to.handicap);
    const newTerraformRating = Number(to.terraformRating) + terraformRatingDelta;
    to.terraformRating = newTerraformRating;
    // Also update the handicap to reflect appropriately.
    to.handicap = Number(from.handicap);
  }
}

================
File: database/Database.ts
================
import {PostgreSQL} from './PostgreSQL';
import {SQLite} from './SQLite';
import {IDatabase} from './IDatabase';
import {LocalFilesystem} from './LocalFilesystem';
import {LocalStorage} from './LocalStorage';

export class Database {
  private static instance: IDatabase;

  private constructor() {}

  public static getInstance() {
    if (!Database.instance) {
      if (process.env.POSTGRES_HOST !== undefined) {
        console.log('Connecting to Postgres database.');
        Database.instance = new PostgreSQL();
      } else if (process.env.LOCAL_FS_DB !== undefined) {
        console.log('Connecting to local filesystem database.');
        Database.instance = new LocalFilesystem();
      } else if (process.env.LOCAL_STORAGE_DB !== undefined) {
        console.log('Connecting to local storage database.');
        Database.instance = new LocalStorage();
      } else {
        console.log('Connecting to SQLite database.');
        Database.instance = new SQLite();
      }
    }
    return Database.instance;
  }
}

================
File: database/GameLoader.ts
================
import * as prometheus from 'prom-client';
import {Database} from './Database';
import {Game} from '../Game';
import {IGame} from '../IGame';
import {PlayerId, GameId, SpectatorId, isGameId, ParticipantId} from '../../common/Types';
import {IGameLoader} from './IGameLoader';
import {GameIdLedger} from './IDatabase';
import {Cache} from './Cache';
import {MultiMap} from 'mnemonist';
import {timeAsync} from '../utils/timer';
import {durationToMilliseconds} from '../utils/durations';
import {CacheConfig} from './CacheConfig';
import {Clock} from '../../common/Timer';

const metrics = {
  initialize: new prometheus.Gauge({
    name: 'gameloader_initialize',
    help: 'Time to load all games',
    registers: [prometheus.register],
  }),
  evictions: new prometheus.Counter({
    name: 'gameloader_evictions',
    help: 'Game evictions count',
    registers: [prometheus.register],
  }),
};

/**
 * Loads games from javascript memory or database
 * Loads games from database sequentially as needed
 */
export class GameLoader implements IGameLoader {
  private static instance?: GameLoader;

  private cache: Cache;
  private readonly config: CacheConfig;
  private readonly clock: Clock;
  private purgedGames: Array<GameId>;

  private constructor(config: CacheConfig, clock: Clock) {
    this.config = config;
    this.clock = clock;
    this.cache = new Cache(config, clock);
    this.purgedGames = [];
    timeAsync(this.cache.load())
      .then((v) => {
        metrics.initialize.set(v.duration);
      });
  }

  public static getInstance(): IGameLoader {
    if (GameLoader.instance === undefined) {
      const config = parseConfigString(process.env.GAME_CACHE ?? '');
      GameLoader.instance = new GameLoader(config, new Clock());
    }
    return GameLoader.instance;
  }

  public static newTestInstance(config: CacheConfig, clock: Clock): GameLoader {
    return new GameLoader(config, clock);
  }

  public resetForTesting(): void {
    this.cache = new Cache(this.config, this.clock);
    this.cache.load();
  }

  public async add(game: IGame): Promise<void> {
    const d = await this.cache.getGames();
    d.games.set(game.id, game);
    if (game.spectatorId !== undefined) {
      d.participantIds.set(game.spectatorId, game.id);
    }
    for (const player of game.getPlayers()) {
      d.participantIds.set(player.id, game.id);
    }
  }

  public async getIds(): Promise<Array<GameIdLedger>> {
    const d = await this.cache.getGames();
    const map = new MultiMap<GameId, ParticipantId>();
    d.participantIds.forEach((gameId, participantId) => map.set(gameId, participantId));
    const arry: Array<[GameId, Array<PlayerId | SpectatorId>]> = Array.from(map.associations());
    return arry.map(([gameId, participantIds]) => ({gameId, participantIds}));
  }

  public async isCached(gameId: GameId): Promise<boolean> {
    const d = await this.cache.getGames();
    return d.games.get(gameId) !== undefined;
  }

  public async getGame(id: GameId | PlayerId | SpectatorId, forceLoad: boolean = false): Promise<IGame | undefined> {
    const d = await this.cache.getGames();
    const gameId = isGameId(id) ? id : d.participantIds.get(id);
    if (gameId === undefined) return undefined;

    // 1. Check the cache as long as forceLoad isn't true.
    if (forceLoad === false && d.games.get(gameId) !== undefined) return d.games.get(gameId);

    // 2. The game isn't cached. If it's in the database, there will still be an entry
    // for it in the cache.
    if (d.games.has(gameId)) {
      try {
        const serializedGame = await Database.getInstance().getGame(gameId);
        if (serializedGame === undefined) {
          console.error(`GameLoader:loadGame: game ${gameId} not found`);
          return undefined;
        }
        const game = Game.deserialize(serializedGame);
        await this.add(game);
        console.log(`GameLoader loaded game ${gameId} into memory from database`);
        return game;
      } catch (e) {
        console.error('GameLoader:loadGame', e);
        return undefined;
      }
    }

    // Otherwise the game ID isn't valid.
    return undefined;
  }

  public async restoreGameAt(gameId: GameId, saveId: number): Promise<IGame> {
    const current = await this.getGame(gameId);
    if (current === undefined) {
      throw new Error('Cannot find game');
    }
    const currentSaveId = current.lastSaveId;
    const serializedGame = await Database.getInstance().getGameVersion(gameId, saveId);
    const game = Game.deserialize(serializedGame);
    const deletes = (currentSaveId - saveId) - 1;
    if (deletes > 0) {
      await Database.getInstance().deleteGameNbrSaves(gameId, deletes);
    }
    await this.add(game);
    game.undoCount++;
    return game;
  }

  public mark(gameId: GameId) {
    this.cache.mark(gameId);
  }

  public sweep() {
    this.cache.sweep();
  }

  public async completeGame(game: IGame) {
    const database = Database.getInstance();
    await database.saveGame(game);
    try {
      this.mark(game.id);
      await database.markFinished(game.id);
      await this.maintenance();
    } catch (err) {
      console.error(err);
    }
  }

  public saveGame(game: IGame): Promise<void> {
    if (this.purgedGames.includes(game.id)) {
      throw new Error('This game no longer exists');
    }
    return Database.getInstance().saveGame(game);
  }

  public async maintenance() {
    const database = Database.getInstance();
    const purgedGames = await database.purgeUnfinishedGames();
    this.purgedGames.push(...purgedGames);
    await database.compressCompletedGames();
  }
}

function parseConfigString(stringValue: string): CacheConfig {
  const options: CacheConfig = {
    sweep: 'manual', // default is manual
    evictMillis: durationToMilliseconds('15m'),
    sleepMillis: durationToMilliseconds('5m'),
  };
  const parsed = Object.fromEntries((stringValue ?? '').split(';').map((s) => s.split('=', 2)));
  if (parsed.sweep === 'auto' || parsed.sweep === 'manual') {
    options.sweep = parsed.sweep;
  } else if (parsed.sweep !== undefined) {
    throw new Error('invalid sweep option from GAME_CACHE: ' + parsed.sweep);
  }
  const evictMillis = durationToMilliseconds(parsed.eviction_age);
  if (!isNaN(evictMillis)) options.evictMillis = evictMillis;
  const sleepMillis = durationToMilliseconds(parsed.sweep_freq);
  if (isNaN(sleepMillis)) options.sleepMillis = sleepMillis;
  return options;
}

================
File: database/IDatabase.ts
================
import {IGame, Score} from '../IGame';
import {GameOptions} from '../game/GameOptions';
import {GameId, ParticipantId} from '../../common/Types';
import {SerializedGame} from '../SerializedGame';

export type GameIdLedger = {gameId: GameId, participantIds: Array<ParticipantId>}

/**
 * A game store. Load, save, you know the drill.
 *
 * Each game has a unique ID represented belowe as `gameId`. As games proceed,
 * the game is saved at later states. Inidividual saves of a game's state have a
 * unique and growing `saveId`. A game's initial _save point_ is always 0.
 *
 * Game state is stored as a single JSON string, which is why the `game` parameter is
 * often JSON.
 *
 * Finally, `players` as a number merely represents the number of players
 * in the game. Why, I have no idea, says kberg.
*/
export interface IDatabase {

    /**
     * Creates any tables needed
     */
    initialize(): Promise<unknown>;

    /**
     * Pulls most recent version of game
     * @param gameId the game id to load
     */
    getGame(gameId: string): Promise<SerializedGame>;

    /**
     * Finds the game id associated with the given player.
     *
     * This is not yet written efficiently in Postgres, so use sparingly.
     *
     * @param id the `PlayerId` or `SpectatorId` assocaited with a game
     */
    getGameId(id: ParticipantId): Promise<GameId>;

    /**
     * Get all the save ids assocaited with a game.
     */
    getSaveIds(gameId: GameId): Promise<Array<number>>;

    /**
     * Load a game at a specific save point.
     */
    getGameVersion(gameId: GameId, saveId: number): Promise<SerializedGame>;

    /**
     * Return a list of all game IDs.
     *
     * When the server starts games will be loaded from first to last. The postgres implmentation
     * speeds up loading by sorting game ids so games most recently updated are loaded first, thereby
     * being available sooner than other games.
     */
    getGameIds(): Promise<Array<GameId>>;

    /**
     * Get the player count for a game.
     *
     * @param gameId the game id to search for
     */
    getPlayerCount(gameId: GameId): Promise<number>;

    /**
     * Saves the current state of the game. at a supplied save point. Used for
     * interim game updates.
     *
     * Do not call directly.
     */
    saveGame(game: IGame): Promise<void>;

    /**
     * Stores the results of a game in perpetuity in a separate table from normal
     * games. Called at a game's conclusion along with {@link markFinished}.
     *
     * This is not impliemented in {@link SQLite}.
     *
     * @param generations the generation number at the end of the game
     * @param gameOptions the options used for this game.
     * @param scores an array of scores correlated to the player's corporation.
     */
    saveGameResults(gameId: GameId, players: number, generations: number, gameOptions: GameOptions, scores: Array<Score>): void;

    /**
     * Deletes the last `rollbackCount` saves of the specified game.
     *
     * Used as part of undo, reset, and via API to roll back a broken game.
     */
    deleteGameNbrSaves(gameId: GameId, rollbackCount: number): Promise<void>;

    /**
     * A maintenance task on a single game to mark it as complete.
     *
     * It will:
     *
     * * Mark the game as finished.
     * * Put it on queue to compress it after a given amount of time.
     *   (Purges all saves between `(0, last save]`.)
     */
    markFinished(gameId: GameId): Promise<void>;


    /**
     * A maintenance task that purges abandoned solo games older
     * than a given date range.
     *
     * Behavior when the environment variable is absent is system-dependent:
     * * In PostgreSQL, it uses a default of 10 days
     * * In Sqlite, it doesn't purge
     * * This whole method is ignored in LocalFilesystem.
     *
     * Returns a list of purged Game IDs.
     */
    purgeUnfinishedGames(maxGameDays?: string): Promise<Array<GameId>>;

    /**
     * A maintenance task that compresses completed games.
     */
    compressCompletedGames(maxGameDays?: string): Promise<unknown>;

    /**
     * Generate database statistics for admin purposes.
     *
     * Key/value responses will vary between databases.
     */
    stats(): Promise<{[key: string]: string | number}>;

    storeParticipants(entry: GameIdLedger): Promise<void>;
    getParticipants(): Promise<Array<GameIdLedger>>;
}

================
File: database/IGameLoader.ts
================
import {IGame} from '../IGame';
import {PlayerId, GameId, SpectatorId} from '../../common/Types';
import {GameIdLedger} from './IDatabase';

/**
 * Loads games from javascript memory or database
 * Loads games from database sequentially as needed
 */
export interface IGameLoader {
  add(game: IGame): Promise<void>;
  getIds(): Promise<Array<GameIdLedger>>;
  /**
   * Fetches a game from the GameLoader cache.
   *
   * @param {GameId | PlayerId | SpectatorId} id the id of the game to retrieve, or
   * one of its player ids, or its spectator id.
   * @param {boolean} forceLoad (default is false.) When true always load from the database,
   * which refreshes the cache. This should never be true during an active game except when
   * doing an adminstrative rollback. Don't even make this true for normal game undos.
   * That's what `restoreGameAt` is for.
   */
  getGame(id: GameId | PlayerId | SpectatorId, forceLoad?: boolean): Promise<IGame | undefined>;
  restoreGameAt(gameId: GameId, saveId: number): Promise<IGame>;
  /**
   * Mark a game to be purged from the cache. It will be
   * purged a a future call to `sweep`.
   *
   * @param {GameId} gameId the game to be removed from the cache. Only call this for completed games.
   */
  mark(gameId: GameId): void;

  /**
   * Saves a game (but takes into account that the game might have already been purged.)
   *
   * Do not call IDatabase.saveGame directly in a running system.
   */
  saveGame(game: IGame): Promise<void>;
  completeGame(game: IGame): Promise<void>;
  maintenance(): Promise<void>;
}

================
File: database/LocalFilesystem.ts
================
import {GameIdLedger, IDatabase} from './IDatabase';
import {IGame, Score} from '../IGame';
import {GameOptions} from '../game/GameOptions';
import {GameId, isGameId, ParticipantId} from '../../common/Types';
import {SerializedGame} from '../SerializedGame';
import {Dirent, existsSync, mkdirSync, readdirSync, readFileSync, unlinkSync, writeFileSync} from 'fs';

const path = require('path');
const defaultDbFolder = path.resolve(process.cwd(), './db/files');

export class LocalFilesystem implements IDatabase {
  protected readonly dbFolder: string;
  private readonly historyFolder: string;
  private readonly completedFolder: string;

  constructor(dbFolder: string = defaultDbFolder) {
    this.dbFolder = dbFolder;
    this.historyFolder = path.resolve(dbFolder, 'history');
    this.completedFolder = path.resolve(dbFolder, 'completed');
  }

  public initialize(): Promise<void> {
    console.log(`Starting local database at ${this.dbFolder}`);
    if (!existsSync(this.dbFolder)) {
      mkdirSync(this.dbFolder);
    }
    if (!existsSync(this.historyFolder)) {
      mkdirSync(this.historyFolder);
    }
    if (!existsSync(this.completedFolder)) {
      mkdirSync(this.completedFolder);
    }
    return Promise.resolve();
  }

  private filename(gameId: string): string {
    return path.resolve(this.dbFolder, `${gameId}.json`);
  }

  private historyFilename(gameId: string, saveId: number) {
    const saveIdString = saveId.toString().padStart(5, '0');
    return path.resolve(this.historyFolder, `${gameId}-${saveIdString}.json`);
  }

  private completedFilename(gameId: string) {
    return path.resolve(this.completedFolder, `${gameId}.json`);
  }

  saveGame(game: IGame): Promise<void> {
    console.log(`saving ${game.id} at position ${game.lastSaveId}`);
    this.saveSerializedGame(game.serialize());
    game.lastSaveId++;
    return Promise.resolve();
  }

  saveSerializedGame(serializedGame: SerializedGame): void {
    const text = JSON.stringify(serializedGame, null, 2);
    writeFileSync(this.filename(serializedGame.id), text);
    writeFileSync(this.historyFilename(serializedGame.id, serializedGame.lastSaveId), text);
  }

  getGame(gameId: GameId): Promise<SerializedGame> {
    try {
      console.log(`Loading ${gameId}`);
      const text = readFileSync(this.filename(gameId));
      const serializedGame = JSON.parse(text.toString());
      return Promise.resolve(serializedGame);
    } catch (e) {
      const error = e instanceof Error ? e : new Error(String(e));
      throw error;
    }
  }

  async getGameId(participantId: ParticipantId): Promise<GameId> {
    const participants = await this.getParticipants();
    for (const entry of participants) {
      if (entry.participantIds.includes(participantId)) {
        return entry.gameId;
      }
    }
    throw new Error(`participant id ${participantId} not found`);
  }

  getSaveIds(gameId: GameId): Promise<Array<number>> {
    const results: Array<number> = [];
    const entries = readdirSync(this.historyFolder, {withFileTypes: true});
    for (const dirent of entries) {
      if (dirent.name.startsWith(gameId + '-') && dirent.isFile()) {
        const match = dirent.name.match(/(.*)-(.*).json/);
        if (match !== null) {
          const saveIdAsString = match[2];
          results.push(Number(saveIdAsString));
        }
      }
    }
    return Promise.resolve(results);
  }

  getGameVersion(gameId: GameId, saveId: number): Promise<SerializedGame> {
    try {
      console.log(`Loading ${gameId} at ${saveId}`);
      const text = readFileSync(this.historyFilename(gameId, saveId));
      const serializedGame = JSON.parse(text.toString());
      return Promise.resolve(serializedGame);
    } catch (e) {
      console.log(e);
      return Promise.reject(new Error(`Game ${gameId} not found at save_id ${saveId}`));
    }
  }

  async getPlayerCount(gameId: GameId): Promise<number> {
    const gameIds = await this.getGameIds();
    const found = gameIds.find((gId) => gId === gameId && existsSync(this.historyFilename(gameId, 0)));
    if (found === undefined) {
      throw new Error(`${gameId} not found`);
    }
    const text = readFileSync(this.historyFilename(gameId, 0));
    const serializedGame = JSON.parse(text.toString()) as SerializedGame;
    return serializedGame.players.length;
  }

  getGameIds(): Promise<Array<GameId>> {
    const gameIds: Array<GameId> = [];

    readdirSync(this.dbFolder, {withFileTypes: true}).forEach((dirent: Dirent) => {
      const gameId = this.asGameId(dirent);
      if (gameId !== undefined) {
        gameIds.push(gameId);
      }
    });
    return Promise.resolve(gameIds);
  }

  saveGameResults(gameId: GameId, players: number, generations: number, gameOptions: GameOptions, scores: Array<Score>): void {
    const obj = {gameId, players, generations, gameOptions, scores};
    const text = JSON.stringify(obj, null, 2);
    writeFileSync(this.completedFilename(gameId), text);
  }

  markFinished(_gameId: GameId): Promise<void> {
    // Not implemented here.
    return Promise.resolve();
  }

  purgeUnfinishedGames(): Promise<Array<GameId>> {
    // Not implemented.
    return Promise.resolve([]);
  }

  compressCompletedGames(): Promise<unknown> {
    // Not implemented.
    return Promise.resolve();
  }

  deleteGameNbrSaves(gameId: GameId, rollbackCount: number): Promise<void> {
    if (rollbackCount <= 0) {
      console.error(`invalid rollback count for ${gameId}: ${rollbackCount}`);
      // Should this be an error?
      return Promise.resolve();
    }

    return this.getSaveIds(gameId).then((saveIds) => {
      const versionsToDelete = saveIds.slice(-rollbackCount);
      for (const version of versionsToDelete) {
        this.deleteVersion(gameId, version);
      }
      return undefined;
    });
  }

  public stats(): Promise<{[key: string]: string | number}> {
    return Promise.resolve({
      type: 'Local Filesystem',
      path: this.dbFolder.toString(),
      history_path: this.historyFolder.toString(),
    });
  }

  public storeParticipants(_entry: GameIdLedger): Promise<void> {
    // Not necessary.
    return Promise.resolve();
  }

  private asGameId(dirent: Dirent): GameId | undefined {
    if (!dirent.isFile()) return undefined;
    const re = /(.*).json/;
    const result = dirent.name.match(re);
    if (result === null) return undefined;
    return isGameId(result[1]) ? result[1] : undefined;
  }

  public getParticipants(): Promise<Array<GameIdLedger>> {
    const gameIds: Array<GameIdLedger> = [];

    readdirSync(this.dbFolder, {withFileTypes: true}).forEach((dirent: Dirent) => {
      const gameId = this.asGameId(dirent);
      if (gameId !== undefined) {
        try {
          const text = readFileSync(this.filename(gameId));
          const game: SerializedGame = JSON.parse(text.toString());
          const participantIds: Array<ParticipantId> = game.players.map((p) => p.id);
          if (game.spectatorId) participantIds.push(game.spectatorId);
          gameIds.push({gameId, participantIds});
        } catch (e) {
          console.error(`While reading ${gameId} `, e);
        }
      }
    });
    return Promise.resolve(gameIds);
  }

  private deleteVersion(gameId: GameId, version: number) {
    unlinkSync(this.historyFilename(gameId, version));
  }
}

================
File: database/LocalStorage.ts
================
import {GameIdLedger, IDatabase} from './IDatabase';
import {IGame, Score} from '../IGame';
import {GameOptions} from '../game/GameOptions';
import {GameId, ParticipantId} from '../../common/Types';
import {SerializedGame} from '../SerializedGame';

let storage: Storage;

if (typeof localStorage !== 'undefined') {
  storage = localStorage;
} else {
  let map: {[x: string]: string} = {};

  storage = {
    length: 0,
    clear: function() {
      map = {};
    },
    key: function(i) {
      return Object.keys(map)[i] ?? null;
    },
    getItem: function(key) {
      return map[key] ?? null;
    },
    removeItem: function(key) {
      delete map[key];
    },
    setItem: function(key, value) {
      map[key] = value;
    },
  };
  Object.defineProperty(storage, 'length', {
    get: function() {
      return Object.keys(map).length;
    },
  });
}

export class LocalStorage implements IDatabase {
  public initialize(): Promise<void> {
    console.log(`Starting local storage database`);
    return Promise.resolve();
  }

  protected clear(): void {
    storage.clear();
  }

  saveGame(game: IGame): Promise<void> {
    console.log(`saving ${game.id} at position ${game.lastSaveId}`);
    this.saveSerializedGame(game.serialize());
    game.lastSaveId++;
    return Promise.resolve();
  }

  saveSerializedGame(serializedGame: SerializedGame): void {
    const text = JSON.stringify(serializedGame, null, 2);
    storage.setItem('game:' + serializedGame.id, text);
    storage.setItem('game:' + serializedGame.id + ':' + serializedGame.lastSaveId, text);
  }

  getGame(gameId: GameId): Promise<SerializedGame> {
    try {
      console.log(`Loading ${gameId}`);
      const text = storage.getItem('game:' + gameId);
      if (text === null) {
        throw new Error('game not found ' + gameId);
      }
      const serializedGame = JSON.parse(text.toString());
      return Promise.resolve(serializedGame);
    } catch (e) {
      const error = e instanceof Error ? e : new Error(String(e));
      return Promise.reject(error);
    }
  }

  async getGameId(participantId: ParticipantId): Promise<GameId> {
    const participants = await this.getParticipants();
    for (const entry of participants) {
      if (entry.participantIds.includes(participantId)) {
        return entry.gameId;
      }
    }
    throw new Error(`participant id ${participantId} not found`);
  }

  getSaveIds(gameId: GameId): Promise<Array<number>> {
    const results: Array<number> = [];
    for (let i = 0; i < storage.length; i++) {
      const key = storage.key(i);
      if (key === null || key === 'game:' + gameId) {
        continue;
      }
      if (key.startsWith('game:' + gameId)) {
        const parts = key.split(':');
        results.push(Number(parts[2]));
      }
    }
    return Promise.resolve(results);
  }

  getGameVersion(gameId: GameId, saveId: number): Promise<SerializedGame> {
    try {
      console.log(`Loading ${gameId} at ${saveId}`);
      const text = storage.getItem('game:' + gameId + ':' + saveId);
      if (text === null) {
        throw new Error('game not found');
      }
      const serializedGame = JSON.parse(text.toString());
      return Promise.resolve(serializedGame);
    } catch (e) {
      console.log(e);
      return Promise.reject(new Error(`Game ${gameId} not found at save_id ${saveId}`));
    }
  }

  getPlayerCount(gameId: GameId): Promise<number> {
    const text = storage.getItem('game:' + gameId);
    if (text === null) {
      return Promise.reject(new Error('game not found ' + gameId));
    }
    const serializedGame = JSON.parse(text.toString()) as SerializedGame;
    return Promise.resolve(serializedGame.players.length);
  }

  getGameIds(): Promise<Array<GameId>> {
    const gameIds: Array<GameId> = [];

    for (let i = 0; i < storage.length; i++) {
      const key = storage.key(i);
      if (key !== null && key.startsWith('game:') && key.split(':').length === 2) {
        gameIds.push(key.substring('game:'.length) as `g${string}`);
      }
    }
    return Promise.resolve(gameIds);
  }

  saveGameResults(gameId: GameId, players: number, generations: number, gameOptions: GameOptions, scores: Array<Score>): void {
    const obj = {gameId, players, generations, gameOptions, scores};
    const text = JSON.stringify(obj, null, 2);
    storage.setItem('completed:' + gameId, text);
  }

  markFinished(_gameId: GameId): Promise<void> {
    // Not implemented here.
    return Promise.resolve();
  }

  purgeUnfinishedGames(): Promise<Array<GameId>> {
    // Not implemented.
    return Promise.resolve([]);
  }

  compressCompletedGames(): Promise<unknown> {
    // Not implemented.
    return Promise.resolve();
  }

  deleteGameNbrSaves(gameId: GameId, rollbackCount: number): Promise<void> {
    if (rollbackCount <= 0) {
      console.error(`invalid rollback count for ${gameId}: ${rollbackCount}`);
      // Should this be an error?
      return Promise.resolve();
    }

    return this.getSaveIds(gameId).then((saveIds) => {
      const versionsToDelete = saveIds.slice(-rollbackCount);
      for (const version of versionsToDelete) {
        storage.removeItem('game:' + gameId + ':' + version);
      }
    });
  }

  public stats(): Promise<{[key: string]: string | number}> {
    return Promise.resolve({
      type: 'Local Storage',
    });
  }

  public storeParticipants(_entry: GameIdLedger): Promise<void> {
    // Not necessary.
    return Promise.resolve();
  }

  public getParticipants(): Promise<Array<GameIdLedger>> {
    const gameIds: Array<GameIdLedger> = [];
    for (let i = 0; i < storage.length; i++) {
      const key = storage.key(i);
      if (key !== null && key.startsWith('game:') && key.split(':').length === 2) {
        const text = storage.getItem(key);
        if (text === null) {
          continue;
        }
        const game: SerializedGame = JSON.parse(text.toString());
        const participantIds: Array<ParticipantId> = game.players.map((p) => p.id);
        if (game.spectatorId) participantIds.push(game.spectatorId);
        gameIds.push({gameId: game.id, participantIds});
      }
    }
    return Promise.resolve(gameIds);
  }
}

================
File: database/PostgreSQL.ts
================
import type * as pg from 'pg';
import {IDatabase} from './IDatabase';
import {IGame, Score} from '../IGame';
import {GameOptions} from '../game/GameOptions';
import {GameId, ParticipantId, isGameId, safeCast} from '../../common/Types';
import {SerializedGame} from '../SerializedGame';
import {daysAgoToSeconds} from './utils';
import {GameIdLedger} from './IDatabase';
import {oneWayDifference} from '../../common/utils/utils';

export class PostgreSQL implements IDatabase {
  private databaseName: string | undefined = undefined; // Use this only for stats.

  protected statistics = {
    saveCount: 0,
    saveErrorCount: 0,
    saveConflictUndoCount: 0,
    saveConflictNormalCount: 0,
  };
  private _client: pg.Pool | undefined;

  protected get client(): pg.Pool {
    if (this._client === undefined) {
      throw new Error('attempt to get client before intialized');
    }
    return this._client;
  }

  constructor(
    private config: pg.ClientConfig = {
      connectionString: process.env.POSTGRES_HOST,
    }) {
    if (config.connectionString?.startsWith('postgres')) {
      config.ssl = {
        // heroku uses self-signed certificates
        rejectUnauthorized: false,
      };
    }

    if (config.database) {
      this.databaseName = config.database;
    } else if (config.connectionString) {
      try {
        // Remove leading / from pathname.
        this.databaseName = new URL(config.connectionString).pathname.replace(/^\//, '');
      } catch (e) {
        console.log(e);
      }
    }
  }

  public async initialize(): Promise<void> {
    const {Pool} = await import('pg');
    this._client = new Pool(this.config);
    await this.client.query('CREATE TABLE IF NOT EXISTS games(game_id varchar, players integer, save_id integer, game text, status text default \'running\', created_time timestamp default now(), PRIMARY KEY (game_id, save_id))');
    await this.client.query('CREATE TABLE IF NOT EXISTS participants(game_id varchar, participants varchar[], PRIMARY KEY (game_id))');
    await this.client.query('CREATE TABLE IF NOT EXISTS game_results(game_id varchar not null, seed_game_id varchar, players integer, generations integer, game_options text, scores text, PRIMARY KEY (game_id))');
    await this.client.query('CREATE TABLE IF NOT EXISTS completed_game(game_id varchar not null, completed_time timestamp default now(), PRIMARY KEY (game_id))');

    await this.client.query('CREATE INDEX IF NOT EXISTS games_i1 on games(save_id)');
    await this.client.query('CREATE INDEX IF NOT EXISTS games_i2 on games(created_time)');
    await this.client.query('CREATE INDEX IF NOT EXISTS participants_idx_ids on participants USING GIN (participants)');
    await this.client.query('CREATE INDEX IF NOT EXISTS completed_game_idx_completed_time on completed_game(completed_time)');
  }

  public async getPlayerCount(gameId: GameId): Promise<number> {
    const sql = 'SELECT players FROM games WHERE save_id = 0 AND game_id = $1 LIMIT 1';

    const res = await this.client.query(sql, [gameId]);
    if (res.rows.length === 0) {
      throw new Error(`no rows found for game id ${gameId}`);
    }
    return res.rows[0].players;
  }

  public async getGameIds(): Promise<Array<GameId>> {
    // To only load incomplete games add `WHERE status=\'running\'`
    // above "GROUP BY game_id) a"
    const sql: string =
    `SELECT games.game_id
    FROM games, (
      SELECT max(save_id) save_id, game_id
      FROM games
      GROUP BY game_id) a
    WHERE games.game_id = a.game_id
    AND games.save_id = a.save_id
    ORDER BY created_time DESC`;
    const res = await this.client.query(sql);
    return res.rows.map((row) => row.game_id);
  }

  public async getGame(gameId: GameId): Promise<SerializedGame> {
    // Retrieve last save from database
    const res = await this.client.query('SELECT game game FROM games WHERE game_id = $1 ORDER BY save_id DESC LIMIT 1', [gameId]);
    if (res.rows.length === 0 || res.rows[0] === undefined) {
      throw new Error(`Game ${gameId} not found`);
    }
    const json = JSON.parse(res.rows[0].game);
    return json;
  }

  public async getGameId(participantId: ParticipantId): Promise<GameId> {
    try {
      const res = await this.client.query('select game_id from participants where $1 = ANY(participants)', [participantId]);
      if (res.rowCount === 0) {
        throw new Error(`Game for player id ${participantId} not found`);
      }
      return res.rows[0].game_id;
    } catch (err) {
      console.error('PostgreSQL:getGameId', err);
      throw err;
    }
  }

  public async getSaveIds(gameId: GameId): Promise<Array<number>> {
    const res = await this.client.query('SELECT distinct save_id FROM games WHERE game_id = $1', [gameId]);
    const allSaveIds: Array<number> = [];
    res.rows.forEach((row) => {
      allSaveIds.push(row.save_id);
    });
    return Promise.resolve(allSaveIds);
  }

  async getGameVersion(gameId: GameId, saveId: number): Promise<SerializedGame> {
    const res = await this.client.query('SELECT game game FROM games WHERE game_id = $1 and save_id = $2', [gameId, saveId]);
    if (res.rowCount === 0) {
      throw new Error(`Game ${gameId} not found at save_id ${saveId}`);
    }
    return JSON.parse(res.rows[0].game);
  }

  saveGameResults(gameId: GameId, players: number, generations: number, gameOptions: GameOptions, scores: Array<Score>): void {
    this.client.query('INSERT INTO game_results (game_id, seed_game_id, players, generations, game_options, scores) VALUES($1, $2, $3, $4, $5, $6)', [gameId, gameOptions.clonedGamedId, players, generations, gameOptions, JSON.stringify(scores)], (err) => {
      if (err) {
        console.error('PostgreSQL:saveGameResults', err);
        throw err;
      }
    });
  }

  async getMaxSaveId(gameId: GameId): Promise<number> {
    const res = await this.client.query('SELECT MAX(save_id) as save_id FROM games WHERE game_id = $1', [gameId]);
    return res.rows[0].save_id;
  }

  throwIf(err: any, condition: string) {
    if (err) {
      console.error('PostgreSQL', condition, err);
      throw err;
    }
  }

  async markFinished(gameId: GameId): Promise<void> {
    const promise1 = this.client.query('UPDATE games SET status = \'finished\' WHERE game_id = $1', [gameId]);
    const promise2 = this.client.query('INSERT INTO completed_game(game_id) VALUES ($1)', [gameId]);
    await Promise.all([promise1, promise2]);
  }

  // Purge unfinished games older than MAX_GAME_DAYS days. If this environment variable is absent, it uses the default of 10 days.
  async purgeUnfinishedGames(maxGameDays: string | undefined = process.env.MAX_GAME_DAYS): Promise<Array<GameId>> {
    const dateToSeconds = daysAgoToSeconds(maxGameDays, 10);
    const selectResult = await this.client.query('SELECT DISTINCT game_id FROM games WHERE created_time < to_timestamp($1)', [dateToSeconds]);
    let gameIds = selectResult.rows.map((row) => row.game_id);
    if (gameIds.length > 1000) {
      console.log('Truncated purge to 1000 games.');
      gameIds = gameIds.slice(0, 1000);
    } else {
      console.log(`${gameIds.length} games to be purged.`);
    }

    if (gameIds.length > 0) {
      // https://github.com/brianc/node-postgres/wiki/FAQ#11-how-do-i-build-a-where-foo-in--query-to-find-rows-matching-an-array-of-values
      const deleteGamesResult = await this.client.query('DELETE FROM games WHERE game_id = ANY($1)', [gameIds]);
      console.log(`Purged ${deleteGamesResult.rowCount} rows from games`);
      const deleteParticipantsResult = await this.client.query('DELETE FROM participants WHERE game_id = ANY($1)', [gameIds]);
      console.log(`Purged ${deleteParticipantsResult.rowCount} rows from participants`);
    }
    return gameIds;
  }


  async compressCompletedGames(compressCompletedGamesDays: string | undefined = process.env.COMPRESS_COMPLETED_GAMES_DAYS): Promise<void> {
    if (compressCompletedGamesDays === undefined) {
      return;
    }
    const dateToSeconds = daysAgoToSeconds(compressCompletedGamesDays, 0);
    const selectResult = await this.client.query('SELECT DISTINCT game_id FROM completed_game WHERE completed_time < to_timestamp($1)', [dateToSeconds]);
    const gameIds = selectResult.rows.slice(0, 1000).map((row) => row.game_id);
    console.log(`${gameIds.length} completed games to be compressed.`);
    if (gameIds.length > 1000) {
      gameIds.length = 1000;
      console.log('Compressing 1000 games.');
    }
    for (const gameId of gameIds) {
      // This isn't using await because nothing really depends on it.
      this.compressCompletedGame(gameId);
    }
  }

  async compressCompletedGame(gameId: GameId): Promise<pg.QueryResult<any>> {
    const maxSaveId = await this.getMaxSaveId(gameId);
    return this.client.query('DELETE FROM games WHERE game_id = $1 AND save_id < $2 AND save_id > 0', [gameId, maxSaveId])
      .then(() => {
        return this.client.query('DELETE FROM completed_game where game_id = $1', [gameId]);
      });
  }

  async saveGame(game: IGame): Promise<void> {
    const gameJSON = game.toJSON();
    this.statistics.saveCount++;
    if (game.gameOptions.undoOption) logForUndo(game.id, 'start save', game.lastSaveId);
    try {
      // Holding onto a value avoids certain race conditions where saveGame is called twice in a row.
      const thisSaveId = game.lastSaveId;
      // xmax = 0 is described at https://stackoverflow.com/questions/39058213/postgresql-upsert-differentiate-inserted-and-updated-rows-using-system-columns-x
      const res = await this.client.query(
        `INSERT INTO games (game_id, save_id, game, players)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (game_id, save_id) DO UPDATE SET game = $3
        RETURNING (xmax = 0) AS inserted`,
        [game.id, game.lastSaveId, gameJSON, game.getPlayers().length]);

      game.lastSaveId = thisSaveId + 1;

      let inserted = true;
      try {
        inserted = res.rows[0].inserted;
      } catch (err) {
        console.error(err);
      }
      if (inserted === false) {
        if (game.gameOptions.undoOption) {
          this.statistics.saveConflictUndoCount++;
        } else {
          this.statistics.saveConflictNormalCount++;
        }
      }

      // Save IDs on the very first save for this game. That's when the incoming saveId is 0, and also
      // when the database operation was an insert. (We should figure out why multiple saves occur and
      // try to stop them. But that's for another day.)
      if (inserted === true && thisSaveId === 0) {
        const participantIds: Array<ParticipantId> = game.getPlayers().map((p) => p.id);
        if (game.spectatorId) participantIds.push(game.spectatorId);
        await this.storeParticipants({gameId: game.id, participantIds: participantIds});
      }

      if (game.gameOptions.undoOption) logForUndo(game.id, 'increment save id, now', game.lastSaveId);
    } catch (err) {
      this.statistics.saveErrorCount++;
      console.error('PostgreSQL:saveGame', err);
    }
  }

  async deleteGameNbrSaves(gameId: GameId, rollbackCount: number): Promise<void> {
    if (rollbackCount <= 0) {
      console.error(`invalid rollback count for ${gameId}: ${rollbackCount}`);
      // Should this be an error?
      return;
    }
    logForUndo(gameId, 'deleting', rollbackCount, 'saves');
    const first = await this.getSaveIds(gameId);
    const res = await this.client.query('DELETE FROM games WHERE ctid IN (SELECT ctid FROM games WHERE game_id = $1 ORDER BY save_id DESC LIMIT $2)', [gameId, rollbackCount]);
    logForUndo(gameId, 'deleted', res?.rowCount, 'rows');
    const second = await this.getSaveIds(gameId);
    logForUndo(gameId, 'second', second);
    logForUndo(gameId, 'Rollback difference', oneWayDifference(first, second));
  }

  public async storeParticipants(entry: GameIdLedger): Promise<void> {
    await this.client.query('INSERT INTO participants (game_id, participants) VALUES($1, $2)', [entry.gameId, entry.participantIds]);
  }

  public async getParticipants(): Promise<Array<{gameId: GameId, participantIds: Array<ParticipantId>}>> {
    const res = await this.client.query('select game_id, participants from participants');
    return res.rows.map((row) => {
      return {gameId: safeCast(row.game_id, isGameId), participantIds: row.participants as Array<ParticipantId>};
    });
  }

  public async stats(): Promise<{[key: string]: string | number}> {
    const map: {[key: string]: string | number}= {
      'type': 'POSTGRESQL',
      'pool-total-count': this.client.totalCount,
      'pool-idle-count': this.client.idleCount,
      'pool-waiting-count': this.client.waitingCount,
      'save-count': this.statistics.saveCount,
      'save-error-count': this.statistics.saveErrorCount,
      'save-conflict-normal-count': this.statistics.saveConflictNormalCount,
      'save-conflict-undo-count': this.statistics.saveConflictUndoCount,
    };

    const dbsizes = await this.client.query(`
    SELECT
      pg_size_pretty(pg_total_relation_size('games')) as game_size,
      pg_size_pretty(pg_total_relation_size('game_results')) as game_results_size,
      pg_size_pretty(pg_total_relation_size('participants')) as participants_size,
      pg_size_pretty(pg_database_size($1)) as db_size
    `, [this.databaseName]);

    map['size-bytes-games'] = dbsizes.rows[0].game_size;
    map['size-bytes-game-results'] = dbsizes.rows[0].game_results_size;
    map['size-bytes-participants'] = dbsizes.rows[0].participants_size;
    map['size-bytes-database'] = dbsizes.rows[0].db_size;

    // Using count(*) is inefficient, but the estimates from here
    // https://stackoverflow.com/questions/7943233/fast-way-to-discover-the-row-count-of-a-table-in-postgresql
    // seem wildly inaccurate.
    //
    // heroku pg:bloat --app terraforming-mars
    // shows some bloat
    // and the postgres command
    // VACUUM (VERBOSE) shows a fairly reasonable vacumm (no rows locked, for instance),
    // so it's not clear why those wrong. But these select count(*) commands seem pretty quick
    // in testing. :fingers-crossed:
    for (const table of ['games', 'game_results', 'participants']) {
      const result = await this.client.query('select count(*) as rowcount from ' + table);
      map['rows-' + table] = result.rows[0].rowcount;
    }
    return map;
  }
}

function logForUndo(gameId: string, ...message: any[]) {
  console.error(['TRACKING:', gameId, ...message]);
}

================
File: database/SQLite.ts
================
import * as fs from 'fs';
import * as path from 'path';

import {GameIdLedger, IDatabase} from './IDatabase';
import {IGame, Score} from '../IGame';
import {GameOptions} from '../game/GameOptions';
import {GameId, ParticipantId} from '../../common/Types';
import {SerializedGame} from '../SerializedGame';

import type * as sqlite3 from 'sqlite3';

import {daysAgoToSeconds} from './utils';
import {MultiMap} from 'mnemonist';
export const IN_MEMORY_SQLITE_PATH = ':memory:';

export class SQLite implements IDatabase {
  private _db: sqlite3.Database | undefined;

  protected get db(): sqlite3.Database {
    if (this._db === undefined) {
      throw new Error('attempt to get db before initialize');
    }
    return this._db;
  }

  constructor(private filename: undefined | string = undefined, private throwQuietFailures: boolean = false) {
  }

  public async initialize(): Promise<void> {
    const {Database} = await import('sqlite3');
    const dbFolder = path.resolve(process.cwd(), './db');
    const dbPath = path.resolve(dbFolder, 'game.db');
    if (this.filename === undefined) {
      this.filename = dbPath;
    }
    if (this.filename !== IN_MEMORY_SQLITE_PATH) {
      if (!fs.existsSync(dbFolder)) {
        fs.mkdirSync(dbFolder);
      }
    }
    this._db = new Database(String(this.filename));
    await this.asyncRun('CREATE TABLE IF NOT EXISTS games(game_id varchar, players integer, save_id integer, game text, status text default \'running\', created_time timestamp default (strftime(\'%s\', \'now\')), PRIMARY KEY (game_id, save_id))');
    await this.asyncRun('CREATE TABLE IF NOT EXISTS participants(game_id varchar, participant varchar, PRIMARY KEY (game_id, participant))');
    await this.asyncRun('CREATE TABLE IF NOT EXISTS game_results(game_id varchar not null, seed_game_id varchar, players integer, generations integer, game_options text, scores text, PRIMARY KEY (game_id))');
    await this.asyncRun(
      `CREATE TABLE IF NOT EXISTS completed_game(
      game_id varchar not null,
      completed_time timestamp not null default (strftime('%s', 'now')),
      PRIMARY KEY (game_id))`);
    await this.asyncRun('DROP TABLE IF EXISTS purges');
  }

  public async getPlayerCount(gameId: GameId): Promise<number> {
    const sql = 'SELECT players FROM games WHERE save_id = 0 AND game_id = ? LIMIT 1';
    const row = await this.asyncGet(sql, [gameId]);
    if (row === undefined) {
      throw new Error(`bad game id ${gameId}`);
    }
    return row.players;
  }

  public async getGameIds(): Promise<Array<GameId>> {
    const sql = 'SELECT distinct game_id game_id FROM games';
    const rows = await this.asyncAll(sql, []);
    return rows.map((row) => row.game_id);
  }

  saveGameResults(gameId: GameId, players: number, generations: number, gameOptions: GameOptions, scores: Array<Score>): void {
    this.db.run(
      'INSERT INTO game_results (game_id, seed_game_id, players, generations, game_options, scores) VALUES($1, $2, $3, $4, $5, $6)',
      [gameId, gameOptions.clonedGamedId, players, generations, JSON.stringify(gameOptions), JSON.stringify(scores)], (err) => {
        if (err) {
          console.error('SQLite:saveGameResults', err);
          throw err;
        }
      },
    );
  }

  public async getGame(gameId: GameId): Promise<SerializedGame> {
    // Retrieve last save from database
    const row: { game: any; } = await this.asyncGet('SELECT game game FROM games WHERE game_id = ? ORDER BY save_id DESC LIMIT 1', [gameId]);
    if (row === undefined) {
      throw new Error(`bad game id ${gameId}`);
    }
    return JSON.parse(row.game);
  }

  public async getGameId(participantId: ParticipantId): Promise<GameId> {
    // Default sql is for player id;
    let sql = 'SELECT game_id from games, json_each(games.game, \'$.players\') e where json_extract(e.value, \'$.id\') = ?';
    if (participantId.charAt(0) === 's') {
      sql = 'SELECT game_id from games where json_extract(games.game, \'$.spectatorId\') = ?';
    } else if (participantId.charAt(0) !== 'p') {
      throw new Error(`id ${participantId} is neither a player id or spectator id`);
    }

    const row: { game_id: any; } = await this.asyncGet(sql, [participantId]);
    if (row === undefined) {
      throw new Error(`No game id found for participant id ${participantId}`);
    }
    return row.game_id;
  }

  public async getSaveIds(gameId: GameId): Promise<Array<number>> {
    const rows = await this.asyncAll('SELECT distinct save_id FROM games WHERE game_id = ?', [gameId]);
    return rows.map((row) => row.save_id);
  }

  public async getGameVersion(gameId: GameId, saveId: number): Promise<SerializedGame> {
    const sql = 'SELECT game_id, game FROM games WHERE game_id = ? and save_id = ?';
    const row: { game_id: GameId, game: any; } = await this.asyncGet(sql, [gameId, saveId]);
    if (row === undefined || row.game_id === undefined || row.game === undefined) {
      throw new Error(`Game ${gameId} not found`);
    }
    return JSON.parse(row.game);
  }

  async getMaxSaveId(gameId: GameId): Promise<number> {
    const row: { save_id: any; } = await this.asyncGet('SELECT MAX(save_id) AS save_id FROM games WHERE game_id = ?', [gameId]);
    if (row === undefined) {
      throw new Error(`bad game id ${gameId}`);
    }
    return row.save_id;
  }

  async markFinished(gameId: GameId): Promise<void> {
    const promise1 = this.asyncRun('INSERT into completed_game (game_id) values (?)', [gameId]);
    const promise2 = this.asyncRun('UPDATE games SET status = \'finished\' WHERE game_id = ?', [gameId]);
    await Promise.all([promise1, promise2]);
  }


  async purgeUnfinishedGames(maxGameDays: string | undefined = process.env.MAX_GAME_DAYS): Promise<Array<GameId>> {
    // Purge unfinished games older than MAX_GAME_DAYS days. If this .env variable is not present, unfinished games will not be purged.
    if (maxGameDays !== undefined) {
      const dateToSeconds = daysAgoToSeconds(maxGameDays, 0);
      const selectResult = await this.asyncAll('SELECT DISTINCT game_id game_id FROM games WHERE created_time < ? and status = \'running\'', [dateToSeconds]);
      let gameIds = selectResult.map((row) => row.game_id);
      if (gameIds.length > 1000) {
        console.log('Truncated purge to 1000 games.');
        gameIds = gameIds.slice(0, 1000);
      } else {
        console.log(`${gameIds.length} games to be purged.`);
      }

      if (gameIds.length > 0) {
        console.log(`About to purge ${gameIds.length} games`);
        const placeholders = gameIds.map(() => '?').join(', ');
        const deleteResult = await this.asyncRun(`DELETE FROM games WHERE game_id in ( ${placeholders} )`, [...gameIds]);
        console.log(`Purged ${deleteResult.changes} rows from games`);
        const deleteParticipantsResult = await this.asyncRun(`DELETE FROM participants WHERE game_id in ( ${placeholders} )`, [...gameIds]);
        console.log(`Purged ${deleteParticipantsResult.changes} rows from participants`);
      }
      return gameIds;
    } else {
      return Promise.resolve([]);
    }
  }

  async compressCompletedGames(compressCompletedGamesDays: string | undefined = process.env.COMPRESS_COMPLETED_GAMES_DAYS): Promise<void> {
    if (compressCompletedGamesDays === undefined) {
      return;
    }
    const dateToSeconds = daysAgoToSeconds(compressCompletedGamesDays, 0);
    const selectResult = await this.asyncAll('SELECT DISTINCT game_id FROM completed_game WHERE completed_time < ?', [dateToSeconds]);
    const gameIds = selectResult.map((row) => row.game_id);
    console.log(`${gameIds.length} completed games to be compressed.`);
    if (gameIds.length > 1000) {
      gameIds.length = 1000;
      console.log('Compressing 1000 games.');
    }
    for (const gameId of gameIds) {
      // This isn't using await because nothing really depends on it.
      this.compressCompletedGame(gameId);
    }
  }

  async compressCompletedGame(gameId: GameId): Promise<sqlite3.RunResult> {
    const maxSaveId = await this.getMaxSaveId(gameId);
    return this.asyncRun('DELETE FROM games WHERE game_id = ? AND save_id < ? AND save_id > 0', [gameId, maxSaveId])
      .then(() => {
        return this.asyncRun('DELETE FROM completed_games where game_id = ?', [gameId]);
      });
  }

  async saveGame(game: IGame): Promise<void> {
    const gameJSON = game.toJSON();
    // Insert
    await this.runQuietly(
      'INSERT INTO games (game_id, save_id, game, players) VALUES (?, ?, ?, ?) ON CONFLICT (game_id, save_id) DO UPDATE SET game = ?',
      [game.id, game.lastSaveId, gameJSON, game.getPlayers().length, gameJSON]);

    // Save IDs on the very first save for this game. That's when the incoming saveId is 0, and also
    // when the database operation was an insert. (We should figure out why multiple saves occur and
    // try to stop them. But that's for another day.)
    if (game.lastSaveId === 0) {
      const participantIds: Array<ParticipantId> = game.getPlayers().map((p) => p.id);
      if (game.spectatorId) participantIds.push(game.spectatorId);
      try {
        await this.storeParticipants({gameId: game.id, participantIds: participantIds});
      } catch (e) {
        console.error(e);
      }
    }

    // This must occur after the save.
    game.lastSaveId++;
  }

  deleteGameNbrSaves(gameId: GameId, rollbackCount: number): Promise<void> {
    if (rollbackCount <= 0) {
      console.error(`invalid rollback count for ${gameId}: ${rollbackCount}`);
      // Should this be an error?
      return Promise.resolve();
    }
    return this.runQuietly('DELETE FROM games WHERE rowid IN (SELECT rowid FROM games WHERE game_id = ? ORDER BY save_id DESC LIMIT ?)', [gameId, rollbackCount]);
  }

  public stats(): Promise<{[key: string]: string | number}> {
    const size = this.filename === IN_MEMORY_SQLITE_PATH ? -1 : fs.statSync(String(this.filename)).size;

    return Promise.resolve({
      type: 'SQLite',
      path: String(this.filename),
      size_bytes: size,
    });
  }

  public async storeParticipants(entry: GameIdLedger): Promise<void> {
    // Sequence of '(?, ?)' pairs.
    const placeholders = entry.participantIds.map(() => '(?, ?)').join(', ');
    // Sequence of [game_id, id] pairs.
    const values: Array<GameId | ParticipantId> = entry.participantIds.map((participant) => [entry.gameId, participant]).flat();

    await this.asyncRun('INSERT INTO participants (game_id, participant) VALUES ' + placeholders, values);
  }

  public async getParticipants(): Promise<Array<GameIdLedger>> {
    const rows = await this.asyncAll('SELECT game_id, participant FROM participants');
    const multimap = new MultiMap<GameId, ParticipantId>();
    rows.forEach((row) => multimap.set(row.game_id, row.participant));
    const result: Array<GameIdLedger> = [];
    multimap.forEachAssociation((participantIds, gameId) => {
      result.push({gameId, participantIds});
    });
    return result;
  }

  protected asyncRun(sql: string, params?: any): Promise<sqlite3.RunResult> {
    return new Promise((resolve, reject) => {
      // It is intentional that this is declared `function` and that the first
      // parameter is `this`.
      // See https://stackoverflow.com/questions/73523387/in-node-sqlite3-does-runs-first-callback-parameter-return-error
      function cb(this: sqlite3.RunResult, err: Error | null) {
        if (err) {
          reject(err);
        } else {
          // eslint-disable-next-line no-invalid-this
          resolve(this);
        }
      }

      if (params !== undefined) {
        this.db.run(sql, params, cb);
      } else {
        this.db.run(sql, cb);
      }
    });
  }

  protected asyncGet(sql: string, params?: any): Promise<any> {
    return new Promise((resolve, reject) => {
      this.db.get(sql, params, function(err: Error | null, row: any) {
        if (err) {
          reject(err);
        } else {
          resolve(row);
        }
      });
    });
  }

  protected asyncAll(sql: string, params?: any): Promise<Array<any>> {
    return new Promise((resolve, reject) => {
      this.db.all(sql, params, function(err, rows: Array<any>) {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }

  // Run the given SQL but do not return errors.
  protected async runQuietly(sql: string, params: any): Promise<void> {
    try {
      await this.asyncRun(sql, params);
    } catch (err) {
      console.error(err);
      console.error('for sql: ' + sql);
      if (this.throwQuietFailures) {
        throw err;
      }
    }
  }
}

================
File: database/utils.ts
================
/**
 * Adds `days` days to `date`. `days can be negative.
 * @param date a valid date
 * @param days a number of days
 * @returns date + days (in days)
 */
export function addDays(date: Date, days: number) {
  const ms = Math.round(date.getTime());
  const daysInMs = days * 86400 * 1000;
  return new Date(ms + daysInMs);
}

export function dateToSeconds(date: Date) {
  return Math.round(date.getTime() / 1000);
}

export function dayStringToDays(dayString: string | undefined, defaultValue: number): number {
  const parsed = parseInt(dayString || '');
  return Number.isInteger(parsed) ? parsed : defaultValue;
}

export function daysAgoToSeconds(dayString: string | undefined, defaultValue: number): number {
  const days = dayStringToDays(dayString, defaultValue);
  const date = addDays(new Date(), -days);
  return dateToSeconds(date);
}

================
File: deferredActions/AddResourcesToCard.ts
================
import {IPlayer} from '../IPlayer';
import {SelectCard} from '../inputs/SelectCard';
import {CardResource} from '../../common/CardResource';
import {ICard} from '../cards/ICard';
import {Tag} from '../../common/cards/Tag';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {Message} from '../../common/logs/Message';
import {IProjectCard} from '../cards/IProjectCard';
import {message} from '../logs/MessageBuilder';

export type Options = {
  count?: number;
  restrictedTag?: Tag;
  min?: number;
  title?: string | Message;
  robotCards?: boolean;
  filter?(card: ICard): boolean;
  log?: boolean;
}

export class AddResourcesToCard extends DeferredAction {
  constructor(
    player: IPlayer,
    /** The card type to add to. Undefined means any resource. */
    public resourceType: CardResource | undefined,
    public options: Options = {},
  ) {
    super(player, Priority.GAIN_RESOURCE_OR_PRODUCTION);
  }

  private getCardsInPlay(): Array<ICard> {
    let cards = this.player.getResourceCards(this.resourceType);
    const restrictedTag = this.options.restrictedTag;
    if (restrictedTag !== undefined) {
      cards = cards.filter((card) => card.tags.includes(restrictedTag));
    }
    if (this.options.filter !== undefined) {
      cards = cards.filter(this.options.filter);
    }
    const min = this.options.min;
    if (min) {
      cards = cards.filter((c) => c.resourceCount >= min);
    }
    return cards;
  }

  private getSelfReplicatingRobotCards(): Array<IProjectCard> {
    if (this.options.robotCards !== true) {
      return [];
    }
    let cards = this.player.getSelfReplicatingRobotsTargetCards();
    if (this.options.restrictedTag !== undefined) {
      throw new Error('restrictedTag does not work when filtering SRR cards');
    }
    if (this.options.filter !== undefined) {
      throw new Error('Filter does not work when filtering SRR cards');
    }
    if (this.options.min) {
      const min = this.options.min;
      cards = cards.filter((c) => c.resourceCount >= min);
    }
    return cards;
  }

  /**
   * Returns the cards this deferredAction could apply to. Does not cache results.
   *
   * This is made public because of `Executor.canExecute` and should probably be someplace else.
   */
  public getCardCount(): number {
    return this.getCardsInPlay().length + this.getSelfReplicatingRobotCards().length;
  }

  public getCards(): Array<ICard> {
    return [...this.getCardsInPlay(), ...this.getSelfReplicatingRobotCards()];
  }

  public execute() {
    const qty = this.options.count ?? 1;
    const cards = this.getCards();
    if (cards.length === 0) {
      return undefined;
    }

    if (cards.length === 1) {
      this.addResource(cards[0], qty);
      return undefined;
    }

    const count = this.options.count ?? 1;
    const title = this.options.title ??
      message('Select card to add ${0} ${1}', (b) => b.number(count).string(this.resourceType || 'resources'));
    const buttonLabel = count === 1 ? 'Add resource' : 'Add resources';

    return new SelectCard(title, buttonLabel, cards)
      .andThen(([card]) => {
        this.addResource(card, qty);
        return undefined;
      });
  }

  private addResource(card: ICard, qty: number) {
    const autoLog = this.options.log !== false;
    this.player.addResourceTo(card, {qty, log: autoLog});
    this.cb(undefined);
  }
}

================
File: deferredActions/AddResourcesToCards.ts
================
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {IPlayer} from '../IPlayer';
import {CardResource} from '../../common/CardResource';
import {CardName} from '../../common/cards/CardName';
import {SelectAmount} from '../inputs/SelectAmount';
import {AndOptions} from '../inputs/AndOptions';

export class AddResourcesToCards extends DeferredAction {
  constructor(
    player: IPlayer,
    public resourceType: CardResource,
    public count: number) {
    super(player, Priority.GAIN_RESOURCE_OR_PRODUCTION);
  }

  public execute() {
    if (this.count === 0) {
      return undefined;
    }
    const cards = this.player.getResourceCards(this.resourceType);

    if (cards.length === 0) {
      return undefined;
    }
    if (cards.length === 1) {
      this.player.addResourceTo(cards[0], {qty: this.count, log: true});
      return undefined;
    }
    const map = new Map<CardName, number>();
    const options = cards.map((card) => {
      return new SelectAmount(card.name, '', 0, this.count)
        .andThen((amount) => {
          map.set(card.name, amount);
          return undefined;
        });
    });

    return new AndOptions(...options).andThen(() => {
      let sum = 0;
      cards.forEach((card) => {
        sum += map.get(card.name) ?? 0;
      });
      if (sum !== this.count) {
        throw new Error(`Expecting ${this.count} resources distributed, got ${sum}.`);
      }
      cards.forEach((card) => {
        const amount = map.get(card.name) ?? 0;
        if (amount > 0) {
          this.player.addResourceTo(card, {qty: amount, log: true});
        }
      });
      return undefined;
    });
  }
}

================
File: deferredActions/BuildColony.ts
================
import {IPlayer} from '../IPlayer';
import {SelectColony} from '../inputs/SelectColony';
import {IColony} from '../colonies/IColony';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';

export class BuildColony extends DeferredAction<IColony> {
  constructor(
    player: IPlayer,
    private options?: {
      allowDuplicate?: boolean, // Allow placing a colony on a tile that already has a colony.
      title?: string,
      colonies?: Array<IColony>, // If not specified, will accept all playable colonies.
      giveBonusTwice?: boolean, // Custom for Vital Colony. Rewards the bonus when placing a colony a second time.
    },
  ) {
    super(player, Priority.BUILD_COLONY);
  }

  public execute() {
    const colonies = this.options?.colonies || this.player.colonies.getPlayableColonies(this.options?.allowDuplicate);

    if (colonies.length === 0) {
      return undefined;
    }

    const title = this.options?.title ?? 'Select where to build a colony';
    return new SelectColony(title, 'Build', colonies)
      .andThen((colony: IColony) => {
        colony.addColony(this.player, {giveBonusTwice: this.options?.giveBonusTwice ?? false});
        this.cb(colony);
        return undefined;
      });
  }
}

================
File: deferredActions/ChooseAlliedParty.ts
================
import {OrOptions} from '../inputs/OrOptions';
import {SelectOption} from '../inputs/SelectOption';
import {IPlayer} from '../IPlayer';
import {PlayerInput} from '../PlayerInput';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {message} from '../logs/MessageBuilder';
import {IParty} from '../turmoil/parties/IParty';
import {policyDescription} from '../turmoil/Policy';

export class ChooseAlliedParty extends DeferredAction {
  constructor(
    player: IPlayer,
    public parties: ReadonlyArray<IParty>,
    public partyCb: (party: IParty) => void,
  ) {
    super(player, Priority.DEFAULT);
  }

  public execute(): PlayerInput {
    const alliedOptions = this.parties.map((party) => {
      return new SelectOption(this.partyDescription(party, this.player),
        'Select')
        .andThen(() => {
          this.partyCb(party);
          return undefined;
        });
    });
    const orPolicies = new OrOptions(...alliedOptions);
    orPolicies.title = message('Select an allied party');

    return orPolicies;
  }

  private partyDescription(party: IParty, _player: IPlayer) {
    const description = policyDescription(party.policies[0], undefined);
    return `[${party.name}] - Bonus: ${party.bonuses[0].description} -  Policy: ${description}`;
  }
}

================
File: deferredActions/ChooseCards.ts
================
import {IPlayer} from '../IPlayer';
import {IProjectCard} from '../cards/IProjectCard';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {SelectCard} from '../inputs/SelectCard';
import {SelectPaymentDeferred} from './SelectPaymentDeferred';
import {LogHelper} from '../LogHelper';
import {oneWayDifference} from '../../common/utils/utils';
import {message} from '../logs/MessageBuilder';

export enum LogType {
  DREW = 'drew',
  BOUGHT = 'bought',
  DREW_VERBOSE = 'drew_verbose',
}

export type ChooseOptions = {
  keepMax?: number,
  logDrawnCard?: boolean,
  paying?: boolean,
}

export class ChooseCards extends DeferredAction {
  public constructor(
    player: IPlayer,
    public cards: ReadonlyArray<IProjectCard>,
    public options: ChooseOptions = {},
  ) {
    super(player, Priority.DRAW_CARDS);
  }

  public execute() {
    const options = this.options;
    const cards = this.cards;
    const player = this.player;

    let max = options.keepMax || cards.length;
    let msg = '';
    if (options.paying) {
      const spendableMegacredits = this.player.spendableMegacredits();
      const affordableCards = Math.floor(spendableMegacredits / this.player.cardCost);
      max = Math.min(max, affordableCards);
      if (max === 0) {
        msg = 'You cannot afford any cards';
      } else if (max < this.cards.length) {
        // We're being offered more cards than we're able to buy
        // So we should be specific on maximum number of cards
        msg = `Select up to ${max} card(s) to buy`;
      } else {
        msg = 'Select card(s) to buy';
      }
    } else {
      msg = `Select ${max} card(s) to keep`;
    }
    const min = options.paying ? 0 : options.keepMax;

    const button = max === 0 ? 'Ok' : (options.paying ? 'Buy' : 'Select');
    const cb = (selected: ReadonlyArray<IProjectCard>) => {
      if (selected.length > max) {
        throw new Error('Selected too many cards');
      }
      const unselected = oneWayDifference(cards, selected);
      if (options.paying && selected.length > 0) {
        const cost = selected.length * player.cardCost;
        player.game.defer(
          new SelectPaymentDeferred(
            player,
            cost,
            {title: message('Select how to spend ${0} M€ for ${1} cards', (b) => b.number(cost).number(selected.length))})
            .andThen(() => keep(player, selected, unselected, LogType.BOUGHT)));
      } else if (options.logDrawnCard === true) {
        keep(player, selected, unselected, LogType.DREW_VERBOSE);
      } else {
        keep(player, selected, unselected, options.paying ? LogType.BOUGHT : LogType.DREW);
      }
      return undefined;
    };
    return new SelectCard(msg, button, cards, {max, min}).andThen(cb);
  }
}

export function keep(player: IPlayer, cards: ReadonlyArray<IProjectCard>, discards: ReadonlyArray<IProjectCard>, logType: LogType = LogType.DREW): void {
  player.cardsInHand.push(...cards);
  player.game.projectDeck.discard(...discards);

  if (logType === LogType.DREW_VERBOSE) {
    LogHelper.logDrawnCards(player, cards);
  } else {
    player.game.log('${0} ${1} ${2} card(s)', (b) => b.player(player).string(logType).number(cards.length));
    LogHelper.logDrawnCards(player, cards, /* privateMessage */ true);
  }
}

================
File: deferredActions/ChoosePolicyBonus.ts
================
import {IPlayer} from '../IPlayer';
import {PlayerInput} from '../PlayerInput';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {BonusId} from '../../common/turmoil/Types';
import {IBonus} from '../turmoil/Bonus';
import {OrOptions} from '../inputs/OrOptions';
import {SelectOption} from '../inputs/SelectOption';

export class ChoosePolicyBonus extends DeferredAction {
  constructor(
    player: IPlayer,
    public bonuses: Array<IBonus>,
    public bonusCb: (bonusId: BonusId) => void,
  ) {
    super(player, Priority.DEFAULT);
  }

  public execute(): PlayerInput {
    const bonusOptions = this.bonuses.map((b) => {
      return new SelectOption(b.description, 'Select')
        .andThen(() => {
          this.bonusCb(b.id);
          return undefined;
        });
    });
    return new OrOptions(...bonusOptions);
  }
}

================
File: deferredActions/ChoosePoliticalAgenda.ts
================
import {OrOptions} from '../inputs/OrOptions';
import {SelectOption} from '../inputs/SelectOption';
import {IPlayer} from '../IPlayer';
import {PlayerInput} from '../PlayerInput';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {IParty} from '../turmoil/parties/IParty';
import {BonusId, PolicyId} from '../../common/turmoil/Types';
import {policyDescription} from '../turmoil/Policy';
import {message} from '../logs/MessageBuilder';

export class ChoosePoliticalAgenda extends DeferredAction {
  constructor(
    player: IPlayer,
    public party: IParty,
    public bonusCb: (bonusId: BonusId) => void,
    public policyCb: (policyId: PolicyId) => void,
  ) {
    super(player, Priority.DEFAULT);
  }

  public execute(): PlayerInput {
    const players = this.player.game.getPlayers();
    const bonuses: Array<SelectOption> = this.party.bonuses.map((bonus) => {
      const description = message(
        bonus.description + ' (${0})',
        (b) => b.rawString(players.map((player) => player.name + ': ' + bonus.getScore(player)).join(' / ')),
      );

      return new SelectOption(description).andThen(() => {
        this.bonusCb(bonus.id);
        return undefined;
      });
    });

    const orBonuses = new OrOptions(...bonuses);
    orBonuses.title = message('Select a ${0} bonus', (b) => b.party(this.party));

    const policies = this.party.policies.map((policy) => {
      return new SelectOption(policyDescription(policy, this.player),
        'Select')
        .andThen(() => {
          this.policyCb(policy.id);
          return undefined;
        });
    });
    const orPolicies = new OrOptions(...policies);
    orPolicies.title = message('Select a ${0} policy', (b) => b.party(this.party));

    return new OrOptions(orBonuses, orPolicies);
  }
}

================
File: deferredActions/CorrosiveRainDeferredAction.ts
================
import {IPlayer} from '../IPlayer';
import {SelectCard} from '../inputs/SelectCard';
import {OrOptions} from '../inputs/OrOptions';
import {Resource} from '../../common/Resource';
import {CardResource} from '../../common/CardResource';
import {SelectOption} from '../inputs/SelectOption';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {GlobalEventName} from '../../common/turmoil/globalEvents/GlobalEventName';

export class CorrosiveRainDeferredAction extends DeferredAction {
  constructor(
    player: IPlayer,
    public title: string = 'Remove 2 floaters from a card or lose up to 10 M€',
  ) {
    super(player, Priority.DEFAULT);
  }

  public execute() {
    const floaterCards = this.player.getCardsWithResources(CardResource.FLOATER).filter((card) => card.resourceCount >= 2);

    const selectAction = new OrOptions();
    const payMC = new SelectOption('Lose up to 10 M€', 'Lose M€').andThen(() => {
      this.player.stock.deduct(Resource.MEGACREDITS, 10, {log: true, from: GlobalEventName.CORROSIVE_RAIN});
      return undefined;
    });
    const removeFloaters = new SelectCard(
      'Select card to remove 2 floaters from', 'Remove floaters', floaterCards)
      .andThen(([card]) => {
        this.player.removeResourceFrom(card, 2);
        return undefined;
      });
    selectAction.options.push(payMC, removeFloaters);

    if (floaterCards.length === 0) {
      payMC.cb(undefined);
      return undefined;
    }

    return selectAction;
  }
}

================
File: deferredActions/DecreaseAnyProduction.ts
================
import {IPlayer} from '../IPlayer';
import {Resource} from '../../common/Resource';
import {SelectPlayer} from '../inputs/SelectPlayer';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {Message} from '../../common/logs/Message';
import {message} from '../logs/MessageBuilder';

export type Options = {
  count: number,
  stealing?: boolean
}

export class DecreaseAnyProduction extends DeferredAction<boolean> {
  constructor(
    player: IPlayer,
    public resource: Resource,
    public options: Options = {
      count: 1,
      stealing: false,
    },
    public title: string | Message = message('Select player to decrease ${0} production by ${1} step(s)', (b) => b.string(resource).number(options.count)),
  ) {
    super(player, Priority.ATTACK_OPPONENT);
  }

  private attack(target: IPlayer): void {
    target.maybeBlockAttack(this.player, (proceed: boolean) => {
      if (proceed) {
        target.production.add(this.resource, -this.options.count, {log: true, from: this.player, stealing: this.options.stealing});
      }
      this.cb(proceed);
      return undefined;
    });
  }

  public execute() {
    if (this.player.game.isSoloMode()) {
      this.player.resolveInsuranceInSoloGame();
      this.cb(true);
    } else {
      const targets = this.player.game.getPlayers().filter((p) => p.canHaveProductionReduced(this.resource, this.options.count, this.player));

      if (targets.length === 0) {
        this.cb(false);
        return undefined;
      }
      if (targets.length > 0) {
        if (targets.length > 1 || targets[0] === this.player) {
          return new SelectPlayer(targets, this.title, 'Decrease')
            .andThen((candidate) => {
              this.attack(candidate);
              return undefined;
            });
        } else {
          this.attack(targets[0]);
        }
      }
    }

    return undefined;
  }
}

================
File: deferredActions/DeferredAction.ts
================
import {IPlayer} from '../IPlayer';
import {PlayerInput} from '../PlayerInput';
import {Priority} from './Priority';

export interface AndThen<T> {
  andThen(cb: (param: T) => void): this;
}

export interface IDeferredAction <T = undefined> extends AndThen<T> {
  queueId: number;
  player: IPlayer;
  priority: Priority;
  execute(): PlayerInput | undefined;
}

export abstract class DeferredAction<T = undefined> implements IDeferredAction<T> {
  // The position in the queue. Do not set directly.
  public queueId: number = -1;
  constructor(
    public player: IPlayer,
    public priority: Priority = Priority.DEFAULT,
  ) {}

  public abstract execute(): PlayerInput | undefined;
  // TODO(kberg): Make protected again.
  public cb: (param: T) => PlayerInput | undefined | void = () => {};
  private callbackSet = false;

  public andThen(cb: (param: T) => void): this {
    if (this.callbackSet) {
      throw new Error('Cannot call andThen twice for the same object.');
    }
    this.cb = cb;
    this.callbackSet = true;
    return this;
  }
}

export class SimpleDeferredAction<T> extends DeferredAction<T> {
  constructor(
    player: IPlayer,
    public execute: () => PlayerInput | undefined,
    priority?: Priority,
  ) {
    super(player, priority);
  }
}

================
File: deferredActions/DeferredActionsQueue.ts
================
import {IDeferredAction} from './DeferredAction';
import {GiveColonyBonus} from './GiveColonyBonus';
import {IPlayer} from '../IPlayer';

export class DeferredActionsQueue {
  private insertId: number = 0;
  private queue: Array<IDeferredAction<any>> = [];

  get length(): number {
    return this.queue.length;
  }

  public push(action: IDeferredAction<any>): void {
    action.queueId = this.insertId++;
    this.queue.push(action);
  }

  public runAllFor(player: IPlayer, cb: () => void): void {
    let b: IDeferredAction | undefined;
    let j = -1;
    for (let i = this.queue.length - 1; i >= 0; i--) {
      const a = this.queue[i];
      if (a.player.id === player.id && (b === undefined || this.hasHigherPriority(a, b))) {
        b = a;
        j = i;
      }
    }
    if (b === undefined) {
      cb();
      return;
    }
    this.queue.splice(j, 1);
    this.run(b, () => this.runAllFor(player, cb));
  }

  private hasHigherPriority(a: IDeferredAction, b: IDeferredAction) {
    return a.priority < b.priority || (a.priority === b.priority && a.queueId < b.queueId);
  }

  private nextItemIndex(): number {
    if (this.queue.length === 0) {
      return -1;
    }
    let b = this.queue[0];
    let j = 0;
    for (let i = this.queue.length - 1; i >= 1; i--) {
      const a = this.queue[i];
      if (this.hasHigherPriority(a, b)) {
        b = a;
        j = i;
      }
    }
    return j;
  }

  public runAll(cb: () => void): void {
    const next = this.nextItemIndex();
    const action = this.queue[next];
    if (action === undefined) {
      cb();
      return;
    }
    this.queue.splice(next, 1);
    this.run(action, () => {
      this.runAll(cb);
    });
  }

  // The following methods are used in tests
  public peek(): IDeferredAction<any> | undefined {
    return this.queue[this.nextItemIndex()];
  }

  public pop(): IDeferredAction<any> | undefined {
    return this.queue.splice(this.nextItemIndex(), 1)[0];
  }

  public run(action: IDeferredAction, cb: () => void): void {
    // Special hook for trade bonus deferred actions
    // So that they happen for all players at the same time
    if (action instanceof GiveColonyBonus) {
      action.andThen(cb);
      action.execute();
      return;
    }

    const input = action.execute();
    if (input !== undefined) {
      action.player.setWaitingFor(input, cb);
    } else {
      cb();
    }
  }

  public runNext(): void {
    const action = this.pop();
    if (action !== undefined) {
      this.run(action, () => {});
    }
  }
}

================
File: deferredActions/DiscardCards.ts
================
import {IPlayer} from '../IPlayer';
import {SelectCard} from '../inputs/SelectCard';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {Message} from '../../common/logs/Message';
import {message} from '../logs/MessageBuilder';
import {IProjectCard} from '../cards/IProjectCard';

export class DiscardCards extends DeferredAction<ReadonlyArray<IProjectCard>> {
  constructor(
    player: IPlayer,
    public min: number = 1,
    public max: number = 1,
    public title?: string | Message,
  ) {
    super(player, Priority.DISCARD_CARDS);
  }

  public execute() {
    if (this.player.cardsInHand.length <= this.min) {
      const discards = [...this.player.cardsInHand];
      for (const card of discards) {
        this.player.discardCardFromHand(card);
      }
      this.cb(discards);
      return undefined;
    }

    let title: string | Message | undefined = this.title;
    if (title === undefined) {
      if (this.min === this.max) {
        if (this.min === 1) {
          title = 'Select 1 card to discard';
        } else {
          title = message('Select ${0} cards to discard', (b) => b.number(this.min));
        }
      } else {
        title = message('Select between ${0} and ${1} cards to discard', (b) => b.number(this.min).number(this.max));
      }
    }
    return new SelectCard(
      title,
      'Discard',
      this.player.cardsInHand,
      {min: this.min, max: this.max})
      .andThen((discards) => {
        for (const card of discards) {
          this.player.discardCardFromHand(card);
        }
        this.cb(discards);
        return undefined;
      });
  }
}

================
File: deferredActions/DrawCards.ts
================
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';
import {IProjectCard} from '../cards/IProjectCard';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {CardResource} from '../../common/CardResource';
import {CardType} from '../../common/cards/CardType';
import {ChooseCards, ChooseOptions, LogType, keep} from './ChooseCards';

export type DrawOptions = {
  tag?: Tag,
  resource?: CardResource,
  cardType?: CardType,
  include?(card: IProjectCard): boolean,
}

export type AllOptions = DrawOptions & ChooseOptions;

export class DrawCards extends DeferredAction<ReadonlyArray<IProjectCard>> {
  // Visible for tests.
  public constructor(
    player: IPlayer,
    public count: number = 1,
    public options: AllOptions = {},
  ) {
    super(player, Priority.DRAW_CARDS);
  }

  public execute(): undefined {
    this.player.game.resettable = false;
    const game = this.player.game;
    const cards = game.projectDeck.drawByCondition(game, this.count, (card) => {
      if (this.options.resource !== undefined && this.options.resource !== card.resourceType) {
        return false;
      }
      if (this.options.cardType !== undefined && this.options.cardType !== card.type) {
        return false;
      }
      if (this.options.tag !== undefined && !this.player.tags.cardHasTag(card, this.options.tag)) {
        return false;
      }
      if (this.options.include !== undefined && !this.options.include(card)) {
        return false;
      }
      return true;
    });

    this.cb(cards);
    return undefined;
  }

  public static keepAll(player: IPlayer, count: number = 1, options?: DrawOptions): DrawCards {
    return new DrawCards(player, count, options).andThen((cards) => {
      let verbosity = LogType.DREW;
      if (options !== undefined) {
        if (options.tag !== undefined ||
          options.resource !== undefined ||
          options.cardType !== undefined ||
          options.include !== undefined) {
          verbosity = LogType.DREW_VERBOSE;
        }
      }
      keep(player, cards, [], verbosity);
    });
  }

  public static keepSome(player: IPlayer, count: number = 1, options: AllOptions): DrawCards {
    return new DrawCards(player, count, options).andThen((cards) => player.game.defer(new ChooseCards(player, cards, options)));
  }
}

================
File: deferredActions/DrawCeoCardFromDeck.ts
================
import {inplaceRemove} from '../../common/utils/utils';
import {ICeoCard} from '../cards/ceos/ICeoCard';
import {SelectCard} from '../inputs/SelectCard';
import {IPlayer} from '../IPlayer';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';

export class DrawCeoCardFromDeck extends DeferredAction<ICeoCard | undefined> {
  private count: number;
  constructor(player: IPlayer, count: number) {
    super(player, Priority.DEFAULT);
    this.count = count;
  }

  public execute() {
    const game = this.player.game;
    const cards = game.ceoDeck.drawN(game, this.count);
    const playableCards = cards.filter((card) => {
      if (card.canPlay?.(this.player) === true) {
        return true;
      }
      this.player.game.ceoDeck.discard(card);
      // TODO(kberg): rewrite to "Discarding ${1} as you could not play it."
      game.log('${0} was discarded as ${1} could not play it.', (b) => b.card(card).player(this.player), {reservedFor: this.player});
      return false;
    });

    if (playableCards.length === 0) {
      game.log('${0} drew no playable CEO cards', (b) => b.player(this.player));
      this.cb(undefined);
      return;
    }
    return new SelectCard('Choose CEO card', 'Take', playableCards)
      .andThen(([card]) => {
        // Discard unselected CEOs
        inplaceRemove(playableCards, card);
        game.ceoDeck.discard(...playableCards);

        this.cb(card);
        return undefined;
      });
  }
}

================
File: deferredActions/GainProduction.ts
================
import {IPlayer} from '../IPlayer';
import {Resource} from '../../common/Resource';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';

export type Options = {
  count?: number;
  log?: boolean;
}

export class GainProduction extends DeferredAction {
  constructor(
    player: IPlayer,
    public resource: Resource,
    public options: Options = {},
  ) {
    super(player, Priority.GAIN_RESOURCE_OR_PRODUCTION);
  }

  public execute() {
    if (this.options.count === undefined) {
      this.options.count = 1;
    } else if (this.options.count < 0) {
      throw new Error('GainProduction count option must be >= 0');
    }

    if (this.options.count > 0) {
      this.player.production.add(this.resource, this.options.count, {log: this.options.log ?? true});
    }
    this.cb(undefined);
    return undefined;
  }
}

================
File: deferredActions/GainResources.ts
================
import {IPlayer, ResourceSource} from '../IPlayer';
import {Resource} from '../../common/Resource';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';

export type Options = {
  count?: number;
  log?: boolean;
  from?: ResourceSource;
}

export class GainResources extends DeferredAction {
  constructor(
    player: IPlayer,
    public resource: Resource,
    public options: Options = {},
  ) {
    super(player, Priority.GAIN_RESOURCE_OR_PRODUCTION);
    if ((options.count ?? 0) < 0) {
      throw new Error('GainResources count option must be >= 0');
    }
  }

  public execute() {
    if (this.options.count === 0) {
      return undefined;
    }
    this.player.stock.add(this.resource, this.options.count ?? 1, {log: this.options.log, from: this.options.from});
    this.cb(undefined);
    return undefined;
  }
}

================
File: deferredActions/GainStock.ts
================
import {IPlayer} from '../IPlayer';
import {Units} from '../../common/Units';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';

export type Options = {
  cb?(): void;
  log?: boolean;
}

export class GainStock extends DeferredAction {
  constructor(
    player: IPlayer,
    public units: Units,
    public options: Options = {},
  ) {
    super(player, Priority.GAIN_RESOURCE_OR_PRODUCTION);
    if (Units.values(this.units).some((v) => v < 0)) {
      throw new Error('GainStock does not accept negative unit values');
    }
  }

  public execute() {
    this.player.stock.addUnits(this.units, {log: this.options.log});
    this.options.cb?.();
    return undefined;
  }
}

================
File: deferredActions/GiveColonyBonus.ts
================
import {IPlayer} from '../IPlayer';
import {PlayerId} from '../../common/Types';
import {IColony} from '../colonies/IColony';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {MultiSet} from 'mnemonist';

export class GiveColonyBonus extends DeferredAction {
  private waitingFor = new MultiSet<PlayerId>();
  private playersWithBonuses = new Set<PlayerId>();

  constructor(
    player: IPlayer,
    public colony: IColony,
    public selfish: boolean = false, // Used for CoordinatedRaid.
  ) {
    super(player, Priority.DEFAULT);
  }

  public execute() {
    if (this.colony.colonies.length === 0) {
      this.cb(undefined);
      return undefined;
    }

    for (const playerId of this.colony.colonies) {
      if (!this.selfish) {
        // Normal behavior; colony owners get their bonuses.
        this.waitingFor.add(playerId);
        this.playersWithBonuses.add(playerId);
      } else {
        // Selfish behavior, `player` gets all the colony bonuses.
        this.waitingFor.add(this.player.id);
        this.playersWithBonuses.add(this.player.id);
      }
    }

    for (const playerId of this.waitingFor.keys()) {
      const bonusPlayer = this.player.game.getPlayerById(playerId);
      this.giveColonyBonus(bonusPlayer);
    }

    return undefined;
  }

  private giveColonyBonus(player: IPlayer): void {
    if (this.waitingFor.get(player.id) ?? 0 > 0) {
      this.waitingFor.remove(player.id);
      const input = this.colony.giveColonyBonus(player, true);
      if (input !== undefined) {
        player.setWaitingFor(input, () => this.giveColonyBonus(player));
      } else {
        this.giveColonyBonus(player);
      }
    } else {
      this.playersWithBonuses.delete(player.id);
      this.doneGettingBonus();
    }
  }

  private doneGettingBonus(): void {
    if (this.playersWithBonuses.size === 0) {
      this.cb(undefined);
    }
  }
}

================
File: deferredActions/IncreaseColonyTrack.ts
================
import {IPlayer} from '../IPlayer';
import {IColony} from '../colonies/IColony';
import {OrOptions} from '../inputs/OrOptions';
import {SelectOption} from '../inputs/SelectOption';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {LogHelper} from '../LogHelper';
import {Message} from '../../common/logs/Message';
import {message} from '../logs/MessageBuilder';

export class IncreaseColonyTrack extends DeferredAction {
  constructor(
    player: IPlayer,
    public colony: IColony,
    public steps: number,
    public title: string | Message = message('Increase ${0} colony track before trade', (b) => b.colony(colony)),
  ) {
    super(player, Priority.INCREASE_COLONY_TRACK);
  }

  public execute() {
    if (this.steps === 0) {
      this.cb(undefined);
      return undefined;
    }

    const options = new OrOptions();
    for (let step = this.steps; step > 0; step--) {
      options.options.push(
        new SelectOption(message('Increase colony track ${0} step(s)', (b) => b.number(step)))
          .andThen(() => {
            this.colony.increaseTrack(step);
            LogHelper.logColonyTrackIncrease(this.player, this.colony, step);
            this.cb(undefined);
            return undefined;
          }),
      );
    }
    options.title = this.title;
    options.options.push(
      new SelectOption('Don\'t increase colony track').andThen(() => {
        this.cb(undefined);
        return undefined;
      }),
    );

    return options;
  }
}

================
File: deferredActions/LoseProduction.ts
================
import {IPlayer} from '../IPlayer';
import {Resource} from '../../common/Resource';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';

export type Options = {
  count?: number;
}

export class LoseProduction extends DeferredAction {
  constructor(
    player: IPlayer,
    public resource: Resource,
    public options: Options = {},
  ) {
    super(player, Priority.LOSE_RESOURCE_OR_PRODUCTION);
  }

  public execute() {
    if (this.options.count === undefined) {
      this.options.count = 1;
    } else if (this.options.count < 0) {
      throw new Error('LoseProduction count option must be >= 0');
    } else if (this.options.count === 0) {
      return undefined;
    }
    this.player.production.add(this.resource, -this.options.count);
    return undefined;
  }
}

================
File: deferredActions/PlaceCityTile.ts
================
import {IPlayer} from '../IPlayer';
import {SelectSpace} from '../inputs/SelectSpace';
import {Space} from '../boards/Space';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {PlacementType} from '../boards/PlacementType';

export class PlaceCityTile extends DeferredAction<Space | undefined> {
  constructor(
    player: IPlayer,
    private options?: {
      on?: PlacementType,
      title?: string,
      spaces?: ReadonlyArray<Space>,
    }) {
    super(player, Priority.DEFAULT);
  }

  public execute() {
    const type = this.options?.on || 'city';
    const spaces = this.options?.spaces || this.player.game.board.getAvailableSpacesForType(this.player, type);
    const title = this.options?.title ?? this.getTitle(type);

    if (spaces.length === 0) {
      this.cb(undefined);
      return undefined;
    }
    return new SelectSpace(title, spaces)
      .andThen((space) => {
        this.player.game.addCity(this.player, space);
        this.cb(space);
        return undefined;
      });
  }

  private getTitle(type: PlacementType) {
    switch (type) {
    case 'city': return 'Select space for city tile';
    case 'isolated': return 'Select place next to no other tile for city';
    // case '': return 'Select space reserved for ocean to place greenery tile';
    default: throw new Error('unhandled type; ' + type);
    }
  }
}

================
File: deferredActions/PlaceGreeneryTile.ts
================
import {IPlayer} from '../IPlayer';
import {SelectSpace} from '../inputs/SelectSpace';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {PlacementType} from '../boards/PlacementType';

export class PlaceGreeneryTile extends DeferredAction {
  constructor(
    player: IPlayer,
    private on: PlacementType = 'greenery',
  ) {
    super(player, Priority.DEFAULT);
  }

  public execute() {
    const availableSpaces = this.player.game.board.getAvailableSpacesForType(this.player, this.on);
    if (availableSpaces.length === 0) {
      return undefined;
    }

    return new SelectSpace(this.getTitle(), availableSpaces)
      .andThen((space) => {
        this.player.game.addGreenery(this.player, space);
        return undefined;
      });
  }

  private getTitle() {
    switch (this.on) {
    case 'greenery': return 'Select space for greenery tile';
    case 'ocean': return 'Select space reserved for ocean to place greenery tile';
    default: throw new Error('unhandled type; ' + this.on);
    }
  }
}

================
File: deferredActions/PlaceHazardTile.ts
================
import {IPlayer} from '../IPlayer';
import {SelectSpace} from '../inputs/SelectSpace';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {_AresHazardPlacement} from '../ares/AresHazards';
import {TileType} from '../../common/TileType';
import {Message} from '../../common/logs/Message';
import {message} from '../logs/MessageBuilder';
import {Space} from '../boards/Space';
import {LogHelper} from '../LogHelper';

export class PlaceHazardTile extends DeferredAction<Space> {
  constructor(
    player: IPlayer,
    public hazardType: TileType.DUST_STORM_MILD | TileType.EROSION_MILD,
    private options?: {
      title?: string | Message,
      spaces?: ReadonlyArray<Space>,
    }) {
    super(player, Priority.DEFAULT);
  }

  public execute() {
    const availableSpaces = this.options?.spaces ?? this.player.game.board.getAvailableSpacesForType(this.player, 'land');
    if (availableSpaces.length === 0) {
      return undefined;
    }
    const hazardType = this.hazardType;
    const title = this.options?.title || message('Select space for ${0}', (b) => b.tileType(hazardType));

    return new SelectSpace(title, availableSpaces)
      .andThen((space) => {
        _AresHazardPlacement.putHazardAt(space, hazardType);
        LogHelper.logTilePlacement(this.player, space, this.hazardType);
        this.cb(space);
        return undefined;
      });
  }
}

================
File: deferredActions/PlaceOceanTile.ts
================
import {IPlayer} from '../IPlayer';
import {SelectSpace} from '../inputs/SelectSpace';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {PlacementType} from '../boards/PlacementType';
import {Space} from '../boards/Space';
import {CardName} from '../../common/cards/CardName';
import {Message} from '../../common/logs/Message';

type Options = {
  title?: string | Message,
  on?: PlacementType,
  spaces?: Array<Space>,
  /** For Icy Impactors */
  creditedPlayer?: IPlayer,
};

export class PlaceOceanTile extends DeferredAction<Space> {
  constructor(
    player: IPlayer,
    private options: Options = {}) {
    super(player, Priority.PLACE_OCEAN_TILE);
  }

  public execute() {
    if (!this.player.game.canAddOcean()) {
      const whales = this.player.playedCards.find((card) => card.name === CardName.WHALES);
      if (whales !== undefined) {
        this.player.addResourceTo(whales, {qty: 1, log: true});
      }
      return undefined;
    }

    let title = this.options.title ?? this.getTitle('ocean');
    let availableSpaces: ReadonlyArray<Space> = [];
    if (this.options.spaces !== undefined) {
      availableSpaces = this.options.spaces;
    } else {
      const on = this.options?.on || 'ocean';
      availableSpaces = this.player.game.board.getAvailableSpacesForType(this.player, on);
      title = this.options?.title ?? this.getTitle(on);
    }

    return new SelectSpace(title, availableSpaces)
      .andThen((space) => {
        const creditedPlayer = this.options.creditedPlayer ?? this.player;
        creditedPlayer.game.addOcean(creditedPlayer, space);
        creditedPlayer.defer(this.cb(space));
        return undefined;
      });
  }

  private getTitle(type: PlacementType) {
    switch (type) {
    case 'ocean': return 'Select space for ocean tile';
    case 'land': return 'Select a land space to place an ocean tile';
    // case '': return 'Select space reserved for ocean to place greenery tile';
    default: throw new Error('unhandled type; ' + type);
    }
  }
}

================
File: deferredActions/PlaceTile.ts
================
import {IPlayer} from '../IPlayer';
import {SelectSpace} from '../inputs/SelectSpace';
import {Space} from '../boards/Space';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {PlacementType} from '../boards/PlacementType';
import {Tile} from '../Tile';
import {AdjacencyBonus} from '../ares/AdjacencyBonus';
import {Message} from '../../common/logs/Message';

export class PlaceTile extends DeferredAction {
  constructor(
    player: IPlayer,
    private options: {
      tile: Tile,
      on: PlacementType,
      title: string | Message,
      adjacencyBonus?: AdjacencyBonus;
    }) {
    super(player, Priority.DEFAULT);
  }

  public execute() {
    const game = this.player.game;
    const on = this.options.on;
    const availableSpaces = game.board.getAvailableSpacesForType(this.player, on);
    const title = this.options?.title;

    return new SelectSpace(title, availableSpaces)
      .andThen((space: Space) => {
        const tile: Tile = {...this.options.tile};
        if (this.options.on === 'upgradeable-ocean') {
          tile.covers = space.tile;
        }
        game.addTile(this.player, space, tile);
        space.adjacency = this.options.adjacencyBonus;
        return undefined;
      });
  }
}

================
File: deferredActions/PlayProjectCard.ts
================
import {IProjectCard} from '../cards/IProjectCard';
import {SelectProjectCardToPlay} from '../inputs/SelectProjectCardToPlay';
import {IPlayer} from '../IPlayer';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';

export class PlayProjectCard extends DeferredAction<IProjectCard | undefined> {
  constructor(player: IPlayer) {
    super(player, Priority.DEFAULT);
  }

  public execute() {
    const playableCards = this.player.getPlayableCards();
    if (playableCards.length === 0) {
      this.cb(undefined);
      return undefined;
    }
    return new SelectProjectCardToPlay(this.player, playableCards).andThen((card) => {
      this.cb(card);
      return undefined;
    });
  }
}

================
File: deferredActions/Priority.ts
================
export enum Priority {
  /** Legacy value that should not be further used. */
  SUPERPOWER = -1,
  /** Used for Pathfinders. First thing a player must do before further effects. */
  DECLARE_CLONE_TAG,
  /** Cost of a blue card action, or paying Reds costs. Must happen before the effects. */
  COST,
  /** Pharmacy Union special case, players typically prefer to resolve this early. */
  PHARMACY_UNION,
  /** Any effect from one of your opponent's card that triggers during your turn. */
  OPPONENT_TRIGGER,

  /** When you must discard before you can draw. Making a determination that Sponsored Academies should come before Mars U. */
  SPONSORED_ACADEMIES,
  DRAW_CARDS,
  BUILD_COLONY,
  INCREASE_COLONY_TRACK,
  PLACE_OCEAN_TILE,
  IDENTIFY_UNDERGROUND_RESOURCE,
  EXCAVATE_UNDERGROUND_RESOURCE,

  /** Anything that doesn't fit into another category. */
  DEFAULT,
  /**
   * When you must discard before you can draw. Mars U, Ender (CEO).
   *
   * Note: This used to be before DRAW_CARDS, and I don't know why it would be.
   * Moving this just after DEFAULT. See #5488
   */
  DISCARD_AND_DRAW,
  /** Effects that make your opponents lose resources or production. */
  ATTACK_OPPONENT,
  /** Effects that make you lose resource or production "as much as possible". Pharmacy Union, Mons. */
  LOSE_AS_MUCH_AS_POSSIBLE,
  GAIN_RESOURCE_OR_PRODUCTION,
  LOSE_RESOURCE_OR_PRODUCTION,
  DECREASE_COLONY_TRACK_AFTER_TRADE,
  DISCARD_CARDS,
  ROBOTIC_WORKFORCE,
  BACK_OF_THE_LINE,
}

================
File: deferredActions/RemoveAnyPlants.ts
================
import {IPlayer} from '../IPlayer';
import {Resource} from '../../common/Resource';
import {OrOptions} from '../inputs/OrOptions';
import {SelectOption} from '../inputs/SelectOption';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {CardName} from '../../common/cards/CardName';
import {MessageBuilder, message} from '../logs/MessageBuilder';
import {Message} from '../../common/logs/Message';
export class RemoveAnyPlants extends DeferredAction {
  private title: string | Message;
  private count: number;

  constructor(player: IPlayer, count: number = 1, title?: string | Message) {
    super(player, Priority.ATTACK_OPPONENT);
    this.count = count;
    this.title = title ?? message('Select player to remove up to ${0} plants', (b) => b.number(count));
  }

  private createOption(target: IPlayer) {
    let qtyToRemove = Math.min(target.plants, this.count);

    // Botanical Experience hook.
    if (target.cardIsInEffect(CardName.BOTANICAL_EXPERIENCE)) {
      qtyToRemove = Math.ceil(qtyToRemove / 2);
    }

    const message =
      new MessageBuilder('Remove ${0} plants from ${1}')
        .number(qtyToRemove)
        .player(target)
        .getMessage();

    return new SelectOption(
      message, 'Remove plants').andThen(() => {
      target.maybeBlockAttack(this.player, (proceed) => {
        if (proceed === true) {
          target.stock.deduct(Resource.PLANTS, qtyToRemove, {log: true, from: this.player});
        }
        return undefined;
      });
      return undefined;
    });
  }

  public execute() {
    if (this.player.game.isSoloMode()) {
      // Crash site cleanup hook
      this.player.game.someoneHasRemovedOtherPlayersPlants = true;
      this.player.resolveInsuranceInSoloGame();
      return undefined;
    }

    const candidates = this.player.getOpponents().filter((p) => !p.plantsAreProtected() && p.plants > 0);

    if (candidates.length === 0) {
      return undefined;
    }

    const removalOptions: Array<SelectOption> = candidates.map((target) => {
      let qtyToRemove = Math.min(target.plants, this.count);

      // Botanical Experience hook.
      if (target.cardIsInEffect(CardName.BOTANICAL_EXPERIENCE)) {
        qtyToRemove = Math.ceil(qtyToRemove / 2);
      }

      const message =
        new MessageBuilder('Remove ${0} plants from ${1}')
          .number(qtyToRemove)
          .player(target)
          .getMessage();

      return new SelectOption(
        message, {
          buttonLabel: 'Remove plants',
          warnings: (target === this.player) ? ['removeOwnPlants'] : undefined,
        }).andThen(() => {
        target.maybeBlockAttack(this.player, (proceed) => {
          if (proceed === true) {
            target.stock.deduct(Resource.PLANTS, qtyToRemove, {log: true, from: this.player});
          }
          return undefined;
        });
        return undefined;
      });
    });

    removalOptions.push(new SelectOption('Skip removing plants').andThen(() => {
      return undefined;
    }));

    if (this.player.plants > 0) {
      const option = this.createOption(this.player);
      option.warnings = ['removeOwnPlants'];
      removalOptions.push(option);
    }

    const orOptions = new OrOptions(...removalOptions);
    orOptions.title = this.title;
    return orOptions;
  }
}

================
File: deferredActions/RemoveColonyFromGame.ts
================
import {IPlayer} from '../IPlayer';
import {SelectColony} from '../inputs/SelectColony';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';

export class RemoveColonyFromGame extends DeferredAction {
  constructor(player: IPlayer) {
    super(player, Priority.DEFAULT);
  }

  public execute() {
    const game = this.player.game;
    const removeColony = new SelectColony('Select colony tile to remove', 'Remove colony', game.colonies)
      .andThen((colony) => {
        game.colonies.splice(game.colonies.indexOf(colony), 1);
        game.discardedColonies.push(colony);
        game.log('You discarded ${0}', (b) => b.colony(colony));
        return undefined;
      });
    removeColony.showTileOnly = true;

    return removeColony;
  }
}

================
File: deferredActions/RemoveOceanTile.ts
================
import {IPlayer} from '../IPlayer';
import {SelectSpace} from '../inputs/SelectSpace';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {LogHelper} from '../LogHelper';

export class RemoveOceanTile extends DeferredAction {
  constructor(
    player: IPlayer,
    public title: string = 'Select an Ocean tile to remove from board',
  ) {
    super(player, Priority.DEFAULT);
  }

  public execute() {
    // false: don't include upgraded oceans.
    const removableOceanTiles = this.player.game.board.getOceanSpaces({upgradedOceans: false});
    if (removableOceanTiles.length === 0) {
      return undefined;
    }
    return new SelectSpace(this.title, removableOceanTiles)
      .andThen((space) => {
        this.player.game.removeTile(space.id);
        LogHelper.logBoardTileAction(this.player, space, 'ocean tile', 'removed');
        return undefined;
      });
  }
}

================
File: deferredActions/RemoveResources.ts
================
import {IPlayer} from '../IPlayer';
import {Resource} from '../../common/Resource';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {CardName} from '../../common/cards/CardName';
import {UnderworldExpansion} from '../underworld/UnderworldExpansion';

export class RemoveResources extends DeferredAction<number> {
  constructor(
    private target: IPlayer,
    public perpetrator: IPlayer,
    public resource: Resource,
    public count: number = 1,
  ) {
    super(target, Priority.ATTACK_OPPONENT);
  }

  public execute() {
    if (this.resource === Resource.PLANTS) {
      if (this.target.plantsAreProtected()) {
        this.cb(0);
        return undefined;
      }
    }
    if (this.resource === Resource.STEEL || this.resource === Resource.TITANIUM) {
      if (this.target.alloysAreProtected()) {
        this.cb(0);
        return undefined;
      }
    }

    let qtyLost = Math.min(this.target.stock.get(this.resource), this.count);

    // Botanical Experience hook.
    if (this.resource === Resource.PLANTS && this.target.cardIsInEffect(CardName.BOTANICAL_EXPERIENCE)) {
      qtyLost = Math.ceil(qtyLost / 2);
    }

    if (qtyLost === 0) {
      return undefined;
    }
    // Move to this.target.maybeBlockAttack?
    this.target.defer(UnderworldExpansion.maybeBlockAttack(this.target, this.perpetrator, (proceed) => {
      if (proceed) {
        this.target.stock.deduct(this.resource, qtyLost, {log: true, from: this.perpetrator});
        this.cb(qtyLost);
      }
      return undefined;
    }));
    return undefined;
  }
}

================
File: deferredActions/RemoveResourcesFromCard.ts
================
import {IPlayer} from '../IPlayer';
import {CardResource} from '../../common/CardResource';
import {OrOptions} from '../inputs/OrOptions';
import {SelectCard} from '../inputs/SelectCard';
import {SelectOption} from '../inputs/SelectOption';
import {ICard} from '../cards/ICard';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {Message} from '../../common/logs/Message';
import {UnderworldExpansion} from '../underworld/UnderworldExpansion';

export type Source = 'self' | 'opponents' | 'all';
export type Response = {card: ICard, owner: IPlayer, proceed: boolean} | {card: undefined, owner: undefined, proceed: boolean};
export class RemoveResourcesFromCard extends DeferredAction<Response> {
  public cardResource: CardResource | undefined;
  public count: number;
  private source: Source;
  private mandatory: boolean;
  private blockable: boolean;
  private autoselect: boolean;
  private title: string | Message;

  public override priority = Priority.ATTACK_OPPONENT;
  constructor(
    player: IPlayer,
    cardResource: CardResource | undefined,
    count: number = 1,
    options?: {
      /** Which players to take from. Default all. */
      source?: Source,
      /** Resource must be removed (either it's a cost or the icon is not red-bordered.) default true. */
      mandatory?: boolean,
      /** If there's only one card, automatically select it. Default is true. Ignored if mandatory is false. */
      autoselect?: boolean
      title?: string | Message,
      blockable?: boolean,
    }) {
    super(player, Priority.ATTACK_OPPONENT);
    this.cardResource = cardResource;
    this.count = count;
    this.source = options?.source ?? 'all';
    this.mandatory = options?.mandatory ?? true;
    this.blockable = options?.blockable ?? true;
    this.autoselect = options?.autoselect ?? true;
    this.title = options?.title ?? (`Select card to remove ${count} ${cardResource}(s)`);
    if (this.source === 'self') {
      this.priority = Priority.LOSE_RESOURCE_OR_PRODUCTION;
      if (this.blockable) {
        throw new Error('Cannot block removing resources from self');
      }
    }
  }

  public execute() {
    if (this.source !== 'self' && this.player.game.isSoloMode()) {
      this.player.resolveInsuranceInSoloGame();
      this.cb({card: undefined, owner: undefined, proceed: true});
      return undefined;
    }

    const cards = RemoveResourcesFromCard.getAvailableTargetCards(this.player, this.cardResource, this.source);

    if (cards.length === 0) {
      this.cb({card: undefined, owner: undefined, proceed: false});
      return undefined;
    }

    const selectCard = new SelectCard(
      this.title,
      'Remove resource(s)',
      cards,
      {showOwner: true})
      .andThen(([card]) => {
        this.attack(card);
        return undefined;
      });

    if (this.mandatory) {
      if (cards.length === 1 && this.autoselect === true) {
        this.attack(cards[0]);
        return undefined;
      }
      return selectCard;
    }

    return new OrOptions(
      selectCard,
      new SelectOption('Do not remove'));
  }

  private attack(card: ICard) {
    const target = this.player.game.getCardPlayerOrThrow(card.name);

    // // TODO(kberg): Consolidate the blockable in mayBlock.
    // if (this.blockable === false) {
    //   target.removeResourceFrom(card, this.count, {removingPlayer: this.player});
    //   this.cb(true);
    //   return;
    // }
    target.defer(UnderworldExpansion.maybeBlockAttack(target, this.player, ((proceed) => {
      if (proceed) {
        target.removeResourceFrom(card, this.count, {removingPlayer: this.player});
      }
      this.cb({card: card, owner: target, proceed: proceed});
      return undefined;
    })));
  }

  public static getAvailableTargetCards(player: IPlayer, resourceType: CardResource | undefined, source: Source = 'all'): Array<ICard> {
    const resourceCards: Array<ICard> = [];
    for (const p of player.game.getPlayers()) {
      // Making this a function just to delay calling getCardsWithResources unless it's needed.
      const get = () => p.getCardsWithResources(resourceType).filter((card) => card.protectedResources !== true);
      if (p === player) {
        if (source !== 'opponents') {
          resourceCards.push(...get());
        }
      } else {
        if (source !== 'self') {
          switch (resourceType) {
          case CardResource.ANIMAL:
          case CardResource.MICROBE:
            if (!p.hasProtectedHabitats()) {
              resourceCards.push(...get());
            }
            break;
          default:
            resourceCards.push(...get());
          }
        }
      }
    }
    return resourceCards;
  }
}

================
File: deferredActions/RunNTimes.ts
================
import {IPlayer} from '../IPlayer';
import {DeferredAction} from '../deferredActions/DeferredAction';
import {Priority} from '../deferredActions/Priority';
import {PlayerInput} from '../PlayerInput';

/**
 * Run a deferred action many times, dynamically calculating each time.
 * This is a Deferred Action helper for running the same action
 * several times, producing input results each time.
 *
 * Very often a series of deferred actions don't depend on a prior one, and
 * those don't need RunNTimes -- just defer the same action in a loop.
 *
 * But there are cases, like, selecting spaces, where you don't want to
 * make the same space eligible in a series of selections.
 */
export abstract class RunNTimes<T> extends DeferredAction<ReadonlyArray<T>> {
  private nth: number = 1;
  protected collection: Array<T> = [];

  constructor(player: IPlayer, private count: number, priority?: Priority) {
    super(player, priority);
  }

  protected abstract run(): PlayerInput | undefined;

  protected titleSuffix(): string {
    return this.count > 1 ? ` (${this.nth} of ${this.count})` : '';
  }

  protected next() {
    this.nth++;
    if (this.nth <= this.count) {
      return this.run();
    }
    this.cb(this.collection);
    return undefined;
  }

  public execute(): PlayerInput | undefined {
    if (this.count === 0) {
      return undefined;
    }
    return this.run();
  }
}

================
File: deferredActions/SelectPaymentDeferred.ts
================
import {IPlayer} from '../IPlayer';
import {SelectPayment} from '../inputs/SelectPayment';
import {Payment} from '../../common/inputs/Payment';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {CardName} from '../../common/cards/CardName';
import {Message} from '../../common/logs/Message';
import {message} from '../logs/MessageBuilder';

export type Options = {
  canUseSteel?: boolean;
  canUseTitanium?: boolean;
  canUseSeeds?: boolean,
  canUseAuroraiData?: boolean,
  canUseGraphene?: boolean;
  canUseAsteroids?: boolean;
  canUseSpireScience?: boolean,
  title?: string | Message;
}

export class SelectPaymentDeferred extends DeferredAction<Payment> {
  constructor(
    player: IPlayer,
    public amount: number,
    public options: Options = {},
  ) {
    super(player, Priority.DEFAULT);
  }

  private mustPayWithMegacredits() {
    if (this.player.canUseHeatAsMegaCredits && this.player.availableHeat() > 0) {
      return false;
    }
    if (this.options.canUseSteel && this.player.steel > 0) {
      return false;
    }
    if (this.options.canUseTitanium && this.player.titanium > 0) {
      return false;
    }
    if (this.options.canUseGraphene && this.player.resourcesOnCard(CardName.CARBON_NANOSYSTEMS) > 0) {
      return false;
    }
    if (this.options.canUseAsteroids && this.player.resourcesOnCard(CardName.KUIPER_COOPERATIVE) > 0) {
      return false;
    }
    if (this.player.isCorporation(CardName.LUNA_TRADE_FEDERATION) && this.player.titanium > 0) {
      return false;
    }
    if (this.options.canUseSeeds && (this.player.resourcesOnCard(CardName.SOYLENT_SEEDLING_SYSTEMS) > 0)) {
      return false;
    }
    if (this.options.canUseAuroraiData && (this.player.resourcesOnCard(CardName.AURORAI) > 0)) {
      return false;
    }
    if (this.options.canUseSpireScience && (this.player.resourcesOnCard(CardName.SPIRE) > 0)) {
      return false;
    }

    return true;
  }

  public execute() {
    if (this.mustPayWithMegacredits()) {
      if (this.player.megaCredits < this.amount) {
        throw new Error(`Player does not have ${this.amount} M€`);
      }
      const payment = Payment.of({megaCredits: this.amount});
      this.player.pay(payment);
      this.cb(payment);
      return undefined;
    }

    return new SelectPayment(
      this.options.title || message('Select how to spend ${0} M€', (b) => b.number(this.amount)),
      this.amount,
      {
        steel: this.options.canUseSteel || false,
        titanium: this.options.canUseTitanium || false,
        heat: this.player.canUseHeatAsMegaCredits,
        seeds: this.options.canUseSeeds || false,
        auroraiData: this.options.canUseAuroraiData || false,
        spireScience: this.options.canUseSpireScience || false,
        lunaTradeFederationTitanium: this.player.canUseTitaniumAsMegacredits,
        kuiperAsteroids: this.options.canUseAsteroids || false,
      })
      .andThen((payment) => {
        this.player.pay(payment);
        this.cb(payment);
        return undefined;
      });
  }
}

================
File: deferredActions/SelectProductionToLoseDeferred.ts
================
import {SelectProductionToLose} from '../inputs/SelectProductionToLose';
import {IPlayer} from '../IPlayer';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {Units} from '../../common/Units';

export class SelectProductionToLoseDeferred extends DeferredAction {
  constructor(
    player: IPlayer,
    private unitsToLose: number,
    private title: string = `Choose ${unitsToLose} unit(s) of production to lose`,
  ) {
    super(player, Priority.LOSE_RESOURCE_OR_PRODUCTION);
  }

  public execute() {
    return new SelectProductionToLose(
      this.title,
      this.unitsToLose,
      this.player)
      .andThen((production) => {
        this.player.production.adjust(Units.negative(production), {log: true});
        return undefined;
      });
  }
}

================
File: deferredActions/SelectResourceTypeDeferred.ts
================
import {Resource} from '../../common/Resource';
import {OrOptions} from '../inputs/OrOptions';
import {SelectOption} from '../inputs/SelectOption';
import {IPlayer} from '../IPlayer';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';

export class SelectResourceTypeDeferred extends DeferredAction<Resource> {
  constructor(
    player: IPlayer,
    public resources: ReadonlyArray<Resource>,
    public title: string,
  ) {
    super(player, Priority.DEFAULT);
  }

  public execute() {
    const orOptions = new OrOptions();
    orOptions.title = this.title;
    orOptions.options = this.resources.map((resource) => {
      return new SelectOption(resource, 'OK').andThen(() => {
        this.cb(resource);
        return undefined;
      });
    });
    if (orOptions.options.length === 0) {
      return undefined;
    }
    if (orOptions.options.length === 1) {
      orOptions.options[0].cb();
      return undefined;
    }
    return orOptions;
  }
}

================
File: deferredActions/SendDelegateToArea.ts
================
import {IPlayer} from '../IPlayer';
import {SelectParty} from '../inputs/SelectParty';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {SelectPaymentDeferred} from './SelectPaymentDeferred';
import {Delegate, Turmoil} from '../turmoil/Turmoil';

export type Options = {
  /** The number of delegates to replace. Default is 1. */
  count?: number,
  /** If defined, this action is used to replace another player's delegates */
  replace?: Delegate | undefined,
  /** Cost for sending this delegate. Default is no cost. */
  cost?: number,
  freeStandardAction?: boolean,
}
export class SendDelegateToArea extends DeferredAction {
  private turmoil: Turmoil;

  constructor(
    player: IPlayer,
    public title: string = 'Select where to send a delegate',
    public options: Options = {},
  ) {
    super(player, Priority.DEFAULT);
    this.turmoil = Turmoil.getTurmoil(player.game);
  }

  private getAvailableParties() {
    // All parties are eligible, unless this action is used to replace a delegate.
    let parties = this.turmoil.parties;
    if (this.options.replace) {
      parties = this.turmoil.parties.filter((party) => {
        if (party.delegates.size < 2) return false;

        for (const delegate of party.delegates) {
          if (delegate !== this.options.replace) continue;
          if (delegate !== party.partyLeader) return true;
          return party.delegates.get(this.options.replace) > 1;
        }
        return false;
      });
    }

    return parties.map((party) => party.name);
  }

  public execute() {
    const availableParties = this.getAvailableParties();
    if (availableParties.length === 0) {
      return undefined;
    }
    const numDelegateToSend = this.options.count ?? 1;

    const sendDelegate = new SelectParty(this.title, 'Send delegate', availableParties)
      .andThen((partyName) => {
        if (this.options.cost) {
          this.player.game.defer(new SelectPaymentDeferred(this.player, this.options.cost, {title: 'Select how to pay for send delegate action'}));
        }

        for (let i = 0; i < numDelegateToSend; i++) {
          if (this.options.replace) {
            this.turmoil.replaceDelegateFromParty(this.options.replace, this.player, partyName, this.player.game);
          } else {
            this.turmoil.sendDelegateToParty(this.player, partyName, this.player.game);
          }
        }

        if (this.options?.freeStandardAction === true) {
          this.turmoil.usedFreeDelegateAction.add(this.player);
        }
        this.player.totalDelegatesPlaced += numDelegateToSend;
        this.player.game.log('${0} sent ${1} delegate(s) in ${2} area', (b) => b.player(this.player).number(numDelegateToSend).partyName(partyName));
        return undefined;
      });

    return sendDelegate;
  }
}

================
File: deferredActions/ShiftAresGlobalParametersDeferred.ts
================
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {IPlayer} from '../IPlayer';
import {ShiftAresGlobalParameters} from '../inputs/ShiftAresGlobalParameters';
import {AresHandler} from '../ares/AresHandler';
import {PlayerInput} from '../PlayerInput';

export class ShiftAresGlobalParametersDeferred extends DeferredAction {
  constructor(player: IPlayer) {
    super(player, Priority.DEFAULT);
  }

  public execute() {
    let pi: PlayerInput | undefined = undefined;
    AresHandler.ifAres(this.player.game, (aresData) => {
      pi = new ShiftAresGlobalParameters()
        .andThen((response) => {
          const hazardData = aresData.hazardData;
          if (hazardData.erosionOceanCount.available) {
            hazardData.erosionOceanCount.threshold += response.lowOceanDelta;
          }
          if (hazardData.removeDustStormsOceanCount.available) {
            hazardData.removeDustStormsOceanCount.threshold += response.highOceanDelta;
          }
          if (hazardData.severeErosionTemperature.available) {
            hazardData.severeErosionTemperature.threshold += (response.temperatureDelta * 2);
          }
          if (hazardData.severeDustStormOxygen.available) {
            hazardData.severeDustStormOxygen.threshold += response.oxygenDelta;
          }

          // Basically the order is irrelevant, but evaluating the severe erosions
          // first reduces the visual impact on players when this action simultaneously
          // reveals erosions and makes them severe.
          if (response.temperatureDelta !== 0) {
            AresHandler.onTemperatureChange(this.player.game, aresData);
          }
          if (response.oxygenDelta !== 0) {
            AresHandler.onOxygenChange(this.player.game, aresData);
          }
          if (response.lowOceanDelta !== 0 || response.highOceanDelta !== 0) {
            AresHandler.onOceanPlaced(aresData, this.player);
          }
          return undefined;
        });
    });
    if (pi === undefined) {
      throw new Error('Should not reach.');
    }
    return pi;
  }
}

================
File: deferredActions/StealResources.ts
================
import {IPlayer} from '../IPlayer';
import {Resource} from '../../common/Resource';
import {OrOptions} from '../inputs/OrOptions';
import {SelectOption} from '../inputs/SelectOption';
import {DeferredAction} from './DeferredAction';
import {Priority} from './Priority';
import {CardName} from '../../common/cards/CardName';
import {Message} from '../../common/logs/Message';
import {message} from '../logs/MessageBuilder';

export class StealResources extends DeferredAction {
  constructor(
    player: IPlayer,
    public resource: Resource,
    public count: number = 1,
    public title: string | Message = message('Select player to steal up to ${0} ${1} from', (b) => b.number(count).string(resource)),
  ) {
    super(player, Priority.ATTACK_OPPONENT);
  }

  public execute() {
    if (this.player.game.isSoloMode()) {
      this.player.stock.add(this.resource, this.count);
      this.player.resolveInsuranceInSoloGame();
      return undefined;
    }

    let candidates: Array<IPlayer> = this.player.getOpponents().filter((p) => p.stock.get(this.resource) > 0);
    if (this.resource === Resource.PLANTS) {
      candidates = candidates.filter((p) => !p.plantsAreProtected());
    }
    if (this.resource === Resource.STEEL || this.resource === Resource.TITANIUM) {
      candidates = candidates.filter((p) => !p.alloysAreProtected());
    }

    if (candidates.length === 0) {
      return undefined;
    }

    const stealOptions = candidates.map((target) => {
      let qtyToSteal = Math.min(target.stock.get(this.resource), this.count);

      // Botanical Experience hook.
      if (this.resource === Resource.PLANTS && target.cardIsInEffect(CardName.BOTANICAL_EXPERIENCE)) {
        qtyToSteal = Math.ceil(qtyToSteal / 2);
      }

      return new SelectOption(
        message('Steal ${0} ${1} from ${2}', (b) => b.number(qtyToSteal).string(this.resource).player(target)),
        'Steal')
        .andThen(() => {
          target.maybeBlockAttack(this.player, (proceed) => {
            if (proceed) {
              target.stock.deduct(this.resource, qtyToSteal, {log: true, from: this.player, stealing: true});
              this.player.stock.add(this.resource, qtyToSteal);
            }
            return undefined;
          });
          return undefined;
        });
    });

    return new OrOptions(
      ...stealOptions,
      new SelectOption('Do not steal'),
    );
  }
}

================
File: Draft.ts
================
import {inplaceRemove, copyAndClear as copyAndEmpty, zip} from '../common/utils/utils';
import {CardName} from '../common/cards/CardName';
import {IGame} from './IGame';
import {IPlayer} from './IPlayer';
import {IProjectCard} from './cards/IProjectCard';
import {LunaProjectOffice} from './cards/moon/LunaProjectOffice';
import {SelectCard} from './inputs/SelectCard';
import {message} from './logs/MessageBuilder';

export type DraftType = 'none' | 'initial' | 'prelude' | 'standard';

/*
 * Drafting terminology:
 *
 * Draft iteration: A complete cycle of draft rounds. In the standard draft, there are 4 draft rounds in a draft iteration.
 *  In the initial draft, there are 2 iterations, or up to 3 with preludes.
 * Draft round: A single pass through the players, where each player gets to pick a card.
*/

/**
 * Implements a specific draft.
 */
export abstract class Draft {
  constructor(public readonly type: DraftType, protected readonly game: IGame) {}

  /** draw cards into hand at the start of the iteration. */
  protected abstract draw(player: IPlayer): Array<IProjectCard>;
  /** The number of cards the player will choose in this draft round. Almost always 1. */
  protected abstract cardsToKeep(player: IPlayer): number;
  /** The direction in which cards are passed. Either to the player before (right) or after (left). */
  protected abstract passDirection(): 'before' | 'after';
  /** Called when all cards are drafted. */
  protected abstract endRound(): void;

  /** Start an entire draft iteration (or draft round). Saves the game, sets all the cards up, and asks players to make their first choice. */
  // TODO(kberg): Create a startDraft() which draws, and a continueDraft() which uses the cards a player is handed.
  public startDraft() {
    // Might be better to save the game after the draft, given how draft state is
    // restored now.
    this.game.save();
    this._startDraft();
  }

  private _startDraft() {
    const arrays: Array<Array<IProjectCard>> = [];
    if (this.game.draftRound === 1) {
      for (const player of this.game.getPlayers()) {
        arrays.push(this.draw(player));
      }
    } else {
      arrays.push(...this.game.getPlayers().map((player) => player.draftHand));
      if (this.passDirection() === 'after') {
        arrays.unshift(arrays.pop()!); // eslint-disable-line @typescript-eslint/no-non-null-assertion
      } else {
        arrays.push(arrays.shift()!); // eslint-disable-line @typescript-eslint/no-non-null-assertion
      }
    }

    for (const [player, draftHand] of zip(this.game.getPlayers(), arrays)) {
      player.draftHand = draftHand;
      player.needsToDraft = true;
      this.askPlayerToDraft(player);
    }
  }

  /**
   * Called when the game is reloaded from disk. Restores the draft state.
   *
   * Games are stored after every selection, whereas historically it was
   * stored after round. So restoring the draft is a bit tricky.
   */
  public restoreDraft() {
    const players = this.game.getPlayers();

    // When restoring drafting, it might be that nothing was dealt yet.
    if (!players.some((p) => p.needsToDraft !== undefined)) {
      this._startDraft();
      return;
    }

    for (const player of players) {
      if (player.needsToDraft) {
        this.askPlayerToDraft(player);
      }
    }

    if (!players.some((p) => p.needsToDraft)) {
      this.endRound();
    }
  }

  /** The player this player is taking their cards from when everybody passes their draft hands */
  private takingFrom(player: IPlayer): IPlayer {
    return this.passDirection() === 'after' ? this.game.getPlayerBefore(player) : this.game.getPlayerAfter(player);
  }

  /** The player this player is givign their cards to when everybody passes their draft hands */
  private givingTo(player: IPlayer): IPlayer {
    return this.passDirection() === 'after' ? this.game.getPlayerAfter(player) : this.game.getPlayerBefore(player);
  }

  /**
   * Ask the player to choose from a set of cards.
   */
  private askPlayerToDraft(player: IPlayer): void {
    const giveTo = this.givingTo(player);
    const cardsToKeep = this.cardsToKeep(player);

    const messageTitle = cardsToKeep === 1 ?
      'Select a card to keep and pass the rest to ${0}' :
      'Select two cards to keep and pass the rest to ${0}';
    player.setWaitingFor(
      new SelectCard(
        message(messageTitle, (b) => b.player(giveTo)),
        'Keep',
        player.draftHand,
        {min: cardsToKeep, max: cardsToKeep, played: false})
        .andThen((selected) => {
          for (const card of selected) {
            player.draftedCards.push(card);
            inplaceRemove(player.draftHand, card);
          }
          this.onCardDrafted(player);
          return undefined;
        }),
    );
  }

  /** Called when a player has chosen a card to draft. */
  private onCardDrafted(player: IPlayer): void {
    player.needsToDraft = false;

    // If anybody still needs to draft, stop here.
    if (this.game.getPlayers().some((p) => p.needsToDraft === true)) {
      this.game.save();
      return;
    }

    // If more than 1 card is to be passed to the next player, that means we're still drafting
    if (player.draftHand.length > 1) {
      this.game.draftRound++;
      this.startDraft();
      return;
    }

    // Push last cards for each player
    for (const player of this.game.getPlayers()) {
      player.draftedCards.push(...copyAndEmpty(this.takingFrom(player).draftHand));
      player.needsToDraft = undefined;
    }

    this.endRound();
  }
}

class StandardDraft extends Draft {
  constructor(game: IGame) {
    super('standard', game);
  }

  override draw(player: IPlayer) {
    const cardsToDraw = this.cardsToDraw(player);
    return this.game.projectDeck.drawN(this.game, cardsToDraw, 'bottom');
  }

  private cardsToDraw(player: IPlayer): number {
    if (LunaProjectOffice.isActive(player)) {
      return 5;
    }
    if (player.isCorporation(CardName.MARS_MATHS)) {
      return 5;
    }

    return 4;
  }

  override cardsToKeep(player: IPlayer): number {
    if (this.game.draftRound === 1) {
      if (LunaProjectOffice.isActive(player)) {
        return 2;
      }
      if (player.isCorporation(CardName.MARS_MATHS)) {
        return 2;
      }
    }

    return 1;
  }

  /** Return whether passing this round goes to the player after (right, +1) or before (left, -1) */
  override passDirection() {
    return this.game.generation % 2 === 0 ? 'after' : 'before';
  }

  override endRound() {
    this.game.gotoResearchPhase();
  }
}

class InitialDraft extends Draft {
  constructor(game: IGame) {
    super('initial', game);
  }

  override draw(_player: IPlayer) {
    return this.game.projectDeck.drawN(this.game, 5, 'bottom');
  }

  override cardsToKeep(_player: IPlayer): number {
    return 1;
  }

  override passDirection() {
    return this.game.initialDraftIteration === 2 ? 'before' : 'after';
  }

  override endRound() {
    this.game.initialDraftIteration++;
    // TODO(kberg): Move this to runDraftRound.
    this.game.draftRound = 1;

    switch (this.game.initialDraftIteration) {
    case 2:
      this.startDraft();
      break;
    case 3:
      for (const player of this.game.getPlayers()) {
        player.dealtProjectCards = player.draftedCards;
        player.draftedCards = [];
      }
      if (this.game.gameOptions.preludeExtension && this.game.gameOptions.preludeDraftVariant) {
        newPreludeDraft(this.game).startDraft();
      } else {
        this.game.gotoInitialResearchPhase();
      }
      break;
    }
  }
}

class PreludeDraft extends Draft {
  constructor(game: IGame) {
    super('prelude', game);
  }

  override draw(player: IPlayer) {
    return player.dealtPreludeCards;
  }

  override cardsToKeep(_player: IPlayer): number {
    return 1;
  }

  override passDirection(): 'after' {
    return 'after';
  }

  override endRound() {
    for (const player of this.game.getPlayers()) {
      player.dealtPreludeCards = player.draftedCards;
      player.draftedCards = [];
    }

    this.game.gotoInitialResearchPhase();
  }
}

export function newStandardDraft(game: IGame) {
  return new StandardDraft(game);
}

export function newInitialDraft(game: IGame) {
  return new InitialDraft(game);
}

export function newPreludeDraft(game: IGame) {
  return new PreludeDraft(game);
}

================
File: Game.ts
================
import * as constants from '../common/constants';
import {BeginnerCorporation} from './cards/corporation/BeginnerCorporation';
import {Board} from './boards/Board';
import {cardsFromJSON, newProjectCard} from './createCard';
import {CardName} from '../common/cards/CardName';
import {CardType} from '../common/cards/CardType';
import {ClaimedMilestone, serializeClaimedMilestones, deserializeClaimedMilestones} from './milestones/ClaimedMilestone';
import {ColonyDealer} from './colonies/ColonyDealer';
import {IColony} from './colonies/IColony';
import {Color} from '../common/Color';
import {ICorporationCard} from './cards/corporation/ICorporationCard';
import {Database} from './database/Database';
import {FundedAward, serializeFundedAwards, deserializeFundedAwards} from './awards/FundedAward';
import {IAward} from './awards/IAward';
import {IMilestone} from './milestones/IMilestone';
import {IProjectCard} from './cards/IProjectCard';
import {Space} from './boards/Space';
import {Tile} from './Tile';
import {LogMessageBuilder} from './logs/LogMessageBuilder';
import {LogHelper} from './LogHelper';
import {LogMessage} from '../common/logs/LogMessage';
import {ALL_MILESTONES} from './milestones/Milestones';
import {ALL_AWARDS} from './awards/Awards';
import {PartyHooks} from './turmoil/parties/PartyHooks';
import {Phase} from '../common/Phase';
import {IPlayer} from './IPlayer';
import {Player} from './Player';
import {PlayerId, GameId, SpectatorId, SpaceId} from '../common/Types';
import {PlayerInput} from './PlayerInput';
import {CardResource} from '../common/CardResource';
import {Resource} from '../common/Resource';
import {AndThen, DeferredAction} from './deferredActions/DeferredAction';
import {Priority} from './deferredActions/Priority';
import {DeferredActionsQueue} from './deferredActions/DeferredActionsQueue';
import {SelectPaymentDeferred} from './deferredActions/SelectPaymentDeferred';
import {SelectInitialCards} from './inputs/SelectInitialCards';
import {PlaceOceanTile} from './deferredActions/PlaceOceanTile';
import {RemoveColonyFromGame} from './deferredActions/RemoveColonyFromGame';
import {GainResources} from './deferredActions/GainResources';
import {SerializedGame} from './SerializedGame';
import {SpaceBonus} from '../common/boards/SpaceBonus';
import {TileType} from '../common/TileType';
import {Turmoil} from './turmoil/Turmoil';
import {RandomMAOptionType} from '../common/ma/RandomMAOptionType';
import {AresHandler} from './ares/AresHandler';
import {AresData} from '../common/ares/AresData';
import {GameSetup} from './GameSetup';
import {GameCards} from './GameCards';
import {GlobalParameter} from '../common/GlobalParameter';
import {AresSetup} from './ares/AresSetup';
import {MoonData} from './moon/MoonData';
import {MoonExpansion} from './moon/MoonExpansion';
import {TurmoilHandler} from './turmoil/TurmoilHandler';
import {SeededRandom} from '../common/utils/Random';
import {chooseMilestonesAndAwards} from './ma/MilestoneAwardSelector';
import {BoardType} from './boards/BoardType';
import {MultiSet} from 'mnemonist';
import {GrantVenusAltTrackBonusDeferred} from './venusNext/GrantVenusAltTrackBonusDeferred';
import {PathfindersExpansion} from './pathfinders/PathfindersExpansion';
import {PathfindersData} from './pathfinders/PathfindersData';
import {AddResourcesToCard} from './deferredActions/AddResourcesToCard';
import {ColonyDeserializer} from './colonies/ColonyDeserializer';
import {GameLoader} from './database/GameLoader';
import {DEFAULT_GAME_OPTIONS, GameOptions} from './game/GameOptions';
import {TheNewSpaceRace} from './cards/pathfinders/TheNewSpaceRace';
import {CorporationDeck, PreludeDeck, ProjectDeck, CeoDeck} from './cards/Deck';
import {Logger} from './logs/Logger';
import {addDays, dayStringToDays} from './database/utils';
import {ALL_TAGS, Tag} from '../common/cards/Tag';
import {IGame, Score} from './IGame';
import {MarsBoard} from './boards/MarsBoard';
import {UnderworldData} from './underworld/UnderworldData';
import {UnderworldExpansion} from './underworld/UnderworldExpansion';
import {SpaceType} from '../common/boards/SpaceType';
import {GenerationData} from './player/GenerationData';
import {SendDelegateToArea} from './deferredActions/SendDelegateToArea';
import {BuildColony} from './deferredActions/BuildColony';
import {newInitialDraft, newPreludeDraft, newStandardDraft} from './Draft';

// Can be overridden by tests

let createGameLog: () => Array<LogMessage> = () => [];

export function setGameLog(f: () => Array<LogMessage>) {
  createGameLog = f;
}

export class Game implements IGame, Logger {
  public readonly id: GameId;
  public readonly gameOptions: Readonly<GameOptions>;
  private players: Array<IPlayer>;

  // Game-level data
  public lastSaveId: number = 0;
  private clonedGamedId: string | undefined;
  public rng: SeededRandom;
  public spectatorId: SpectatorId | undefined;
  public deferredActions: DeferredActionsQueue = new DeferredActionsQueue();
  public createdTime: Date = new Date(0);
  public gameAge: number = 0; // Each log event increases it
  public gameLog: Array<LogMessage> = createGameLog();
  public undoCount: number = 0; // Each undo increases it
  public inputsThisRound = 0;
  public resettable: boolean = false;
  public globalsPerGeneration: Array<Partial<Record<GlobalParameter, number>>> = [];

  public generation: number = 1;
  public phase: Phase = Phase.RESEARCH;
  public projectDeck: ProjectDeck;
  public preludeDeck: PreludeDeck;
  public ceoDeck: CeoDeck;
  public corporationDeck: CorporationDeck;
  public board: MarsBoard;

  // Global parameters
  private oxygenLevel: number = constants.MIN_OXYGEN_LEVEL;
  private temperature: number = constants.MIN_TEMPERATURE;
  private venusScaleLevel: number = constants.MIN_VENUS_SCALE;

  // Player data
  public activePlayer: PlayerId;
  /** Players that are done with the game after final greenery placement. */
  private donePlayers = new Set<PlayerId>();
  private passedPlayers = new Set<PlayerId>();
  private researchedPlayers = new Set<PlayerId>();
  /** The first player of this generation. */
  public first: IPlayer;

  // Drafting

  public draftRound: number = 1;
  public initialDraftIteration: number = 1;

  // Milestones and awards
  public claimedMilestones: Array<ClaimedMilestone> = [];
  public milestones: Array<IMilestone> = [];
  public fundedAwards: Array<FundedAward> = [];
  public awards: Array<IAward> = [];

  // Expansion-specific data
  public colonies: Array<IColony> = [];
  public discardedColonies: Array<IColony> = []; // Not serialized
  public turmoil: Turmoil | undefined;
  public aresData: AresData | undefined;
  public moonData: MoonData | undefined;
  public pathfindersData: PathfindersData | undefined;
  public underworldData: UnderworldData = UnderworldExpansion.initializeGameWithoutUnderworld();

  // Card-specific data
  // Mons Insurance promo corp
  public monsInsuranceOwner?: PlayerId; // Not serialized
  // Crash Site promo project
  public someoneHasRemovedOtherPlayersPlants: boolean = false;
  // Syndicate Pirate Raids
  public syndicatePirateRaider?: PlayerId;
  // Gagarin Mobile Base
  public gagarinBase: Array<SpaceId> = [];
  // St. Joseph of Cupertino Mission
  stJosephCathedrals: Array<SpaceId> = [];
  // Mars Nomads
  nomadSpace: SpaceId | undefined = undefined;
  // Trade Embargo
  public tradeEmbargo: boolean = false;
  // Behold The Emperor
  public beholdTheEmperor: boolean = false;

  // The set of tags available in this game.
  public readonly tags: ReadonlyArray<Tag>;

  private constructor(
    id: GameId,
    players: Array<IPlayer>,
    first: IPlayer,
    activePlayer: PlayerId,
    gameOptions: GameOptions,
    rng: SeededRandom,
    board: MarsBoard,
    projectDeck: ProjectDeck,
    corporationDeck: CorporationDeck,
    preludeDeck: PreludeDeck,
    ceoDeck: CeoDeck) {
    this.id = id;
    this.gameOptions = {...gameOptions};
    this.players = players;
    const playerIds = players.map((p) => p.id);
    if (playerIds.includes(first.id) === false) {
      throw new Error('Cannot find first player ' + first.id + ' in ' + playerIds);
    }
    if (playerIds.includes(activePlayer) === false) {
      throw new Error('Cannot find active player ' + activePlayer + ' in ' + playerIds);
    }
    if (new Set(playerIds).size !== players.length) {
      throw new Error('Duplicate player found: ' + playerIds);
    }
    const colors = players.map((p) => p.color);
    if (new Set(colors).size !== players.length) {
      throw new Error('Duplicate color found: ' + colors);
    }

    this.activePlayer = activePlayer;
    this.first = first;
    this.rng = rng;
    this.projectDeck = projectDeck;
    this.corporationDeck = corporationDeck;
    this.preludeDeck = preludeDeck;
    this.ceoDeck = ceoDeck;
    this.board = board;

    this.players.forEach((player) => {
      player.game = this;
      if (player.isCorporation(CardName.MONS_INSURANCE)) this.monsInsuranceOwner = player.id;
    });

    this.tags = ALL_TAGS.filter((tag) => {
      if (tag === Tag.VENUS) return gameOptions.venusNextExtension;
      if (tag === Tag.MOON) return gameOptions.moonExpansion;
      if (tag === Tag.MARS) return gameOptions.pathfindersExpansion;
      if (tag === Tag.CLONE) return gameOptions.pathfindersExpansion;
      return true;
    });
  }

  public static newInstance(id: GameId,
    players: Array<IPlayer>,
    firstPlayer: IPlayer,
    options: Partial<GameOptions> = {},
    seed = 0,
    spectatorId: SpectatorId | undefined = undefined): Game {
    const gameOptions = {...DEFAULT_GAME_OPTIONS, ...options};
    if (gameOptions.clonedGamedId !== undefined) {
      throw new Error('Cloning should not come through this execution path.');
    }
    const rng = new SeededRandom(seed);
    const board = GameSetup.newBoard(gameOptions, rng);
    const gameCards = new GameCards(gameOptions);

    const projectDeck = new ProjectDeck(gameCards.getProjectCards(), [], rng);
    projectDeck.shuffle();

    const corporationDeck = new CorporationDeck(gameCards.getCorporationCards(), [], rng);
    corporationDeck.shuffle(gameOptions.customCorporationsList);

    const preludeDeck = new PreludeDeck(gameCards.getPreludeCards(), [], rng);
    preludeDeck.shuffle(gameOptions.customPreludes);

    const ceoDeck = new CeoDeck(gameCards.getCeoCards(), [], rng);
    ceoDeck.shuffle(gameOptions.customCeos);

    const activePlayer = firstPlayer.id;

    if (players.length === 1) {
      gameOptions.draftVariant = false;
      gameOptions.initialDraftVariant = false;
      gameOptions.preludeDraftVariant = false;
      gameOptions.randomMA = RandomMAOptionType.NONE;

      // Single player game player starts with 14TR
      players[0].setTerraformRating(14);
    }

    const game = new Game(id, players, firstPlayer, activePlayer, gameOptions, rng, board, projectDeck, corporationDeck, preludeDeck, ceoDeck);
    game.spectatorId = spectatorId;
    // This evaluation of created time doesn't match what's stored in the database, but that's fine.
    game.createdTime = new Date();
    // Initialize Ares data
    if (gameOptions.aresExtension) {
      game.aresData = AresSetup.initialData(gameOptions.aresHazards, players);
    }

    const milestonesAwards = chooseMilestonesAndAwards(gameOptions);
    game.milestones = milestonesAwards.milestones;
    game.awards = milestonesAwards.awards;

    // Add colonies stuff
    if (gameOptions.coloniesExtension) {
      const colonyDealer = new ColonyDealer(rng, gameOptions);
      colonyDealer.drawColonies(players.length);
      game.colonies = colonyDealer.colonies;
      game.discardedColonies = colonyDealer.discardedColonies;
    }

    // Add Turmoil stuff
    if (gameOptions.turmoilExtension) {
      game.turmoil = Turmoil.newInstance(game, gameOptions.politicalAgendasExtension);
    }

    // Must configure this before solo placement.
    if (gameOptions.underworldExpansion) {
      game.underworldData = UnderworldExpansion.initialize(rng);
    }

    // and 2 neutral cities and forests on board
    if (players.length === 1) {
      //  Setup solo player's starting tiles
      GameSetup.setupNeutralPlayer(game);
    }

    // Setup Ares hazards
    if (gameOptions.aresExtension && gameOptions.aresHazards) {
      AresSetup.setupHazards(game, players.length);
    }

    if (gameOptions.moonExpansion) {
      game.moonData = MoonExpansion.initialize(gameOptions, rng);
    }

    if (gameOptions.pathfindersExpansion) {
      game.pathfindersData = PathfindersExpansion.initialize(gameOptions);
    }

    // Failsafe for exceeding corporation pool
    // (I do not think this is necessary any further given how corporation cards are stored now)
    const minCorpsRequired = players.length * gameOptions.startingCorporations;
    if (minCorpsRequired > corporationDeck.drawPile.length) {
      gameOptions.startingCorporations = 2;
    }

    // Initialize each player:
    // Give them their corporation cards, other cards, starting production,
    // handicaps.
    for (const player of game.getPlayersInGenerationOrder()) {
      player.setTerraformRating(player.getTerraformRating() + player.handicap);
      if (!gameOptions.corporateEra) {
        player.production.override({
          megacredits: 1,
          steel: 1,
          titanium: 1,
          plants: 1,
          energy: 1,
          heat: 1,
        });
      }

      if (!player.beginner ||
        // Bypass beginner choice if any extension is choosen
        gameOptions.ceoExtension ||
        gameOptions.preludeExtension ||
        gameOptions.prelude2Expansion ||
        gameOptions.venusNextExtension ||
        gameOptions.coloniesExtension ||
        gameOptions.turmoilExtension ||
        gameOptions.initialDraftVariant ||
        gameOptions.preludeDraftVariant ||
        gameOptions.underworldExpansion ||
        gameOptions.moonExpansion) {
        player.dealtCorporationCards.push(...corporationDeck.drawN(game, gameOptions.startingCorporations));
        if (gameOptions.initialDraftVariant === false) {
          player.dealtProjectCards.push(...projectDeck.drawN(game, 10));
          const standardAlloys = newProjectCard(CardName.AERIAL_MAPPERS)         
          if (standardAlloys) {
            player.dealtProjectCards.push(standardAlloys);            
          }
          const spacePortColonyTest = newProjectCard(CardName.AIR_SCRAPPING_EXPEDITION)
          if (spacePortColonyTest) {
            player.dealtProjectCards.push(spacePortColonyTest);
          }  
          const spacePortColonyTest1 = newProjectCard(CardName.PHOBOS_SPACE_HAVEN)
          if (spacePortColonyTest1) {
            player.dealtProjectCards.push(spacePortColonyTest1);
          }            
        }
        if (gameOptions.preludeExtension) {
          player.dealtPreludeCards.push(...preludeDeck.drawN(game, constants.PRELUDE_CARDS_DEALT_PER_PLAYER));
        }
        if (gameOptions.ceoExtension) {
          player.dealtCeoCards.push(...ceoDeck.drawN(game, gameOptions.startingCeos));
        }
      } else {
        game.playerHasPickedCorporationCard(player, new BeginnerCorporation());
      }
    }

    // Print game_id if solo game
    if (players.length === 1) {
      game.log('The id of this game is ${0}', (b) => b.rawString(id));
    }

    players.forEach((player) => {
      game.log('Good luck ${0}!', (b) => b.player(player), {reservedFor: player});
    });

    game.log('Generation ${0}', (b) => b.forNewGeneration().number(game.generation));

    game.gotoInitialPhase();

    return game;
  }

  /** Properly starts the game with the project draft, or initial research phase. */
  public gotoInitialPhase(): void {
    // Initial Draft
    if (this.gameOptions.initialDraftVariant) {
      this.phase = Phase.INITIALDRAFTING;
      newInitialDraft(this).startDraft();
    } else {
      this.gotoInitialResearchPhase();
    }
  }

  public save(): void {
    GameLoader.getInstance().saveGame(this);
  }

  public toJSON(): string {
    return JSON.stringify(this.serialize());
  }

  public serialize(): SerializedGame {
    const result: SerializedGame = {
      activePlayer: this.activePlayer,
      awards: this.awards.map((a) => a.name),
      beholdTheEmperor: this.beholdTheEmperor,
      board: this.board.serialize(),
      claimedMilestones: serializeClaimedMilestones(this.claimedMilestones),
      ceoDeck: this.ceoDeck.serialize(),
      colonies: this.colonies.map((colony) => colony.serialize()),
      corporationDeck: this.corporationDeck.serialize(),
      createdTimeMs: this.createdTime.getTime(),
      currentSeed: this.rng.current,
      deferredActions: [],
      donePlayers: Array.from(this.donePlayers),
      draftRound: this.draftRound,
      first: this.first.id,
      fundedAwards: serializeFundedAwards(this.fundedAwards),
      gagarinBase: this.gagarinBase,
      stJosephCathedrals: this.stJosephCathedrals,
      nomadSpace: this.nomadSpace,
      gameAge: this.gameAge,
      gameLog: this.gameLog,
      gameOptions: this.gameOptions,
      generation: this.generation,
      globalsPerGeneration: this.globalsPerGeneration,
      id: this.id,
      initialDraftIteration: this.initialDraftIteration,
      lastSaveId: this.lastSaveId,
      milestones: this.milestones.map((m) => m.name),
      moonData: MoonData.serialize(this.moonData),
      oxygenLevel: this.oxygenLevel,
      passedPlayers: Array.from(this.passedPlayers),
      pathfindersData: PathfindersData.serialize(this.pathfindersData),
      phase: this.phase,
      players: this.players.map((p) => p.serialize()),
      preludeDeck: this.preludeDeck.serialize(),
      projectDeck: this.projectDeck.serialize(),
      researchedPlayers: Array.from(this.researchedPlayers),
      seed: this.rng.seed,
      someoneHasRemovedOtherPlayersPlants: this.someoneHasRemovedOtherPlayersPlants,
      spectatorId: this.spectatorId,
      syndicatePirateRaider: this.syndicatePirateRaider,
      temperature: this.temperature,
      tradeEmbargo: this.tradeEmbargo,
      underworldData: this.underworldData,
      undoCount: this.undoCount,
      venusScaleLevel: this.venusScaleLevel,
    };
    if (this.aresData !== undefined) {
      result.aresData = this.aresData;
    }
    if (this.clonedGamedId !== undefined) {
      result.clonedGamedId = this.clonedGamedId;
    }
    if (this.turmoil !== undefined) {
      result.turmoil = this.turmoil.serialize();
    }
    return result;
  }

  public isSoloMode() :boolean {
    return this.players.length === 1;
  }

  // Function to retrieve a player by it's id
  public getPlayerById(id: PlayerId): IPlayer {
    const player = this.players.find((p) => p.id === id);
    if (player === undefined) {
      throw new Error(`player ${id} does not exist on game ${this.id}`);
    }
    return player;
  }

  // Function to return an array of players from an array of player ids
  public getPlayersById(ids: Array<PlayerId>): Array<IPlayer> {
    return ids.map((id) => this.getPlayerById(id));
  }

  public defer<T>(action: DeferredAction<T>, priority?: Priority): AndThen<T> {
    if (priority !== undefined) {
      action.priority = priority;
    }
    this.deferredActions.push(action);
    return action;
  }

  public milestoneClaimed(milestone: IMilestone): boolean {
    return this.claimedMilestones.some(
      (claimedMilestone) => claimedMilestone.milestone.name === milestone.name,
    );
  }

  public marsIsTerraformed(): boolean {
    const oxygenMaxed = this.oxygenLevel >= constants.MAX_OXYGEN_LEVEL;
    const temperatureMaxed = this.temperature >= constants.MAX_TEMPERATURE;
    const oceansMaxed = !this.canAddOcean();
    let globalParametersMaxed = oxygenMaxed && temperatureMaxed && oceansMaxed;
    const venusMaxed = this.getVenusScaleLevel() === constants.MAX_VENUS_SCALE;

    MoonExpansion.ifMoon(this, (moonData) => {
      if (this.gameOptions.requiresMoonTrackCompletion) {
        const moonMaxed =
          moonData.habitatRate === constants.MAXIMUM_HABITAT_RATE &&
          moonData.miningRate === constants.MAXIMUM_MINING_RATE &&
          moonData.logisticRate === constants.MAXIMUM_LOGISTICS_RATE;
        globalParametersMaxed = globalParametersMaxed && moonMaxed;
      }
    });

    // Solo games with Venus needs Venus maxed to end the game.
    if (this.players.length === 1 && this.gameOptions.venusNextExtension) {
      return globalParametersMaxed && venusMaxed;
    }
    // Option "requiresVenusTrackCompletion" also makes maximizing Venus a game-end requirement
    if (this.gameOptions.venusNextExtension && this.gameOptions.requiresVenusTrackCompletion) {
      return globalParametersMaxed && venusMaxed;
    }
    return globalParametersMaxed;
  }

  public lastSoloGeneration(): number {
    let lastGeneration = 14;
    const options = this.gameOptions;
    if (options.preludeExtension) {
      lastGeneration -= 2;
    }

    // Only add 2 more generations when using the track completion option
    // and not the solo TR option.
    //
    // isSoloModeWin backs this up.
    if (options.moonExpansion) {
      if (!options.soloTR && options.requiresMoonTrackCompletion) {
        lastGeneration += 2;
      }
    }
    return lastGeneration;
  }

  public isSoloModeWin(): boolean {
    // Solo TR victory condition
    if (this.gameOptions.soloTR) {
      return this.players[0].getTerraformRating() >= 63;
    }

    // Complete terraforing victory condition.
    if (!this.marsIsTerraformed()) {
      return false;
    }

    // This last conditional doesn't make much sense to me. It's only ever really used
    // on the client at components/GameEnd.ts. Which is probably why it doesn't make
    // obvious sense why when this generation is earlier than the last generation
    // of the game means "true, is solo mode win."
    return this.generation <= this.lastSoloGeneration();
  }

  public getAwardFundingCost(): number {
    return 8 + (6 * this.fundedAwards.length);
  }

  public fundAward(player: IPlayer, award: IAward): void {
    if (this.allAwardsFunded()) {
      throw new Error('All awards already funded');
    }
    this.log('${0} funded ${1} award',
      (b) => b.player(player).award(award));

    if (this.hasBeenFunded(award)) {
      throw new Error(award.name + ' cannot is already funded.');
    }
    this.fundedAwards.push({
      award: award,
      player: player,
    });
  }

  public hasBeenFunded(award: IAward): boolean {
    return this.fundedAwards.some(
      (fundedAward) => fundedAward.award.name === award.name,
    );
  }

  public allAwardsFunded(): boolean {
    // Awards are disabled for 1 player games
    if (this.players.length === 1) return true;

    return this.fundedAwards.length >= constants.MAX_AWARDS;
  }

  public allMilestonesClaimed(): boolean {
    // Milestones are disabled for 1 player games
    if (this.players.length === 1) return true;

    return this.claimedMilestones.length >= constants.MAX_MILESTONES;
  }

  private playerHasPickedCorporationCard(player: IPlayer, corporationCard: ICorporationCard): void {
    // TODO(kberg): I think we can get rid of this weird validation at a later time.
    player.pickedCorporationCard = corporationCard;
    if (this.players.every((p) => p.pickedCorporationCard !== undefined)) {
      for (const somePlayer of this.getPlayersInGenerationOrder()) {
        if (somePlayer.pickedCorporationCard === undefined) {
          throw new Error(`pickedCorporationCard is not defined for ${somePlayer.id}`);
        }
        somePlayer.playCorporationCard(somePlayer.pickedCorporationCard);
      }
    }
  }

  private selectInitialCards(player: IPlayer): PlayerInput {
    return new SelectInitialCards(player, (corporation: ICorporationCard) => {
      this.playerHasPickedCorporationCard(player, corporation);
      return undefined;
    });
  }

  public hasPassedThisActionPhase(player: IPlayer): boolean {
    return this.passedPlayers.has(player.id);
  }

  // Public for testing.
  public incrementFirstPlayer(): void {
    let firstIndex = this.players.map((x) => x.id).indexOf(this.first.id);
    if (firstIndex === -1) {
      throw new Error('Didn\'t even find player');
    }
    firstIndex = (firstIndex + 1) % this.players.length;
    this.first = this.players[firstIndex];
  }

  // Only used in the prelude The New Space Race.
  public overrideFirstPlayer(newFirstPlayer: IPlayer): void {
    if (newFirstPlayer.game.id !== this.id) {
      throw new Error(`player ${newFirstPlayer.id} is not part of this game`);
    }
    this.first = newFirstPlayer;
  }

  public gotoInitialResearchPhase(): void {
    this.phase = Phase.RESEARCH;

    this.save();

    for (const player of this.players) {
      if (player.pickedCorporationCard === undefined && player.dealtCorporationCards.length > 0) {
        player.setWaitingFor(this.selectInitialCards(player));
      }
    }
    if (this.players.length === 1 && this.gameOptions.coloniesExtension) {
      this.players[0].production.add(Resource.MEGACREDITS, -2);
      this.defer(new RemoveColonyFromGame(this.players[0]));
    }
  }

  public gotoResearchPhase(): void {
    this.phase = Phase.RESEARCH;
    this.researchedPlayers.clear();
    this.save();
    this.players.forEach((player) => {
      player.runResearchPhase();
    });
  }

  private gotoDraftPhase(): void {
    this.phase = Phase.DRAFTING;
    this.draftRound = 1;
    newStandardDraft(this).startDraft();
  }

  public gameIsOver(): boolean {
    if (this.isSoloMode()) {
      // Solo games continue until the designated generation end even if Mars is already terraformed
      return this.generation === this.lastSoloGeneration();
    }
    return this.marsIsTerraformed();
  }

  public isDoneWithFinalProduction(): boolean {
    return this.phase === Phase.END || (this.gameIsOver() && this.phase === Phase.PRODUCTION);
  }

  private gotoProductionPhase(): void {
    this.phase = Phase.PRODUCTION;
    this.passedPlayers.clear();
    this.someoneHasRemovedOtherPlayersPlants = false;
    this.players.forEach((player) => {
      player.colonies.cardDiscount = 0; // Iapetus reset hook
      player.runProductionPhase();
    });
    this.postProductionPhase();
  }

  private postProductionPhase(): void {
    if (this.deferredActions.length > 0) {
      this.deferredActions.runAll(() => this.postProductionPhase());
      return;
    }
    if (this.gameIsOver()) {
      this.log('Final greenery placement', (b) => b.forNewGeneration());
      this.takeNextFinalGreeneryAction();
      return;
    } else {
      this.players.forEach((player) => {
        player.colonies.returnTradeFleets();
      });
    }

    // solar Phase Option
    this.phase = Phase.SOLAR;
    if (this.gameOptions.solarPhaseOption && ! this.marsIsTerraformed()) {
      this.gotoWorldGovernmentTerraforming();
      return;
    }
    this.gotoEndGeneration();
  }

  private endGenerationForColonies() {
    if (this.gameOptions.coloniesExtension) {
      this.colonies.forEach((colony) => {
        colony.endGeneration(this);
      });
      // Syndicate Pirate Raids hook. Also see Colony.ts and Player.ts
      this.syndicatePirateRaider = undefined;
      // Trade embargo hook.
      this.tradeEmbargo = false;
    }
  }

  private gotoEndGeneration() {
    this.endGenerationForColonies();

    Turmoil.ifTurmoil(this, (turmoil) => {
      turmoil.endGeneration(this);
      // Behold The Emperor hook
      this.beholdTheEmperor = false;
    });

    UnderworldExpansion.endGeneration(this);

    // turmoil.endGeneration might have added actions.
    if (this.deferredActions.length > 0) {
      this.deferredActions.runAll(() => this.startGeneration());
    } else {
      this.startGeneration();
    }
  }

  private updatePlayerVPForTheGeneration(): void {
    this.getPlayers().forEach((player) => {
      player.victoryPointsByGeneration.push(player.getVictoryPoints().total);
    });
  }

  private updateGlobalsForTheGeneration(): void {
    if (!Array.isArray(this.globalsPerGeneration)) {
      this.globalsPerGeneration = [];
    }
    this.globalsPerGeneration.push({});
    const entry = this.globalsPerGeneration[this.globalsPerGeneration.length - 1];
    entry[GlobalParameter.TEMPERATURE] = this.temperature;
    entry[GlobalParameter.OXYGEN] = this.oxygenLevel;
    entry[GlobalParameter.OCEANS] = this.board.getOceanSpaces().length;
    if (this.gameOptions.venusNextExtension) {
      entry[GlobalParameter.VENUS] = this.venusScaleLevel;
    }
    MoonExpansion.ifMoon(this, (moonData) => {
      entry[GlobalParameter.MOON_HABITAT_RATE] = moonData.habitatRate;
      entry[GlobalParameter.MOON_MINING_RATE] = moonData.miningRate;
      entry[GlobalParameter.MOON_LOGISTICS_RATE] = moonData.logisticRate;
    });
  }

  private startGeneration() {
    this.phase = Phase.INTERGENERATION;

    // Reset Generation data
    this.players.forEach((player) => player.generationData = new GenerationData());

    this.updatePlayerVPForTheGeneration();
    this.updateGlobalsForTheGeneration();
    this.generation++;
    this.log('Generation ${0}', (b) => b.forNewGeneration().number(this.generation));
    this.incrementFirstPlayer();

    if (this.gameOptions.draftVariant) {
      this.gotoDraftPhase();
    } else {
      this.gotoResearchPhase();
    }
  }

  private gotoWorldGovernmentTerraforming() {
    this.first.worldGovernmentTerraforming();
  }

  public doneWorldGovernmentTerraforming() {
    // Carry on to next phase
    this.gotoEndGeneration();
  }

  private allPlayersHavePassed(): boolean {
    for (const player of this.players) {
      if (!this.hasPassedThisActionPhase(player)) {
        return false;
      }
    }
    return true;
  }

  public playerHasPassed(player: IPlayer): void {
    this.passedPlayers.add(player.id);
  }

  public hasResearched(player: IPlayer): boolean {
    return this.researchedPlayers.has(player.id);
  }

  private allPlayersHaveFinishedResearch(): boolean {
    for (const player of this.players) {
      if (!this.hasResearched(player)) {
        return false;
      }
    }
    return true;
  }

  public playerIsFinishedWithResearchPhase(player: IPlayer): void {
    this.deferredActions.runAllFor(player, () => {
      this.researchedPlayers.add(player.id);
      if (this.allPlayersHaveFinishedResearch()) {
        this.phase = Phase.ACTION;
        this.passedPlayers.clear();
        TheNewSpaceRace.potentiallyChangeFirstPlayer(this);
        this.startActionsForPlayer(this.first);
      }
    });
  }

  public getPlayerBefore(player: IPlayer): IPlayer {
    const playerIndex = this.players.indexOf(player);
    if (playerIndex === -1) {
      throw new Error(`Player ${player.id} not in game ${this.id}`);
    }

    // Go to the end of the array if stand at the start
    return this.players[(playerIndex === 0) ? this.players.length - 1 : playerIndex - 1];
  }

  public getPlayerAfter(player: IPlayer): IPlayer {
    const playerIndex = this.players.indexOf(player);

    if (playerIndex === -1) {
      throw new Error(`Player ${player.id} not in game ${this.id}`);
    }

    // Go to the beginning of the array if we reached the end
    return this.players[(playerIndex + 1 >= this.players.length) ? 0 : playerIndex + 1];
  }

  public playerIsFinishedTakingActions(): void {
    if (this.deferredActions.length > 0) {
      this.deferredActions.runAll(() => this.playerIsFinishedTakingActions());
      return;
    }

    this.inputsThisRound = 0;

    // This next section can be done more simply.
    if (this.allPlayersHavePassed()) {
      this.gotoProductionPhase();
      return;
    }

    const nextPlayer = this.getPlayerAfter(this.getPlayerById(this.activePlayer));
    if (!this.hasPassedThisActionPhase(nextPlayer)) {
      this.startActionsForPlayer(nextPlayer);
    } else {
      // Recursively find the next player
      this.activePlayer = nextPlayer.id;
      this.playerIsFinishedTakingActions();
    }
  }

  private async gotoEndGame(): Promise<void> {
    // Log id or cloned game id
    if (this.clonedGamedId !== undefined && this.clonedGamedId.startsWith('#')) {
      const clonedGamedId = this.clonedGamedId;
      this.log('This game was a clone from game ${0}', (b) => b.rawString(clonedGamedId));
    } else {
      const id = this.id;
      this.log('This game id was ${0}', (b) => b.rawString(id));
    }

    const scores: Array<Score> = [];
    this.players.forEach((player) => {
      const corporation = player.corporations.map((c) => c.name).join('|');
      const vpb = player.getVictoryPoints();
      scores.push({corporation: corporation, playerScore: vpb.total});
    });

    Database.getInstance().saveGameResults(this.id, this.players.length, this.generation, this.gameOptions, scores);
    this.phase = Phase.END;
    const gameLoader = GameLoader.getInstance();
    await gameLoader.saveGame(this);
    gameLoader.completeGame(this);
  }

  // Part of final greenery placement.
  public canPlaceGreenery(player: IPlayer): boolean {
    return !this.donePlayers.has(player.id) &&
            player.plants >= player.plantsNeededForGreenery &&
            this.board.getAvailableSpacesForGreenery(player).length > 0;
  }

  // Called when a player cannot or chose not to place any more greeneries.
  public playerIsDoneWithGame(player: IPlayer): void {
    this.donePlayers.add(player.id);
    // Go back in to find someone else to play final greeneries.
    this.takeNextFinalGreeneryAction();
  }

  /**
   * Find the next player who might be able to place a final greenery and ask them.
   *
   * If nobody can add a greenery, end the game.
   */
  public /* for testing */ takeNextFinalGreeneryAction(): void {
    for (const player of this.getPlayersInGenerationOrder()) {
      if (this.donePlayers.has(player.id)) {
        continue;
      }

      // You many not place greeneries in solo mode unless you have already won the game
      // (e.g. completed global parameters, reached TR63.)
      if (this.isSoloMode() && !this.isSoloModeWin()) {
        this.log('Final greenery phase is skipped since you did not complete the win condition.', (b) => b.forNewGeneration());
        continue;
      }

      if (this.canPlaceGreenery(player)) {
        this.activePlayer = player.id;
        player.takeActionForFinalGreenery();
        return;
      } else if (player.getWaitingFor() !== undefined) {
        return;
      } else {
        this.donePlayers.add(player.id);
      }
    }
    this.updatePlayerVPForTheGeneration();
    this.updateGlobalsForTheGeneration();
    this.gotoEndGame();
  }

  private startActionsForPlayer(player: IPlayer) {
    this.activePlayer = player.id;
    player.actionsTakenThisRound = 0;

    player.takeAction();
  }

  public increaseOxygenLevel(player: IPlayer, increments: -2 | -1 | 1 | 2): void {
    if (this.oxygenLevel >= constants.MAX_OXYGEN_LEVEL) {
      return undefined;
    }

    // PoliticalAgendas Reds P3 && Magnetic Field Stimulation Delays hook
    if (increments < 0) {
      this.oxygenLevel = Math.max(constants.MIN_OXYGEN_LEVEL, this.oxygenLevel + increments);
      return undefined;
    }
    // Literal typing makes |increments| a const
    const steps = Math.min(increments, constants.MAX_OXYGEN_LEVEL - this.oxygenLevel);
    player.playedCards.forEach((card) => card.onGlobalParameterIncrease?.(player, GlobalParameter.OXYGEN, steps));

    if (this.phase !== Phase.SOLAR) {
      TurmoilHandler.onGlobalParameterIncrease(player, GlobalParameter.OXYGEN, steps);
      player.increaseTerraformRating(steps);
      player.generationData.hasRaisedGlobalParameter[GlobalParameter.OXYGEN] = true;
    }
    if (this.oxygenLevel < constants.OXYGEN_LEVEL_FOR_TEMPERATURE_BONUS &&
      this.oxygenLevel + steps >= constants.OXYGEN_LEVEL_FOR_TEMPERATURE_BONUS) {
      this.increaseTemperature(player, 1);
    }

    this.oxygenLevel += steps;

    AresHandler.ifAres(this, (aresData) => {
      AresHandler.onOxygenChange(this, aresData);
    });
  }

  public getOxygenLevel(): number {
    return this.oxygenLevel;
  }

  public increaseVenusScaleLevel(player: IPlayer, increments: -1 | 1 | 2 | 3): number {
    if (this.venusScaleLevel >= constants.MAX_VENUS_SCALE) {
      return 0;
    }

    // PoliticalAgendas Reds P3 hook
    if (increments === -1) {
      this.venusScaleLevel = Math.max(constants.MIN_VENUS_SCALE, this.venusScaleLevel + increments * 2);
      return -1;
    }

    // Literal typing makes |increments| a const
    const steps = Math.min(increments, (constants.MAX_VENUS_SCALE - this.venusScaleLevel) / 2);

    if (this.phase !== Phase.SOLAR) {
      if (this.venusScaleLevel < constants.VENUS_LEVEL_FOR_CARD_BONUS &&
        this.venusScaleLevel + steps * 2 >= constants.VENUS_LEVEL_FOR_CARD_BONUS) {
        player.drawCard();
      }
      if (this.venusScaleLevel < constants.VENUS_LEVEL_FOR_TR_BONUS &&
        this.venusScaleLevel + steps * 2 >= constants.VENUS_LEVEL_FOR_TR_BONUS) {
        player.increaseTerraformRating();
      }
      if (this.gameOptions.altVenusBoard) {
        const newValue = this.venusScaleLevel + steps * 2;
        const minimalBaseline = Math.max(this.venusScaleLevel, constants.ALT_VENUS_MINIMUM_BONUS);
        const maximumBaseline = Math.min(newValue, constants.MAX_VENUS_SCALE);
        const standardResourcesGranted = Math.max((maximumBaseline - minimalBaseline) / 2, 0);

        const grantWildResource = this.venusScaleLevel + (steps * 2) >= constants.MAX_VENUS_SCALE;
        // The second half of this expression removes any increases earler than 16-to-18.
        if (grantWildResource || standardResourcesGranted > 0) {
          this.defer(new GrantVenusAltTrackBonusDeferred(player, standardResourcesGranted, grantWildResource));
        }
      }
      player.playedCards.forEach((card) => card.onGlobalParameterIncrease?.(player, GlobalParameter.VENUS, steps));
      TurmoilHandler.onGlobalParameterIncrease(player, GlobalParameter.VENUS, steps);
      player.increaseTerraformRating(steps);
      player.generationData.hasRaisedGlobalParameter[GlobalParameter.VENUS] = true;
    }

    const aphrodite = this.players.find((p) => p.isCorporation(CardName.APHRODITE_RB));
    if (aphrodite !== undefined) {
      aphrodite.megaCredits += steps * 3;
      this.log('${0} gained ${1} M€ from Aphrodite effect', (b) => b.player(aphrodite).number(steps * 3));
    }
  
    if (aphrodite !== undefined && this.phase !== Phase.SOLAR) {
      player.megaCredits += steps * 2;
      this.log('${0} gained ${1} M€ from raising Venus', (b) => b.player(player).number(steps * 2));
    }
    

    const venusGHGExports = this.players.find((player) => player.cardIsInEffect(CardName.VENUS_GHG_EXPORTS));
    if (venusGHGExports !== undefined) {
      venusGHGExports.stock.add(Resource.HEAT, steps * 2, {log: true});
    }

    this.venusScaleLevel += steps * 2;

    return steps;
  }

  public getVenusScaleLevel(): number {
    return this.venusScaleLevel;
  }

  public increaseTemperature(player: IPlayer, increments: -2 | -1 | 1 | 2 | 3): undefined {
    if (this.temperature >= constants.MAX_TEMPERATURE) {
      return undefined;
    }

    if (increments === -2 || increments === -1) {
      this.temperature = Math.max(constants.MIN_TEMPERATURE, this.temperature + increments * 2);
      return undefined;
    }

    // Literal typing makes |increments| a const
    const steps = Math.min(increments, (constants.MAX_TEMPERATURE - this.temperature) / 2);

    if (this.phase !== Phase.SOLAR) {
      // BONUS FOR HEAT PRODUCTION AT -20 and -24
      if (this.temperature < constants.TEMPERATURE_BONUS_FOR_HEAT_1 &&
        this.temperature + steps * 2 >= constants.TEMPERATURE_BONUS_FOR_HEAT_1) {
        player.production.add(Resource.HEAT, 1, {log: true});
      }
      if (this.temperature < constants.TEMPERATURE_BONUS_FOR_HEAT_2 &&
        this.temperature + steps * 2 >= constants.TEMPERATURE_BONUS_FOR_HEAT_2) {
        player.production.add(Resource.HEAT, 1, {log: true});
      }

      player.playedCards.forEach((card) => card.onGlobalParameterIncrease?.(player, GlobalParameter.TEMPERATURE, steps));
      TurmoilHandler.onGlobalParameterIncrease(player, GlobalParameter.TEMPERATURE, steps);
      player.increaseTerraformRating(steps);
      player.generationData.hasRaisedGlobalParameter[GlobalParameter.TEMPERATURE] = true;
    }

    // BONUS FOR OCEAN TILE AT 0
    if (this.temperature < constants.TEMPERATURE_FOR_OCEAN_BONUS && this.temperature + steps * 2 >= constants.TEMPERATURE_FOR_OCEAN_BONUS) {
      this.defer(new PlaceOceanTile(player, {title: 'Select space for ocean from temperature increase'}));
    }

    this.temperature += steps * 2;

    AresHandler.ifAres(this, (aresData) => {
      AresHandler.onTemperatureChange(this, aresData);
    });
    UnderworldExpansion.onTemperatureChange(this, steps);
    return undefined;
  }

  public getTemperature(): number {
    return this.temperature;
  }

  public getGeneration(): number {
    return this.generation;
  }

  public getPassedPlayers():Array<Color> {
    const passedPlayersColors: Array<Color> = [];
    this.passedPlayers.forEach((player) => {
      passedPlayersColors.push(this.getPlayerById(player).color);
    });
    return passedPlayersColors;
  }

  // addTile applies to the Mars board, but not the Moon board, see MoonExpansion.addTile for placing
  // a tile on The Moon.
  public addTile(
    player: IPlayer,
    space: Space,
    tile: Tile): void {
    // Part 1, basic validation checks.

    if (space.tile !== undefined && !(this.gameOptions.aresExtension || this.gameOptions.pathfindersExpansion)) {
      throw new Error('Selected space is occupied');
    }

    // Land claim a player can claim land for themselves
    if (space.player !== undefined && space.player !== player) {
      throw new Error('This space is land claimed by ' + space.player.name);
    }

    if (!AresHandler.canCover(space, tile)) {
      throw new Error('Selected space is occupied: ' + space.id);
    }

    // Oceans are not subject to Ares adjacency production penalties.
    const subjectToHazardAdjacency = tile.tileType !== TileType.OCEAN;

    AresHandler.ifAres(this, () => {
      AresHandler.assertCanPay(player, space, subjectToHazardAdjacency);
    });

    // Part 2. Collect additional fees.
    // Adjacency costs are before the hellas ocean tile because this is a mandatory cost.
    AresHandler.ifAres(this, () => {
      AresHandler.payAdjacencyAndHazardCosts(player, space, subjectToHazardAdjacency);
    });

    TurmoilHandler.resolveTilePlacementCosts(player);

    // Part 3. Setup for bonuses
    const initialTileTypeForAres = space.tile?.tileType;
    const coveringExistingTile = space.tile !== undefined;
    const arcadianCommunityBonus = space.player === player && player.isCorporation(CardName.ARCADIAN_COMMUNITIES);

    // Part 4. Place the tile
    this.simpleAddTile(player, space, tile);

    // Part 5. Collect the bonuses
    if (this.phase !== Phase.SOLAR) {
      this.grantPlacementBonuses(player, space, coveringExistingTile, arcadianCommunityBonus);

      AresHandler.ifAres(this, (aresData) => {
        AresHandler.maybeIncrementMilestones(aresData, player, space);
      });
    } else {
      space.player = undefined;
    }

    this.players.forEach((p) => {
      p.tableau.forEach((playedCard) => {
        playedCard.onTilePlaced?.(p, player, space, BoardType.MARS);
      });
    });

    AresHandler.ifAres(this, () => {
      AresHandler.grantBonusForRemovingHazard(player, initialTileTypeForAres);
    });

    if (this.gameOptions.underworldExpansion) {
      if (space.spaceType !== SpaceType.COLONY && space.player === player) {
        UnderworldExpansion.identify(this, space, player);
      }
    }
  }

  public grantPlacementBonuses(player: IPlayer, space: Space, coveringExistingTile: boolean, arcadianCommunityBonus: boolean = false) {
    if (!coveringExistingTile) {
      this.grantSpaceBonuses(player, space);
    }

    this.board.getAdjacentSpaces(space).forEach((adjacentSpace) => {
      if (Board.isOceanSpace(adjacentSpace)) {
        player.megaCredits += player.oceanBonus;
      }
    });

    if (space.tile !== undefined) {
      AresHandler.ifAres(this, () => {
        AresHandler.earnAdjacencyBonuses(player, space);
      });

      TurmoilHandler.resolveTilePlacementBonuses(player, space.spaceType);

      if (arcadianCommunityBonus) {
        this.defer(new GainResources(player, Resource.MEGACREDITS, {count: 3}));
      }
    }
  }

  public simpleAddTile(player: IPlayer, space: Space, tile: Tile) {
    space.tile = tile;
    if (tile.tileType === TileType.OCEAN ||
      tile.tileType === TileType.MARTIAN_NATURE_WONDERS ||
      tile.tileType === TileType.REY_SKYWALKER) {
      space.player = undefined;
    } else {
      space.player = player;
    }
    LogHelper.logTilePlacement(player, space, tile.tileType);
  }

  public grantSpaceBonuses(player: IPlayer, space: Space) {
    const bonuses = MultiSet.from(space.bonus);
    bonuses.forEachMultiplicity((count: number, bonus: SpaceBonus) => {
      this.grantSpaceBonus(player, bonus, count);
    });
  }

  public grantSpaceBonus(player: IPlayer, spaceBonus: SpaceBonus, count: number = 1) {
    switch (spaceBonus) {
    case SpaceBonus.DRAW_CARD:
      player.drawCard(count);
      break;
    case SpaceBonus.PLANT:
      player.stock.add(Resource.PLANTS, count, {log: true});
      break;
    case SpaceBonus.STEEL:
      player.stock.add(Resource.STEEL, count, {log: true});
      break;
    case SpaceBonus.TITANIUM:
      player.stock.add(Resource.TITANIUM, count, {log: true});
      break;
    case SpaceBonus.HEAT:
      player.stock.add(Resource.HEAT, count, {log: true});
      break;
    case SpaceBonus.OCEAN:
      // Hellas special requirements ocean tile
      if (this.canAddOcean()) {
        this.defer(new PlaceOceanTile(player, {title: 'Select space for ocean from placement bonus'}));
        this.defer(new SelectPaymentDeferred(player, constants.HELLAS_BONUS_OCEAN_COST, {title: 'Select how to pay for placement bonus ocean'}));
      }
      break;
    case SpaceBonus.MICROBE:
      this.defer(new AddResourcesToCard(player, CardResource.MICROBE, {count: count}));
      break;
    case SpaceBonus.ANIMAL:
      this.defer(new AddResourcesToCard(player, CardResource.ANIMAL, {count: count}));
      break;
    case SpaceBonus.DATA:
      this.defer(new AddResourcesToCard(player, CardResource.DATA, {count: count}));
      break;
    case SpaceBonus.ENERGY_PRODUCTION:
      player.production.add(Resource.ENERGY, count, {log: true});
      break;
    case SpaceBonus.SCIENCE:
      this.defer(new AddResourcesToCard(player, CardResource.SCIENCE, {count: count}));
      break;
    case SpaceBonus.TEMPERATURE:
      if (this.getTemperature() < constants.MAX_TEMPERATURE) {
        this.defer(new SelectPaymentDeferred(
          player,
          constants.VASTITAS_BOREALIS_BONUS_TEMPERATURE_COST,
          {title: 'Select how to pay for placement bonus temperature'}))
          .andThen(() => this.increaseTemperature(player, 1));
      }
      break;
    case SpaceBonus.ENERGY:
      player.stock.add(Resource.ENERGY, count, {log: true});
      break;
    case SpaceBonus.ASTEROID:
      this.defer(new AddResourcesToCard(player, CardResource.ASTEROID, {count: count}));
      break;
    case SpaceBonus.DELEGATE:
      Turmoil.ifTurmoil(this, () => this.defer(new SendDelegateToArea(player)));
      break;
    case SpaceBonus.COLONY:
      this.defer(new SelectPaymentDeferred(
        player,
        constants.VASTITAS_BOREALIS_BONUS_TEMPERATURE_COST,
        {title: 'Select how to pay for placement bonus temperature'}))
        .andThen(() => this.defer(new BuildColony(player)));
      break;
    default:
      throw new Error('Unhandled space bonus ' + spaceBonus + '. Report this exact error, please.');
    }
  }

  public addGreenery(
    player: IPlayer, space: Space,
    shouldRaiseOxygen: boolean = true): undefined {
    this.addTile(player, space, {
      tileType: TileType.GREENERY,
    });
    // Turmoil Greens ruling policy
    PartyHooks.applyGreensRulingPolicy(player, space);

    if (shouldRaiseOxygen) this.increaseOxygenLevel(player, 1);
    return undefined;
  }

  public addCity(
    player: IPlayer, space: Space,
    cardName: CardName | undefined = undefined): void {
    this.addTile(player, space, {
      tileType: TileType.CITY,
      card: cardName,
    });
  }

  public canAddOcean(): boolean {
    return this.board.getOceanSpaces().length < constants.MAX_OCEAN_TILES;
  }

  public canRemoveOcean(): boolean {
    const count = this.board.getOceanSpaces().length;
    return count > 0 && count < constants.MAX_OCEAN_TILES;
  }

  public addOcean(player: IPlayer, space: Space): void {
    if (this.canAddOcean() === false) return;

    this.addTile(player, space, {
      tileType: TileType.OCEAN,
    });
    if (this.phase !== Phase.SOLAR) {
      TurmoilHandler.onGlobalParameterIncrease(player, GlobalParameter.OCEANS);
      player.increaseTerraformRating();
    }
    AresHandler.ifAres(this, (aresData) => {
      AresHandler.onOceanPlaced(aresData, player);
    });
  }

  public removeTile(spaceId: SpaceId): void {
    const space = this.board.getSpaceOrThrow(spaceId);
    space.tile = undefined;
    space.player = undefined;
  }

  public getPlayers(): ReadonlyArray<IPlayer> {
    return this.players;
  }

  // Players returned in play order starting with first player this generation.
  public getPlayersInGenerationOrder(): ReadonlyArray<IPlayer> {
    const ret: Array<IPlayer> = [];
    let insertIdx = 0;
    for (const p of this.players) {
      if (p.id === this.first.id || insertIdx > 0) {
        ret.splice(insertIdx, 0, p);
        insertIdx ++;
      } else {
        ret.push(p);
      }
    }
    return ret;
  }

  /**
   * Returns the Player holding this card, or throws.
   */
  public getCardPlayerOrThrow(name: CardName): IPlayer {
    const player = this.getCardPlayerOrUndefined(name);
    if (player === undefined) {
      throw new Error(`No player has played ${name}`);
    }
    return player;
  }

  /**
   * Returns the Player holding this card, or throws.
   */
  public getCardPlayerOrUndefined(name: CardName): IPlayer | undefined {
    for (const player of this.players) {
      for (const card of player.tableau) {
        if (card.name === name) {
          return player;
        }
      }
    }
    return undefined;
  }

  // Returns the player holding a card in hand. Return undefined when nobody has that card in hand.
  public getCardHolder(name: CardName): [IPlayer | undefined, IProjectCard | undefined] {
    for (const player of this.players) {
      // Check cards player has in hand
      for (const card of [...player.preludeCardsInHand, ...player.cardsInHand]) {
        if (card.name === name) {
          return [player, card];
        }
      }
    }
    return [undefined, undefined];
  }

  public getCardsInHandByResource(player: IPlayer, resourceType: CardResource) {
    return player.cardsInHand.filter((card) => card.resourceType === resourceType);
  }

  public getCardsInHandByType(player: IPlayer, cardType: CardType) {
    return player.cardsInHand.filter((card) => card.type === cardType);
  }

  public log(message: string, f?: (builder: LogMessageBuilder) => void, options?: {reservedFor?: IPlayer}) {
    const builder = new LogMessageBuilder(message);
    f?.(builder);
    const logMessage = builder.build();
    logMessage.playerId = options?.reservedFor?.id;
    this.gameLog.push(logMessage);
    this.gameAge++;
  }

  public discardForCost(cardCount: 1 | 2, toPlace: TileType) {
    // This method uses drawOrThrow, which means if there are really no more cards, it breaks the game.
    // I predict it will be an exceedingly rare problem.
    if (cardCount === 1) {
      const card = this.projectDeck.drawOrThrow(this);
      this.projectDeck.discard(card);
      this.log('Drew and discarded ${0} to place a ${1}', (b) => b.card(card, {cost: true}).tileType(toPlace));
      return card.cost;
    } else {
      const card1 = this.projectDeck.drawOrThrow(this);
      this.projectDeck.discard(card1);
      const card2 = this.projectDeck.drawOrThrow(this);
      this.projectDeck.discard(card2);
      this.log('Drew and discarded ${0} and ${1} to place a ${2}', (b) => b.card(card1, {cost: true}).card(card2, {cost: true}).tileType(toPlace));
      return card1.cost + card2.cost;
    }
  }

  public getSpaceByOffset(direction: -1 | 1, toPlace: TileType, cardCount: 1 | 2 = 1) {
    const cost = this.discardForCost(cardCount, toPlace);

    const distance = Math.max(cost - 1, 0); // Some cards cost zero.
    const space = this.board.getNthAvailableLandSpace(distance, direction, undefined /* player */,
      (space) => {
        // TODO(kberg): this toPlace check is a short-term hack.
        //
        // If the tile is a city, then follow these extra placement rules for initial solo player placement.
        // Otherwise it's a hazard tile, and the city rules don't matter. Ideally this should just split into separate functions,
        // which would be nice, since it makes Game smaller.
        if (toPlace === TileType.CITY) {
          const adjacentSpaces = this.board.getAdjacentSpaces(space);
          return adjacentSpaces.every((sp) => sp.tile?.tileType !== TileType.CITY) && // no cities nearby
              adjacentSpaces.some((sp) => this.board.canPlaceTile(sp)); // can place forest nearby
        } else {
          return true;
        }
      });
    if (space === undefined) {
      throw new Error('Couldn\'t find space when card cost is ' + cost);
    }
    return space;
  }

  public expectedPurgeTimeMs(): number {
    if (this.createdTime.getTime() === 0) {
      return 0;
    }
    const days = dayStringToDays(process.env.MAX_GAME_DAYS, 10);
    return addDays(this.createdTime, days).getTime();
  }

  public static deserialize(d: SerializedGame): Game {
    const gameOptions = d.gameOptions;

    const players = d.players.map((element) => Player.deserialize(element));
    const first = players.find((player) => player.id === d.first);
    if (first === undefined) {
      throw new Error(`Player ${d.first} not found when rebuilding First Player`);
    }

    const board = GameSetup.deserializeBoard(players, gameOptions, d);

    const rng = new SeededRandom(d.seed, d.currentSeed);

    const projectDeck = ProjectDeck.deserialize(d.projectDeck, rng);
    const corporationDeck = CorporationDeck.deserialize(d.corporationDeck, rng);
    const preludeDeck = PreludeDeck.deserialize(d.preludeDeck, rng);

    const ceoDeck = CeoDeck.deserialize(d.ceoDeck, rng);

    const game = new Game(d.id, players, first, d.activePlayer, gameOptions, rng, board, projectDeck, corporationDeck, preludeDeck, ceoDeck);
    game.resettable = true;
    game.spectatorId = d.spectatorId;
    game.createdTime = new Date(d.createdTimeMs);

    const milestones: Array<IMilestone> = [];
    d.milestones.forEach((element: IMilestone | string) => {
      const milestoneName = typeof element === 'string' ? element : element.name;
      const foundMilestone = ALL_MILESTONES.find((milestone) => milestone.name === milestoneName);
      if (foundMilestone !== undefined) {
        milestones.push(foundMilestone);
      }
    });

    game.milestones = milestones;
    game.claimedMilestones = deserializeClaimedMilestones(d.claimedMilestones, players, milestones);

    const awards: Array<IAward> = [];
    d.awards.forEach((element: IAward | string) => {
      const awardName = typeof element === 'string' ? element : element.name;
      const foundAward = ALL_AWARDS.find((award) => award.name === awardName);
      if (foundAward !== undefined) {
        awards.push(foundAward);
      }
    });

    game.awards = awards;
    game.fundedAwards = deserializeFundedAwards(d.fundedAwards, players, awards);

    if (gameOptions.aresExtension) {
      game.aresData = d.aresData;
    }
    // Reload colonies elements if needed
    if (gameOptions.coloniesExtension) {
      game.colonies = ColonyDeserializer.deserializeAndFilter(d.colonies);
      const colonyDealer = new ColonyDealer(rng, gameOptions);
      colonyDealer.restore(game.colonies);
      game.discardedColonies = colonyDealer.discardedColonies;
    }

    // Reload turmoil elements if needed
    if (d.turmoil && gameOptions.turmoilExtension) {
      game.turmoil = Turmoil.deserialize(d.turmoil, players);
    }

    // Reload moon elements if needed
    if (d.moonData !== undefined && gameOptions.moonExpansion === true) {
      game.moonData = MoonData.deserialize(d.moonData, players);
    }

    if (d.pathfindersData !== undefined && gameOptions.pathfindersExpansion === true) {
      game.pathfindersData = PathfindersData.deserialize(d.pathfindersData);
    }

    if (d.underworldData !== undefined) {
      game.underworldData = d.underworldData;
    }
    game.passedPlayers = new Set<PlayerId>(d.passedPlayers);
    game.donePlayers = new Set<PlayerId>(d.donePlayers);
    game.researchedPlayers = new Set<PlayerId>(d.researchedPlayers);

    if (d.unDraftedCards && d.unDraftedCards.length > 0) {
      d.unDraftedCards.forEach(([playerId, cardNames]) => {
        const player = players.find((p) => p.id === playerId);
        if (player === undefined) {
          throw new Error('Unexpected undefined player when deserializing undrafted cards');
        }
        player.draftHand = cardsFromJSON(cardNames);
      });
    }

    game.lastSaveId = d.lastSaveId;
    game.clonedGamedId = d.clonedGamedId;
    game.gameAge = d.gameAge;
    game.gameLog = d.gameLog;
    game.generation = d.generation;
    game.phase = d.phase;
    game.oxygenLevel = d.oxygenLevel;
    game.undoCount = d.undoCount ?? 0;
    game.temperature = d.temperature;
    game.venusScaleLevel = d.venusScaleLevel;
    game.activePlayer = d.activePlayer;
    game.draftRound = d.draftRound;
    game.initialDraftIteration = d.initialDraftIteration;
    game.someoneHasRemovedOtherPlayersPlants = d.someoneHasRemovedOtherPlayersPlants;
    game.syndicatePirateRaider = d.syndicatePirateRaider;
    game.gagarinBase = d.gagarinBase;
    game.stJosephCathedrals = d.stJosephCathedrals;
    game.nomadSpace = d.nomadSpace;
    game.tradeEmbargo = d.tradeEmbargo ?? false;
    game.beholdTheEmperor = d.beholdTheEmperor ?? false;
    game.globalsPerGeneration = d.globalsPerGeneration;
    // Still in Draft or Research of generation 1
    if (game.generation === 1 && players.some((p) => p.corporations.length === 0)) {
      if (game.phase === Phase.INITIALDRAFTING) {
        if (game.initialDraftIteration === 3) {
          newPreludeDraft(game).restoreDraft();
        } else {
          newInitialDraft(game).restoreDraft();
        }
      } else {
        game.gotoInitialResearchPhase();
      }
    } else if (game.phase === Phase.DRAFTING) {
      newStandardDraft(game).restoreDraft();
    } else if (game.phase === Phase.RESEARCH) {
      game.gotoResearchPhase();
    } else if (game.phase === Phase.END) {
      // There's nowhere that we need to go for end game.
    } else {
      // We should be in ACTION phase, let's prompt the active player for actions
      game.getPlayerById(game.activePlayer).takeAction(/* saveBeforeTakingAction */ false);
    }

    if (game.phase === Phase.END) GameLoader.getInstance().mark(game.id);
    return game;
  }

  public logIllegalState(description: string, metadata: {}) {
    const gameMetadata = {
      gameId: this.id,
      lastSaveId: this.lastSaveId,
      logAge: this.gameLog.length,
      currentPlayer: this.activePlayer,

      metadata: metadata,
    };
    console.warn('Illegal state: ' + description, JSON.stringify(gameMetadata, null, ' '));
  }
}

================
File: game/calculateVictoryPoints.ts
================
import {Phase} from '../../common/Phase';
import {IPlayer} from '../IPlayer';
import {Board} from '../boards/Board';
import {MoonExpansion} from '../moon/MoonExpansion';
import {PathfindersExpansion} from '../pathfinders/PathfindersExpansion';
import {Turmoil} from '../turmoil/Turmoil';
import {VictoryPointsBreakdown} from './VictoryPointsBreakdown';
import {FundedAward} from '../awards/FundedAward';
import {AwardScorer} from '../awards/AwardScorer';

export function calculateVictoryPoints(player: IPlayer) {
  const victoryPointsBreakdown = new VictoryPointsBreakdown();

  // Victory points from cards
  let negativeVP = 0; // For Underworld.
  for (const playedCard of player.tableau) {
    if (playedCard.victoryPoints !== undefined) {
      const vp = playedCard.getVictoryPoints(player);
      victoryPointsBreakdown.setVictoryPoints('victoryPoints', vp, playedCard.name);
      if (vp < 0) {
        negativeVP += vp;
      }
    }
  }

  // Victory points from TR
  victoryPointsBreakdown.setVictoryPoints('terraformRating', player.getTerraformRating());

  // Victory points from awards
  giveAwards(player, victoryPointsBreakdown);

  // Victory points from milestones
  for (const milestone of player.game.claimedMilestones) {
    if (milestone.player !== undefined && milestone.player.id === player.id) {
      victoryPointsBreakdown.setVictoryPoints('milestones', 5, 'Claimed ${0} milestone', [milestone.milestone.name]);
    }
  }

  // Victory points from board
  player.game.board.spaces.forEach((space) => {
    // Victory points for greenery tiles
    if (Board.isGreenerySpace(space) && Board.spaceOwnedBy(space, player)) {
      victoryPointsBreakdown.setVictoryPoints('greenery', 1);
    }

    // Victory points for greenery tiles adjacent to cities
    if (Board.isCitySpace(space) && Board.spaceOwnedBy(space, player)) {
      const adjacent = player.game.board.getAdjacentSpaces(space);
      for (const adj of adjacent) {
        if (Board.isGreenerySpace(adj)) {
          victoryPointsBreakdown.setVictoryPoints('city', 1);
        }
      }
    }
  });

  // Turmoil Victory Points
  const includeTurmoilVP = player.game.gameIsOver() || player.game.phase === Phase.END;

  Turmoil.ifTurmoil(player.game, (turmoil) => {
    if (includeTurmoilVP) {
      victoryPointsBreakdown.setVictoryPoints('victoryPoints', turmoil.getPlayerVictoryPoints(player), 'Turmoil Points');
    }
  });

  player.colonies.calculateVictoryPoints(victoryPointsBreakdown);
  MoonExpansion.calculateVictoryPoints(player, victoryPointsBreakdown);
  PathfindersExpansion.calculateVictoryPoints(player, victoryPointsBreakdown);

  // Underworld Score Bribing
  if (player.game.gameOptions.underworldExpansion === true) {
    const bribe = Math.min(Math.abs(negativeVP), player.underworldData.corruption);
    victoryPointsBreakdown.setVictoryPoints('victoryPoints', bribe, 'Underworld Corruption Bribe');
  }

  // Escape velocity VP penalty
  if (player.game.gameOptions.escapeVelocityMode) {
    const threshold = player.game.gameOptions.escapeVelocityThreshold;
    const bonusSecondsPerAction = player.game.gameOptions.escapeVelocityBonusSeconds;
    const period = player.game.gameOptions.escapeVelocityPeriod;
    const penaltyPerMin = player.game.gameOptions.escapeVelocityPenalty ?? 1;
    const elapsedTimeInMinutes = player.timer.getElapsedTimeInMinutes();
    if (threshold !== undefined && bonusSecondsPerAction !== undefined && period !== undefined && elapsedTimeInMinutes > threshold) {
      const overTimeInMinutes = Math.max(elapsedTimeInMinutes - threshold - (player.actionsTakenThisGame * (bonusSecondsPerAction / 60)), 0);
      // Don't lose more VP than what is available
      victoryPointsBreakdown.updateTotal();

      const totalBeforeEscapeVelocity = victoryPointsBreakdown.points.total;
      const penaltyTotal = Math.min(penaltyPerMin * Math.floor(overTimeInMinutes / period), totalBeforeEscapeVelocity);
      victoryPointsBreakdown.setVictoryPoints('escapeVelocity', -penaltyTotal, 'Escape Velocity Penalty');
    }
  }

  victoryPointsBreakdown.updateTotal();
  return victoryPointsBreakdown.points;
}

function maybeSetVP(thisPlayer: IPlayer, awardWinner: IPlayer, fundedAward: FundedAward, vps: number, place: '1st' | '2nd', vpb: VictoryPointsBreakdown) {
  if (thisPlayer.id === awardWinner.id) {
    vpb.setVictoryPoints(
      'awards',
      vps,
      '${0} place for ${1} award (funded by ${2})',
      [place, fundedAward.award.name, fundedAward.player.name],
    );
  }
}

function giveAwards(player: IPlayer, vpb: VictoryPointsBreakdown) {
  // Awards are disabled for 1 player games
  if (player.game.isSoloMode()) return;

  player.game.fundedAwards.forEach((fundedAward) => {
    const award = fundedAward.award;
    const scorer = new AwardScorer(player.game, award);
    const players: Array<IPlayer> = player.game.getPlayers().slice();
    players.sort((p1, p2) => scorer.get(p2) - scorer.get(p1));

    // There is one rank 1 player
    if (scorer.get(players[0]) > scorer.get(players[1])) {
      maybeSetVP(player, players[0], fundedAward, 5, '1st', vpb);
      players.shift();

      if (players.length > 1) {
        // There is one rank 2 player
        if (scorer.get(players[0]) > scorer.get(players[1])) {
          maybeSetVP(player, players[0], fundedAward, 2, '2nd', vpb);
        } else {
          // There are at least two rank 2 players
          const score = scorer.get(players[0]);
          while (players.length > 0 && scorer.get(players[0]) === score) {
            maybeSetVP(player, players[0], fundedAward, 2, '2nd', vpb);
            players.shift();
          }
        }
      }
    } else {
      // There are at least two rank 1 players
      const score = scorer.get(players[0]);
      while (players.length > 0 && scorer.get(players[0]) === score) {
        maybeSetVP(player, players[0], fundedAward, 5, '1st', vpb);
        players.shift();
      }
    }
  });
}

================
File: game/GameOptions.ts
================
import * as constants from '../../common/constants';
import {BoardName} from '../../common/boards/BoardName';
import {CardName} from '../../common/cards/CardName';
import {ColonyName} from '../../common/colonies/ColonyName';
import {GameId} from '../../common/Types';
import {RandomMAOptionType} from '../../common/ma/RandomMAOptionType';
import {AgendaStyle} from '../../common/turmoil/Types';

export type GameOptions = {
  boardName: BoardName;
  clonedGamedId: GameId | undefined;

  // Configuration
  undoOption: boolean;
  showTimers: boolean;
  fastModeOption: boolean;
  showOtherPlayersVP: boolean;

  // Extensions
  corporateEra: boolean;
  venusNextExtension: boolean;
  coloniesExtension: boolean;
  preludeExtension: boolean;
  prelude2Expansion: boolean;
  turmoilExtension: boolean;
  promoCardsOption: boolean;
  communityCardsOption: boolean;
  aresExtension: boolean;
  aresHazards: boolean;
  politicalAgendasExtension: AgendaStyle;
  solarPhaseOption: boolean;
  removeNegativeGlobalEventsOption: boolean;
  includeVenusMA: boolean;
  moonExpansion: boolean;
  pathfindersExpansion: boolean;
  ceoExtension: boolean;
  starWarsExpansion: boolean;
  underworldExpansion: boolean;
  chemicalExpansion: boolean;

  // Variants
  draftVariant: boolean;
  initialDraftVariant: boolean;
  preludeDraftVariant: boolean;
  // corporationsDraft: boolean;
  startingCorporations: number;
  shuffleMapOption: boolean;
  randomMA: RandomMAOptionType;
  includeFanMA: boolean;
  soloTR: boolean; // Solo victory by getting TR 63 by game end
  customCorporationsList: Array<CardName>;
  bannedCards: Array<CardName>;
  includedCards: Array<CardName>;
  customColoniesList: Array<ColonyName>;
  customPreludes: Array<CardName>;
  customCeos: Array<CardName>;
  startingCeos: number;
  /** Moon must be completed to end the game */
  requiresMoonTrackCompletion: boolean;
  /** Venus must be completed to end the game */
  requiresVenusTrackCompletion: boolean;
  /** Standard projects cost more MC and do not require steel or titanium */
  moonStandardProjectVariant: boolean;
  /** Standard projects can be paid for with steel or titanium at a 1MC loss per alloy */
  moonStandardProjectVariant1: boolean;
  altVenusBoard: boolean;
  escapeVelocityMode: boolean;
  escapeVelocityThreshold?: number;
  escapeVelocityBonusSeconds?: number;
  escapeVelocityPeriod?: number;
  escapeVelocityPenalty?: number;
  twoCorpsVariant: boolean;
}

export const DEFAULT_GAME_OPTIONS: GameOptions = {
  altVenusBoard: false,
  aresExtension: false,
  aresHazards: true,
  boardName: BoardName.THARSIS,
  bannedCards: [],
  includedCards: [],
  ceoExtension: false,
  clonedGamedId: undefined,
  coloniesExtension: false,
  communityCardsOption: false,
  corporateEra: true,
  customCeos: [],
  customColoniesList: [],
  customCorporationsList: [],
  customPreludes: [],
  draftVariant: false,
  escapeVelocityMode: false, // When true, escape velocity is enabled.
  escapeVelocityThreshold: constants.DEFAULT_ESCAPE_VELOCITY_THRESHOLD, // Time in minutes a player has to complete a game.
  escapeVelocityBonusSeconds: constants.DEFAULT_ESCAPE_VELOCITY_BONUS_SECONDS, // Number of seconds a player gets back with every action.
  escapeVelocityPeriod: constants.DEFAULT_ESCAPE_VELOCITY_PERIOD, // VP a player loses for every `escapeVelocityPenalty` minutes after `escapeVelocityThreshold`.
  escapeVelocityPenalty: constants.DEFAULT_ESCAPE_VELOCITY_PENALTY,
  fastModeOption: false,
  includeVenusMA: true,
  includeFanMA: false,
  initialDraftVariant: false,
  moonExpansion: false,
  moonStandardProjectVariant: false,
  moonStandardProjectVariant1: false,
  pathfindersExpansion: false,
  politicalAgendasExtension: AgendaStyle.STANDARD,
  preludeDraftVariant: false,
  preludeExtension: false,
  prelude2Expansion: false,
  promoCardsOption: false,
  randomMA: RandomMAOptionType.NONE,
  requiresMoonTrackCompletion: false,
  removeNegativeGlobalEventsOption: false,
  requiresVenusTrackCompletion: false,
  showOtherPlayersVP: false,
  showTimers: true,
  shuffleMapOption: false,
  solarPhaseOption: false,
  soloTR: false,
  startingCeos: 3,
  startingCorporations: 2,
  starWarsExpansion: false,
  turmoilExtension: false,
  underworldExpansion: false,
  undoOption: false,
  venusNextExtension: false,
  twoCorpsVariant: false,
  chemicalExpansion: false,
};

================
File: game/VictoryPointsBreakdown.ts
================
import {Tag} from '../../common/cards/Tag';
import {IVictoryPointsBreakdown} from '../../common/game/IVictoryPointsBreakdown';

export type VictoryPoints = 'terraformRating' | 'milestones' | 'awards' | 'greenery' | 'city' | 'escapeVelocity' | 'moon habitat' | 'moon mine' | 'moon road' | 'planetary tracks' | 'victoryPoints';

export class VictoryPointsBreakdown {
  public readonly points: IVictoryPointsBreakdown = {
    terraformRating: 0,
    milestones: 0,
    awards: 0,
    greenery: 0,
    city: 0,
    escapeVelocity: 0,
    moonHabitats: 0,
    moonMines: 0,
    moonRoads: 0,
    planetaryTracks: 0,
    victoryPoints: 0,
    total: 0,
    detailsCards: [],
    detailsMilestones: [],
    detailsAwards: [],
    detailsPlanetaryTracks: [],
  };

  public updateTotal(): void {
    this.points.total = 0;
    this.points.total += this.points.terraformRating;
    this.points.total += this.points.milestones;
    this.points.total += this.points.awards;
    this.points.total += this.points.greenery;
    this.points.total += this.points.city;
    this.points.total += this.points.escapeVelocity;
    this.points.total += this.points.moonHabitats;
    this.points.total += this.points.moonMines;
    this.points.total += this.points.moonRoads;
    this.points.total += this.points.planetaryTracks;
    this.points.total += this.points.victoryPoints;
  }

  public setVictoryPoints(key: VictoryPoints, points: number, message?: string, messageArgs?: Array<string>) {
    switch (key) {
    case 'terraformRating':
      this.points.terraformRating += points;
      break;
    case 'milestones':
      this.points.milestones += points;
      if (message !== undefined) this.points.detailsMilestones.push({message: message, victoryPoint: points, messageArgs: messageArgs});
      break;
    case 'awards':
      this.points.awards += points;
      if (message !== undefined) this.points.detailsAwards.push({message: message, victoryPoint: points, messageArgs: messageArgs});
      break;
    case 'greenery':
      this.points.greenery += points;
      break;
    case 'city':
      this.points.city += points;
      break;
    case 'escapeVelocity':
      this.points.escapeVelocity += points;
      break;
    case 'victoryPoints':
      this.points.victoryPoints += points;
      if (message !== undefined) this.points.detailsCards.push({cardName: message, victoryPoint: points});
      break;
    case 'moon habitat':
      this.points.moonHabitats += points;
      break;
    case 'moon mine':
      this.points.moonMines += points;
      break;
    case 'moon road':
      this.points.moonRoads += points;
      break;
    case 'planetary tracks':
      this.points.planetaryTracks += points;
      if (message !== undefined) this.points.detailsPlanetaryTracks.push({tag: message as Tag, points});
      break;
    default:
      console.warn('Unknown victory point constraint ' + key);
      break;
    }
  }
}

================
File: GameCards.ts
================
import {COLONIES_CARD_MANIFEST} from './cards/colonies/ColoniesCardManifest';
import {PRELUDE_CARD_MANIFEST} from './cards/prelude/PreludeCardManifest';
import {PROMO_CARD_MANIFEST} from './cards/promo/PromoCardManifest';
import {BASE_CARD_MANIFEST, CORP_ERA_CARD_MANIFEST} from './cards/StandardCardManifests';
import {TURMOIL_CARD_MANIFEST} from './cards/turmoil/TurmoilCardManifest';
import {VENUS_CARD_MANIFEST} from './cards/venusNext/VenusCardManifest';
import {COMMUNITY_CARD_MANIFEST} from './cards/community/CommunityCardManifest';
import {ARES_CARD_MANIFEST} from './cards/ares/AresCardManifest';
import {MOON_CARD_MANIFEST} from './cards/moon/MoonCardManifest';
import {PATHFINDERS_CARD_MANIFEST} from './cards/pathfinders/PathfindersCardManifest';
import {CEO_CARD_MANIFEST} from './cards/ceos/CeoCardManifest';
import {CardManifest, ModuleManifest} from './cards/ModuleManifest';
import {CardName} from '../common/cards/CardName';
import {ICard} from './cards/ICard';
import {isCompatibleWith} from './cards/ICardFactory';
import {GameOptions} from './game/GameOptions';
import {ICorporationCard} from './cards/corporation/ICorporationCard';
import {isIProjectCard, IProjectCard} from './cards/IProjectCard';
import {IStandardProjectCard} from './cards/IStandardProjectCard';
import {newCard} from './createCard';
import {IPreludeCard} from './cards/prelude/IPreludeCard';
import {ICeoCard} from './cards/ceos/ICeoCard';
import {PRELUDE2_CARD_MANIFEST} from './cards/prelude2/Prelude2CardManifest';
import {STAR_WARS_CARD_MANIFEST} from './cards/starwars/StarwarsCardManifest';
import {UNDERWORLD_CARD_MANIFEST} from './cards/underworld/UnderworldCardManifest';
import {CHEMICAL_CARD_MANIFEST} from './cards/chemical/ChemicalCardManifest';


/**
 * Returns the cards available to a game based on its `GameOptions`.
 *
 * It only includes manifests appropriate to the modules for the game,
 * and considers the banned cards, and extra-module compatibility
 * (e.g. cards in one module that can't be played without another one.)
 *
 * Therefore, this is only used when constructing a brand new instance.
 *
 * ... and one other place. When trying to determine the available standard
 * projects for a game. This is just done on the fly all the time, rather
 * that store them. (We should fix that.)
 */
export class GameCards {
  private readonly gameOptions: GameOptions;
  private readonly moduleManifests: Array<ModuleManifest>;

  public constructor(gameOptions: GameOptions) {
    this.gameOptions = gameOptions;

    const manifests: Array<[boolean, ModuleManifest]> = [
      [true, BASE_CARD_MANIFEST],
      [gameOptions.corporateEra, CORP_ERA_CARD_MANIFEST],
      [gameOptions.preludeExtension, PRELUDE_CARD_MANIFEST],
      [gameOptions.prelude2Expansion, PRELUDE2_CARD_MANIFEST],
      [gameOptions.venusNextExtension, VENUS_CARD_MANIFEST],
      [gameOptions.coloniesExtension, COLONIES_CARD_MANIFEST],
      [gameOptions.turmoilExtension, TURMOIL_CARD_MANIFEST],
      [gameOptions.aresExtension, ARES_CARD_MANIFEST],
      [gameOptions.promoCardsOption, PROMO_CARD_MANIFEST],
      [gameOptions.communityCardsOption, COMMUNITY_CARD_MANIFEST],
      [gameOptions.moonExpansion, MOON_CARD_MANIFEST],
      [gameOptions.pathfindersExpansion, PATHFINDERS_CARD_MANIFEST],
      [gameOptions.ceoExtension, CEO_CARD_MANIFEST],
      [gameOptions.starWarsExpansion, STAR_WARS_CARD_MANIFEST],
      [gameOptions.underworldExpansion, UNDERWORLD_CARD_MANIFEST],
      [gameOptions.chemicalExpansion, CHEMICAL_CARD_MANIFEST],
    ];
    this.moduleManifests = manifests
      .filter(([option, _manifest]) => option === true)
      .map(([_option, manifest]) => manifest);
  }

  private instantiate<T extends ICard>(manifest: CardManifest<T>): Array<T> {
    return CardManifest.values(manifest)
      .filter((factory) => factory.instantiate !== false)
      .filter((factory) => isCompatibleWith(factory, this.gameOptions))
      .map((factory) => new factory.Factory());
  }

  public getProjectCards() {
    const cards = this.getCards<IProjectCard>('projectCards');
    const cardsWithIncludedCards = this.addCustomCards(
      cards,
      this.gameOptions.includedCards,
    );
    return cardsWithIncludedCards.filter(isIProjectCard);
  }
  public getStandardProjects() {
    return this.getCards<IStandardProjectCard>('standardProjects');
  }
  
  public getCorporationCards(): Array<ICorporationCard> {
    console.log("Starting getCorporationCards");
    let cards = this.getCards<ICorporationCard>('corporationCards')
      .filter((card) => card.name !== CardName.BEGINNER_CORPORATION);
    
    console.log("Initial corporation cards:", cards.map(card => card.name));
    console.log("Chemical Expansion active:", this.gameOptions.chemicalExpansion);
  
    const cardsToRemove = this.getCardsToRemove();
    console.log("Cards to remove:", cardsToRemove);
  
    const removeCards = (cardList: Array<ICorporationCard>) => 
      cardList.filter((card) => !cardsToRemove.includes(card.name));
  
    cards = removeCards(cards);
    console.log("Corporation cards after removal:", cards.map(card => card.name));
  
    const customCards = this.addCustomCards(cards, this.gameOptions.customCorporationsList);
    console.log("Cards after custom additions:", customCards.map(card => card.name));
  
    // Apply removal again to ensure removed cards are not added back
    const finalCards = removeCards(customCards);
    console.log("Final corporation cards:", finalCards.map(card => card.name));
    
    return finalCards;
  }


  public getPreludeCards() {
    let preludes = this.getCards<IPreludeCard>('preludeCards');
    // https://github.com/terraforming-mars/terraforming-mars/issues/2833
    // Make Valley Trust playable even when Preludes is out of the game
    // by preparing a deck of preludes.
    if (preludes.length === 0) {
      preludes = this.instantiate(PRELUDE_CARD_MANIFEST.preludeCards);
    }
    preludes = this.addCustomCards(preludes, this.gameOptions.customPreludes);

    if (this.gameOptions.twoCorpsVariant) {
      // As each player who doesn't have Merger is dealt Merger in SelectInitialCards.ts,
      // remove it from the deck to avoid possible conflicts (e.g. Valley Trust / New Partner)
      preludes = preludes.filter((c) => c.name !== CardName.MERGER);
    }

    //Andy Removes duplicate preludes from Pathfinders that the manifest doesn't seem to
    if (this.gameOptions.pathfindersExpansion) {
    preludes = preludes.filter((c) => c.name !== CardName.VALUABLE_GASES);
    preludes = preludes.filter((c) => c.name !== CardName.RESEARCH_GRANT);
    }

    //Andy Removes duplicate preludes from Andy's chemical expansion
    if (this.gameOptions.chemicalExpansion) {
      preludes = preludes.filter((c) => c.name !== CardName.BIOFUELS);
      preludes = preludes.filter((c) => c.name !== CardName.BIOSPHERE_SUPPORT);
      preludes = preludes.filter((c) => c.name !== CardName.DOME_FARMING);
      preludes = preludes.filter((c) => c.name !== CardName.EARLY_SETTLEMENT);
      preludes = preludes.filter((c) => c.name !== CardName.ECCENTRIC_SPONSOR);
      preludes = preludes.filter((c) => c.name !== CardName.GALILEAN_MINING);
      preludes = preludes.filter((c) => c.name !== CardName.HUGE_ASTEROID);
      preludes = preludes.filter((c) => c.name !== CardName.IO_RESEARCH_OUTPOST);
      preludes = preludes.filter((c) => c.name !== CardName.LOAN);
      preludes = preludes.filter((c) => c.name !== CardName.MARTIAN_INDUSTRIES);
      preludes = preludes.filter((c) => c.name !== CardName.METALS_COMPANY);
      preludes = preludes.filter((c) => c.name !== CardName.MOHOLE);
      preludes = preludes.filter((c) => c.name !== CardName.MOHOLE_EXCAVATION);
      preludes = preludes.filter((c) => c.name !== CardName.NITROGEN_SHIPMENT);
      preludes = preludes.filter((c) => c.name !== CardName.ORBITAL_CONSTRUCTION_YARD);
      preludes = preludes.filter((c) => c.name !== CardName.POLAR_INDUSTRIES);
      preludes = preludes.filter((c) => c.name !== CardName.SELF_SUFFICIENT_SETTLEMENT);
      preludes = preludes.filter((c) => c.name !== CardName.SMELTING_PLANT);
      preludes = preludes.filter((c) => c.name !== CardName.SOCIETY_SUPPORT);
      preludes = preludes.filter((c) => c.name !== CardName.NITROGEN_SHIPMENT);
      preludes = preludes.filter((c) => c.name !== CardName.NITROGEN_SHIPMENT);
      preludes = preludes.filter((c) => c.name !== CardName.NITROGEN_SHIPMENT);

      
        }

    return preludes;
  }

  public getCeoCards() {
    let ceos = this.getCards<ICeoCard>('ceoCards');
    ceos = this.addCustomCards(ceos, this.gameOptions.customCeos);
    return ceos;
  }

  private getCardsToRemove(): Array<CardName> {
    if (this.gameOptions.chemicalExpansion) {
      return [
        CardName.POINT_LUNA,
        CardName.APHRODITE,
        CardName.ARCADIAN_COMMUNITIES,
        CardName.ARKLIGHT,
        CardName.ASTRODRILL,
        CardName.CELESTIC,
        CardName.CHEUNG_SHING_MARS,
        CardName.FACTORUM,
        CardName.HELION,
        CardName.INTERPLANETARY_CINEMATICS,
        CardName.INVENTRIX,
        CardName.MINING_GUILD,
        CardName.MORNING_STAR_INC,
        CardName.PHOBOLOG,
        CardName.POINT_LUNA,
        CardName.POLYPHEMOS,
        CardName.POSEIDON,
        CardName.PRISTAR,
        CardName.RECYCLON,
        CardName.ROBINSON_INDUSTRIES,
        CardName.SPLICE,
        CardName.STORMCRAFT_INCORPORATED,
        CardName.TERRALABS_RESEARCH,
        CardName.THARSIS_REPUBLIC,
        // Add more CardNames here as needed
        // For example:
        // CardName.ANOTHER_CORPORATION,
        // CardName.YET_ANOTHER_CORPORATION,
      ];
    }
    return [];
  }

  private addCustomCards<T extends ICard>(cards: Array<T>, customList: Array<CardName> = []): Array<T> {
    const cardsToRemove = this.getCardsToRemove();
    for (const cardName of customList) {
      if (cardsToRemove.includes(cardName)) {
        console.log(`Skipping ${cardName} in custom additions due to removal list`);
        continue;
      }
      const idx = cards.findIndex((c) => c.name === cardName);
      if (idx === -1) {
        const card = newCard(cardName);
        if (card === undefined) {
          console.warn(`Unknown card: ${cardName}`);
        } else {
          cards.push(<T>card);
        }
      }
    }
    return cards;
  }

  private getCards<T extends ICard>(cardManifestName: keyof ModuleManifest) : Array<T> {
    let cards: Array<T> = [];
    for (const moduleManifest of this.moduleManifests) {
      // a bit of a hack, but since this is a private API, this is reasonable.
      const cardManifest: CardManifest<T> = moduleManifest[cardManifestName] as CardManifest<T>;
      cards.push(...this.instantiate(cardManifest));
    }

    cards = this.filterBannedCards(cards);
    cards = this.filterReplacedCards(cards);
    return cards;
  }

  /* Remove cards excluded by choice in game options */
  private filterBannedCards<T extends ICard>(cards: Array<T>): Array<T> {
    return cards.filter((card) => {
      return this.gameOptions.bannedCards.includes(card.name) !== true;
    });
  }
  /* Remove cards that are replaced by new versions in other manifests */
  private filterReplacedCards<T extends ICard>(cards: Array<T>): Array<T> {
    return cards.filter((card) => {
      for (const manifest of this.moduleManifests) {
        if (manifest.cardsToRemove.has(card.name)) return false;
      }
      return true;
    });
  }
}

================
File: GameSetup.ts
================
import {MarsBoard} from './boards/MarsBoard';
import {BoardName} from '../common/boards/BoardName';
import {ElysiumBoard} from './boards/ElysiumBoard';
import {IGame} from './IGame';
import {GameOptions} from './game/GameOptions';
import {GameId, isPlayerId, safeCast} from '../common/Types';
import {HellasBoard} from './boards/HellasBoard';
import {TharsisBoard} from './boards/TharsisBoard';
import {IPlayer} from './IPlayer';
import {Player} from './Player';
import {Color} from '../common/Color';
import {TileType} from '../common/TileType';
import {Random} from '../common/utils/Random';
import {ArabiaTerraBoard} from './boards/ArabiaTerraBoard';
import {VastitasBorealisBoard} from './boards/VastitasBorealisBoard';
import {SerializedGame} from './SerializedGame';
import {TerraCimmeriaBoard} from './boards/TerraCimmeriaBoard';
import {AmazonisBoard} from './boards/AmazonisBoard';
import {UnderworldExpansion} from './underworld/UnderworldExpansion';
import {UtopiaPlanitiaBoard} from './boards/UtopiaPlanitiaBoard';
import {VastitasBorealisNovusBoard} from './boards/VastitasBorealisNovusBoard';
import {TerraCimmeriaNovusBoard} from './boards/TerraCimmeriaNovusBoard';
import {Board} from './boards/Board';
import {Space} from './boards/Space';

type BoardFactory = (new (spaces: ReadonlyArray<Space>) => MarsBoard) & {newInstance: (gameOptions: GameOptions, rng: Random) => MarsBoard};

const boards: Record<BoardName, BoardFactory> = {
  [BoardName.THARSIS]: TharsisBoard,
  [BoardName.HELLAS]: HellasBoard,
  [BoardName.ELYSIUM]: ElysiumBoard,
  [BoardName.UTOPIA_PLANITIA]: UtopiaPlanitiaBoard,
  [BoardName.VASTITAS_BOREALIS_NOVUS]: VastitasBorealisNovusBoard,
  [BoardName.TERRA_CIMMERIA_NOVUS]: TerraCimmeriaNovusBoard,
  [BoardName.AMAZONIS]: AmazonisBoard,
  [BoardName.ARABIA_TERRA]: ArabiaTerraBoard,
  [BoardName.TERRA_CIMMERIA]: TerraCimmeriaBoard,
  [BoardName.VASTITAS_BOREALIS]: VastitasBorealisBoard,
};

export class GameSetup {
  public static newBoard(gameOptions: GameOptions, rng: Random): MarsBoard {
    const factory = boards[gameOptions.boardName];
    return factory.newInstance(gameOptions, rng);
  }

  public static deserializeBoard(players: Array<IPlayer>, gameOptions: GameOptions, d: SerializedGame) {
    const playersForBoard = players.length !== 1 ? players : [players[0], GameSetup.neutralPlayerFor(d.id)];
    const deserialized = Board.deserialize(d.board, playersForBoard).spaces;
    const Factory: BoardFactory = boards[gameOptions.boardName];
    return new Factory(deserialized);
  }

  public static neutralPlayerFor(gameId: GameId): IPlayer {
    const playerId = safeCast('p-' + gameId + '-neutral', isPlayerId);
    return new Player('neutral', Color.NEUTRAL, true, 0, playerId);
  }

  public static setupNeutralPlayer(game: IGame) {
    // Single player add neutral player
    // put 2 neutrals cities on board with adjacent forest
    const neutral = this.neutralPlayerFor(game.id);

    function placeCityAndForest(game: IGame, direction: -1 | 1) {
      const board = game.board;
      const citySpace = game.getSpaceByOffset(direction, TileType.CITY);
      game.simpleAddTile(neutral, citySpace, {tileType: TileType.CITY});
      if (game.gameOptions.underworldExpansion === true) {
        UnderworldExpansion.identify(game, citySpace, undefined);
      }

      const adjacentSpaces = board.getAdjacentSpaces(citySpace).filter((s) => game.board.canPlaceTile(s));
      if (adjacentSpaces.length === 0) {
        throw new Error('No space for forest');
      }
      let idx = game.discardForCost(1, TileType.GREENERY);
      idx = Math.max(idx-1, 0); // Some cards cost zero.
      const greenerySpace = adjacentSpaces[idx%adjacentSpaces.length];
      game.simpleAddTile(neutral, greenerySpace, {tileType: TileType.GREENERY});
      if (game.gameOptions.underworldExpansion === true) {
        UnderworldExpansion.identify(game, greenerySpace, undefined);
      }
    }

    placeCityAndForest(game, 1);
    placeCityAndForest(game, -1);
  }
}

================
File: IGame.ts
================
import {MarsBoard} from './boards/MarsBoard';
import {CardName} from '../common/cards/CardName';
import {CardType} from '../common/cards/CardType';
import {ClaimedMilestone} from './milestones/ClaimedMilestone';
import {IColony} from './colonies/IColony';
import {Color} from '../common/Color';
import {FundedAward} from './awards/FundedAward';
import {IAward} from './awards/IAward';
import {IMilestone} from './milestones/IMilestone';
import {IProjectCard} from './cards/IProjectCard';
import {Space} from './boards/Space';
import {LogMessageBuilder} from './logs/LogMessageBuilder';
import {LogMessage} from '../common/logs/LogMessage';
import {Phase} from '../common/Phase';
import {IPlayer} from './IPlayer';
import {PlayerId, GameId, SpectatorId, SpaceId, isGameId} from '../common/Types';
import {CardResource} from '../common/CardResource';
import {AndThen, DeferredAction} from './deferredActions/DeferredAction';
import {Priority} from './deferredActions/Priority';
import {DeferredActionsQueue} from './deferredActions/DeferredActionsQueue';
import {SerializedGame} from './SerializedGame';
import {SpaceBonus} from '../common/boards/SpaceBonus';
import {TileType} from '../common/TileType';
import {Turmoil} from './turmoil/Turmoil';
import {AresData} from '../common/ares/AresData';
import {MoonData} from './moon/MoonData';
import {SeededRandom} from '../common/utils/Random';
import {PathfindersData} from './pathfinders/PathfindersData';
import {GameOptions} from './game/GameOptions';
import {CorporationDeck, PreludeDeck, ProjectDeck, CeoDeck} from './cards/Deck';
import {Tag} from '../common/cards/Tag';
import {Tile} from './Tile';
import {Logger} from './logs/Logger';
import {GlobalParameter} from '../common/GlobalParameter';
import {UnderworldData} from './underworld/UnderworldData';

export interface Score {
  corporation: String;
  playerScore: number;
}

export interface IGame extends Logger {
  readonly id: GameId;
  readonly gameOptions: Readonly<GameOptions>;
  // Game-level data
  lastSaveId: number;
  rng: SeededRandom;
  spectatorId: SpectatorId | undefined;
  deferredActions: DeferredActionsQueue;
  createdTime: Date;
  gameAge: number; // Each log event increases it
  gameLog: Array<LogMessage>;
  undoCount: number; // Each undo increases it
  inputsThisRound: number;
  resettable: boolean;
  generation: number;
  /**
   * Stores the state of each global parameter at the end of each generation.
   *
   * Used for rendering game-end statistics.
   */
  globalsPerGeneration: Array<Partial<Record<GlobalParameter, number>>>;
  phase: Phase;
  projectDeck: ProjectDeck;
  preludeDeck: PreludeDeck;
  ceoDeck: CeoDeck;
  corporationDeck: CorporationDeck;
  board: MarsBoard;
  activePlayer: PlayerId;
  claimedMilestones: Array<ClaimedMilestone>;
  milestones: Array<IMilestone>;
  fundedAwards: Array<FundedAward>;
  awards: Array<IAward>;
  // Expansion-specific data
  colonies: Array<IColony>;
  discardedColonies: Array<IColony>; // Not serialized
  turmoil: Turmoil | undefined;
  aresData: AresData | undefined;
  moonData: MoonData | undefined;
  pathfindersData: PathfindersData | undefined;
  underworldData: UnderworldData;

  // Card-specific data
  // Mons Insurance promo corp
  monsInsuranceOwner?: PlayerId; // Not serialized
  // Crash Site promo project
  someoneHasRemovedOtherPlayersPlants: boolean;
  // Syndicate Pirate Raids
  syndicatePirateRaider?: PlayerId;
  /**
   * The spaces Gagarin Mobile Base has visited. The zeroeth element contains
   * its current location, and as it moves the new location is added to the front.
   */
  gagarinBase: Array<SpaceId>;
  /**
   * The spaces where a St. Joseph of Cupertino Mission's cathedrals are.
   */
  stJosephCathedrals: Array<SpaceId>;
  // Mars Nomads
  nomadSpace: SpaceId | undefined;
  // Trade Embargo
  tradeEmbargo: boolean;
  /** True when Behold The Emperor is in effect this coming Turmoil phase */
  beholdTheEmperor: boolean;

  /** The set of tags available in this game. */
  readonly tags: ReadonlyArray<Tag>;
  // Function use to properly start the game: with project draft or with research phase
  gotoInitialPhase(): void;
  /** Initiates the first research phase, which is when a player chooses their starting hand, corps and preludes. */
  gotoInitialResearchPhase(): void;
  gotoResearchPhase(): void;
  save(): void;
  toJSON(): string;
  serialize(): SerializedGame;
  isSoloMode() :boolean;
  // Retrieve a player by it's id
  getPlayerById(id: PlayerId): IPlayer;
  // Return an array of players from an array of player ids
  getPlayersById(ids: Array<PlayerId>): ReadonlyArray<IPlayer>;
  defer<T>(action: DeferredAction<T>, priority?: Priority): AndThen<T>;
  milestoneClaimed(milestone: IMilestone): boolean;
  marsIsTerraformed(): boolean;
  lastSoloGeneration(): number;
  isSoloModeWin(): boolean;
  getAwardFundingCost(): number;
  fundAward(player: IPlayer, award: IAward): void;
  hasBeenFunded(award: IAward): boolean;
  allAwardsFunded(): boolean;
  allMilestonesClaimed(): boolean;
  hasPassedThisActionPhase(player: IPlayer): boolean;
  // Public for testing.
  incrementFirstPlayer(): void;
  // Only used in the prelude The New Space Race
  overrideFirstPlayer(newFirstPlayer: IPlayer): void;
  // The first player this generation
  readonly first: IPlayer;
  gameIsOver(): boolean;
  isDoneWithFinalProduction(): boolean;
  doneWorldGovernmentTerraforming(): void;
  playerHasPassed(player: IPlayer): void;
  hasResearched(player: IPlayer): boolean;
  playerIsFinishedWithResearchPhase(player: IPlayer): void;
  /**
   * Called when a player has finished taking actions. It sets up
   * the next player, or moves to the production phase.
   */
  playerIsFinishedTakingActions(): void;
  /**
   * Returns true if the player may place a greenery tile.
   * Applicable only during final greenery placement.
   */
  canPlaceGreenery(player: IPlayer): boolean;
  /**
   * Called during final greenery placement when a player cannot or chooses not to place any more greeneries.
   */
  playerIsDoneWithGame(player: IPlayer): void;
  /**
   * Find the next player who might be able to place a final greenery and ask them.
   *
   * If nobody can add a greenery, end the game.
   */
  /* for testing */ takeNextFinalGreeneryAction(): void;
  increaseOxygenLevel(player: IPlayer, increments: -2 | -1 | 1 | 2): void;
  getOxygenLevel(): number;
  increaseVenusScaleLevel(player: IPlayer, increments: -1 | 1 | 2 | 3): number;
  getVenusScaleLevel(): number;
  increaseTemperature(player: IPlayer, increments: -2 | -1 | 1 | 2 | 3): undefined;
  getTemperature(): number;
  getGeneration(): number;
  getPassedPlayers():ReadonlyArray<Color>;
  /**
   * Add `tile` to `space` for `player`. Triggers all effects that come with placing a tile.
   *
   * This only applies to the Mars board. See MoonExpansion.addTile for placing
   * a tile on The Moon.
   */
  addTile(player: IPlayer, space: Space, tile: Tile): void;
  /**
   * Add `tile` to `space` for `player` without triggering any effects.
   *
   * This only applies to the Mars board.
   */
  simpleAddTile(player: IPlayer, space: Space, tile: Tile): void;
  /**
   * Gives all the bonuses a player may gain when placing a tile on a space.
   *
   * This includes bonuses on the map, from oceans, Ares tiles, Turmoil, Colonies, etc.
   */
  grantPlacementBonuses(player: IPlayer, space: Space, coveringExistingTile: boolean): void

  /**
   * Gives all the bonuses from a space on the map.
   */
  grantSpaceBonuses(player: IPlayer, space: Space): void;
  grantSpaceBonus(player: IPlayer, spaceBonus: SpaceBonus, count?: number): void;
  addGreenery(player: IPlayer, space: Space, shouldRaiseOxygen?: boolean): void;
  addCity(player: IPlayer, space: Space, cardName?: CardName | undefined): void;
  canAddOcean(): boolean;
  canRemoveOcean(): boolean;
  addOcean(player: IPlayer, space: Space): void;
  removeTile(spaceId: string): void;
  getPlayers(): ReadonlyArray<IPlayer>;
  // Players returned in play order starting with first player this generation.
  getPlayersInGenerationOrder(): ReadonlyArray<IPlayer>;
  /**
   * Returns the Player holding this card, or throws.
   */
  getCardPlayerOrThrow(name: CardName): IPlayer;
  /**
   * Returns the Player holding this card, or returns undefined.
   */
  getCardPlayerOrUndefined(name: CardName): IPlayer | undefined;
  // Returns the player holding a card in hand. Return undefined when nobody has that card in hand.
  getCardHolder(name: CardName): [IPlayer | undefined, IProjectCard | undefined];
  getCardsInHandByResource(player: IPlayer, resourceType: CardResource): void;
  getCardsInHandByType(player: IPlayer, cardType: CardType): void;
  log(message: string, f?: (builder: LogMessageBuilder) => void, options?: {reservedFor?: IPlayer}): void;
  discardForCost(cardCount: 1 | 2, toPlace: TileType): number;
  getSpaceByOffset(direction: -1 | 1, toPlace: TileType, cardCount?: 1 | 2): Space;
  expectedPurgeTimeMs(): number;
  logIllegalState(description: string, metadata: {}): void;

  /**
   * Drafting before the first generation goes through 3 iterations:
   * 1. first 5 project cards,
   * 2. second 5 project cards
   * 3. [optional] preludes.
   *
   * This works, but makes it hard to add a CEO draft.
   */
  initialDraftIteration: number;
  /**
   * When drafting n cards, this counts the each step in the draft.
   * When players get all the cards, this is 1. After everybody drafts a card,
   * this is round 2.
   */
  draftRound: number;
  getPlayerAfter(player: IPlayer): IPlayer;
  getPlayerBefore(player: IPlayer): IPlayer;
}

export function isIGame(object: any): object is IGame {
  return object !== undefined && object.hasOwnProperty('id') && isGameId(object.id);
}

================
File: inputs/AndOptions.ts
================
import {PlayerInput} from '../PlayerInput';
import {InputResponse, isAndOptionsResponse} from '../../common/inputs/InputResponse';
import {IPlayer} from '../IPlayer';
import {AndOptionsModel} from '../../common/models/PlayerInputModel';
import {OptionsInput} from './OptionsPlayerInput';
import {InputError} from './InputError';

export class AndOptions extends OptionsInput<undefined> {
  constructor(...options: Array<PlayerInput>) {
    super('and', '', options);
  }

  public toModel(player: IPlayer): AndOptionsModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'and',
      options: this.options.map((option) => option.toModel(player)),
    };
  }

  public process(input: InputResponse, player: IPlayer) {
    if (!isAndOptionsResponse(input)) {
      throw new InputError('Not a valid AndOptionsResponse');
    }
    if (input.responses.length !== this.options.length) {
      throw new InputError('Incorrect options provided');
    }
    for (let i = 0; i < input.responses.length; i++) {
      player.runInput(input.responses[i], this.options[i]);
    }
    return this.cb(undefined);
  }
}

================
File: inputs/GainResources.ts
================
import {IPlayer} from '../IPlayer';
import {AndOptions} from './AndOptions';
import {SelectAmount} from './SelectAmount';
import {Units} from '../../common/Units';
import {sum} from '../../common/utils/utils';
import {Message} from '../../common/logs/Message';
import {InputError} from './InputError';

export class GainResources extends AndOptions {
  private static makeOptions(count: number, units: Units) {
    const selectMegacredits = new SelectAmount('Megacredits', 'Select', 0, count)
      .andThen((amount) => {
        units.megacredits = amount;
        return undefined;
      });
    const selectSteel = new SelectAmount('Steel', 'Select', 0, count)
      .andThen((amount) => {
        units.steel = amount;
        return undefined;
      });
    const selectTitanium = new SelectAmount('Titanium', 'Select', 0, count)
      .andThen((amount) => {
        units.titanium = amount;
        return undefined;
      });
    const selectPlants = new SelectAmount('Plants', 'Select', 0, count)
      .andThen((amount) => {
        units.plants = amount;
        return undefined;
      });
    const selectEnergy = new SelectAmount('Energy', 'Select', 0, count)
      .andThen((amount) => {
        units.energy = amount;
        return undefined;
      });
    const selectHeat = new SelectAmount('Heat', 'Select', 0, count)
      .andThen((amount) => {
        units.heat = amount;
        return undefined;
      });
    return [selectMegacredits, selectSteel, selectTitanium, selectPlants, selectEnergy, selectHeat];
  }
  constructor(
    public player: IPlayer,
    public count: number,
    public override title: string | Message,
    // this isn't actually used as a paramteter, but  this class
    // is kind of strangely structured. If you can refactor this,
    // please do.
    private units = Units.of({})) {
    super(...GainResources.makeOptions(count, units));
    this.andThen(() => {
      const array = Object.values(units);
      if (array.some((count) => count < 0)) {
        throw new InputError('All units must be positive');
      }
      if (sum(array) !== this.count) {
        throw new InputError(`Select ${this.count} resource(s)`);
      }

      this.player.stock.addUnits(this.units, {log: true});
      return undefined;
    });
  }
}

================
File: inputs/InputError.ts
================
/**
 * An Error caused by bad user input.
 *
 * At this point in time the only meaningful difference is that these errors aren't logged to the console.
 */
export class InputError extends Error {
  constructor(message: string) {
    super(message);
  }
}

================
File: inputs/OptionsPlayerInput.ts
================
import {PlayerInputType} from '../../common/input/PlayerInputType';
import {Message} from '../../common/logs/Message';
import {BasePlayerInput, PlayerInput} from '../PlayerInput';

export abstract class OptionsInput<T> extends BasePlayerInput<T> {
  public options: Array<PlayerInput>;
  constructor(type: PlayerInputType, title: string | Message, options: Array<PlayerInput>) {
    super(type, title);
    this.options = options;
  }
}

================
File: inputs/OrOptions.ts
================
import {PlayerInput} from '../PlayerInput';
import {InputResponse, isOrOptionsResponse} from '../../common/inputs/InputResponse';
import {IPlayer} from '../IPlayer';
import {OrOptionsModel} from '../../common/models/PlayerInputModel';
import {OptionsInput} from './OptionsPlayerInput';
import {InputError} from './InputError';

export class OrOptions extends OptionsInput<undefined> {
  constructor(...options: Array<PlayerInput>) {
    super('or', 'Select one option', options);
  }

  public toModel(player: IPlayer): OrOptionsModel {
    const initialIdx = this.options.findIndex((option) => option.eligibleForDefault !== false);
    const model: OrOptionsModel = {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'or',
      options: this.options.map((option) => option.toModel(player)),
    };
    if (initialIdx > -1) {
      model.initialIdx = initialIdx;
    }
    return model;
  }

  public process(input: InputResponse, player: IPlayer) {
    if (!isOrOptionsResponse(input)) {
      throw new InputError('Not a valid OrOptionsResponse');
    }
    if (this.options.length <= input.index) {
      throw new InputError('Invalid index');
    }
    player.runInput(input.response, this.options[input.index]);
    return this.cb(undefined);
  }

  public reduce(): PlayerInput | undefined {
    if (this.options.length === 0) {
      return undefined;
    }
    if (this.options.length === 1) {
      return this.options[0].cb();
    }
    return this;
  }
}

================
File: inputs/SelectAmount.ts
================
import {Message} from '../../common/logs/Message';
import {BasePlayerInput} from '../PlayerInput';
import {InputResponse, isSelectAmountResponse} from '../../common/inputs/InputResponse';
import {SelectAmountModel} from '../../common/models/PlayerInputModel';
import {InputError} from './InputError';

export class SelectAmount extends BasePlayerInput<number> {
  constructor(
    title: string | Message,
    buttonLabel: string = 'Save',
    public min: number,
    public max: number,
    public maxByDefault?: boolean,
  ) {
    super('amount', title);
    this.buttonLabel = buttonLabel;
  }

  public toModel(): SelectAmountModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'amount',
      max: this.max,
      min: this.min,
      maxByDefault: this.maxByDefault ?? false,
    };
  }

  public process(input: InputResponse) {
    if (!isSelectAmountResponse(input)) {
      throw new InputError('Not a valid SelectAmountResponse');
    }
    if (isNaN(input.amount)) {
      throw new InputError('Amount is not a number');
    }
    if (input.amount > this.max) {
      throw new InputError('Amount provided too high (max ' + String(this.max) + ')');
    }
    if (input.amount < this.min) {
      throw new InputError('Amount provided too low (min ' + String(this.min) + ')');
    }
    return this.cb(input.amount);
  }
}

================
File: inputs/SelectCard.ts
================
import {ICard} from '../cards/ICard';
import {Message} from '../../common/logs/Message';
import {getCardFromPlayerInput} from '../PlayerInput';
import {BasePlayerInput} from '../PlayerInput';
import {CardName} from '../../common/cards/CardName';
import {InputResponse, isSelectCardResponse} from '../../common/inputs/InputResponse';
import {SelectCardModel} from '../../common/models/PlayerInputModel';
import {IPlayer} from '../IPlayer';
import {cardsToModel} from '../models/ModelUtils';
import {InputError} from './InputError';

export type Options = {
  max: number,
  min: number,
  /** Default is false. When true, ??? */
  selectBlueCardAction: boolean,
  /** When provided, then the cards with false in `enabled` are not selectable and grayed out */
  enabled: ReadonlyArray<boolean> | undefined,
  /** Default is true. If true, then shows resources on those cards. If false than shows discounted price. */
  played: boolean | CardName.SELF_REPLICATING_ROBOTS
  /** Default is false. If true then show the name of the card owner below. */
  showOwner: boolean,
}
export class SelectCard<T extends ICard> extends BasePlayerInput<ReadonlyArray<T>> {
  public config: Options;

  constructor(
    title: string | Message,
    buttonLabel: string = 'Save',
    public cards: ReadonlyArray<T>,
    config?: Partial<Options>,
  ) {
    super('card', title);
    this.config = {
      max: config?.max ?? 1,
      min: config?.min ?? 1,
      selectBlueCardAction: config?.selectBlueCardAction ?? false,
      enabled: config?.enabled,
      played: config?.played ?? true,
      showOwner: config?.showOwner ?? false,
    };
    this.buttonLabel = buttonLabel;
  }

  public toModel(player: IPlayer): SelectCardModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'card',
      cards: cardsToModel(player, this.cards, {
        showCalculatedCost: this.config.played === false || this.config.played === CardName.SELF_REPLICATING_ROBOTS,
        showResources: this.config.played === true || this.config.played === CardName.SELF_REPLICATING_ROBOTS,
        enabled: this.config.enabled,
      }),
      max: this.config.max,
      min: this.config.min,
      showOnlyInLearnerMode: this.config.enabled?.every((p: boolean) => p === false) ?? false,
      selectBlueCardAction: this.config.selectBlueCardAction,
      showOwner: this.config.showOwner === true,
    };
  }

  public process(input: InputResponse) {
    if (!isSelectCardResponse(input)) {
      throw new InputError('Not a valid SelectCardResponse');
    }
    if (input.cards.length < this.config.min) {
      throw new InputError('Not enough cards selected');
    }
    if (input.cards.length > this.config.max) {
      throw new InputError('Too many cards selected');
    }
    const cards = [];
    for (const cardName of input.cards) {
      const {card, idx} = getCardFromPlayerInput(this.cards, cardName);
      cards.push(card);
      if (this.config.enabled?.[idx] === false) {
        throw new InputError(`${cardName} is not available`);
      }
    }
    return this.cb(cards);
  }
}

================
File: inputs/SelectColony.ts
================
import {Message} from '../../common/logs/Message';
import {BasePlayerInput} from '../PlayerInput';
import {IColony} from '../colonies/IColony';
import {InputResponse, isSelectColonyResponse} from '../../common/inputs/InputResponse';
import {SelectColonyModel} from '../../common/models/PlayerInputModel';
import {coloniesToModel} from '../models/ModelUtils';
import {IPlayer} from '../IPlayer';
import {InputError} from './InputError';

export class SelectColony extends BasePlayerInput<IColony> {
  // When true, show just the tile, and none of the cubes on top.
  // Used for tiles that are not yet in the game, or for a clearer
  // visualziation when necesary.
  public showTileOnly = false;

  constructor(
    title: string | Message,
    buttonLabel: string = 'Save',
    public colonies: Array<IColony>,
  ) {
    super('colony', title);
    this.buttonLabel = buttonLabel;
  }

  public toModel(player: IPlayer): SelectColonyModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'colony',
      coloniesModel: coloniesToModel(player.game, this.colonies, this.showTileOnly),
    };
  }

  public process(input: InputResponse) {
    if (!isSelectColonyResponse(input)) {
      throw new InputError('Not a valid SelectColonyResponse');
    }
    if (input.colonyName === undefined) {
      throw new InputError('No colony selected');
    }
    const colony = this.colonies.find((c) => c.name === input.colonyName);
    if (colony === undefined) {
      throw new InputError(`Colony ${input.colonyName} not found`);
    }
    return this.cb(colony);
  }
}

================
File: inputs/SelectDelegate.ts
================
import {Message} from '../../common/logs/Message';
import {BasePlayerInput} from '../PlayerInput';
import {IPlayer} from '../IPlayer';
import {NeutralPlayer} from '../turmoil/Turmoil';
import {InputResponse, isSelectDelegateResponse} from '../../common/inputs/InputResponse';
import {SelectDelegateModel} from '../../common/models/PlayerInputModel';
import {InputError} from './InputError';

export class SelectDelegate extends BasePlayerInput<IPlayer | NeutralPlayer> {
  constructor(
    public players: ReadonlyArray<IPlayer | NeutralPlayer>,
    title: string | Message) {
    super('delegate', title);
  }

  public override toModel(): SelectDelegateModel {
    return {
      type: 'delegate',
      title: this.title,
      buttonLabel: this.buttonLabel,
      players: this.players.map((player) => player === 'NEUTRAL' ? 'NEUTRAL' : player.color),
    };
  }

  public process(input: InputResponse) {
    if (!isSelectDelegateResponse(input)) {
      throw new InputError('Not a valid SelectDelegateResponse');
    }
    for (const player of this.players) {
      if (player === 'NEUTRAL') {
        if (input.player !== 'NEUTRAL') {
          continue;
        }
      } else {
        if (input.player !== player.color) {
          continue;
        }
      }
      return this.cb(player);
    }
    throw new InputError('Player not available');
  }
}

================
File: inputs/SelectGlobalEvent.ts
================
import {BasePlayerInput} from '../PlayerInput';
import {InputResponse, isSelectGlobalEventResponse} from '../../common/inputs/InputResponse';
import {SelectGlobalEventModel} from '../../common/models/PlayerInputModel';
import {IGlobalEvent} from '../turmoil/globalEvents/IGlobalEvent';
import {InputError} from './InputError';

export class SelectGlobalEvent extends BasePlayerInput<IGlobalEvent> {
  constructor(public globalEvents: ReadonlyArray<IGlobalEvent>) {
    super('card', 'Select Global Event');
  }

  public toModel(): SelectGlobalEventModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'globalEvent',
      globalEventNames: this.globalEvents.map((globalEvent) => globalEvent.name),
    };
  }

  public process(input: InputResponse) {
    if (!isSelectGlobalEventResponse(input)) {
      throw new InputError('Not a valid SelectGlobalEventResponse');
    }
    const globalEvent = this.globalEvents.find((e) => e.name === input.globalEventName);
    if (globalEvent === undefined) {
      throw new InputError(`Invalid Global Event ${input.globalEventName}`);
    }
    return this.cb(globalEvent);
  }
}

================
File: inputs/SelectInitialCards.ts
================
import * as titles from '../../common/inputs/SelectInitialCards';
import {ICorporationCard} from '../cards/corporation/ICorporationCard';
import {IPlayer} from '../IPlayer';
import {SelectCard} from './SelectCard';
import {Merger} from '../cards/promo/Merger';
import {CardName} from '../../common/cards/CardName';
import {SelectInitialCardsModel} from '../../common/models/PlayerInputModel';
import {InputError} from './InputError';
import {OptionsInput} from './OptionsPlayerInput';
import {InputResponse, isSelectInitialCardsResponse} from '../../common/inputs/InputResponse';

export class SelectInitialCards extends OptionsInput<undefined> {
  constructor(private player: IPlayer, cb: (corporation: ICorporationCard) => undefined) {
    super('initialCards', '', []);
    let corporation: ICorporationCard;
    this.title = ' ';
    this.buttonLabel = 'Start';

    this.options.push(
      new SelectCard<ICorporationCard>(
        titles.SELECT_CORPORATION_TITLE, undefined, player.dealtCorporationCards, {min: 1, max: 1}).andThen(
        (cards) => {
          if (cards.length !== 1) {
            throw new InputError('Only select 1 corporation card');
          }
          corporation = cards[0];
          return undefined;
        }),
    );

    // Give each player Merger in this variant
    if (player.game.gameOptions.twoCorpsVariant) {
      player.dealtPreludeCards.push(new Merger());
    }

    if (player.game.gameOptions.preludeExtension) {
      this.options.push(
        new SelectCard(titles.SELECT_PRELUDE_TITLE, undefined, player.dealtPreludeCards, {min: 2, max: 2})
          .andThen((preludeCards) => {
            if (preludeCards.length !== 2) {
              throw new InputError('Only select 2 preludes');
            }
            player.preludeCardsInHand.push(...preludeCards);
            return undefined;
          }));
    }

    if (player.game.gameOptions.ceoExtension) {
      this.options.push(
        new SelectCard(titles.SELECT_CEO_TITLE, undefined, player.dealtCeoCards, {min: 1, max: 1}).andThen((ceoCards) => {
          if (ceoCards.length !== 1) {
            throw new InputError('Only select 1 CEO');
          }
          // Push chosen card to hand
          player.ceoCardsInHand.push(ceoCards[0]);
          // Discard unchosen CEOs
          player.dealtCeoCards.filter((c) => c !== ceoCards[0]).forEach((c) => player.game.ceoDeck.discard(c));
          return undefined;
        }));
    }

    this.options.push(
      new SelectCard(titles.SELECT_PROJECTS_TITLE, undefined, player.dealtProjectCards, {min: 0, max: 10})
        .andThen((cards) => {
          player.cardsInHand.push(...cards);
          return undefined;
        }),
    );
    this.andThen(() => {
      this.completed(corporation);
      // TODO(kberg): This is probably broken. Stop subclassing AndOptions.
      cb(corporation);
      return undefined;
    });
  }

  private completed(corporation: ICorporationCard) {
    const player = this.player;
    // Check for negative M€
    const cardCost = corporation.cardCost !== undefined ? corporation.cardCost : player.cardCost;
    if (corporation.name !== CardName.BEGINNER_CORPORATION && player.cardsInHand.length * cardCost > corporation.startingMegaCredits) {
      player.cardsInHand = [];
      player.preludeCardsInHand = [];
      throw new InputError('Too many cards selected');
    }
    // discard all unpurchased cards
    player.dealtProjectCards.forEach((card) => {
      if (player.cardsInHand.includes(card) === false) {
        player.game.projectDeck.discard(card);
      }
    });

    player.dealtCorporationCards.forEach((card) => {
      if (card.name !== corporation.name) {
        player.game.corporationDeck.discard(card);
      }
    });
  }

  public toModel(player: IPlayer): SelectInitialCardsModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'initialCards',
      options: this.options.map((option) => option.toModel(player)),
    };
  }

  public process(input: InputResponse, player: IPlayer) {
    if (!isSelectInitialCardsResponse(input)) {
      throw new InputError('Not a valid SelectInitialCardsResponse');
    }
    if (input.responses.length !== this.options.length) {
      throw new InputError('Incorrect options provided');
    }
    for (let i = 0; i < input.responses.length; i++) {
      player.runInput(input.responses[i], this.options[i]);
    }
    return this.cb(undefined);
  }
}

================
File: inputs/SelectOption.ts
================
import {Message} from '../../common/logs/Message';
import {PlayerInput} from '../PlayerInput';
import {BasePlayerInput} from '../PlayerInput';
import {InputResponse, isSelectOptionResponse} from '../../common/inputs/InputResponse';
import {SelectOptionModel} from '../../common/models/PlayerInputModel';
import {Warning} from '../../common/cards/Warning';
import {InputError} from './InputError';

export type Options = {
  buttonLabel?: string;
  warnings?: Array<Warning>;
}

export class SelectOption extends BasePlayerInput<undefined> {
  constructor(
    title: string | Message,
    options: string | Options = 'Confirm') {
    super('option', title);
    if (typeof options === 'string') {
      this.buttonLabel = options;
    } else {
      this.buttonLabel = options.buttonLabel ?? 'Confirm';
      this.warnings = options.warnings;
    }
  }


  public warnings: Array<Warning> | undefined = undefined;

  public override toModel(): SelectOptionModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'option',
      warnings: this.warnings,
    };
  }
  public process(response: InputResponse): PlayerInput | undefined {
    if (!isSelectOptionResponse(response)) {
      throw new InputError('Not a valid SelectOptionResponse');
    }
    return this.cb(undefined);
  }
}

================
File: inputs/SelectParty.ts
================
import {Message} from '../../common/logs/Message';
import {BasePlayerInput} from '../PlayerInput';
import {PartyName} from '../../common/turmoil/PartyName';
import {InputResponse, isSelectPartyResponse} from '../../common/inputs/InputResponse';
import {IPlayer} from '../IPlayer';
import {SelectPartyModel} from '../../common/models/PlayerInputModel';
import {getTurmoilModel} from '../models/TurmoilModel';
import {InputError} from './InputError';

export class SelectParty extends BasePlayerInput<PartyName> {
  constructor(
    title: string | Message,
    buttonLabel: string = 'Send delegate',
    public parties: Array<PartyName>) {
    super('party', title);
    this.buttonLabel = buttonLabel;
  }

  public override toModel(player: IPlayer): SelectPartyModel {
    const turmoil = getTurmoilModel(player.game);
    if (turmoil === undefined) {
      throw new InputError('This game is not set up for Turmoil.');
    }
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'party',
      parties: this.parties,
    };
  }

  public process(input: InputResponse) {
    if (!isSelectPartyResponse(input)) {
      throw new InputError('Not a valid SelectPartyResponse');
    }
    if (input.partyName === undefined) {
      // TODO(kberg): prevent click unless party is selected.
      throw new InputError('No party selected');
    }
    if (!this.parties.includes(input.partyName)) {
      throw new InputError('Invalid party selected');
    }
    return this.cb(input.partyName);
  }
}

================
File: inputs/SelectPayment.ts
================
import {Message} from '../../common/logs/Message';
import {BasePlayerInput} from '../PlayerInput';
import {isPayment, Payment, PaymentOptions} from '../../common/inputs/Payment';
import {InputResponse, isSelectPaymentResponse} from '../../common/inputs/InputResponse';
import {IPlayer} from '../IPlayer';
import {SelectPaymentModel} from '../../common/models/PlayerInputModel';
import {InputError} from './InputError';

export class SelectPayment extends BasePlayerInput<Payment> {
  constructor(
    title: string | Message,
    public amount: number,
    public paymentOptions: Partial<PaymentOptions>,
  ) {
    super('payment', title);
    this.buttonLabel = 'Pay'; // no input button
  }

  public toModel(player: IPlayer): SelectPaymentModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'payment',
      amount: this.amount,
      paymentOptions: {
        // TODO(kberg): These are set both here and in Player. Consolidate, perhaps.
        heat: player.canUseHeatAsMegaCredits,
        lunaTradeFederationTitanium: player.canUseTitaniumAsMegacredits,
        ...this.paymentOptions,
      },
      seeds: player.getSpendable('seeds'),
      auroraiData: player.getSpendable('auroraiData'),
      kuiperAsteroids: player.getSpendable('kuiperAsteroids'),
      spireScience: player.getSpendable('spireScience'),
    };
  }

  public process(input: InputResponse, player: IPlayer) {
    if (!isSelectPaymentResponse(input)) {
      throw new InputError('Not a valid SelectPaymentResponse');
    }
    const payment = input.payment;
    if (!isPayment(payment)) {
      throw new InputError('payment is not a valid type');
    }
    // TODO(kberg): This is called here and in SelectPaymentDeferred.
    // There's no reason for both.
    if (!player.canSpend(payment)) {
      throw new InputError('You do not have that many resources');
    }
    if (!player.canSpend(payment)) {
      throw new InputError('You do not have that many resources to spend');
    }
    const amountPaid = player.payingAmount(payment, this.paymentOptions);
    if (amountPaid < this.amount) {
      throw new InputError('Did not spend enough');
    }
    return this.cb(input.payment);
  }
}

================
File: inputs/SelectPlayer.ts
================
import {Message} from '../../common/logs/Message';
import {BasePlayerInput} from '../PlayerInput';
import {IPlayer} from '../IPlayer';
import {InputResponse, isSelectPlayerResponse} from '../../common/inputs/InputResponse';
import {SelectPlayerModel} from '../../common/models/PlayerInputModel';
import {InputError} from './InputError';

export class SelectPlayer extends BasePlayerInput<IPlayer> {
  constructor(public players: ReadonlyArray<IPlayer>, title: string | Message, buttonLabel: string = 'Save') {
    super('player', title);
    this.buttonLabel = buttonLabel;
  }

  public override toModel(): SelectPlayerModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'player',
      players: this.players.map((player) => player.color),
    };
  }

  public process(input: InputResponse) {
    if (!isSelectPlayerResponse(input)) {
      throw new InputError('Not a valid SelectPlayerResponse');
    }
    const foundPlayer = this.players.find((player) => player.color === input.player);
    if (foundPlayer === undefined) {
      throw new InputError('Player not available');
    }
    return this.cb(foundPlayer);
  }
}

================
File: inputs/SelectProductionToLose.ts
================
import {Message} from '../../common/logs/Message';
import {BasePlayerInput} from '../PlayerInput';
import {IPlayer} from '../IPlayer';
import {Units} from '../../common/Units';
import {InputResponse, isSelectProductionToLoseResponse} from '../../common/inputs/InputResponse';
import {sum} from '../../common/utils/utils';
import {SelectProductionToLoseModel} from '../../common/models/PlayerInputModel';
import {InputError} from './InputError';

export class SelectProductionToLose extends BasePlayerInput<Units> {
  constructor(
    title: string | Message,
    public unitsToLose: number,
    public player: IPlayer,
    buttonLabel: string = 'Save',
  ) {
    super('productionToLose', title);
    this.buttonLabel = buttonLabel;
  }

  public override toModel(): SelectProductionToLoseModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'productionToLose',
      payProduction: {
        cost: this.unitsToLose,
        units: this.player.production.asUnits(),
      },
    };
  }
  // TODO(kberg): Could merge this with SelectResources, though it
  // would take some work.
  public process(input: InputResponse, player: IPlayer) {
    if (!isSelectProductionToLoseResponse(input)) {
      throw new InputError('Not a valid SelectProductionToLoseResponse');
    }
    if (!Units.isUnits(input.units)) {
      throw new InputError('not a units object');
    }
    const array = Object.values(input.units);
    if (array.some((count) => count < 0)) {
      throw new InputError('All units must be positive');
    }
    if (!player.production.canAdjust(Units.negative(input.units))) {
      throw new InputError('You do not have those units');
    }
    if (sum(array) !== this.unitsToLose) {
      throw new InputError(`Select ${this.unitsToLose} steps of production.`);
    }
    this.cb(input.units);
    return undefined;
  }
}

================
File: inputs/SelectProjectCardToPlay.ts
================
import {BasePlayerInput} from '../PlayerInput';
import {isPayment, Payment} from '../../common/inputs/Payment';
import {IProjectCard, PlayableCard} from '../cards/IProjectCard';
import {Units} from '../../common/Units';
import {MoonExpansion} from '../moon/MoonExpansion';
import {CardAction, IPlayer} from '../IPlayer';
import {InputResponse, isSelectProjectCardToPlayResponse} from '../../common/inputs/InputResponse';
import {CardName} from '../../common/cards/CardName';
import {CanPlayResponse} from '../cards/IProjectCard';
import {YesAnd} from '../cards/requirements/CardRequirement';
import {cardsToModel} from '../models/ModelUtils';
import {SelectProjectCardToPlayModel} from '../../common/models/PlayerInputModel';
import {InputError} from './InputError';

export type PlayCardMetadata = {
  reserveUnits: Readonly<Units>;
  details: CanPlayResponse | undefined;
};

export class SelectProjectCardToPlay extends BasePlayerInput<IProjectCard> {
  public cards: Array<IProjectCard> = [];
  public extras: Map<CardName, PlayCardMetadata>;

  constructor(
    private player: IPlayer,
    cards: Array<PlayableCard> = player.getPlayableCards(),
    public config?: {
      action?: CardAction,
    }) {
    super('projectCard', 'Play project card');
    this.buttonLabel = 'Play card';
    this.cards = cards.map((card) => card.card);
    this.extras = new Map(
      cards.map((card) => {
        return [
          card.card.name,
          {
            reserveUnits: card.card.reserveUnits ?
              MoonExpansion.adjustedReserveCosts(player, card.card) :
              Units.EMPTY,
            details: card.details,
          },
        ];
      }));
  }

  public toModel(player: IPlayer): SelectProjectCardToPlayModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'projectCard',
      cards: cardsToModel(player, this.cards, {showCalculatedCost: true, extras: this.extras}),
      microbes: player.getSpendable('microbes'),
      dirigiblesFloaters: player.getSpendable('dirigiblesFloaters'),
      paymentOptions: {
        heat: player.canUseHeatAsMegaCredits,
        lunaTradeFederationTitanium: player.canUseTitaniumAsMegacredits,
        plants: player.canUsePlantsAsMegacredits,
        corruption: player.canUseCorruptionAsMegacredits,
        energy: player.cardIsInEffect(CardName.ENERGY_LAB),
      },
      lunaArchivesScience: player.getSpendable('lunaArchivesScience'),
      seeds: player.getSpendable('seeds'),
      graphene: player.getSpendable('graphene'),
      kuiperAsteroids: player.getSpendable('kuiperAsteroids'),
      corruption: player.underworldData.corruption,
      heavyAerospaceTechSteel: player.cardIsInEffect(CardName.HEAVY_AEROSPACE_TECH),
      ecologicalContractPlants: player.cardIsInEffect(CardName.ECOLOGICAL_CONTRACT),
      undergroundVenusBaseSteel: player.cardIsInEffect(CardName.UNDERGROUND_VENUS_BASE),
      energyLabEnergy: player.cardIsInEffect(CardName.ENERGY_LAB),
      bioengineeringStudiesAnimals: player.getSpendable('bioengineeringStudiesAnimals'),
      asteroidBeltColonyAsteroids: player.getSpendable('asteroidBeltColonyAsteroids'),
      jovianConstructionYardFloaters: player.getSpendable('jovianConstructionYardFloaters'),
      aerialMassDriversFloaters: player.getSpendable('aerialMassDriversFloaters'),
    };
  }

  public process(input: InputResponse) {
    if (!isSelectProjectCardToPlayResponse(input)) {
      throw new InputError('Not a valid SelectProjectCardToPlayResponse');
    }
    if (!isPayment(input.payment)) {
      throw new InputError('payment is not a valid type');
    }

    const card = this.cards.find((card) => card.name === input.card);
    if (card === undefined) {
      throw new InputError('Unknown card name ' + input.card);
    }
    const details = this.extras.get(input.card);
    if (details === undefined) {
      throw new InputError('Unknown card name ' + input.card);
    }
    // These are not used for safety but do help give a better error message
    // to the user
    const reserveUnits = details.reserveUnits;
    if (reserveUnits.steel + input.payment.steel > this.player.steel) {
      throw new InputError(`${reserveUnits.steel} units of steel must be reserved for ${input.card}`);
    }
    if (reserveUnits.titanium + input.payment.titanium > this.player.titanium) {
      throw new InputError(`${reserveUnits.titanium} units of titanium must be reserved for ${input.card}`);
    }
    if (reserveUnits.plants + input.payment.plants > this.player.plants) {
      throw new InputError(`${reserveUnits.titanium} units of plants must be reserved for ${input.card}`);
    }
    const yesAnd = typeof(details.details) === 'boolean' ? undefined : details.details;
    this.payAndPlay(card, input.payment, yesAnd);
    return undefined;
  }

  public payAndPlay(card: IProjectCard, payment: Payment, yesAnd?: YesAnd) {
    this.player.checkPaymentAndPlayCard(card, payment, this.config?.action);
    if ((yesAnd?.thinkTankResources ?? 0) > 0) {
      const thinkTank = this.player.tableau.find((card) => card.name === CardName.THINK_TANK);
      // TODO(kberg): this processing ought to be done while paying for the card.
      if (thinkTank !== undefined) {
        this.player.removeResourceFrom(thinkTank, yesAnd?.thinkTankResources, {log: true});
      }
    }
    this.cb(card);
  }
}

================
File: inputs/SelectResource.ts
================
import {Message} from '../../common/logs/Message';
import {Units} from '../../common/Units';
import {BasePlayerInput} from '../PlayerInput';
import {SelectResourceModel} from '../../common/models/PlayerInputModel';
import {InputResponse, isSelectResourceResponse} from '../../common/inputs/InputResponse';
import {InputError} from './InputError';

export class SelectResource extends BasePlayerInput<keyof Units> {
  constructor(
    public override title: string | Message,
    public include: ReadonlyArray<keyof Units> = Units.keys,
    public override buttonLabel: string = 'Select',
  ) {
    super('resource', title);
  }

  public override toModel(): SelectResourceModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'resource',
      include: this.include,
    };
  }

  public process(input: InputResponse) {
    if (!isSelectResourceResponse(input)) {
      throw new InputError('Not a valid SelectResourceResponse');
    }
    if (!this.include.includes(input.resource)) {
      throw new InputError('Not a valid unit');
    }
    return this.cb(input.resource);
  }
}

================
File: inputs/SelectResources.ts
================
import {Message} from '../../common/logs/Message';
import {Units} from '../../common/Units';
import {BasePlayerInput} from '../PlayerInput';
import {SelectResourcesModel} from '../../common/models/PlayerInputModel';
import {InputResponse, isSelectResourcesResponse} from '../../common/inputs/InputResponse';
import {InputError} from './InputError';
import {sum} from '../../common/utils/utils';

export class SelectResources extends BasePlayerInput<Units> {
  constructor(
    public override title: string | Message,
    public count: number,
    public override buttonLabel: string = 'Select',
  ) {
    super('resources', title);
  }

  public override toModel(): SelectResourcesModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'resources',
      count: this.count,
    };
  }

  public process(input: InputResponse) {
    if (!isSelectResourcesResponse(input)) {
      throw new InputError('Not a valid SelectResourcesResponse');
    }
    const array = Object.values(input.units);
    if (array.some((count) => count < 0)) {
      throw new InputError('All units must be positive');
    }
    if (sum(array) !== this.count) {
      throw new InputError(`Select ${this.count} resource(s)`);
    }
    return this.cb(input.units);
  }
}

================
File: inputs/SelectSpace.ts
================
import {Message} from '../../common/logs/Message';
import {Space} from '../boards/Space';
import {InputResponse, isSelectSpaceResponse} from '../../common/inputs/InputResponse';
import {SelectSpaceModel} from '../../common/models/PlayerInputModel';
import {BasePlayerInput} from '../PlayerInput';
import {InputError} from './InputError';

export class SelectSpace extends BasePlayerInput<Space> {
  constructor(
    title: string | Message,
    public spaces: ReadonlyArray<Space>) {
    super('space', title);
    if (spaces.length === 0) {
      throw new InputError('No available spaces');
    }
  }

  public override toModel(): SelectSpaceModel {
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'space',
      spaces: this.spaces.map((space) => space.id),
    };
  }

  public process(input: InputResponse) {
    if (!isSelectSpaceResponse(input)) {
      throw new InputError('Not a valid SelectSpaceResponse');
    }
    const space = this.spaces.find((space) => space.id === input.spaceId);
    if (space === undefined) {
      throw new InputError('Space not available');
    }
    return this.cb(space);
  }
}

================
File: inputs/ShiftAresGlobalParameters.ts
================
import {BasePlayerInput} from '../PlayerInput';
import {IPlayer} from '../IPlayer';
import {AresGlobalParametersResponse} from '../../common/inputs/AresGlobalParametersResponse';
import {InputResponse, isAresGlobalParametersResponse, isShiftAresGlobalParametersResponse} from '../../common/inputs/InputResponse';
import {ShiftAresGlobalParametersModel} from '../../common/models/PlayerInputModel';
import {InputError} from './InputError';

export class ShiftAresGlobalParameters extends BasePlayerInput<AresGlobalParametersResponse> {
  constructor() {
    super('aresGlobalParameters', 'Adjust Ares global parameters up to 1 step.');
  }

  public toModel(player: IPlayer): ShiftAresGlobalParametersModel {
    if (player.game.aresData === undefined) {
      throw new InputError('Ares is not defined');
    }
    return {
      title: this.title,
      buttonLabel: this.buttonLabel,
      type: 'aresGlobalParameters',
      aresData: player.game.aresData,
    };
  }
  public process(input: InputResponse, _player: IPlayer) {
    if (!isShiftAresGlobalParametersResponse(input)) {
      throw new InputError('Not a valid ShiftAresGlobalParametersResponse');
    }
    if (!isAresGlobalParametersResponse(input.response)) {
      throw new InputError('Not a valid ShiftAresGlobalParametersResponse');
    }

    if (!this.inRange(input.response.lowOceanDelta) ||
      !this.inRange(input.response.highOceanDelta) ||
      !this.inRange(input.response.temperatureDelta) ||
      !this.inRange(input.response.oxygenDelta)) {
      throw new InputError('values out of range');
    }
    this.cb(input.response);
    return undefined;
  }

  private inRange(val: number) {
    return (val >= -1 && val <= 1);
  }
}

================
File: inputs/titles.ts
================
import {CardName} from '../../common/cards/CardName';
import {PartyName} from '../../common/turmoil/PartyName';
import {message} from '../logs/MessageBuilder';

export const TITLES = {
  action: 'Select how to pay for action',
  payForCardAction: (cardName: CardName) => message('Select how to pay for ${0} action', (b) => b.cardName(cardName)),
  payForPartyAction: (partyName: PartyName) => message('Select how to pay for Turmoil ${0} action', (b) => b.partyName(partyName)),
} as const;

================
File: inputs/UndoActionOption.ts
================
import {SelectOption} from './SelectOption';

export class UndoActionOption extends SelectOption {
  constructor() {
    // No AndThen
    super('Undo last action', 'Undo');
  }
}

================
File: IPlayer.ts
================
import {PlayerId, isPlayerId} from '../common/Types';
import {CardName} from '../common/cards/CardName';
import {ICorporationCard} from './cards/corporation/ICorporationCard';
import {IGame, isIGame} from './IGame';
import {Payment, PaymentOptions} from '../common/inputs/Payment';
import {SpendableCardResource} from '../common/inputs/Spendable';
import {ICard, IActionCard} from './cards/ICard';
import {TRSource} from '../common/cards/TRSource';
import {IProjectCard} from './cards/IProjectCard';
import {PlayerInput} from './PlayerInput';
import {Resource} from '../common/Resource';
import {CardResource} from '../common/CardResource';
import {SelectCard} from './inputs/SelectCard';
import {Priority} from './deferredActions/Priority';
import {SerializedPlayer} from './SerializedPlayer';
import {Timer} from '../common/Timer';
import {AllOptions, DrawOptions} from './deferredActions/DrawCards';
import {Units} from '../common/Units';
import {IStandardProjectCard} from './cards/IStandardProjectCard';
import {GlobalParameter} from '../common/GlobalParameter';
import {GlobalEventName} from '../common/turmoil/globalEvents/GlobalEventName';
import {InputResponse} from '../common/inputs/InputResponse';
import {Tags} from './player/Tags';
import {Colonies} from './player/Colonies';
import {Production} from './player/Production';
import {ICeoCard} from './cards/ceos/ICeoCard';
import {IVictoryPointsBreakdown} from '../common/game/IVictoryPointsBreakdown';
import {YesAnd} from './cards/requirements/CardRequirement';
import {PlayableCard} from './cards/IProjectCard';
import {Color} from '../common/Color';
import {OrOptions} from './inputs/OrOptions';
import {Stock} from './player/Stock';
import {UnderworldPlayerData} from './underworld/UnderworldData';
import {AlliedParty} from './turmoil/AlliedParty';
import {IParty} from './turmoil/parties/IParty';
import {GenerationData} from './player/GenerationData';

export type ResourceSource = IPlayer | GlobalEventName | ICard;

export type CanAffordOptions = Partial<PaymentOptions> & {
  cost: number,
  reserveUnits?: Units,
  tr?: TRSource,
}

/**
 * Behavior when playing a card:
 *   add it to the tableau
 *   discard it from the tableau
 *   only play the card (used for replaying a card)
 *   or do nothing.
 */
export type CardAction = 'add' | 'discard' | 'nothing' | 'action-only';

export interface IPlayer {
  readonly id: PlayerId;
  name: string;
  color: Color;
  beginner: boolean;
  handicap: number;

  game: IGame;
  tags: Tags;
  colonies: Colonies;
  readonly production: Production;
  readonly stock: Stock;

  // Corporate identity
  corporations: Array<ICorporationCard>;

  // Used only during set-up
  pickedCorporationCard?: ICorporationCard;

  // Resources
  megaCredits: number;
  steel: number;
  titanium: number;
  plants: number;
  energy: number;
  heat: number;

  // Helion
  canUseHeatAsMegaCredits: boolean;
  // Luna Trade Federation
  canUseTitaniumAsMegacredits: boolean;
  // Martian Lumber Corp
  canUsePlantsAsMegacredits: boolean;
  // Friends in High Places
  canUseCorruptionAsMegacredits: boolean;

  // This generation / this round
  actionsTakenThisRound: number;
  lastCardPlayed: CardName | undefined;
  pendingInitialActions: Array<ICorporationCard>;

  // Cards
  dealtCorporationCards: Array<ICorporationCard>;
  dealtPreludeCards: Array<IProjectCard>;
  dealtCeoCards: Array<ICeoCard>;
  dealtProjectCards: Array<IProjectCard>;
  cardsInHand: Array<IProjectCard>;
  preludeCardsInHand: Array<IProjectCard>;
  ceoCardsInHand: Array<IProjectCard>;
  playedCards: Array<IProjectCard>;
  cardCost: number;

  /** Cards this player has in their draft hand. Player chooses from them, and passes them to the next player */
  draftHand: Array<IProjectCard>;
  /** Cards this player has already chosen during this draft round */
  draftedCards: Array<IProjectCard>;
  /** true when this player is drafting, false when player is not, undefined when there is no draft phase. */
  needsToDraft?: boolean;

  timer: Timer;

  // Turmoil
  turmoilPolicyActionUsed: boolean;
  politicalAgendasActionUsedCount: number;

  oceanBonus: number;

  // Custom cards
  // Community Leavitt Station and Pathfinders Leavitt Station
  scienceTagCount: number;
  // PoliticalAgendas Scientists P41
  hasTurmoilScienceTagBonus: boolean;
  // Ecoline
  plantsNeededForGreenery: number;

  //andy helion
  heatNeededForTemperature: number;
  heatDiscount: number;

  // Lawsuit
  removingPlayers: Array<PlayerId>;
  // For Playwrights corp.
  // removedFromPlayCards is a bit of a misname: it's a temporary storage for
  // cards that provide 'next card' discounts. This will clear between turns.
  removedFromPlayCards: Array<IProjectCard>;

  // The number of actions a player can take this round.
  // It's almost always 2, but certain cards can change this value.
  //
  // This value isn't serialized. Probably ought to.
  availableActionsThisRound: number;

  // Stats
  actionsTakenThisGame: number;
  victoryPointsByGeneration: Array<number>;
  totalDelegatesPlaced: number;

  // Supercapacitors Effect
  optionalEnergyConversion: boolean;

  generationData: GenerationData;

  underworldData: UnderworldPlayerData;
  readonly alliedParty?: AlliedParty;

  //Andy test one trade
  hasTraded: boolean;

  tearDown(): void;
  tableau: Array<ICorporationCard | IProjectCard>;

  /**
   * Return `true` if this player has played the supplied corporation card.
   */
  isCorporation(corporationName: CardName): boolean;
  /**
   * Return the corporation card this player has played by the given name, or `undefined`.
   */
  getCorporation(corporationName: CardName): ICorporationCard | undefined;
  /**
   * Return the corporation card this player has played by the given name, or throw an Error.
   */
  getCorporationOrThrow(corporationName: CardName): ICorporationCard;
  getTitaniumValue(): number;
  increaseTitaniumValue(): void;
  decreaseTitaniumValue(): void;
  getSelfReplicatingRobotsTargetCards(): Array<IProjectCard>;
  getSteelValue(): number;
  increaseSteelValue(): void;
  decreaseSteelValue(): void;
  getTerraformRating(): number;
  increaseTerraformRating(steps?: number, opts?: {log?: boolean}): void;
  decreaseTerraformRating(steps?: number, opts?: {log?: boolean}): void;
  setTerraformRating(value: number): void;
  logUnitDelta(resource: Resource, amount: number, unitType: 'production' | 'amount', from: ResourceSource | undefined, stealing?: boolean): void;

  getActionsThisGeneration(): Set<CardName>;
  addActionThisGeneration(cardName: CardName): void;
  getVictoryPoints(): IVictoryPointsBreakdown;
  cardIsInEffect(cardName: CardName): boolean;
  hasProtectedHabitats(): boolean;
  plantsAreProtected(): boolean;
  alloysAreProtected(): boolean;
  /**
   * Returns true when this player can lose |minQuantity| units of production.
   *
   * This typically means they have the required units of production, and that production
   * isn't protected.
   */
  canHaveProductionReduced(resource: Resource, minQuantity: number, attacker: IPlayer): boolean;
  maybeBlockAttack(perpetrator: IPlayer, cb: (proceed: boolean) => PlayerInput | undefined): void;

  /**
   * Return true if this player cannot have their production reduced.
   *
   * It can if this player is attacking themselves, or if this player has played Private Security.
   */
  productionIsProtected(attacker: IPlayer): boolean;
  /**
   * In the multiplayer game, after an attack, the attacked player makes a claim
   * for insurance. If Mons Insurance is in the game, the claimant will receive
   * as much as possible from the insurer.
   *
   * `this` is the attacked player.
   */
  resolveInsurance(): void;
  /**
   * In the solo game, Mons Insurance is only held by the sole player, who will
   * have to pay the penalty for hurting the neutral player.
   *
   * `this` is the potentialInsurer: the solo player in the game. It's not
   * clear yet whether the player has Mons Insurance, but if they do, they will
   * pay. Unlike `resolveInsurance`, there is no claimant Player so the money
   * disappears.
   */
  resolveInsuranceInSoloGame(): void;
  /**
   * When the card Legal Firm is in play, anyone who removes resources or production from
   * the card owner has 3MC stolen from them
   */
  legalFirmEffect(attackingPlayer: IPlayer): void;
  /**
   * Returns the number of colonies this player has on all the colony types.
   *
   * If Colonies is not in this game, this returns 0.
   */
  getColoniesCount(): number;
  /**
   * Count the number of cards in the player's event pile.
   */
  getPlayedEventsCount(): number;
  /**
   * For the given global parameter, return a sum of all requirements bonuses this
   * player has thanks to played cards, Turmoil policies, etcetera.
   */
  getGlobalParameterRequirementBonus(parameter: GlobalParameter): number;
  /**
   * Remove resources from this player's played card
   */
  removeResourceFrom(card: ICard, count?: number, options?: {removingPlayer? : IPlayer, log?: boolean}): void;
  /**
   * Add resources to this player's played card
   */
  addResourceTo(card: ICard, options?: number | {qty?: number, log: boolean, logZero?: boolean}): void;

  /**
   * Returns the set of played cards that have actual resources on them.
   *
   * If `resource` is absent, include cards that collect any resource.
   */
  getCardsWithResources(resource?: CardResource): Array<ICard>;

  /**
   * Return the cards that collect `resource`.
   *
   * If `resource` is absent, return the cards that collect any resource.
   */
  getResourceCards(resource?: CardResource): Array<ICard>;

  /**
   * Count all the resources of a given type in the tableau.
   */
  getResourceCount(resource: CardResource): number;
  runInput(input: InputResponse, pi: PlayerInput): void;
  getAvailableBlueActionCount(): number;
  getPlayableActionCards(): Array<ICard & IActionCard>;
  getUsableOPGCeoCards(): Array<ICeoCard>;
  runProductionPhase(): void;
  finishProductionPhase(): void;
  worldGovernmentTerraforming(): void;

  runResearchPhase(): void;
  getCardCost(card: IProjectCard): number;

  /** The number of resources on this card for this player, or 0 if the player does not have this card. */
  resourcesOnCard(name: CardName): number;
  spendableMegacredits(): number;
  /** Return then amount of spendable units of a given card resource */
  getSpendable(resource: SpendableCardResource): number;
  checkPaymentAndPlayCard(selectedCard: IProjectCard, payment: Payment, cardAction?: CardAction): void;
  pay(payment: Payment): void;
  availableHeat(): number;
  spendHeat(amount: number, cb?: () => (undefined | PlayerInput)) : PlayerInput | undefined;

  playCard(selectedCard: IProjectCard, payment?: Payment, cardAction?: CardAction): void;
  onCardPlayed(card: IProjectCard): void;
  playAdditionalCorporationCard(corporationCard: ICorporationCard): void;
  playCorporationCard(corporationCard: ICorporationCard): void;
  drawCard(count?: number, options?: DrawOptions): void;
  drawCardKeepSome(count: number, options: AllOptions): void;
  discardPlayedCard(card: IProjectCard): void;
  discardCardFromHand(card: IProjectCard, options?: {log?: boolean}): void;

  /** Player has prestated they want to pass on their next turn */
  autopass: boolean;
  /** Player is done taking actions this generation. */
  pass(): void;
  takeActionForFinalGreenery(): void;
  getPlayableCards(): Array<PlayableCard>;
  canPlay(card: IProjectCard): boolean | YesAnd;
  canSpend(payment: Payment, reserveUnits?: Units): boolean;
  payingAmount(payment: Payment, options?: Partial<PaymentOptions>): number;
  /**
   * Returns a summary of how much a player would have to spend to play a card,
   * any associated costs, and ways the player can pay.
   */
  affordOptionsForCard(card: IProjectCard): CanAffordOptions;
  canAfford(options: number | CanAffordOptions): boolean;
  getStandardProjectOption(): SelectCard<IStandardProjectCard>;
  takeAction(saveBeforeTakingAction?: boolean): void;
  getOpponents(): ReadonlyArray<IPlayer>;
  /** Add `corp`'s initial action to the deferred action queue, if it has one. */
  deferInitialAction(corp: ICorporationCard): void;
  getActions(): OrOptions;
  process(input: InputResponse): void;
  getWaitingFor(): PlayerInput | undefined;
  setWaitingFor(input: PlayerInput, cb?: () => void): void;
  setWaitingForSafely(input: PlayerInput, cb?: () => void): void;
  serialize(): SerializedPlayer;
  /** Shorthand for deferring evaluating a PlayerInput */
  defer(input: PlayerInput | undefined | void | (() => PlayerInput | undefined | void), priority?: Priority): void;
  setAlliedParty(party: IParty): void;
}

export function isIPlayer(object: any): object is IPlayer {
  return object !== undefined && object.hasOwnProperty('id') && isPlayerId(object.id) && isIGame(object.game);
}

================
File: LogHelper.ts
================
import {CardName} from '../common/cards/CardName';
import {IPlayer} from './IPlayer';
import {ICard} from './cards/ICard';
import {Space} from './boards/Space';
import {TileType, tileTypeToString} from '../common/TileType';
import {IColony} from './colonies/IColony';
import {Logger} from './logs/Logger';

export class LogHelper {
  static logAddResource(player: IPlayer, card: ICard, qty: number = 1): void {
    let resourceType = 'resource(s)';

    if (card.resourceType) {
      resourceType = card.resourceType.toLowerCase() + '(s)';
    }

    player.game.log('${0} added ${1} ${2} to ${3}', (b) =>
      b.player(player).number(qty).string(resourceType).card(card));
  }

  static logRemoveResource(player: IPlayer, card: ICard, qty: number = 1, effect: string): void {
    let resourceType = 'resource(s)';

    if (card.resourceType) {
      resourceType = card.resourceType.toLowerCase() + '(s)';
    }

    player.game.log('${0} removed ${1} ${2} from ${3} to ${4}', (b) =>
      b.player(player).number(qty).string(resourceType).card(card).string(effect));
  }

  static logTilePlacement(player: IPlayer, space: Space, tileType: TileType) {
    this.logBoardTileAction(player, space, tileTypeToString[tileType] + ' tile');
  }

  static logBoardTileAction(player: IPlayer, space: Space, description: string, action: string = 'placed') {
    // Skip off-grid tiles
    if (space.x === -1 && space.y === -1) return;
    // Skip solo play random tiles
    if (player.name === 'neutral') return;

    const offset = Math.abs(space.y - 4);
    const row = space.y + 1;
    const position = space.x - offset + 1;

    player.game.log('${0} ${1} ${2} on row ${3} position ${4}', (b) =>
      b.player(player).string(action).string(description).number(row).number(position));
  }

  static logColonyTrackIncrease(player: IPlayer, colony: IColony, steps: number = 1) {
    player.game.log('${0} increased ${1} colony track ${2} step(s)', (b) =>
      b.player(player).colony(colony).number(steps));
  }

  static logColonyTrackDecrease(player: IPlayer, colony: IColony) {
    player.game.log('${0} decreased ${1} colony track 1 step', (b) =>
      b.player(player).colony(colony));
  }

  static logVenusIncrease(player: IPlayer, steps: number) {
    player.game.log('${0} raised the Venus scale ${1} step(s)', (b) => b.player(player).number(steps));
  }

  static logDiscardedCards(logger: Logger, cards: ReadonlyArray<ICard> | ReadonlyArray<CardName>) {
    logger.log('${0} card(s) were discarded', (b) => {
      b.rawString(cards.length.toString());
      for (const card of cards) {
        if (typeof card === 'string') {
          b.cardName(card);
        } else {
          b.card(card);
        }
      }
    });
  }

  static logDrawnCards(player: IPlayer, cards: ReadonlyArray<ICard> | ReadonlyArray<CardName>, privateMessage: boolean = false) {
    // If |this.count| equals 3, for instance, this generates "${0} drew ${1}, ${2} and ${3}"
    let message = '${0} drew ';
    if (cards.length === 0) {
      message += 'no cards';
    } else {
      for (let i = 0, length = cards.length; i < length; i++) {
        if (i > 0) {
          if (i < length - 1) {
            message += ', ';
          } else {
            message += ' and ';
          }
        }
        message += '${' + (i + 1) + '}';
      }
    }
    const options = privateMessage ? {reservedFor: player} : {};

    player.game.log(message, (b) => {
      if (privateMessage === false) {
        b.player(player);
      } else {
        b.string('You');
      }
      for (const card of cards) {
        if (typeof card === 'string') {
          b.cardName(card);
        } else {
          b.card(card);
        }
      }
    }, options);
  }
}

================
File: ma/MilestoneAwardSelector.ts
================
import {
  AMAZONIS_PLANITIA_AWARDS,
  ARABIA_TERRA_AWARDS,
  ARES_AWARDS,
  Awards,
  ELYSIUM_AWARDS,
  HELLAS_AWARDS,
  MOON_AWARDS,
  TERRA_CIMMERIA_AWARDS,
  THARSIS_AWARDS,
  UNDERWORLD_AWARDS,
  // UTOPIA_PLANITIA_AWARDS,
  VASTITAS_BOREALIS_AWARDS,
  VENUS_AWARDS,
} from '../awards/Awards';
import {IAward} from '../awards/IAward';
import {BoardName} from '../../common/boards/BoardName';
import {GameOptions} from '../game/GameOptions';
import {IMilestone} from '../milestones/IMilestone';
import {
  AMAZONIS_PLANITIA_MILESTONES,
  ARABIA_TERRA_MILESTONES,
  ARES_MILESTONES,
  ELYSIUM_MILESTONES,
  HELLAS_MILESTONES,
  Milestones,
  MOON_MILESTONES,
  TERRA_CIMMERIA_MILESTONES,
  THARSIS_MILESTONES,
  UNDERWORLD_MILESTONES,
  // UTOPIA_PLANITIA_MILESTONES,
  VASTITAS_BOREALIS_MILESTONES,
  VENUS_MILESTONES,
} from '../milestones/Milestones';
import {FullMoon} from '../moon/FullMoon';
import {Lunarchitect} from '../moon/Lunarchitect';
import {LunarMagnate} from '../moon/LunarMagnate';
import {OneGiantStep} from '../moon/OneGiantStep';
import {RandomMAOptionType} from '../../common/ma/RandomMAOptionType';
import {inplaceShuffle} from '../utils/shuffle';
import {UnseededRandom} from '../../common/utils/Random';
import {MilestoneName} from '../../common/ma/MilestoneName';
import {AwardName} from '../../common/ma/AwardName';
import {inplaceRemove} from '../../common/utils/utils';
import {synergies} from './MilestoneAwardSynergies';

type DrawnMilestonesAndAwards = {
  milestones: Array<IMilestone>,
  awards: Array<IAward>
}


// Function to compute max synergy of a given set of milestones and awards.
// Exported for testing
export function maximumSynergy(names: Array<string>) : number {
  let max = 0;
  for (let i = 0; i < names.length - 1; i++) {
    for (let j = i + 1; j < names.length; j++) {
      const synergy = synergies.get(names[i], names[j]);
      max = Math.max(synergy, max);
    }
  }
  return max;
}

type Constraints = {
    // No pairing may have a synergy greater than this.
    maxSynergyAllowed: number;
    // Sum of all the synergies may be no greater than this.
    totalSynergyAllowed: number;
    // 3) Limited a number of pair with synergy at |highThreshold| or above to |numberOfHighAllowed| or below.
    numberOfHighAllowed: number;
    highThreshold: number;
  }

export const LIMITED_SYNERGY: Constraints = {
  maxSynergyAllowed: 6,
  totalSynergyAllowed: 20,
  numberOfHighAllowed: 20,
  highThreshold: 4,
};

const UNLIMITED_SYNERGY: Constraints = {
  maxSynergyAllowed: 100,
  totalSynergyAllowed: 100,
  numberOfHighAllowed: 100,
  highThreshold: 100,
};

export function chooseMilestonesAndAwards(gameOptions: GameOptions): DrawnMilestonesAndAwards {
  let drawnMilestonesAndAwards: DrawnMilestonesAndAwards = {
    milestones: [],
    awards: [],
  };

  function push(milestones: Array<IMilestone>, awards: Array<IAward>) {
    drawnMilestonesAndAwards.milestones.push(...milestones);
    drawnMilestonesAndAwards.awards.push(...awards);
  }

  const includeVenus = gameOptions.venusNextExtension && gameOptions.includeVenusMA;
  const requiredQty = includeVenus ? 6 : 5;

  switch (gameOptions.randomMA) {
  case RandomMAOptionType.NONE:
    switch (gameOptions.boardName) {
    case BoardName.THARSIS:
      push(THARSIS_MILESTONES, THARSIS_AWARDS);
      break;
    case BoardName.HELLAS:
      push(HELLAS_MILESTONES, HELLAS_AWARDS);
      break;
    case BoardName.ELYSIUM:
      push(ELYSIUM_MILESTONES, ELYSIUM_AWARDS);
      break;
    case BoardName.ARABIA_TERRA:
      push(ARABIA_TERRA_MILESTONES, ARABIA_TERRA_AWARDS);
      break;
    case BoardName.AMAZONIS:
      push(AMAZONIS_PLANITIA_MILESTONES, AMAZONIS_PLANITIA_AWARDS);
      break;
    case BoardName.TERRA_CIMMERIA:
      push(TERRA_CIMMERIA_MILESTONES, TERRA_CIMMERIA_AWARDS);
      break;
    case BoardName.VASTITAS_BOREALIS:
      push(VASTITAS_BOREALIS_MILESTONES, VASTITAS_BOREALIS_AWARDS);
      break;
    case BoardName.UTOPIA_PLANITIA:
    case BoardName.VASTITAS_BOREALIS_NOVUS:
    case BoardName.TERRA_CIMMERIA_NOVUS:
      // There's no need to add more milestones and awards for these boards, so it returns.
      return getRandomMilestonesAndAwards(gameOptions, requiredQty, LIMITED_SYNERGY);
    }
    if (includeVenus) {
      push(VENUS_MILESTONES, VENUS_AWARDS);
    }
    if (gameOptions.aresExtension) {
      push(ARES_MILESTONES, ARES_AWARDS);
    }
    if (gameOptions.moonExpansion) {
      // One MA will reward moon tags, the other will reward moon tiles.
      if (Math.random() > 0.5) {
        push([new OneGiantStep], [new LunarMagnate()]);
      } else {
        push([new Lunarchitect], [new FullMoon()]);
      }
    }
    break;

  case RandomMAOptionType.LIMITED:
    drawnMilestonesAndAwards = getRandomMilestonesAndAwards(gameOptions, requiredQty, LIMITED_SYNERGY);
    break;
  case RandomMAOptionType.UNLIMITED:
    drawnMilestonesAndAwards = getRandomMilestonesAndAwards(gameOptions, requiredQty, UNLIMITED_SYNERGY);
    break;
  default:
    throw new Error('Unknown milestone/award type: ' + gameOptions.randomMA);
  }

  return drawnMilestonesAndAwards;
}

// Selects |numberMARequested| milestones and |numberMARequested| awards from all available awards and milestones (optionally including
// Venusian.) It does this by following these rules:
// 1) No pair with synergy above |maxSynergyAllowed|.
// 2) Total synergy is |totalSynergyAllowed| or below.
// 3) Limited a number of pair with synergy at |highThreshold| or above to |numberOfHighAllowed| or below.
function getRandomMilestonesAndAwards(gameOptions: GameOptions,
  numberMARequested: number,
  constraints: Constraints,
  attempt: number = 1): DrawnMilestonesAndAwards {
  // 5 is a fine number of attempts. A sample of 100,000 runs showed that this algorithm
  // didn't get past 3.
  // https://github.com/terraforming-mars/terraforming-mars/pull/1637#issuecomment-711411034
  const maxAttempts = 5;
  if (attempt > maxAttempts) {
    throw new Error('No limited synergy milestones and awards set was generated after ' + maxAttempts + ' attempts. Please try again.');
  }

  function toName<T>(e: {name: T}): T {
    return e.name;
  }

  const candidateMilestones: Array<MilestoneName> = [...THARSIS_MILESTONES, ...ELYSIUM_MILESTONES, ...HELLAS_MILESTONES].map(toName);
  const candidateAwards: Array<AwardName> = [...THARSIS_AWARDS, ...ELYSIUM_AWARDS, ...HELLAS_AWARDS].map(toName);

  if (gameOptions.venusNextExtension && gameOptions.includeVenusMA) {
    candidateMilestones.push(...VENUS_MILESTONES.map(toName));
    candidateAwards.push(...VENUS_AWARDS.map(toName));
  }
  if (gameOptions.aresExtension) {
    candidateMilestones.push(...ARES_MILESTONES.map(toName));
    candidateAwards.push(...ARES_AWARDS.map(toName));
  }
  if (gameOptions.moonExpansion) {
    candidateMilestones.push(...MOON_MILESTONES.map(toName));
    candidateAwards.push(...MOON_AWARDS.map(toName));
  }

  if (gameOptions.underworldExpansion) {
    candidateMilestones.push(...UNDERWORLD_MILESTONES.map(toName));
    candidateAwards.push(...UNDERWORLD_AWARDS.map(toName));
  }

  if (gameOptions.includeFanMA) {
    candidateMilestones.push(
      ...ARABIA_TERRA_MILESTONES.map(toName),
      ...AMAZONIS_PLANITIA_MILESTONES.map(toName),
      ...TERRA_CIMMERIA_MILESTONES.map(toName),
      ...VASTITAS_BOREALIS_MILESTONES.map(toName));

    candidateAwards.push(
      ...ARABIA_TERRA_AWARDS.map(toName),
      ...AMAZONIS_PLANITIA_AWARDS.map(toName),
      ...TERRA_CIMMERIA_AWARDS.map(toName),
      ...VASTITAS_BOREALIS_AWARDS.map(toName));

    if (!gameOptions.pathfindersExpansion) {
      inplaceRemove(candidateMilestones, 'Martian');
    }
    if (!gameOptions.coloniesExtension) {
      inplaceRemove(candidateMilestones, 'Colonizer');
      inplaceRemove(candidateMilestones, 'Pioneer');
    }
    if (!gameOptions.turmoilExtension) {
      inplaceRemove(candidateAwards, 'Politician');
    }
    // Special-case Terran and Businessperson, which are exactly the same.
    if (candidateMilestones.includes('Terran') && candidateMilestones.includes('Businessperson')) {
      inplaceRemove(candidateMilestones, 'Terran');
    }
  }

  inplaceShuffle(candidateMilestones, UnseededRandom.INSTANCE);
  inplaceShuffle(candidateAwards, UnseededRandom.INSTANCE);

  const accum = new Accumulator(constraints);

  // Keep adding milestones or awards until there are as many as requested
  while (accum.milestones.length + accum.awards.length < numberMARequested * 2) {
    // If there is enough award, add a milestone. And vice versa. If still need both, flip a coin to decide which to add.
    if (accum.awards.length === numberMARequested || (accum.milestones.length !== numberMARequested && Math.round(Math.random()))) {
      const newMilestone = candidateMilestones.splice(0, 1)[0];
      // If not enough milestone are left to satisfy the constraints, restart the function with a recursive call.
      if (newMilestone === undefined) {
        return getRandomMilestonesAndAwards(gameOptions, numberMARequested, constraints, attempt+1);
      }
      accum.add(newMilestone, true);
    } else {
      const newAward = candidateAwards.splice(0, 1)[0];
      // If not enough awards are left to satisfy the constraints, restart the function with a recursive call.
      if (newAward === undefined) {
        return getRandomMilestonesAndAwards(gameOptions, numberMARequested, constraints, attempt+1);
      }
      accum.add(newAward, false);
    }
  }

  if (!verifySynergyRules(accum.milestones.concat(accum.awards), constraints)) {
    throw new Error('The randomized milestones and awards set does not satisfy the given synergy rules.');
  }

  return {
    milestones: accum.milestones.map((name) => Milestones.getByName(name)),
    awards: accum.awards.map((name) => Awards.getByName(name)),
  };
}

// Verify whether a given array of |milestoneAwardArray| satisfies the following these rules:
// 1) No pair with synergy above |maxSynergyAllowed|.
// 2) Total synergy is |totalSynergyAllowed| or below.
// 3) Limited a number of pair with synergy at |highThreshold| or above to |numberOfHighAllowed| or below.
export function verifySynergyRules(
  mas: Array<string>,
  constraints: Constraints): boolean {
  let max = 0;
  let totalSynergy = 0;
  let numberOfHigh = 0;
  for (let i = 0; i < mas.length - 1; i++) {
    for (let j = i + 1; j < mas.length; j++) {
      const synergy = synergies.get(mas[i], mas[j]);
      max = Math.max(synergy, max);
      totalSynergy += synergy;
      if (synergy >= constraints.highThreshold) numberOfHigh++;
    }
  }
  return max <= constraints.maxSynergyAllowed &&
      totalSynergy <= constraints.totalSynergyAllowed &&
      numberOfHigh <= constraints.numberOfHighAllowed;
}

class Accumulator {
  milestones: Array<string> = [];
  awards: Array<string> = [];

  private accumulatedHighCount = 0;
  private accumulatedTotalSynergy = 0;

  constructor(private constraints: Constraints) {
  }

  // Conditionally add a milestone or award when it doesn't
  // violate synergy constraints.
  //
  // |ma| is the milestone or award, |milestone| is true when
  // |ma| represents a milestone and false when it represents
  // an award.
  //
  // Returns true when successful, false otherwise.
  //
  add(candidate: string, milestone: boolean): boolean {
    let totalSynergy = this.accumulatedTotalSynergy;
    let highCount = this.accumulatedHighCount;
    let max = 0;

    // Find the maximum synergy of this new item compared to the others
    this.milestones.concat(this.awards).forEach((ma) => {
      const synergy = synergies.get(ma, candidate);
      totalSynergy += synergy;
      if (synergy >= this.constraints.highThreshold) {
        highCount++;
      }
      max = Math.max(synergy, max);
    });
    // Check whether the addition violates any rule.
    if (max <= this.constraints.maxSynergyAllowed &&
        highCount <= this.constraints.numberOfHighAllowed &&
        totalSynergy <= this.constraints.totalSynergyAllowed) {
      if (milestone) {
        this.milestones.push(candidate);
      } else {
        this.awards.push(candidate);
      }
      // Update the stats
      this.accumulatedHighCount = highCount;
      this.accumulatedTotalSynergy = totalSynergy;
      return true;
    } else {
      return false;
    }
  }
}

================
File: ma/MilestoneAwardSynergies.ts
================
import {MilestoneName} from '../../common/ma/MilestoneName';
import {AwardName} from '../../common/ma/AwardName';
import {Awards} from '../awards/Awards';
import {Milestones} from '../milestones/Milestones';

// Higher synergies represent similar milestones or awards. For instance, Terraformer rewards for high TR
// and the Benefactor award is given to the player with the highest TR. Their synergy weight is 9, very high.

const synergiesData: Array<[MilestoneName | AwardName, MilestoneName | AwardName, number]> = [
  ['Terraformer', 'Benefactor', 9],
  ['Gardener', 'Cultivator', 9],
  ['Builder', 'Contractor', 9],
  ['Networker', 'Entrepreneur', 9],
  ['One Giant Step', 'Full Moon', 9],
  ['Lunarchitect', 'Lunar Magnate', 9],
  ['One Giant Step', 'Lunarchitect', 9],
  ['Full Moon', 'Lunar Magnate', 9],
  ['Estate Dealer', 'Cultivator', 8],
  ['Landlord', 'Cultivator', 8],
  ['Landlord', 'Desert Settler', 7],
  ['Landlord', 'Estate Dealer', 7],
  ['Desert Settler', 'Cultivator', 7],
  ['Miner', 'Industrialist', 7],
  ['One Giant Step', 'Lunar Magnate', 7],
  ['Lunarchitect', 'Full Moon', 7],
  ['Energizer', 'Industrialist', 6],
  ['Gardener', 'Landlord', 6],
  ['Mayor', 'Landlord', 6],
  ['Mayor', 'Cultivator', 6],
  ['Gardener', 'Estate Dealer', 5],
  ['Builder', 'Magnate', 5],
  ['Tycoon', 'Magnate', 5],
  ['Polar Explorer', 'Desert Settler', 5],
  ['Hoverlord', 'Excentric', 5],
  ['Hoverlord', 'Venuphile', 5],
  ['Desert Settler', 'Estate Dealer', 5],
  ['Builder', 'Tycoon', 4],
  ['Specialist', 'Energizer', 4],
  ['Mayor', 'Polar Explorer', 4],
  ['Mayor', 'Desert Settler', 4],
  ['Mayor', 'Estate Dealer', 4],
  ['Gardener', 'Polar Explorer', 4],
  ['Gardener', 'Desert Settler', 4],
  ['Ecologist', 'Excentric', 4],
  ['Polar Explorer', 'Landlord', 4],
  ['Mayor', 'Gardener', 3],
  ['Tycoon', 'Excentric', 3],
  ['Polar Explorer', 'Cultivator', 3],
  ['Energizer', 'Thermalist', 3],
  ['Rim Settler', 'Space Baron', 3],
  ['Celebrity', 'Space Baron', 3],
  ['Benefactor', 'Cultivator', 3],
  ['Gardener', 'Benefactor', 2],
  ['Specialist', 'Banker', 2],
  ['Ecologist', 'Tycoon', 2],
  ['Ecologist', 'Diversifier', 2],
  ['Tycoon', 'Scientist', 2],
  ['Tycoon', 'Contractor', 2],
  ['Tycoon', 'Venuphile', 2],
  ['Polar Explorer', 'Estate Dealer', 2],
  ['Rim Settler', 'Celebrity', 2],
  ['Scientist', 'Magnate', 2],
  ['Magnate', 'Space Baron', 2],
  ['Excentric', 'Venuphile', 2],
  ['Terraformer', 'Cultivator', 2],
  ['Terraformer', 'Gardener', 2],
  ['Builder', 'Miner', 1],
  ['Builder', 'Industrialist', 1],
  ['Planner', 'Scientist', 1],
  ['Generalist', 'Miner', 1],
  ['Specialist', 'Thermalist', 1],
  ['Specialist', 'Miner', 1],
  ['Specialist', 'Industrialist', 1],
  ['Ecologist', 'Cultivator', 1],
  ['Ecologist', 'Magnate', 1],
  ['Tycoon', 'Diversifier', 1],
  ['Tycoon', 'Tactician', 1],
  ['Tycoon', 'Rim Settler', 1],
  ['Tycoon', 'Space Baron', 1],
  ['Diversifier', 'Magnate', 1],
  ['Tactician', 'Scientist', 1],
  ['Tactician', 'Magnate', 1],
  ['Rim Settler', 'Magnate', 1],
  ['Banker', 'Benefactor', 1],
  ['Celebrity', 'Magnate', 1],
  ['Desert Settler', 'Benefactor', 1],
  ['Estate Dealer', 'Benefactor', 1],
  ['Terraformer', 'Landlord', 1],
  ['Terraformer', 'Thermalist', 1],
  ['Terraformer', 'Desert Settler', 1],
  ['Terraformer', 'Estate Dealer', 1],
  ['Gardener', 'Ecologist', 1],

  // Vastitas Borealis
  ['Smith', 'Generalist', 2],
  ['Smith', 'Specialist', 5],
  ['Smith', 'Rim Settler', 3],
  ['Smith', 'Miner', 8],
  ['Smith', 'Industrialist', 5],

  ['Tradesman', 'Ecologist', 6],
  ['Tradesman', 'Diversifier', 3],
  ['Tradesman', 'Hoverlord', 6],
  ['Tradesman', 'Excentric', 8],
  ['Tradesman', 'Venuphile', 4],

  ['Irrigator', 'Mayor', 3],
  ['Irrigator', 'Gardener', 3],
  ['Irrigator', 'Polar Explorer', 3],
  ['Irrigator', 'Landlord', 4],
  ['Irrigator', 'Desert Settler', 5],
  ['Irrigator', 'Estate Dealer', 9],
  ['Irrigator', 'Cultivator', 4],

  ['Adapter', 'Ecologist', 2],
  ['Adapter', 'Tactician', 3],
  ['Adapter', 'Scientist', 5],

  ['Edgedancer', 'Mayor', 2],
  ['Edgedancer', 'Gardener', 4],
  ['Edgedancer', 'Polar Explorer', 5],
  ['Edgedancer', 'Desert Settler', 5],
  ['Edgedancer', 'Estate Dealer', 1],
  ['Edgedancer', 'Cultivator', 4],
  ['Edgedancer', 'Irrigator', 1],

  ['Naturalist', 'Terraformer', 3],
  ['Naturalist', 'Gardener', 2],
  ['Naturalist', 'Generalist', 2],
  ['Naturalist', 'Specialist', 1],
  ['Naturalist', 'Landlord', 4],
  ['Naturalist', 'Thermalist', 6],
  ['Naturalist', 'Desert Settler', 1],
  ['Naturalist', 'Estate Dealer', 1],
  ['Naturalist', 'Benefactor', 5],
  ['Naturalist', 'Cultivator', 3],
  ['Naturalist', 'Edgedancer', 1],

  // Start of fan synergies:
  ['Voyager', 'Rim Settler', 9],
  ['Pioneer', 'Colonizer', 9],

  ['Networker', 'Terraformer', 1],
  ['Lunarchitect', 'Terraformer', 2],
  ['Farmer', 'Terraformer', 2],
  ['Tropicalist', 'Terraformer', 1],
  ['Economizer', 'Terraformer', 2],
  ['Firestarter', 'Terraformer', 1],
  ['Terra Pioneer', 'Terraformer', 1],
  ['Gambler', 'Terraformer', 0.5],
  ['Irrigator', 'Terraformer', 1],
  ['Lunar Magnate', 'Terraformer', 2],
  ['Historian', 'Terraformer', 1],
  ['Tourist', 'Terraformer', 1],
  ['Botanist', 'Terraformer', 2],
  ['Coordinator', 'Terraformer', 1],
  ['Edgedancer', 'Terraformer', 1],
  ['Naturalist', 'Terraformer', 3],
  ['Networker', 'Mayor', 2],
  ['Tropicalist', 'Mayor', 4],
  ['Terra Pioneer', 'Mayor', 4],
  ['Gambler', 'Mayor', 0.5],
  ['Irrigator', 'Mayor', 3],
  ['Tourist', 'Mayor', 1],
  ['Cosmic Settler', 'Mayor', 5],
  ['Urbanist', 'Mayor', 5],
  ['Edgedancer', 'Mayor', 2],
  ['Networker', 'Gardener', 2],
  ['Farmer', 'Gardener', 5],
  ['Tropicalist', 'Gardener', 4],
  ['Terra Pioneer', 'Gardener', 4],
  ['Gambler', 'Gardener', 0.5],
  ['Irrigator', 'Gardener', 3],
  ['Tourist', 'Gardener', 1],
  ['Botanist', 'Gardener', 5],
  ['Biologist', 'Gardener', 1],
  ['Edgedancer', 'Gardener', 4],
  ['Naturalist', 'Gardener', 2],
  ['Collector', 'Builder', 2],
  ['Gambler', 'Builder', 0.5],
  ['Smith', 'Builder', 1],
  ['Curator', 'Builder', 7],
  ['Engineer', 'Builder', 3],
  ['Manufacturer', 'Builder', 1],
  ['Urbanist', 'Builder', 3],
  ['Collector', 'Planner', 1],
  ['Gambler', 'Planner', 0.5],
  ['Manufacturer', 'Planner', 1],
  ['Hoarder', 'Planner', 4],
  ['Farmer', 'Generalist', 1],
  ['Economizer', 'Generalist', 1],
  ['Gambler', 'Generalist', 0.5],
  ['Smith', 'Generalist', 2],
  ['Engineer', 'Generalist', 4],
  ['Botanist', 'Generalist', 1],
  ['Naturalist', 'Generalist', 2],
  ['Farmer', 'Specialist', 3],
  ['Economizer', 'Specialist', 4],
  ['Gambler', 'Specialist', 0.5],
  ['Smith', 'Specialist', 5],
  ['Capitalist', 'Specialist', 1],
  ['Engineer', 'Specialist', 4],
  ['Botanist', 'Specialist', 3],
  ['Naturalist', 'Specialist', 1],
  ['Farmer', 'Ecologist', 3],
  ['Gambler', 'Ecologist', 0.5],
  ['Tradesman', 'Ecologist', 6],
  ['Curator', 'Ecologist', 1],
  ['A. Zoologist', 'Ecologist', 2],
  ['Botanist', 'Ecologist', 3],
  ['Zoologist', 'Ecologist', 2],
  ['Biologist', 'Ecologist', 9],
  ['Adapter', 'Ecologist', 2],
  ['Naturalist', 'Ecologist', 1],
  ['Networker', 'Tycoon', 1],
  ['One Giant Step', 'Tycoon', 2],
  ['Lunarchitect', 'Tycoon', 1],
  ['Minimalist', 'Tycoon', 1],
  ['Terran', 'Tycoon', 1],
  ['Land Specialist', 'Tycoon', 1],
  ['Martian', 'Tycoon', 1],
  ['Businessperson', 'Tycoon', 1],
  ['Collector', 'Tycoon', 3],
  ['Spacefarer', 'Tycoon', 2],
  ['Gambler', 'Tycoon', 0.5],
  ['Electrician', 'Tycoon', 1],
  ['Tradesman', 'Tycoon', 2],
  ['Entrepreneur', 'Tycoon', 1],
  ['Full Moon', 'Tycoon', 1],
  ['Lunar Magnate', 'Tycoon', 1],
  ['Curator', 'Tycoon', 2],
  ['Engineer', 'Tycoon', 1],
  ['A. Zoologist', 'Tycoon', 2],
  ['Botanist', 'Tycoon', 1],
  ['Manufacturer', 'Tycoon', 4],
  ['Zoologist', 'Tycoon', 2],
  ['Biologist', 'Tycoon', 1],
  ['T. Economizer', 'Tycoon', 2],
  ['Warmonger', 'Tycoon', 1],
  ['Adapter', 'Tycoon', 1],
  ['Naturalist', 'Tycoon', 1],
  ['Voyager', 'Tycoon', 1],
  ['Collector', 'Legend', 5],
  ['Gambler', 'Legend', 0.5],
  ['Historian', 'Legend', 8],
  ['Coordinator', 'Legend', 8],
  ['Warmonger', 'Legend', 2],
  ['Collector', 'Diversifier', 1],
  ['Gambler', 'Diversifier', 0.5],
  ['Tradesman', 'Diversifier', 3],
  ['A. Zoologist', 'Diversifier', 1],
  ['Manufacturer', 'Diversifier', 1],
  ['Zoologist', 'Diversifier', 1],
  ['Collector', 'Tactician', 1],
  ['Gambler', 'Tactician', 0.5],
  ['Manufacturer', 'Tactician', 1],
  ['Adapter', 'Tactician', 9],
  ['Networker', 'Polar Explorer', 3],
  ['Farmer', 'Polar Explorer', 1],
  ['Land Specialist', 'Polar Explorer', 4],
  ['Terra Pioneer', 'Polar Explorer', 6],
  ['Gambler', 'Polar Explorer', 0.5],
  ['Irrigator', 'Polar Explorer', 3],
  ['Entrepreneur', 'Polar Explorer', 4],
  ['Tourist', 'Polar Explorer', 2],
  ['Edgedancer', 'Polar Explorer', 5],
  ['Colonizer', 'Energizer', 3],
  ['Pioneer', 'Energizer', 3],
  ['Firestarter', 'Energizer', 2],
  ['Gambler', 'Energizer', 0.5],
  ['Electrician', 'Energizer', 8],
  ['Engineer', 'Energizer', 4],
  ['Spacefarer', 'Rim Settler', 3],
  ['Gambler', 'Rim Settler', 0.5],
  ['Smith', 'Rim Settler', 3],
  ['Capitalist', 'Rim Settler', 1],
  ['Voyager', 'Rim Settler', 9],
  ['Gambler', 'Hoverlord', 0.5],
  ['Tradesman', 'Hoverlord', 6],
  ['Manufacturer', 'Hoverlord', 1],
  ['Networker', 'Landlord', 4],
  ['Lunarchitect', 'Landlord', 7],
  ['Farmer', 'Landlord', 1],
  ['Tropicalist', 'Landlord', 6],
  ['Land Specialist', 'Landlord', 4],
  ['Terra Pioneer', 'Landlord', 9],
  ['Irrigator', 'Landlord', 4],
  ['Entrepreneur', 'Landlord', 4],
  ['Lunar Magnate', 'Landlord', 7],
  ['Tourist', 'Landlord', 2],
  ['Cosmic Settler', 'Landlord', 3],
  ['Botanist', 'Landlord', 1],
  ['Urbanist', 'Landlord', 4],
  ['Edgedancer', 'Landlord', 4],
  ['Naturalist', 'Landlord', 4],
  ['Curator', 'Scientist', 4],
  ['Manufacturer', 'Scientist', 2],
  ['Adapter', 'Scientist', 5],
  ['Hoarder', 'Scientist', 4],
  ['Colonizer', 'Banker', 1],
  ['Pioneer', 'Banker', 1],
  ['Capitalist', 'Banker', 2],
  ['T. Economizer', 'Banker', 1],
  ['Economizer', 'Thermalist', 8],
  ['Firestarter', 'Thermalist', 7],
  ['Naturalist', 'Thermalist', 6],
  ['One Giant Step', 'Miner', 1],
  ['Lunarchitect', 'Miner', 3],
  ['Spacefarer', 'Miner', 1],
  ['Smith', 'Miner', 8],
  ['Full Moon', 'Miner', 1],
  ['Lunar Magnate', 'Miner', 3],
  ['Engineer', 'Miner', 2],
  ['Cosmic Settler', 'Miner', 1],
  ['Urbanist', 'Miner', 1],
  ['Capitalist', 'Celebrity', 2],
  ['Manufacturer', 'Celebrity', 1],
  ['One Giant Step', 'Industrialist', 1],
  ['Lunarchitect', 'Industrialist', 3],
  ['Spacefarer', 'Industrialist', 1],
  ['Electrician', 'Industrialist', 3],
  ['Smith', 'Industrialist', 5],
  ['Full Moon', 'Industrialist', 1],
  ['Lunar Magnate', 'Industrialist', 3],
  ['Engineer', 'Industrialist', 2],
  ['Urbanist', 'Industrialist', 1],
  ['Networker', 'Desert Settler', 3],
  ['Farmer', 'Desert Settler', 1],
  ['Tropicalist', 'Desert Settler', 2],
  ['Land Specialist', 'Desert Settler', 4],
  ['Terra Pioneer', 'Desert Settler', 6],
  ['Irrigator', 'Desert Settler', 5],
  ['Entrepreneur', 'Desert Settler', 4],
  ['Tourist', 'Desert Settler', 2],
  ['Urbanist', 'Desert Settler', 1],
  ['Edgedancer', 'Desert Settler', 5],
  ['Naturalist', 'Desert Settler', 1],
  ['Networker', 'Estate Dealer', 3],
  ['Farmer', 'Estate Dealer', 1],
  ['Tropicalist', 'Estate Dealer', 5],
  ['Land Specialist', 'Estate Dealer', 4],
  ['Terra Pioneer', 'Estate Dealer', 6],
  ['Irrigator', 'Estate Dealer', 9],
  ['Entrepreneur', 'Estate Dealer', 4],
  ['Tourist', 'Estate Dealer', 1],
  ['Urbanist', 'Estate Dealer', 1],
  ['Edgedancer', 'Estate Dealer', 2],
  ['Naturalist', 'Estate Dealer', 1],
  ['Lunarchitect', 'Benefactor', 1],
  ['Farmer', 'Benefactor', 3],
  ['Economizer', 'Benefactor', 3],
  ['Firestarter', 'Benefactor', 1],
  ['Lunar Magnate', 'Benefactor', 1],
  ['Botanist', 'Benefactor', 3],
  ['Naturalist', 'Benefactor', 5],
  ['Networker', 'Cultivator', 2],
  ['Farmer', 'Cultivator', 5],
  ['Tropicalist', 'Cultivator', 4],
  ['Terra Pioneer', 'Cultivator', 4],
  ['Irrigator', 'Cultivator', 4],
  ['Tourist', 'Cultivator', 1],
  ['Botanist', 'Cultivator', 5],
  ['Biologist', 'Cultivator', 1],
  ['Edgedancer', 'Cultivator', 4],
  ['Naturalist', 'Cultivator', 3],
  ['Networker', 'Magnate', 1],
  ['One Giant Step', 'Magnate', 2],
  ['Minimalist', 'Magnate', 1],
  ['Terran', 'Magnate', 1],
  ['Land Specialist', 'Magnate', 1],
  ['Martian', 'Magnate', 1],
  ['Businessperson', 'Magnate', 1],
  ['Collector', 'Magnate', 3],
  ['Spacefarer', 'Magnate', 2],
  ['Electrician', 'Magnate', 1],
  ['Entrepreneur', 'Magnate', 1],
  ['Full Moon', 'Magnate', 1],
  ['Curator', 'Magnate', 2],
  ['Engineer', 'Magnate', 1],
  ['Botanist', 'Magnate', 1],
  ['Biologist', 'Magnate', 1],
  ['T. Economizer', 'Magnate', 2],
  ['Adapter', 'Magnate', 1],
  ['Naturalist', 'Magnate', 1],
  ['Voyager', 'Magnate', 1],
  ['Colonizer', 'Space Baron', 1],
  ['Pioneer', 'Space Baron', 4],
  ['Spacefarer', 'Space Baron', 9],
  ['Tradesman', 'Space Baron', 1],
  ['Curator', 'Space Baron', 2],
  ['Cosmic Settler', 'Space Baron', 5],
  ['Voyager', 'Space Baron', 3],
  ['Tradesman', 'Excentric', 8],
  ['A. Zoologist', 'Excentric', 8],
  ['Zoologist', 'Excentric', 7],
  ['Biologist', 'Excentric', 4],
  ['One Giant Step', 'Contractor', 1],
  ['Lunarchitect', 'Contractor', 1],
  ['Smith', 'Contractor', 4],
  ['Full Moon', 'Contractor', 1],
  ['Lunar Magnate', 'Contractor', 1],
  ['Curator', 'Contractor', 7],
  ['Engineer', 'Contractor', 2],
  ['Manufacturer', 'Contractor', 1],
  ['Urbanist', 'Contractor', 3],
  ['Tradesman', 'Venuphile', 4],
  ['Curator', 'Venuphile', 2],
  ['Manufacturer', 'Venuphile', 2],
  ['Adapter', 'Venuphile', 1],
  ['Tropicalist', 'Networker', 3],
  ['Land Specialist', 'Networker', 3],
  ['Terra Pioneer', 'Networker', 5],
  ['Gambler', 'Networker', 0.5],
  ['Irrigator', 'Networker', 3],
  ['Entrepreneur', 'Networker', 9],
  ['Tourist', 'Networker', 1],
  ['Manufacturer', 'Networker', 1],
  ['Edgedancer', 'Networker', 2],
  ['Lunarchitect', 'One Giant Step', 9],
  ['Spacefarer', 'One Giant Step', 1],
  ['Gambler', 'One Giant Step', 0.5],
  ['Smith', 'One Giant Step', 2],
  ['Full Moon', 'One Giant Step', 9],
  ['Lunar Magnate', 'One Giant Step', 7],
  ['Curator', 'One Giant Step', 2],
  ['Engineer', 'One Giant Step', 1],
  ['Manufacturer', 'One Giant Step', 1],
  ['Spacefarer', 'Lunarchitect', 1],
  ['Gambler', 'Lunarchitect', 0.5],
  ['Smith', 'Lunarchitect', 3],
  ['Full Moon', 'Lunarchitect', 7],
  ['Lunar Magnate', 'Lunarchitect', 9],
  ['Engineer', 'Lunarchitect', 1],
  ['Tourist', 'Lunarchitect', 2],
  ['Manufacturer', 'Lunarchitect', 1],
  ['Minimalist', 'Colonizer', 2],
  ['Pioneer', 'Colonizer', 9],
  ['Spacefarer', 'Colonizer', 4],
  ['Gambler', 'Colonizer', 0.5],
  ['Engineer', 'Colonizer', 1],
  ['Tropicalist', 'Farmer', 1],
  ['Gambler', 'Farmer', 0.5],
  ['Irrigator', 'Farmer', 1],
  ['Engineer', 'Farmer', 4],
  ['Tourist', 'Farmer', 1],
  ['Botanist', 'Farmer', 9],
  ['Biologist', 'Farmer', 3],
  ['Adapter', 'Farmer', 1],
  ['Naturalist', 'Farmer', 6],
  ['Pioneer', 'Minimalist', 2],
  ['Gambler', 'Minimalist', 0.5],
  ['Businessperson', 'Terran', 9],
  ['Gambler', 'Terran', 0.5],
  ['Curator', 'Terran', 1],
  ['Engineer', 'Terran', 1],
  ['Manufacturer', 'Terran', 1],
  ['Land Specialist', 'Tropicalist', 4],
  ['Terra Pioneer', 'Tropicalist', 8],
  ['Gambler', 'Tropicalist', 0.5],
  ['Irrigator', 'Tropicalist', 5],
  ['Entrepreneur', 'Tropicalist', 4],
  ['Tourist', 'Tropicalist', 2],
  ['Urbanist', 'Tropicalist', 1],
  ['Edgedancer', 'Tropicalist', 1],
  ['Firestarter', 'Economizer', 8],
  ['Gambler', 'Economizer', 0.5],
  ['Engineer', 'Economizer', 4],
  ['Naturalist', 'Economizer', 8],
  ['Spacefarer', 'Pioneer', 4],
  ['Gambler', 'Pioneer', 0.5],
  ['Electrician', 'Pioneer', 2],
  ['Terra Pioneer', 'Land Specialist', 7],
  ['Gambler', 'Land Specialist', 0.5],
  ['Irrigator', 'Land Specialist', 4],
  ['Entrepreneur', 'Land Specialist', 9],
  ['Tourist', 'Land Specialist', 2],
  ['Manufacturer', 'Land Specialist', 1],
  ['Edgedancer', 'Land Specialist', 4],
  ['Gambler', 'Martian', 0.5],
  ['Curator', 'Martian', 1],
  ['Manufacturer', 'Martian', 1],
  ['Gambler', 'Businessperson', 0.5],
  ['Curator', 'Businessperson', 1],
  ['Engineer', 'Businessperson', 1],
  ['Manufacturer', 'Businessperson', 1],
  ['Spacefarer', 'Collector', 1],
  ['Gambler', 'Collector', 0.5],
  ['Electrician', 'Collector', 1],
  ['Curator', 'Collector', 1],
  ['Historian', 'Collector', 1],
  ['Coordinator', 'Collector', 1],
  ['Manufacturer', 'Collector', 4],
  ['Biologist', 'Collector', 1],
  ['Adapter', 'Collector', 1],
  ['Gambler', 'Firestarter', 0.5],
  ['Electrician', 'Firestarter', 2],
  ['Engineer', 'Firestarter', 1],
  ['Naturalist', 'Firestarter', 5],
  ['Gambler', 'Terra Pioneer', 0.5],
  ['Irrigator', 'Terra Pioneer', 6],
  ['Entrepreneur', 'Terra Pioneer', 8],
  ['Tourist', 'Terra Pioneer', 2],
  ['Edgedancer', 'Terra Pioneer', 8],
  ['Gambler', 'Spacefarer', 0.5],
  ['Smith', 'Spacefarer', 1],
  ['Full Moon', 'Spacefarer', 1],
  ['Lunar Magnate', 'Spacefarer', 1],
  ['Curator', 'Spacefarer', 4],
  ['Cosmic Settler', 'Spacefarer', 5],
  ['Manufacturer', 'Spacefarer', 2],
  ['Voyager', 'Spacefarer', 3],
  ['Electrician', 'Gambler', 0.5],
  ['Smith', 'Gambler', 0.5],
  ['Tradesman', 'Gambler', 0.5],
  ['Irrigator', 'Gambler', 0.5],
  ['Capitalist', 'Gambler', 0.5],
  ['Curator', 'Electrician', 1],
  ['Engineer', 'Electrician', 3],
  ['Manufacturer', 'Electrician', 1],
  ['Full Moon', 'Smith', 2],
  ['Lunar Magnate', 'Smith', 3],
  ['Engineer', 'Smith', 5],
  ['Cosmic Settler', 'Smith', 1],
  ['Urbanist', 'Smith', 2],
  ['Voyager', 'Smith', 3],
  ['A. Zoologist', 'Tradesman', 7],
  ['Zoologist', 'Tradesman', 6],
  ['Biologist', 'Tradesman', 6],
  ['Adapter', 'Tradesman', 2],
  ['Entrepreneur', 'Irrigator', 4],
  ['Tourist', 'Irrigator', 1],
  ['Urbanist', 'Irrigator', 1],
  ['Edgedancer', 'Irrigator', 1],
  ['T. Economizer', 'Capitalist', 2],
  ['Voyager', 'Capitalist', 1],
  ['Manufacturer', 'Entrepreneur', 1],
  ['Lunar Magnate', 'Full Moon', 9],
  ['Curator', 'Full Moon', 2],
  ['Engineer', 'Full Moon', 1],
  ['Tourist', 'Lunar Magnate', 2],
  ['Biologist', 'Curator', 2],
  ['Voyager', 'Curator', 1],
  ['Botanist', 'Engineer', 4],
  ['Naturalist', 'Engineer', 4],
  ['Coordinator', 'Historian', 9],
  ['Warmonger', 'Historian', 2],
  ['Botanist', 'Tourist', 1],
  ['Edgedancer', 'Tourist', 2],
  ['Botanist', 'A. Zoologist', 2],
  ['Manufacturer', 'A. Zoologist', 1],
  ['Zoologist', 'A. Zoologist', 8],
  ['Biologist', 'A. Zoologist', 6],
  ['Naturalist', 'A. Zoologist', 2],
  ['Zoologist', 'Botanist', 2],
  ['Biologist', 'Botanist', 5],
  ['Naturalist', 'Botanist', 7],
  ['Warmonger', 'Coordinator', 2],
  ['Zoologist', 'Manufacturer', 1],
  ['Biologist', 'Zoologist', 6],
  ['Naturalist', 'Zoologist', 2],

  ['Risktaker', 'Kingpin', 9],
  ['Tunneler', 'EdgeLord', 8],
  ['EdgeLord', 'Edgedancer', 9],
];

// This map uses keys of the format "X|Y" where X and Y are MA names. Entries are stored as "X|Y"
// and also "Y|X"; it just makes searching slightly faster. There will also be entries of the type "X|X".
//
// I honestly don't remember why "X|X" is useful, and it's possible it's no longer necessary. That's
// something that should be carefully conisdered and possibly removed', and not just propagated because
// it's what we had to begin with. In other words, someone figure out why, and preserve it, and document
// why, or be certain it's unnecessary and remove this paragraph and the code below that sets "X|X" to 1000.
//
class SynergyMap {
  private readonly map: Map<string, number> = new Map();
  public set(a: string, b: string, weight: number): void {
    this.map.set(a + '|' + b, weight);
    this.map.set(b + '|' + a, weight);
  }

  public get(a: string, b: string) {
    return this.map.get(a + '|' + b) || 0;
  }
}

export const synergies: SynergyMap = new SynergyMap();

Milestones.ALL.forEach((ma) => {
  // synergies.set(ma.name, 'Gambler', 1);
  synergies.set(ma.name, ma.name, 1000);
});
Awards.ALL.forEach((ma) => {
  // synergies.set(ma.name, 'Gambler', 1);
  synergies.set(ma.name, ma.name, 1000);
});

for (const [a, b, weight] of synergiesData) {
  synergies.set(a, b, weight);
}

================
File: milestones/amazonisPlanitia/Colonizer.ts
================
import {BaseMilestone} from '../IMilestone';
import {IPlayer} from '../../IPlayer';

export class Colonizer extends BaseMilestone {
  constructor() {
    super(
      'Colonizer',
      'Have 4 colonies',
      4);
  }

  public getScore(player: IPlayer): number {
    return player.getColoniesCount();
  }
}

================
File: milestones/amazonisPlanitia/Farmer.ts
================
import {BaseMilestone} from '../IMilestone';
import {IPlayer} from '../../IPlayer';

export class Farmer extends BaseMilestone {
  constructor() {
    super(
      'Farmer',
      'Have 4 plant production',
      4);
  }

  public getScore(player: IPlayer): number {
    return player.production.plants;
  }
}

================
File: milestones/amazonisPlanitia/Minimalist.ts
================
import {IMilestone} from '../IMilestone';
import {IPlayer} from '../../IPlayer';

export class Minimalist implements IMilestone {
  public readonly name = 'Minimalist';
  public readonly description = 'Have no more than 2 cards in hand';

  public getScore(player: IPlayer): number {
    return player.cardsInHand.length;
  }

  public canClaim(player: IPlayer): boolean {
    return this.getScore(player) <= 2;
  }
}

================
File: milestones/amazonisPlanitia/Terran.ts
================
import {Tag} from '../../../common/cards/Tag';
import {BaseMilestone} from '../IMilestone';
import {IPlayer} from '../../IPlayer';

export class Terran extends BaseMilestone {
  constructor() {
    super(
      'Terran',
      'Have 6 Earth tags in play',
      6);
  }

  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.EARTH, 'milestone');
  }
}

================
File: milestones/amazonisPlanitia/Tropicalist.ts
================
import {IPlayer} from '../../IPlayer';
import {isHazardTileType} from '../../../common/AresTileType';
import {BaseMilestone} from '../IMilestone';

export class Tropicalist extends BaseMilestone {
  constructor() {
    super(
      'Tropicalist',
      'Own 3 tiles in the middle 3 equatorial rows',
      3);
  }

  public getScore(player: IPlayer): number {
    return player.game.board.spaces
      .filter((space) => space.player !== undefined &&
          space.player === player &&
          space.tile !== undefined &&
          isHazardTileType(space.tile.tileType) === false &&
          space.y >= 3 && space.y <= 5).length;
  }
}

================
File: milestones/Builder.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';

export class Builder extends BaseMilestone {
  constructor() {
    super(
      'Builder',
      'Have 8 building tags in play',
      8);
  }
  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.BUILDING, 'milestone');
  }
}

================
File: milestones/Businessperson.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';

export class Businessperson extends BaseMilestone {
  constructor() {
    super(
      'Businessperson',
      'Have 6 Earth tags in play',
      6);
  }
  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.EARTH, 'milestone');
  }
}

================
File: milestones/Capitalist.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Capitalist extends BaseMilestone {
  constructor() {
    super(
      'Capitalist',
      'Have 64 M€',
      64);
  }

  public getScore(player: IPlayer): number {
    return player.megaCredits;
  }
}

================
File: milestones/ClaimedMilestone.ts
================
import {IPlayer} from '../IPlayer';
import {PlayerId} from '../../common/Types';
import {IMilestone} from './IMilestone';
import {MilestoneName} from '../../common/ma/MilestoneName';

export type ClaimedMilestone = {
  milestone: IMilestone;
  player: IPlayer;
}

export type SerializedClaimedMilestone = {
  name?: MilestoneName;
  playerId?: PlayerId;
}

export function serializeClaimedMilestones(claimedMilestones: Array<ClaimedMilestone>) : Array<SerializedClaimedMilestone> {
  return claimedMilestones.map((claimedMilestone) => {
    return {
      name: claimedMilestone.milestone.name,
      playerId: claimedMilestone.player.id,
    };
  });
}

export function deserializeClaimedMilestones(
  claimedMilestones: Array<SerializedClaimedMilestone>,
  players: Array<IPlayer>,
  milestones: Array<IMilestone>): Array<ClaimedMilestone> {
  // Remove duplicates
  const ms = new Set<MilestoneName>();
  const filtered = [];
  for (const claimedMilestone of claimedMilestones) {
    const name = claimedMilestone.name;
    if (name === undefined) {
      throw new Error('Milestone name not found');
    }
    const playerId = claimedMilestone.playerId;
    if (playerId === undefined) {
      throw new Error(`Player ID not found when rebuilding claimed milestone ${name}`);
    }

    if (ms.has(name)) {
      console.error('Found duplicate milestone: ' + name);
      continue;
    } else {
      filtered.push({name, playerId});
      ms.add(name);
    }
  }

  return filtered.map((element) => {
    const milestoneName = element.name;
    const milestone: IMilestone | undefined = milestones.find((milestone) => milestone.name === milestoneName);
    if (milestone === undefined) {
      throw new Error(`Milestone ${milestoneName} not found when rebuilding Claimed Milestone`);
    }

    const playerId = element.playerId;
    const player = players.find((player) => player.id === playerId);
    if (player === undefined) {
      throw new Error(`Player ${playerId} not found when rebuilding claimed milestone ${milestoneName}`);
    }

    return {milestone, player};
  });
}

================
File: milestones/Diversifier.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Diversifier extends BaseMilestone {
  constructor() {
    super(
      'Diversifier',
      'Have 8 different tags in play',
      8);
  }
  public getScore(player: IPlayer): number {
    return player.tags.distinctCount('milestone');
  }
}

================
File: milestones/Ecologist.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';

export class Ecologist extends BaseMilestone {
  constructor() {
    super(
      'Ecologist',
      'Have 4 bio tags in play (plant, microbe and animal tags count as bio tags)',
      4);
  }
  public getScore(player: IPlayer): number {
    const tags: Array<Tag> = [Tag.PLANT, Tag.ANIMAL, Tag.MICROBE];
    return player.tags.multipleCount(tags, 'milestone');
  }
}

================
File: milestones/Economizer.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Economizer extends BaseMilestone {
  constructor() {
    super(
      'Economizer',
      'Have 5 heat production',
      5);
  }
  public getScore(player: IPlayer): number {
    return player.production.heat;
  }
}

================
File: milestones/Electrician.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';

export class Electrician extends BaseMilestone {
  constructor() {
    super(
      'Electrician',
      'Have 4 power tags in play',
      4);
  }

  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.POWER, 'milestone');
  }
}

================
File: milestones/Energizer.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Energizer extends BaseMilestone {
  constructor() {
    super(
      'Energizer',
      'Have 6 energy production',
      6);
  }
  public getScore(player: IPlayer): number {
    return player.production.energy;
  }
}

================
File: milestones/Gardener.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Gardener extends BaseMilestone {
  constructor() {
    super(
      'Gardener',
      'Own 3 greenery tiles',
      3);
  }
  public getScore(player: IPlayer): number {
    return player.game.board.getGreeneries(player).length;
  }
}

================
File: milestones/Generalist.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Generalist extends BaseMilestone {
  constructor() {
    super(
      'Generalist',
      'Have increased all 6 productions by 1 step',
      6);
  }

  public getScore(player: IPlayer): number {
    let score = 0;
    const requiredProduction = player.game.gameOptions.corporateEra ? 0 : 1;

    if (player.production.megacredits > requiredProduction) score++;
    if (player.production.steel > requiredProduction) score++;
    if (player.production.titanium > requiredProduction) score++;
    if (player.production.plants > requiredProduction) score++;
    if (player.production.energy > requiredProduction) score++;
    if (player.production.heat > requiredProduction) score++;

    return score;
  }
}

================
File: milestones/Hoverlord.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {CardResource} from '../../common/CardResource';

export class Hoverlord extends BaseMilestone {
  constructor() {
    super(
      'Hoverlord',
      'Have 7 floater resources on your cards',
      7);
  }
  public getScore(player: IPlayer): number {
    let floaterResources = 0;
    player.getCardsWithResources(CardResource.FLOATER).forEach((card) => {
      floaterResources += card.resourceCount;
    });
    return floaterResources;
  }
}

================
File: milestones/IMilestone.ts
================
import {MilestoneName} from '../../common/ma/MilestoneName';
import {IPlayer} from '../IPlayer';

export interface IMilestone {
  name: MilestoneName;
  description: string;
  canClaim(player: IPlayer): boolean;
  getScore(player: IPlayer): number;
}

export abstract class BaseMilestone implements IMilestone {
  public readonly name: MilestoneName;
  public readonly description: string;
  public readonly threshold: number;

  constructor(name: MilestoneName, description: string, threshold: number) {
    this.name = name;
    this.description = description;
    this.threshold = threshold;
  }

  public abstract getScore(player: IPlayer): number;
  public canClaim(player: IPlayer): boolean {
    return this.getScore(player) >= this.threshold;
  }
}

================
File: milestones/Irrigator.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {Board} from '../boards/Board';
import {isHazardTileType} from '../../common/AresTileType';

export class Irrigator extends BaseMilestone {
  constructor() {
    super(
      'Irrigator',
      'Own 4 tiles adjacent to oceans',
      4);
  }

  public getScore(player: IPlayer): number {
    return player.game.board.spaces.filter((space) =>
      space.player === player &&
        space.tile !== undefined &&
        isHazardTileType(space.tile.tileType) === false &&
        player.game.board.getAdjacentSpaces(space).some((space) => Board.isOceanSpace(space)),
    ).length;
  }
}

================
File: milestones/LandSpecialist.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {isSpecialTileSpace, playerTileFn} from '../boards/Board';
import {MoonExpansion} from '../moon/MoonExpansion';

export class LandSpecialist extends BaseMilestone {
  constructor() {
    super(
      'Land Specialist',
      'Own 3 special (normally, brown) tiles',
      3);
  }
  public getScore(player: IPlayer): number {
    const spaces = player.game.board.spaces
      .filter(playerTileFn(player))
      .filter(isSpecialTileSpace);

    const marsCount = spaces.length;
    // Repeated in SpaceRaceToMars
    const moonCount = MoonExpansion.ifElseMoon(player.game, (moonData) => {
      return moonData.moon.spaces
        .filter(playerTileFn(player))
        .filter(isSpecialTileSpace)
        .length;
    },
    () => 0);
    return marsCount + moonCount;
  }
}

================
File: milestones/Legend.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Legend extends BaseMilestone {
  constructor() {
    super(
      'Legend',
      'Have 5 cards in your event pile',
      5);
  }
  public getScore(player: IPlayer): number {
    // TODO(kberg): include events removed by Odyssey and Playwrights?
    return player.getPlayedEventsCount();
  }
}

================
File: milestones/Martian.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';

export class Martian extends BaseMilestone {
  constructor() {
    super(
      'Martian',
      'Have 4 Mars tags in play',
      4);
  }
  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.MARS, 'milestone');
  }
}

================
File: milestones/Mayor.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Mayor extends BaseMilestone {
  constructor() {
    super(
      'Mayor',
      'Own 3 city tiles',
      3);
  }
  public getScore(player: IPlayer): number {
    return player.game.board.getCities(player).length;
  }
}

================
File: milestones/Milestones.ts
================
import {Terraformer} from './Terraformer';
import {Mayor} from './Mayor';
import {Gardener} from './Gardener';
import {Builder} from './Builder';
import {Planner} from './Planner';
import {Hoverlord} from './Hoverlord';
import {IMilestone} from './IMilestone';
import {Generalist} from './Generalist';
import {Specialist} from './Specialist';
import {Ecologist} from './Ecologist';
import {Tycoon} from './Tycoon';
import {Legend} from './Legend';
import {Diversifier} from './Diversifier';
import {Tactician} from './Tactician';
import {PolarExplorer} from './PolarExplorer';
import {Energizer} from './Energizer';
import {RimSettler} from './RimSettler';
import {Networker} from './Networker';
import {OneGiantStep} from '../moon/OneGiantStep';
import {Lunarchitect} from '../moon/Lunarchitect';
import {Economizer} from './Economizer';
import {Pioneer} from './Pioneer';
import {LandSpecialist} from './LandSpecialist';
import {Martian} from './Martian';
import {Businessperson} from './Businessperson';
import {Capitalist} from './Capitalist';
import {Electrician} from './Electrician';
import {Irrigator} from './Irrigator';
import {Smith} from './Smith';
import {Tradesman} from './Tradesman';
import {Colonizer} from './amazonisPlanitia/Colonizer';
import {Farmer} from './amazonisPlanitia/Farmer';
import {Minimalist} from './amazonisPlanitia/Minimalist';
import {Terran} from './amazonisPlanitia/Terran';
import {Tropicalist} from './amazonisPlanitia/Tropicalist';
import {Collector} from './terraCimmeria/Collector';
import {Firestarter} from './terraCimmeria/Firestarter';
import {Gambler} from './terraCimmeria/Gambler';
import {Spacefarer} from './terraCimmeria/Spacefarer';
import {TerraPioneer} from './terraCimmeria/TerraPioneer';
import {Risktaker} from './underworld/Risktaker';
import {Tunneler} from './underworld/Tunneler';

export const THARSIS_MILESTONES = [
  new Terraformer(),
  new Mayor(),
  new Gardener(),
  new Builder(),
  new Planner(),
];

export const VENUS_MILESTONES = [
  new Hoverlord(),
];

export const ELYSIUM_MILESTONES = [
  new Generalist(),
  new Specialist(),
  new Ecologist(),
  new Tycoon(),
  new Legend(),
];

export const UTOPIA_PLANITIA_MILESTONES = [
  // new Specialist(),
  // new Pioneer(),
  // new Trader(),
  // new Metallurgist(),
  // new Researcher(),
];

export const HELLAS_MILESTONES = [
  new Diversifier(),
  new Tactician(),
  new PolarExplorer(),
  new Energizer(),
  new RimSettler(),
];

export const ARES_MILESTONES = [
  new Networker(),
];

export const MOON_MILESTONES = [
  new OneGiantStep(),
  new Lunarchitect(),
];

export const AMAZONIS_PLANITIA_MILESTONES = [
  new Colonizer(),
  new Farmer(),
  new Minimalist(),
  new Terran(),
  new Tropicalist(),
];

export const ARABIA_TERRA_MILESTONES = [
  new Economizer(),
  new Pioneer(),
  new LandSpecialist(),
  new Martian(),
  new Businessperson(),
];

export const TERRA_CIMMERIA_MILESTONES = [
  new Collector(),
  new Firestarter(),
  new TerraPioneer(),
  new Spacefarer(),
  new Gambler(),
];

export const VASTITAS_BOREALIS_MILESTONES = [
  new Electrician(),
  new Smith(),
  new Tradesman(),
  new Irrigator(),
  new Capitalist(),
];

export const UNDERWORLD_MILESTONES = [
  new Risktaker(),
  new Tunneler(),
];

export const ALL_MILESTONES = [
  ...THARSIS_MILESTONES,
  ...ELYSIUM_MILESTONES,
  ...HELLAS_MILESTONES,
  ...UTOPIA_PLANITIA_MILESTONES,
  ...VENUS_MILESTONES,
  ...ARES_MILESTONES,
  ...MOON_MILESTONES,
  ...AMAZONIS_PLANITIA_MILESTONES,
  ...ARABIA_TERRA_MILESTONES,
  ...TERRA_CIMMERIA_MILESTONES,
  ...VASTITAS_BOREALIS_MILESTONES,
  ...UNDERWORLD_MILESTONES,
];

// Remove namespace and rename function
export namespace Milestones {
  export const ALL = ALL_MILESTONES;

  export function getByName(name: string): IMilestone {
    const milestone = ALL_MILESTONES.find((m) => m.name === name);
    if (milestone) {
      return milestone;
    }
    throw new Error(`Milestone ${name} not found.`);
  }
}

================
File: milestones/Networker.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Networker extends BaseMilestone {
  constructor() {
    super(
      'Networker',
      'Have placed 3 tiles adjacent to tiles that grant adjacency bonuses',
      3);
  }
  public getScore(player: IPlayer): number {
    return player.game.aresData?.milestoneResults.find((e) => e.id === player.id)?.count || 0;
  }
}

================
File: milestones/Pioneer.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Pioneer extends BaseMilestone {
  constructor() {
    super(
      'Pioneer',
      'Have 3 colonies',
      3);
  }
  public getScore(player: IPlayer): number {
    return player.getColoniesCount();
  }
}

================
File: milestones/Planner.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Planner extends BaseMilestone {
  constructor() {
    super(
      'Planner',
      'Have 16 cards in your hand',
      16);
  }
  public getScore(player: IPlayer): number {
    return player.cardsInHand.length;
  }
}

================
File: milestones/PolarExplorer.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {isHazardTileType} from '../../common/AresTileType';
import {Board} from '../boards/Board';

export class PolarExplorer extends BaseMilestone {
  constructor() {
    super(
      'Polar Explorer',
      'Own 3 tiles on the two bottom rows',
      3);
  }
  public getScore(player: IPlayer): number {
    return player.game.board.spaces
      .filter(Board.ownedBy(player))
      .filter((space) => space.tile !== undefined &&
        isHazardTileType(space.tile.tileType) === false &&
        space.y >= 7 && space.y <= 8).length;
  }
}

================
File: milestones/RimSettler.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {Tag} from '../../common/cards/Tag';

export class RimSettler extends BaseMilestone {
  constructor() {
    super(
      'Rim Settler',
      'Have 3 Jovian tags in play',
      3);
  }
  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.JOVIAN, 'milestone');
  }
}

================
File: milestones/Smith.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Smith extends BaseMilestone {
  constructor() {
    super(
      'Smith',
      'Have a total of 7 steel and titanium production',
      7);
  }

  public getScore(player: IPlayer): number {
    return player.production.steel + player.production.titanium;
  }
}

================
File: milestones/Specialist.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Specialist extends BaseMilestone {
  constructor() {
    super(
      'Specialist',
      'Have 10 in production of any resource',
      10);
  }
  public getScore(player: IPlayer): number {
    return Math.max(player.production.megacredits,
      player.production.steel,
      player.production.titanium,
      player.production.plants,
      player.production.energy,
      player.production.heat);
  }
}

================
File: milestones/Tactician.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {CardType} from '../../common/cards/CardType';

export class Tactician extends BaseMilestone {
  constructor() {
    super(
      'Tactician',
      'Have 5 cards with requirements in play',
      5);
  }
  private excludedCardTypes = [CardType.PRELUDE, CardType.EVENT];

  public getScore(player: IPlayer): number {
    const validCards = player.playedCards.filter((card) => {
      const isValidCardType = !this.excludedCardTypes.includes(card.type);
      const hasRequirements = card.requirements.length > 0;

      return isValidCardType && hasRequirements;
    });

    return validCards.length;
  }
}

================
File: milestones/terraCimmeria/Collector.ts
================
import {CardType} from '../../../common/cards/CardType';
import {BaseMilestone} from '../IMilestone';
import {IPlayer} from '../../IPlayer';

export class Collector extends BaseMilestone {
  constructor() {
    super(
      'Collector',
      'Have 3 sets of automated (green), active (blue) and event (red) project cards in play',
      3);
  }

  public getScore(player: IPlayer): number {
    const numAutomatedCards = player.playedCards.filter((card) => card.type === CardType.AUTOMATED).length;
    const numActiveCards = player.playedCards.filter((card) => card.type === CardType.ACTIVE).length;
    const numEventCards = player.getPlayedEventsCount();

    return Math.min(numAutomatedCards, numActiveCards, numEventCards);
  }
}

================
File: milestones/terraCimmeria/Firestarter.ts
================
import {BaseMilestone} from '../IMilestone';
import {IPlayer} from '../../IPlayer';

export class Firestarter extends BaseMilestone {
  constructor() {
    super(
      'Firestarter',
      'Have 20 heat',
      20);
  }

  public getScore(player: IPlayer): number {
    return player.heat;
  }
}

================
File: milestones/terraCimmeria/Gambler.ts
================
import {BaseMilestone} from '../IMilestone';
import {IPlayer} from '../../IPlayer';

export class Gambler extends BaseMilestone {
  constructor() {
    super(
      'Gambler',
      'Fund 2 awards',
      2);
  }

  public getScore(player: IPlayer): number {
    return player.game.fundedAwards.filter((award) => award.player === player).length;
  }
}

================
File: milestones/terraCimmeria/Spacefarer.ts
================
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {BaseMilestone} from '../IMilestone'; export class Spacefarer extends BaseMilestone {
  constructor() {
    super(
      'Spacefarer',
      'Have 6 space tags in play',
      6);
  }

  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.SPACE);
  }
}

================
File: milestones/terraCimmeria/TerraPioneer.ts
================
import {IPlayer} from '../../IPlayer';
import {TileType} from '../../../common/TileType';
import {isHazardTileType} from '../../../common/AresTileType';
import {SpaceType} from '../../../common/boards/SpaceType';
import {BaseMilestone} from '../IMilestone';

export class TerraPioneer extends BaseMilestone {
  constructor() {
    super(
      'Terra Pioneer',
      'Own 5 tiles on Mars',
      5);
  }

  public getScore(player: IPlayer): number {
    // Don't simplify this to "space.tile?.tileType !== TileType.OCEAN"
    // Because that will make Land Claim a valid space for Landlord
    const marsSpaces = player.game.board.spaces.filter(
      (space) => {
        return space.tile !== undefined &&
          isHazardTileType(space.tile.tileType) === false &&
          space.tile.tileType !== TileType.OCEAN &&
          space.spaceType !== SpaceType.COLONY &&
          space.player === player;
      },
    ).length;

    return marsSpaces;
  }
}

================
File: milestones/Terraformer.ts
================
import {IMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {Turmoil} from '../turmoil/Turmoil';

export class Terraformer implements IMilestone {
  public readonly name = 'Terraformer';
  private terraformRating: number = 35;
  private terraformRatingTurmoil: number = 26;
  public readonly description;
  constructor() {
    this.description = 'Have a terraform rating of 35 (or 26 with Turmoil.)';
  }
  public getScore(player: IPlayer): number {
    return player.getTerraformRating();
  }
  public canClaim(player: IPlayer): boolean {
    const target = Turmoil.ifTurmoilElse(player.game, () => this.terraformRatingTurmoil, () => this.terraformRating);
    const score = this.getScore(player);
    return score >= target;
  }
}

================
File: milestones/Tradesman.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';

export class Tradesman extends BaseMilestone {
  constructor() {
    super(
      'Tradesman',
      'Have 3 different types of non-standard resources',
      3);
  }

  public getScore(player: IPlayer): number {
    const nonStandardResources = new Set(player.getCardsWithResources().map((card) => card.resourceType));
    return nonStandardResources.size;
  }
}

================
File: milestones/Tycoon.ts
================
import {BaseMilestone} from './IMilestone';
import {IPlayer} from '../IPlayer';
import {CardType} from '../../common/cards/CardType';

export class Tycoon extends BaseMilestone {
  constructor() {
    super(
      'Tycoon',
      'Have 15 project cards in play (not events.)',
      15);
  }
  public getScore(player: IPlayer): number {
    return player.playedCards
      .filter((card) => card.type === CardType.ACTIVE || card.type === CardType.AUTOMATED).length;
  }
}

================
File: milestones/underworld/Risktaker.ts
================
import {BaseMilestone} from '../IMilestone';
import {IPlayer} from '../../IPlayer';
import {sum} from '../../../common/utils/utils';

export class Risktaker extends BaseMilestone {
  constructor() {
    super(
      'Risktaker',
      'Have at least 3 NEGATIVE VPs among your cards. (Event cards count.)',
      3);
  }

  public getScore(player: IPlayer): number {
    const total = sum(player.tableau
      .map((card) => card.getVictoryPoints(player))
      .filter((vp) => vp < 0));
    return Math.abs(total);
  }
}

================
File: milestones/underworld/Tunneler.ts
================
import {BaseMilestone} from '../IMilestone';
import {IPlayer} from '../../IPlayer';
import {UnderworldExpansion} from '../../underworld/UnderworldExpansion';

export class Tunneler extends BaseMilestone {
  constructor() {
    super(
      'Tunneler',
      'Have at least 7 excavation markers',
      7);
  }

  public getScore(player: IPlayer): number {
    return UnderworldExpansion.excavationMarkerCount(player);
  }
}

================
File: models/ModelUtils.ts
================
import {CardModel} from '../../common/models/CardModel';
import {ColonyModel} from '../../common/models/ColonyModel';
import {Color} from '../../common/Color';
import {IGame} from '../IGame';
import {ICard} from '../cards/ICard';
import {isIProjectCard} from '../cards/IProjectCard';
import {isICloneTagCard} from '../cards/pathfinders/ICloneTagCard';
import {IPlayer} from '../IPlayer';
import {PlayCardMetadata} from '../inputs/SelectProjectCardToPlay';
import {IColony} from '../colonies/IColony';
import {CardName} from '../../common/cards/CardName';
import {Tag} from '../../common/cards/Tag';
import {asArray} from '../../common/utils/utils';

export function cardsToModel(
  player: IPlayer,
  cards: ReadonlyArray<ICard>,
  options: {
    showResources?: boolean,
    showCalculatedCost?: boolean,
    extras?: Map<CardName, PlayCardMetadata>,
    enabled?: ReadonlyArray<boolean>, // If provided, then the cards with false in `enabled` are not selectable and grayed out
  } = {},
): ReadonlyArray<CardModel> {
  return cards.map((card, index) => {
    let discount = card.cardDiscount === undefined ? undefined : asArray(card.cardDiscount);

    // Too bad this is hard-coded
    if (card.name === CardName.CRESCENT_RESEARCH_ASSOCIATION) {
      discount = [{tag: Tag.MOON, amount: player.tags.count(Tag.MOON)}];
    }
    if (card.name === CardName.MARS_DIRECT) {
      discount = [{tag: Tag.MARS, amount: player.tags.count(Tag.MARS)}];
    }

    let warning = undefined;
    const playCardMetadata = options?.extras?.get(card.name);
    if (typeof(playCardMetadata?.details) === 'object') {
      const thinkTankResources = playCardMetadata.details.thinkTankResources;
      if ((thinkTankResources ?? 0) > 0) {
        warning = `Playing ${card.name} consumes ${thinkTankResources} data from Think Tank`;
      }
      if (playCardMetadata.details.redsCost) {
        warning = warning === undefined ? '' : '\n';
        warning += `Playing ${card.name} will cost ${playCardMetadata.details.redsCost} M€ more because Reds are in power`;
      }
    }

    const model: CardModel = {
      resources: options.showResources ? card.resourceCount : undefined,
      name: card.name,
      calculatedCost: options.showCalculatedCost ? (isIProjectCard(card) && card.cost !== undefined ? player.getCardCost(card) : undefined) : card.cost,
      warning: warning,
      bonusResource: isIProjectCard(card) ? card.bonusResource : undefined,
      discount: discount,
      cloneTag: isICloneTagCard(card) ? card.cloneTag : undefined,
    };
    if (card.isDisabled) {
      model.isDisabled = true;
    } else if (options.enabled?.[index] === false) {
      model.isDisabled = true;
    }
    const reserveUnits = playCardMetadata?.reserveUnits;
    if (reserveUnits !== undefined) {
      model.reserveUnits = reserveUnits;
    }
    const isSelfReplicatingRobotsCard = isIProjectCard(card) && player.getSelfReplicatingRobotsTargetCards().includes(card);
    if (isSelfReplicatingRobotsCard) {
      model.resources = card.resourceCount;
      model.isSelfReplicatingRobotsCard = true;
    }
    if (card.warnings.size > 0) {
      model.warnings = Array.from(card.warnings);
    }
    return model;
  });
}

/**
 * No need for both isActive and showTitleOnly.
 */
export function coloniesToModel(game: IGame, colonies: Array<IColony>, showTileOnly: boolean, isActive: boolean = true) : Array<ColonyModel> {
  return colonies.map(
    (colony): ColonyModel => ({
      colonies: colony.colonies.map(
        (playerId): Color => game.getPlayerById(playerId).color,
      ),
      isActive: isActive && colony.isActive && showTileOnly === false,
      name: colony.name,
      trackPosition: colony.trackPosition,
      visitor:
        colony.visitor === undefined ?
          undefined :
          game.getPlayerById(colony.visitor).color,
    }),
  );
}

================
File: models/PathfindersModel.ts
================
import {PathfindersModel} from '../../common/models/PathfindersModel';
import {IGame} from '../IGame';

export function createPathfindersModel(game: IGame): PathfindersModel | undefined {
  if (game.pathfindersData === undefined) return undefined;
  const pathfindersData = game.pathfindersData;
  return {
    venus: pathfindersData.venus,
    earth: pathfindersData.earth,
    mars: pathfindersData.mars,
    jovian: pathfindersData.jovian,
    moon: pathfindersData.moon,
  };
}

================
File: models/ServerModel.ts
================
import {CardModel} from '../../common/models/CardModel';
import {Color} from '../../common/Color';
import {IGame} from '../IGame';
import {GameOptions} from '../game/GameOptions';
import {SimpleGameModel} from '../../common/models/SimpleGameModel';
import {GameOptionsModel} from '../../common/models/GameOptionsModel';
import {Board} from '../boards/Board';
import {Space} from '../boards/Space';
import {IPlayer} from '../IPlayer';
import {PlayerInput} from '../PlayerInput';
import {PlayerInputModel} from '../../common/models/PlayerInputModel';
import {PlayerViewModel, Protection, PublicPlayerModel} from '../../common/models/PlayerModel';
import {SpaceHighlight, SpaceModel} from '../../common/models/SpaceModel';
import {TileType} from '../../common/TileType';
import {Phase} from '../../common/Phase';
import {Resource} from '../../common/Resource';
import {
  ClaimedMilestoneModel,
  MilestoneScore,
} from '../../common/models/ClaimedMilestoneModel';
import {FundedAwardModel, AwardScore} from '../../common/models/FundedAwardModel';
import {getTurmoilModel} from '../models/TurmoilModel';
import {SpectatorModel} from '../../common/models/SpectatorModel';
import {GameModel} from '../../common/models/GameModel';
import {Turmoil} from '../turmoil/Turmoil';
import {createPathfindersModel} from './PathfindersModel';
import {MoonExpansion} from '../moon/MoonExpansion';
import {MoonModel} from '../../common/models/MoonModel';
import {CardName} from '../../common/cards/CardName';
import {AwardScorer} from '../awards/AwardScorer';
import {SpaceId} from '../../common/Types';
import {cardsToModel, coloniesToModel} from './ModelUtils';
import {runId} from '../utils/server-ids';
import {UnderworldExpansion} from '../underworld/UnderworldExpansion';

export class Server {
  public static getSimpleGameModel(game: IGame): SimpleGameModel {
    return {
      activePlayer: game.getPlayerById(game.activePlayer).color,
      id: game.id,
      phase: game.phase,
      players: game.getPlayersInGenerationOrder().map((player) => ({
        color: player.color,
        id: player.id,
        name: player.name,
      })),
      spectatorId: game.spectatorId,
      gameOptions: this.getGameOptionsAsModel(game.gameOptions),
      lastSoloGeneration: game.lastSoloGeneration(),
      expectedPurgeTimeMs: game.expectedPurgeTimeMs(),
    };
  }

  public static getGameModel(game: IGame): GameModel {
    const turmoil = getTurmoilModel(game);

    return {
      aresData: game.aresData,
      awards: this.getAwards(game),
      colonies: coloniesToModel(game, game.colonies, false, true),
      deckSize: game.projectDeck.drawPile.length,
      discardedColonies: game.discardedColonies.map((c) => c.name),
      expectedPurgeTimeMs: game.expectedPurgeTimeMs(),
      gameAge: game.gameAge,
      gameOptions: this.getGameOptionsAsModel(game.gameOptions),
      generation: game.getGeneration(),
      globalsPerGeneration: game.gameIsOver() ? game.globalsPerGeneration : [],
      isSoloModeWin: game.isSoloModeWin(),
      lastSoloGeneration: game.lastSoloGeneration(),
      milestones: this.getMilestones(game),
      moon: this.getMoonModel(game),
      oceans: game.board.getOceanSpaces().length,
      oxygenLevel: game.getOxygenLevel(),
      passedPlayers: game.getPassedPlayers(),
      pathfinders: createPathfindersModel(game),
      phase: game.phase,
      spaces: this.getSpaces(game.board, game.gagarinBase, game.stJosephCathedrals, game.nomadSpace),
      spectatorId: game.spectatorId,
      temperature: game.getTemperature(),
      isTerraformed: game.marsIsTerraformed(),
      turmoil: turmoil,
      undoCount: game.undoCount,
      venusScaleLevel: game.getVenusScaleLevel(),
      step: game.lastSaveId,
    };
  }

  public static getPlayerModel(player: IPlayer): PlayerViewModel {
    const game = player.game;

    const players: Array<PublicPlayerModel> = game.getPlayersInGenerationOrder().map(this.getPlayer);
    const thisPlayerIndex = players.findIndex((p) => p.color === player.color);
    const thisPlayer: PublicPlayerModel = players[thisPlayerIndex];

    const rv: PlayerViewModel = {
      cardsInHand: cardsToModel(player, player.cardsInHand, {showCalculatedCost: true}),
      ceoCardsInHand: cardsToModel(player, player.ceoCardsInHand),
      dealtCorporationCards: cardsToModel(player, player.dealtCorporationCards),
      dealtPreludeCards: cardsToModel(player, player.dealtPreludeCards),
      dealtCeoCards: cardsToModel(player, player.dealtCeoCards),
      dealtProjectCards: cardsToModel(player, player.dealtProjectCards),
      draftedCards: cardsToModel(player, player.draftedCards, {showCalculatedCost: true}),
      game: this.getGameModel(player.game),
      id: player.id,
      runId: runId,
      pickedCorporationCard: player.pickedCorporationCard ? cardsToModel(player, [player.pickedCorporationCard]) : [],
      preludeCardsInHand: cardsToModel(player, player.preludeCardsInHand),
      thisPlayer: thisPlayer,
      waitingFor: this.getWaitingFor(player, player.getWaitingFor()),
      players: players,
      autopass: player.autopass,
    };
    return rv;
  }

  public static getSpectatorModel(game: IGame): SpectatorModel {
    return {
      color: Color.NEUTRAL,
      id: game.spectatorId,
      game: this.getGameModel(game),
      players: game.getPlayersInGenerationOrder().map(this.getPlayer),
      thisPlayer: undefined,
      runId: runId,
    };
  }

  public static getSelfReplicatingRobotsTargetCards(player: IPlayer): Array<CardModel> {
    return player.getSelfReplicatingRobotsTargetCards().map((targetCard) => {
      const model: CardModel = {
        resources: targetCard.resourceCount,
        name: targetCard.name,
        calculatedCost: player.getCardCost(targetCard),
        isSelfReplicatingRobotsCard: true,
      };
      return model;
    });
  }

  public static getMilestones(game: IGame): Array<ClaimedMilestoneModel> {
    const allMilestones = game.milestones;
    const claimedMilestones = game.claimedMilestones;
    const milestoneModels: Array<ClaimedMilestoneModel> = [];

    for (const milestone of allMilestones) {
      const claimed = claimedMilestones.find(
        (m) => m.milestone.name === milestone.name,
      );
      let scores: Array<MilestoneScore> = [];
      if (claimed === undefined && claimedMilestones.length < 3) {
        scores = game.getPlayers().map((player) => ({
          playerColor: player.color,
          playerScore: milestone.getScore(player),
        }));
      }

      milestoneModels.push({
        playerName: claimed === undefined ? '' : claimed.player.name,
        playerColor: claimed === undefined ? '' : claimed.player.color,
        name: milestone.name,
        scores,
      });
    }

    return milestoneModels;
  }

  public static getAwards(game: IGame): Array<FundedAwardModel> {
    const fundedAwards = game.fundedAwards;
    const awardModels: Array<FundedAwardModel> = [];

    for (const award of game.awards) {
      const funded = fundedAwards.find((a) => a.award.name === award.name);
      const scorer = new AwardScorer(game, award);
      let scores: Array<AwardScore> = [];
      if (fundedAwards.length < 3 || funded !== undefined) {
        scores = game.getPlayers().map((player) => ({
          playerColor: player.color,
          playerScore: scorer.get(player),
        }));
      }

      awardModels.push({
        playerName: funded === undefined ? '' : funded.player.name,
        playerColor: funded === undefined ? '' : funded.player.color,
        name: award.name,
        scores: scores,
      });
    }

    return awardModels;
  }

  public static getWaitingFor(
    player: IPlayer,
    waitingFor: PlayerInput | undefined,
  ): PlayerInputModel | undefined {
    if (waitingFor === undefined) {
      return undefined;
    }
    return waitingFor.toModel(player);
    // showReset: player.game.inputsThisRound > 0 && player.game.resettable === true && player.game.phase === Phase.ACTION,
  }

  public static getPlayer(player: IPlayer): PublicPlayerModel {
    const game = player.game;
    return {
      actionsTakenThisRound: player.actionsTakenThisRound,
      actionsTakenThisGame: player.actionsTakenThisGame,
      actionsThisGeneration: Array.from(player.getActionsThisGeneration()),
      availableBlueCardActionCount: player.getAvailableBlueActionCount(),
      cardCost: player.cardCost,
      cardDiscount: player.colonies.cardDiscount,
      cardsInHandNbr: player.cardsInHand.length,
      citiesCount: player.game.board.getCities(player).length,
      coloniesCount: player.getColoniesCount(),
      color: player.color,
      energy: player.energy,
      energyProduction: player.production.energy,
      fleetSize: player.colonies.getFleetSize(),
      heat: player.heat,
      heatProduction: player.production.heat,
      id: game.phase === Phase.END ? player.id : undefined,
      influence: Turmoil.ifTurmoilElse(game, (turmoil) => turmoil.getPlayerInfluence(player), () => 0),
      isActive: player.id === game.activePlayer,
      lastCardPlayed: player.lastCardPlayed,
      megaCredits: player.megaCredits,
      megaCreditProduction: player.production.megacredits,
      name: player.name,
      needsToDraft: player.needsToDraft,
      needsToResearch: !game.hasResearched(player),
      noTagsCount: player.tags.numberOfCardsWithNoTags(),
      plants: player.plants,
      plantProduction: player.production.plants,
      protectedResources: Server.getResourceProtections(player),
      protectedProduction: Server.getProductionProtections(player),
      tableau: cardsToModel(player, player.tableau, {showResources: true}),
      selfReplicatingRobotsCards: Server.getSelfReplicatingRobotsTargetCards(player),
      steel: player.steel,
      steelProduction: player.production.steel,
      steelValue: player.getSteelValue(),
      tags: player.tags.countAllTags(),
      terraformRating: player.getTerraformRating(),
      timer: player.timer.serialize(),
      titanium: player.titanium,
      titaniumProduction: player.production.titanium,
      titaniumValue: player.getTitaniumValue(),
      tradesThisGeneration: player.colonies.tradesThisGeneration,
      victoryPointsBreakdown: player.getVictoryPoints(),
      victoryPointsByGeneration: player.victoryPointsByGeneration,
      corruption: player.underworldData.corruption,
      excavations: UnderworldExpansion.excavationMarkerCount(player),
      alliedParty: player.alliedParty,
    };
  }

  private static getResourceProtections(player: IPlayer) {
    const protection: Record<Resource, Protection> = {
      megacredits: 'off',
      steel: 'off',
      titanium: 'off',
      plants: 'off',
      energy: 'off',
      heat: 'off',
    };

    if (player.alloysAreProtected()) {
      protection.steel = 'on';
      protection.titanium = 'on';
    }

    if (player.plantsAreProtected()) {
      protection.plants = 'on';
    } else if (player.cardIsInEffect(CardName.BOTANICAL_EXPERIENCE)) {
      protection.plants = 'half';
    }

    return protection;
  }

  private static getProductionProtections(player: IPlayer) {
    const defaultProteection = player.cardIsInEffect(CardName.PRIVATE_SECURITY) ? 'on' : 'off';
    const protection: Record<Resource, Protection> = {
      megacredits: defaultProteection,
      steel: defaultProteection,
      titanium: defaultProteection,
      plants: defaultProteection,
      energy: defaultProteection,
      heat: defaultProteection,
    };

    if (player.alloysAreProtected()) {
      protection.steel = 'on';
      protection.titanium = 'on';
    }

    return protection;
  }

  // Oceans can't be owned so they shouldn't have a color associated with them
  // Land claim can have a color on a space without a tile
  private static getColor(space: Space): Color | undefined {
    if (
      (space.tile === undefined || space.tile.tileType !== TileType.OCEAN) &&
    space.player !== undefined
    ) {
      return space.player.color;
    }
    if (space.tile?.protectedHazard === true) {
      return Color.BRONZE;
    }
    return undefined;
  }

  private static getSpaces(
    board: Board,
    gagarin: ReadonlyArray<SpaceId> = [],
    cathedrals: ReadonlyArray<SpaceId> = [],
    nomads: SpaceId | undefined = undefined): Array<SpaceModel> {
    const volcanicSpaceIds = board.volcanicSpaceIds;
    const noctisCitySpaceId = board.noctisCitySpaceId;

    return board.spaces.map((space) => {
      let highlight: SpaceHighlight = undefined;
      if (volcanicSpaceIds.includes(space.id)) {
        highlight = 'volcanic';
      } else if (noctisCitySpaceId === space.id) {
        highlight = 'noctis';
      }

      const model: SpaceModel = {
        x: space.x,
        y: space.y,
        id: space.id,
        spaceType: space.spaceType,
        bonus: space.bonus,
      };
      const tileType = space.tile?.tileType;
      if (tileType !== undefined) {
        model.tileType = tileType;
      }
      const color = this.getColor(space);
      if (color !== undefined) {
        model.color = color;
      }
      if (highlight === undefined) {
        model.highlight = highlight;
      }
      if (space.tile?.rotated === true) {
        model.rotated = true;
      }
      const gagarinIndex = gagarin.indexOf(space.id);
      if (gagarinIndex > -1) {
        model.gagarin = gagarinIndex;
      }
      if (cathedrals.includes(space.id)) {
        model.cathedral = true;
      }
      if (space.id === nomads) {
        model.nomads = true;
      }
      if (space.undergroundResources !== undefined) {
        model.undergroundResources = space.undergroundResources;
      }
      if (space.excavator !== undefined) {
        model.excavator = space.excavator.color;
      }
      if (space.coOwner !== undefined) {
        model.coOwner = space.coOwner.color;
      }

      return model;
    });
  }

  public static getGameOptionsAsModel(options: GameOptions): GameOptionsModel {
    return {
      altVenusBoard: options.altVenusBoard,
      aresExtension: options.aresExtension,
      boardName: options.boardName,
      bannedCards: options.bannedCards,
      includedCards: options.includedCards,
      ceoExtension: options.ceoExtension,
      chemicalExpansion: options.chemicalExpansion,
      coloniesExtension: options.coloniesExtension,
      communityCardsOption: options.communityCardsOption,
      corporateEra: options.corporateEra,
      draftVariant: options.draftVariant,
      escapeVelocityMode: options.escapeVelocityMode,
      escapeVelocityThreshold: options.escapeVelocityThreshold,
      escapeVelocityBonusSeconds: options.escapeVelocityBonusSeconds,
      escapeVelocityPeriod: options.escapeVelocityPeriod,
      escapeVelocityPenalty: options.escapeVelocityPenalty,
      fastModeOption: options.fastModeOption,
      includeFanMA: options.includeFanMA,
      includeVenusMA: options.includeVenusMA,
      initialDraftVariant: options.initialDraftVariant,
      moonExpansion: options.moonExpansion,
      pathfindersExpansion: options.pathfindersExpansion,
      preludeDraftVariant: options.preludeDraftVariant,
      preludeExtension: options.preludeExtension,
      prelude2Expansion: options.prelude2Expansion,
      promoCardsOption: options.promoCardsOption,
      politicalAgendasExtension: options.politicalAgendasExtension,
      removeNegativeGlobalEvents: options.removeNegativeGlobalEventsOption,
      showOtherPlayersVP: options.showOtherPlayersVP,
      showTimers: options.showTimers,
      shuffleMapOption: options.shuffleMapOption,
      solarPhaseOption: options.solarPhaseOption,
      soloTR: options.soloTR,
      randomMA: options.randomMA,
      requiresMoonTrackCompletion: options.requiresMoonTrackCompletion,
      requiresVenusTrackCompletion: options.requiresVenusTrackCompletion,
      turmoilExtension: options.turmoilExtension,
      twoCorpsVariant: options.twoCorpsVariant,
      venusNextExtension: options.venusNextExtension,
      undoOption: options.undoOption,
      underworldExpansion: options.underworldExpansion,
    };
  }

  private static getMoonModel(game: IGame): MoonModel | undefined {
    return MoonExpansion.ifElseMoon(game, (moonData) => {
      return {
        logisticsRate: moonData.logisticRate,
        miningRate: moonData.miningRate,
        habitatRate: moonData.habitatRate,
        spaces: this.getSpaces(moonData.moon),
      };
    }, () => undefined);
  }
}

================
File: models/TurmoilModel.ts
================
import {Color} from '../../common/Color';
import {PartyName} from '../../common/turmoil/PartyName';
import {IGame} from '../IGame';
import {PoliticalAgendas} from '../turmoil/PoliticalAgendas';
import {Delegate, Turmoil} from '../turmoil/Turmoil';
import {DelegatesModel, PartyModel, PoliticalAgendasModel, TurmoilModel} from '../../common/models/TurmoilModel';

export function getTurmoilModel(game: IGame): TurmoilModel | undefined {
  return Turmoil.ifTurmoilElse(game, (turmoil) => {
    const parties = getParties(game);
    let chairman: Color | undefined;

    if (turmoil.chairman) {
      chairman = delegateColor(turmoil.chairman);
    }
    const dominant = turmoil.dominantParty.name;
    const ruling = turmoil.rulingParty.name;

    const reserve: Array<DelegatesModel> = [];
    const lobby: Array<Color> = [];
    turmoil.delegateReserve.forEachMultiplicity((count, delegate) => {
      const color = delegateColor(delegate);
      if (delegate !== 'NEUTRAL') {
        if (!turmoil.usedFreeDelegateAction.has(delegate)) {
          count--;
          lobby.push(color);
        }
      }
      reserve.push({
        color: color,
        number: count,
      });
    });

    const politicalAgendas: PoliticalAgendasModel = {
      marsFirst: PoliticalAgendas.getAgenda(turmoil, PartyName.MARS),
      scientists: PoliticalAgendas.getAgenda(turmoil, PartyName.SCIENTISTS),
      unity: PoliticalAgendas.getAgenda(turmoil, PartyName.UNITY),
      greens: PoliticalAgendas.getAgenda(turmoil, PartyName.GREENS),
      reds: PoliticalAgendas.getAgenda(turmoil, PartyName.REDS),
      kelvinists: PoliticalAgendas.getAgenda(turmoil, PartyName.KELVINISTS),
    };

    const policyActionUsers = Array.from(
      game.getPlayersInGenerationOrder(),
      (player) => {
        return {
          color: player.color,
          turmoilPolicyActionUsed: player.turmoilPolicyActionUsed,
          politicalAgendasActionUsedCount: player.politicalAgendasActionUsedCount};
      },
    );

    return {
      chairman,
      ruling,
      dominant,
      parties,
      lobby,
      reserve,
      distant: turmoil.distantGlobalEvent?.name,
      coming: turmoil.comingGlobalEvent?.name,
      current: turmoil.currentGlobalEvent?.name,
      politicalAgendas,
      policyActionUsers,
    };
  },
  () => undefined);
}

function getParties(game: IGame): Array<PartyModel> {
  return Turmoil.ifTurmoilElse(game,
    (turmoil) => {
      return turmoil.parties.map(function(party) {
        const delegates: Array<DelegatesModel> = [];
        for (const player of party.delegates.keys()) {
          const number = party.delegates.count(player);
          delegates.push({
            color: delegateColor(player),
            number,
          });
        }
        const partyLeader = party.partyLeader === undefined ? undefined : delegateColor(party.partyLeader);
        return {
          name: party.name,
          partyLeader: partyLeader,
          delegates: delegates,
        };
      });
    },
    () => []);
}

function delegateColor(delegate: Delegate) {
  return delegate === 'NEUTRAL' ? Color.NEUTRAL : delegate.color;
}

================
File: moon/BasePlaceMoonTile.ts
================
import {Space} from '../boards/Space';
import {DeferredAction} from '../deferredActions/DeferredAction';
import {Priority} from '../deferredActions/Priority';
import {SelectSpace} from '../inputs/SelectSpace';
import {IPlayer} from '../IPlayer';
import {PlayerInput} from '../PlayerInput';
import {MoonData} from './MoonData';
import {MoonExpansion} from './MoonExpansion';

export abstract class BasePlaceMoonTile extends DeferredAction<Space> {
  constructor(
    player: IPlayer,
    public spaces?: Array<Space>,
    public title: string = 'Select a space for a tile',
  ) {
    super(player, Priority.DEFAULT);
  }

  protected abstract getSpaces(moonData: MoonData): ReadonlyArray<Space>;
  protected abstract placeTile(space: Space): PlayerInput | undefined;

  public execute() {
    const spaces = this.spaces !== undefined ? this.spaces : this.getSpaces(MoonExpansion.moonData(this.player.game));

    if (spaces.length === 0) {
      return undefined;
    }
    return new SelectSpace(this.title, spaces)
      .andThen((space) => {
        this.placeTile(space);
        this.cb(space);
        return undefined;
      });
  }
}

================
File: moon/FullMoon.ts
================
import {IAward} from '../awards/IAward';
import {Tag} from '../../common/cards/Tag';
import {IPlayer} from '../IPlayer';

export class FullMoon implements IAward {
  public readonly name = 'Full Moon';
  public readonly description = 'Have the most Moon tags in play';
  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.MOON, 'award');
  }
}

================
File: moon/Lunarchitect.ts
================
import {BaseMilestone} from '../milestones/IMilestone';
import {IPlayer} from '../IPlayer';
import {MoonExpansion} from './MoonExpansion';

export class Lunarchitect extends BaseMilestone {
  constructor() {
    super(
      'Lunarchitect',
      // The original rules had "Own at least 4 Moon tiles" but that
      // was before the moon got 50% bigger.
      'Own 6 Moon tiles',
      6);
  }

  public getScore(player: IPlayer): number {
    return MoonExpansion.ifElseMoon(player.game, (moonData) => {
      return moonData.moon.spaces.filter((space) => space.player?.id === player.id).length;
    }, () => 0) || 0;
  }
}

================
File: moon/LunarMagnate.ts
================
import {IAward} from '../awards/IAward';
import {IPlayer} from '../IPlayer';
import {MoonExpansion} from './MoonExpansion';

export class LunarMagnate implements IAward {
  public readonly name = 'Lunar Magnate';
  public readonly description = 'Own the most tiles on The Moon';
  public getScore(player: IPlayer): number {
    return MoonExpansion.ifElseMoon(player.game, (moonData) => {
      return moonData.moon.spaces.filter((space) => space.player?.id === player.id).length;
    }, () => 0) || 0;
  }
}

================
File: moon/MoonBoard.ts
================
import {Board} from '../boards/Board';
import {Space} from '../boards/Space';
import {IPlayer} from '../IPlayer';
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {SpaceType} from '../../common/boards/SpaceType';
import {MoonSpaces} from '../../common/moon/MoonSpaces';
import {SpaceId, isSpaceId, safeCast} from '../../common/Types';
import {GameOptions} from '../../server/game/GameOptions';
import {Random} from '../../common/utils/Random';
import {preservingShuffle} from '../../server/boards/BoardBuilder';

function colonySpace(id: SpaceId): Space {
  return {id, spaceType: SpaceType.COLONY, x: -1, y: -1, bonus: []};
}


export class MoonBoard extends Board {
  public getAvailableSpacesForMine(player: IPlayer): ReadonlyArray<Space> {
    const spaces = this.spaces.filter((space) => {
      const val = space.tile === undefined &&
        space.spaceType === SpaceType.LUNAR_MINE &&
        space.id !== MoonSpaces.MARE_IMBRIUM &&
        space.id !== MoonSpaces.MARE_SERENITATIS &&
        space.id !== MoonSpaces.MARE_NUBIUM &&
        space.id !== MoonSpaces.MARE_NECTARIS &&
        (space.player === undefined || space.player.id === player.id);
      return val;
    });
    return spaces;
  }

  public static newInstance(gameOptions: GameOptions, rng: Random): MoonBoard {
    const STEEL = SpaceBonus.STEEL;
    const DRAW_CARD = SpaceBonus.DRAW_CARD;
    const TITANIUM = SpaceBonus.TITANIUM;

    const b = new Builder();
    b.row(2).land().land(STEEL, DRAW_CARD).land().mine(TITANIUM);
    b.row(1).mine(TITANIUM, TITANIUM).mine(/* Mare Imbrium */).land(STEEL).land().land();
    b.row(0).mine().land(STEEL).land(STEEL, TITANIUM).mine(/* Mare Serenatis*/).mine(TITANIUM).land(STEEL, STEEL);
    b.row(0).land(STEEL).land().land().mine(TITANIUM).mine(TITANIUM);
    b.row(0).land().mine(TITANIUM).mine(/* Mare Nubium */).land().mine(/* Mare Nectaris */).land(STEEL);
    b.row(1).land().land(STEEL).land(STEEL).land(DRAW_CARD, DRAW_CARD).land(STEEL);
    b.row(2).land(DRAW_CARD, DRAW_CARD).mine(TITANIUM).mine(TITANIUM, TITANIUM).land();

    if (gameOptions.shuffleMapOption!== undefined && gameOptions.shuffleMapOption) {
      b.shuffle(rng,
        MoonSpaces.MARE_IMBRIUM,
        MoonSpaces.MARE_NECTARIS,
        MoonSpaces.MARE_NUBIUM,
        MoonSpaces.MARE_SERENITATIS);
    }
    const spaces = b.build();
    return new MoonBoard(spaces);
  }

  public constructor(spaces: Array<Space>) {
    super(spaces, undefined, []);
  }
}

class Builder {
  y: number = -1;
  x: number = 0;
  spaceTypes: Array<SpaceType> = [];
  bonuses: Array<Array<SpaceBonus>> = [];
  spaces: Array<Space> = [];
  private idx: number = 0;

  public row(startX: number): Row {
    this.y++;
    this.x = startX;
    return new Row(this);
  }
  public colony() {
    this.spaceTypes.push(SpaceType.COLONY);
    this.bonuses.push([]);
  }
  public nextId(): SpaceId {
    this.idx++;
    const strId = this.idx.toString().padStart(2, '0');
    return safeCast('m' + strId, isSpaceId);
  }
  public build(): Array<Space> {
    this.spaces.push(colonySpace(MoonSpaces.LUNA_TRADE_STATION));

    const tilesPerRow = [4, 5, 6, 5, 6, 5, 4];
    const idOffset = this.spaces.length + 1;
    let idx = 0;

    for (let row = 0; row < tilesPerRow.length; row++) {
      const tilesInThisRow = tilesPerRow[row];
      const xOffset = row === 3 ? 0 : 6 - tilesInThisRow; // Hack for central line 0-based x coord
      for (let i = 0; i < tilesInThisRow; i++) {
        const spaceId = idx + idOffset;
        const xCoordinate = xOffset + i;
        const space = {
          id: Builder.spaceId(spaceId),
          spaceType: this.spaceTypes[idx],
          x: xCoordinate,
          y: row,
          bonus: this.bonuses[idx],
        };
        this.spaces.push(space);
        idx++;
      }
    }

    this.spaces.push(colonySpace(MoonSpaces.MOMENTUM_VIRIUM));
    return this.spaces;
  }
  public shuffle(rng: Random, ...preservedSpaceIds: Array<MoonSpaces>) {
    const preservedSpaces = [];
    for (const spaceId of preservedSpaceIds) {
      const idx = Number(spaceId.substring(1, 3));
      preservedSpaces.push(idx - 2);
    }
    preservedSpaces.sort((a, b) => a - b);
    preservingShuffle(this.spaceTypes, preservedSpaces, rng);
    preservingShuffle(this.bonuses, preservedSpaces, rng);
    return;
  }
  private static spaceId(id: number): SpaceId {
    let strId = id.toString();
    if (id < 10) {
      strId = '0'+strId;
    }
    return safeCast('m'+strId, isSpaceId);
  }
}

class Row {
  constructor(private builder: Builder) {
  }

  land(...bonuses: SpaceBonus[]): this {
    this.builder.spaceTypes.push(SpaceType.LAND);
    this.builder.bonuses.push(bonuses);
    return this;
  }

  mine(...bonuses: SpaceBonus[]): this {
    this.builder.spaceTypes.push(SpaceType.LUNAR_MINE);
    this.builder.bonuses.push(bonuses);
    return this;
  }
}

================
File: moon/MoonCards.ts
================
import {CardName} from '../../common/cards/CardName';

export class MoonCards {
  public static scienceCardsWithLessThan2VP: Set<CardName> = new Set([
    CardName.OLYMPUS_CONFERENCE,
    CardName.COPERNICUS_TOWER,
    CardName.LUNA_ARCHIVES,
    CardName.PRIDE_OF_THE_EARTH_ARKSHIP,
    CardName.NANOTECH_INDUSTRIES,
    CardName.APPLIED_SCIENCE,
    CardName.SPIRE,
  ]);
  public static otherScienceCards: Set<CardName> = new Set([
    CardName.PHYSICS_COMPLEX,
    CardName.SEARCH_FOR_LIFE,
    CardName.SEARCH_FOR_LIFE_UNDERGROUND,
  ]);
}

================
File: moon/MoonData.ts
================
import {PlayerId} from '../../common/Types';
import {IPlayer} from '../IPlayer';
import {Board} from '../boards/Board';
import {MoonBoard} from './MoonBoard';
import {SerializedMoonData} from './SerializedMoonData';

export type MoonData = {
  moon: MoonBoard;
  habitatRate: number;
  miningRate: number;
  logisticRate: number;
  lunaFirstPlayer: IPlayer | undefined;
  lunaProjectOfficeLastGeneration: number | undefined;
}

export namespace MoonData {
  export function serialize(moonData: MoonData | undefined): SerializedMoonData | undefined {
    if (moonData === undefined) {
      return undefined;
    }
    return {
      moon: moonData.moon.serialize(),
      habitatRate: moonData.habitatRate,
      miningRate: moonData.miningRate,
      logisticRate: moonData.logisticRate,
      lunaFirstPlayerId: moonData.lunaFirstPlayer ? moonData.lunaFirstPlayer.id : undefined,
      lunaProjectOfficeLastGeneration: moonData.lunaProjectOfficeLastGeneration,
    };
  }

  function findPlayer(players: Array<IPlayer>, playerId: PlayerId | undefined) {
    const player = players.find((player) => player.id === playerId);
    if (playerId !== undefined && player === undefined) {
      throw new Error(`player ${playerId} not found`);
    }
    return player;
  }

  export function deserialize(moonData: SerializedMoonData, players: Array<IPlayer>): MoonData {
    const spaces = Board.deserialize(moonData.moon, players).spaces;
    const board = new MoonBoard(spaces);

    return {
      habitatRate: moonData.habitatRate,
      logisticRate: moonData.logisticRate,
      miningRate: moonData.miningRate,
      moon: board,
      lunaFirstPlayer: findPlayer(players, moonData.lunaFirstPlayerId),
      lunaProjectOfficeLastGeneration: moonData.lunaProjectOfficeLastGeneration,
    };
  }
}

================
File: moon/MoonExpansion.ts
================
import {IGame} from '../IGame';
import {Tile} from '../Tile';
import {MoonBoard} from './MoonBoard';
import {IPlayer} from '../IPlayer';
import {TileType} from '../../common/TileType';
import {SpaceType} from '../../common/boards/SpaceType';
import {MoonData} from './MoonData';
import {CardName} from '../../common/cards/CardName';
import {IProjectCard} from '../cards/IProjectCard';
import {Units} from '../../common/Units';
import {Tag} from '../../common/cards/Tag';
import {Space} from '../boards/Space';
import {MAXIMUM_HABITAT_RATE, MAXIMUM_LOGISTICS_RATE, MAXIMUM_MINING_RATE} from '../../common/constants';
import {Resource} from '../../common/Resource';
import {Phase} from '../../common/Phase';
import {BoardType} from '../boards/BoardType';
import {VictoryPointsBreakdown} from '../game/VictoryPointsBreakdown';
import {SpaceId} from '../../common/Types';
import {Random} from '../../common/utils/Random';
import {GameOptions} from '../game/GameOptions';

export class MoonExpansion {
  public static readonly MOON_TILES: Set<TileType> = new Set([
    TileType.MOON_MINE,
    TileType.MOON_HABITAT,
    TileType.MOON_ROAD,
    TileType.LUNA_TRADE_STATION,
    TileType.LUNA_MINING_HUB,
    TileType.LUNA_TRAIN_STATION,
    TileType.LUNAR_MINE_URBANIZATION,
  ]);

  private constructor() {
  }

  // If the moon expansion is enabled, execute this callback, otherwise do nothing.
  public static ifMoon<T>(game: IGame, cb: (moonData: MoonData) => T): T | undefined {
    if (game.gameOptions.moonExpansion) {
      if (game.moonData === undefined) {
        console.log(`Assertion failure: game.moonData is undefined for ${game.id}`);
      } else {
        return cb(game.moonData);
      }
    }
    return undefined;
  }

  // If the moon expansion is enabled, execute this callback, otherwise execute the else callback.
  public static ifElseMoon<T>(game: IGame, cb: (moonData: MoonData) => T, elseCb: () => T): T {
    if (game.gameOptions.moonExpansion) {
      if (game.moonData === undefined) {
        console.log(`Assertion failure: game.moonData is undefined for ${game.id}`);
      } else {
        return cb(game.moonData);
      }
    }
    return elseCb();
  }

  // If the moon expansion is enabled, return with the game's MoonData instance, otherwise throw an error.
  public static moonData(game: IGame): MoonData {
    if (game.gameOptions.moonExpansion === true && game.moonData !== undefined) {
      return game.moonData;
    }
    throw new Error('Assertion error: Using a Moon feature when the Moon expansion is undefined.');
  }

  public static initialize(gameOptions: GameOptions, rng: Random): MoonData {
    return {
      moon: MoonBoard.newInstance(gameOptions, rng),
      habitatRate: 0,
      miningRate: 0,
      logisticRate: 0,
      lunaFirstPlayer: undefined,
      lunaProjectOfficeLastGeneration: undefined,
    };
  }

  public static addMineTile(
    player: IPlayer, spaceId: SpaceId, cardName: CardName | undefined = undefined): void {
    MoonExpansion.addTile(player, spaceId, {tileType: TileType.MOON_MINE, card: cardName});
  }

  public static addHabitatTile(
    player: IPlayer, spaceId: SpaceId, cardName: CardName | undefined = undefined): void {
    MoonExpansion.addTile(player, spaceId, {tileType: TileType.MOON_HABITAT, card: cardName});
  }

  public static addRoadTile(
    player: IPlayer, spaceId: SpaceId, cardName: CardName | undefined = undefined): void {
    MoonExpansion.addTile(player, spaceId, {tileType: TileType.MOON_ROAD, card: cardName});
  }

  // Having a custom addTile isn't ideal, but game.addTile is pretty specific, and this
  // isn't.

  // Update: I think this is going to have to merge with addTile. It won't be bad.
  public static addTile(player: IPlayer, spaceId: SpaceId, tile: Tile): void {
    const game = player.game;
    MoonExpansion.ifMoon(game, (moonData) => {
      const space = moonData.moon.getSpaceOrThrow(spaceId);
      if (!this.MOON_TILES.has(tile.tileType)) {
        throw new Error(`Bad tile type for the moon: ${tile.tileType}`);
      }
      if (space.tile !== undefined) {
        throw new Error('Selected space is occupied');
      }

      // Note: Land Claim won't be accepted on the moon with this implementation.
      // which is OK for now.
      if (space.player !== undefined && space.player !== player) {
        throw new Error('This space is land claimed by ' + space.player.name);
      }

      space.tile = tile;
      if (player.game.phase !== Phase.SOLAR) {
        space.player = player;
      }

      if (game.phase !== Phase.SOLAR) {
        space.bonus.forEach((spaceBonus) => {
          game.grantSpaceBonus(player, spaceBonus);
        });
      }

      MoonExpansion.logTilePlacement(player, space, tile.tileType);

      // Ideally, this should be part of game.addTile, but since it isn't it's convenient enough to
      // hard-code onTilePlaced here. I wouldn't be surprised if this introduces a problem, but for now
      // it's not a problem until it is.
      game.getPlayers().forEach((p) => {
        p.tableau.forEach((playedCard) => {
          playedCard.onTilePlaced?.(p, player, space, BoardType.MOON);
        });
      });
    });
  }

  private static logTilePlacement(player: IPlayer, space: Space, tileType: TileType) {
    // Skip off-grid tiles
    if (space.x !== -1 && space.y !== -1) {
      const offsets = [-1, 0, 1, 1, 1, 0, -1];
      const row = space.y + 1;
      const position = space.x + offsets[space.y];

      player.game.log('${0} placed a ${1} tile on The Moon at (${2}, ${3})', (b) =>
        b.player(player).tileType(tileType).number(row).number(position));
    }
  }

  private static bonus(originalRate: number, increment: number, value: number, cb: () => void): void {
    if (originalRate < value && originalRate + increment >= value) {
      cb();
    }
  }

  public static raiseMiningRate(player: IPlayer, count: number = 1) {
    MoonExpansion.ifMoon(player.game, (moonData) => {
      const available = MAXIMUM_MINING_RATE - moonData.miningRate;
      const increment = Math.min(count, available);
      if (increment > 0) {
        if (player.game.phase === Phase.SOLAR) {
          player.game.log('${0} acted as World Government and raised the mining rate ${1} step(s)', (b) => b.player(player).number(increment));
          this.activateLunaFirst(undefined, player.game, increment);
        } else {
          player.game.log('${0} raised the mining rate ${1} step(s)', (b) => b.player(player).number(increment));
          player.increaseTerraformRating(increment);
          this.bonus(moonData.miningRate, increment, 3, () => {
            player.drawCard();
          });
          this.bonus(moonData.miningRate, increment, 6, () => {
            player.production.add(Resource.TITANIUM, 1, {log: true});
          });
          this.activateLunaFirst(player, player.game, increment);
        }
        moonData.miningRate += increment;
      }
    });
  }

  public static raiseHabitatRate(player: IPlayer, count: number = 1) {
    MoonExpansion.ifMoon(player.game, (moonData) => {
      const available = MAXIMUM_HABITAT_RATE - moonData.habitatRate;
      const increment = Math.min(count, available);
      if (increment > 0) {
        if (player.game.phase === Phase.SOLAR) {
          player.game.log('${0} acted as World Government and raised the habitat rate ${1} step(s)', (b) => b.player(player).number(increment));
          this.activateLunaFirst(undefined, player.game, count);
        } else {
          player.game.log('${0} raised the habitat rate ${1} step(s)', (b) => b.player(player).number(increment));
          player.increaseTerraformRating(increment);
          this.bonus(moonData.habitatRate, increment, 3, () => {
            player.drawCard();
          });
          this.bonus(moonData.habitatRate, increment, 6, () => {
            player.production.add(Resource.ENERGY, 1, {log: true});
          });
          this.activateLunaFirst(player, player.game, count);
        }
        moonData.habitatRate += increment;
      }
    });
  }

  public static raiseLogisticRate(player: IPlayer, count: number = 1) {
    MoonExpansion.ifMoon(player.game, (moonData) => {
      const available = MAXIMUM_LOGISTICS_RATE - moonData.logisticRate;
      const increment = Math.min(count, available);
      if (increment > 0) {
        if (player.game.phase === Phase.SOLAR) {
          player.game.log('${0} acted as World Government and raised the logistic rate ${1} step(s)', (b) => b.player(player).number(increment));
          this.activateLunaFirst(undefined, player.game, increment);
        } else {
          player.game.log('${0} raised the logistic rate ${1} step(s)', (b) => b.player(player).number(increment));
          player.increaseTerraformRating(increment);
          this.bonus(moonData.logisticRate, increment, 3, () => {
            player.drawCard();
          });
          this.bonus(moonData.logisticRate, increment, 6, () => {
            player.production.add(Resource.STEEL, 1, {log: true});
          });
          this.activateLunaFirst(player, player.game, increment);
        }
        moonData.logisticRate += increment;
      }
    });
  }

  private static activateLunaFirst(sourcePlayer: IPlayer | undefined, game: IGame, count: number) {
    const lunaFirstPlayer = MoonExpansion.moonData(game).lunaFirstPlayer;
    if (lunaFirstPlayer !== undefined) {
      lunaFirstPlayer.stock.add(Resource.MEGACREDITS, count, {log: true});
      if (lunaFirstPlayer.id === sourcePlayer?.id) {
        lunaFirstPlayer.production.add(Resource.MEGACREDITS, count, {log: true});
      }
    }
  }

  public static lowerMiningRate(player: IPlayer, count: number) {
    MoonExpansion.ifMoon(player.game, (moonData) => {
      const increment = Math.min(moonData.miningRate, count);
      moonData.miningRate -= increment;
      player.game.log('${0} lowered the mining rate ${1} step(s)', (b) => b.player(player).number(increment));
    });
  }

  public static lowerHabitatRate(player: IPlayer, count: number) {
    MoonExpansion.ifMoon(player.game, (moonData) => {
      const increment = Math.min(moonData.habitatRate, count);
      moonData.habitatRate -= increment;
      player.game.log('${0} lowered the habitat rate ${1} step(s)', (b) => b.player(player).number(increment));
    });
  }

  public static lowerLogisticRate(player: IPlayer, count: number) {
    MoonExpansion.ifMoon(player.game, (moonData) => {
      const increment = Math.min(moonData.logisticRate, count);
      moonData.logisticRate -= increment;
      player.game.log('${0} lowered the logistic rate ${1} step(s)', (b) => b.player(player).number(increment));
    });
  }

  // Use this to test whether a space has a given moon tile type rather than
  // testing tiletype directly. It takes into account Lunar Mine Urbanization.
  public static spaceHasType(space: Space, type: TileType, upgradedTiles: boolean = true): boolean {
    if (space.tile === undefined) {
      return false;
    }
    if (space.tile.tileType === type) {
      return true;
    }
    if (upgradedTiles && space.tile.tileType === TileType.LUNAR_MINE_URBANIZATION) {
      return type === TileType.MOON_HABITAT || type === TileType.MOON_MINE;
    }
    return false;
  }

  /*
   * Return the list of spaces on the board with a given tile type, optionally excluding
   * colony spaces.
   *
   * Special tiles such as Lunar Mine Urbanization, are especially included.
   */
  public static spaces(
    game: IGame,
    tileType?: TileType,
    options?: {
      surfaceOnly?: boolean,
      ownedBy? : IPlayer,
      upgradedTiles?: boolean,
    }): Array<Space> {
    return MoonExpansion.ifElseMoon(game, (moonData) => {
      return moonData.moon.spaces.filter(
        (space) => {
          if (space.tile === undefined) {
            return false;
          }
          let include = true;
          if (tileType) {
            include = MoonExpansion.spaceHasType(space, tileType, options?.upgradedTiles);
          }
          if (include && options?.surfaceOnly) {
            include = space.spaceType !== SpaceType.COLONY;
          }
          if (include && options?.ownedBy !== undefined) {
            include = space.player === options.ownedBy || space.coOwner === options.ownedBy;
          }

          return include;
        });
    }, () => []);
  }

  /*
   * Reservation units adjusted for cards in a player's hand that might reduce or eliminate these costs.
   */
  public static adjustedReserveCosts(player: IPlayer, card: IProjectCard) : Units {
    // This is a bit hacky and uncoordinated only because this returns early when there's a moon card with LTF Privileges
    // even though the heat component below could be considered (and is, for LocalHeatTrapping.)

    if (player.cardIsInEffect(CardName.LTF_PRIVILEGES) && card.tags.includes(Tag.MOON)) {
      return Units.EMPTY;
    }

    const reserveUnits: Units = card.reserveUnits || Units.EMPTY;

    const heat = reserveUnits.heat || 0;
    const plants = reserveUnits.plants || 0;
    let steel = reserveUnits.steel || 0;
    let titanium = reserveUnits.titanium || 0;

    for (const tileBuilt of card.tilesBuilt) {
      switch (tileBuilt) {
      case TileType.MOON_HABITAT:
        if (player.cardIsInEffect(CardName.SUBTERRANEAN_HABITATS)) {
          // Edge case: Momentum Virum is a space habitat, not a habitat
          // ON the moon.
          if (card.name !== CardName.MOMENTUM_VIRUM_HABITAT) {
            titanium -= 1;
          }
        }
        break;

      case TileType.MOON_MINE:
        if (player.cardIsInEffect(CardName.IMPROVED_MOON_CONCRETE)) {
          titanium -= 1;
        }
        break;

      case TileType.MOON_ROAD:
        if (player.cardIsInEffect(CardName.LUNAR_DUST_PROCESSING_PLANT)) {
          steel = 0;
        }
      }
    }

    steel = Math.max(steel, 0);
    titanium = Math.max(titanium, 0);
    return Units.of({steel, titanium, heat, plants});
  }

  public static calculateVictoryPoints(player: IPlayer, vpb: VictoryPointsBreakdown): void {
    MoonExpansion.ifMoon(player.game, (moonData) => {
      // Each road tile on the map awards 1VP to the player owning it.
      // Each mine and colony (habitat) tile on the map awards 1VP per road tile touching them.
      const moon = moonData.moon;
      const mySpaces = moon.spaces.filter((space) => space.player?.id === player.id || space.coOwner?.id === player.id);
      mySpaces.forEach((space) => {
        if (space.tile !== undefined) {
          const type = space.tile.tileType;
          switch (type) {
          case TileType.MOON_ROAD:
            vpb.setVictoryPoints('moon road', 1);
            break;
          case TileType.MOON_MINE:
          case TileType.MOON_HABITAT:
          case TileType.LUNAR_MINE_URBANIZATION:
            const points = moon.getAdjacentSpaces(space).filter((adj) => MoonExpansion.spaceHasType(adj, TileType.MOON_ROAD)).length;
            if (type === TileType.MOON_MINE || type === TileType.LUNAR_MINE_URBANIZATION) {
              vpb.setVictoryPoints('moon mine', points);
            }
            if (type === TileType.MOON_HABITAT || type === TileType.LUNAR_MINE_URBANIZATION) {
              vpb.setVictoryPoints('moon habitat', points);
            }
            break;
          }
        }
      });
    });
  }
}

================
File: moon/OneGiantStep.ts
================
import {Tag} from '../../common/cards/Tag';
import {BaseMilestone} from '../milestones/IMilestone';
import {IPlayer} from '../IPlayer';

export class OneGiantStep extends BaseMilestone {
  constructor() {
    super(
      'One Giant Step',
      // The original rules had "Have at least 4 moon tags in play" but that
      // was before the deck got 100% larger.
      'Have 6 moon tags',
      6);
  }

  public getScore(player: IPlayer): number {
    return player.tags.count(Tag.MOON, 'milestone');
  }
}

================
File: moon/PlaceMoonHabitatTile.ts
================
import {Space} from '../boards/Space';
import {IPlayer} from '../IPlayer';
import {BasePlaceMoonTile} from './BasePlaceMoonTile';
import {MoonData} from './MoonData';
import {MoonExpansion} from './MoonExpansion';

export class PlaceMoonHabitatTile extends BasePlaceMoonTile {
  constructor(
    player: IPlayer,
    spaces?: Array<Space>,
    title: string = 'Select a space on The Moon for a habitat tile.',
  ) {
    super(player, spaces, title);
  }

  protected getSpaces(moonData: MoonData): ReadonlyArray<Space> {
    return moonData.moon.getAvailableSpacesOnLand(this.player);
  }

  protected placeTile(space: Space) {
    MoonExpansion.addHabitatTile(this.player, space.id);
    MoonExpansion.raiseHabitatRate(this.player);
    return undefined;
  }
}

================
File: moon/PlaceMoonMineTile.ts
================
import {Space} from '../boards/Space';
import {IPlayer} from '../IPlayer';
import {BasePlaceMoonTile} from './BasePlaceMoonTile';
import {MoonData} from './MoonData';
import {MoonExpansion} from './MoonExpansion';

export class PlaceMoonMineTile extends BasePlaceMoonTile {
  constructor(
    player: IPlayer,
    spaces?: Array<Space>,
    title: string = 'Select a space on The Moon for a mining tile.',
  ) {
    super(player, spaces, title);
  }

  protected getSpaces(moonData: MoonData) {
    return moonData.moon.getAvailableSpacesForMine(this.player);
  }

  public placeTile(space: Space) {
    MoonExpansion.addMineTile(this.player, space.id);
    MoonExpansion.raiseMiningRate(this.player);
    return undefined;
  }
}

================
File: moon/PlaceMoonRoadTile.ts
================
import {Space} from '../boards/Space';
import {IPlayer} from '../IPlayer';
import {BasePlaceMoonTile} from './BasePlaceMoonTile';
import {MoonData} from './MoonData';
import {MoonExpansion} from './MoonExpansion';

export class PlaceMoonRoadTile extends BasePlaceMoonTile {
  constructor(
    player: IPlayer,
    spaces?: Array<Space>,
    title = 'Select a space on The Moon for a road tile.',
  ) {
    super(player, spaces, title);
  }

  protected getSpaces(moonData: MoonData) {
    return moonData.moon.getAvailableSpacesOnLand(this.player);
  }

  protected placeTile(space: Space) {
    MoonExpansion.addRoadTile(this.player, space.id);
    MoonExpansion.raiseLogisticRate(this.player);
    return undefined;
  }
}

================
File: moon/PlaceSpecialMoonTile.ts
================
import {DeferredAction} from '../deferredActions/DeferredAction';
import {Priority} from '../deferredActions/Priority';
import {SelectSpace} from '../inputs/SelectSpace';
import {Tile} from '../Tile';
import {IPlayer} from '../IPlayer';
import {MoonExpansion} from './MoonExpansion';
import {Message} from '@/common/logs/Message';
import {message} from '../logs/MessageBuilder';

export class PlaceSpecialMoonTile extends DeferredAction {
  constructor(
    player: IPlayer,
    public tile: Tile,
    public title: string | Message = message('Select a space on The Moon for ${0}', (b) => b.tileType(tile.tileType)),
  ) {
    super(player, Priority.DEFAULT);
  }

  public execute() {
    const moonData = MoonExpansion.moonData(this.player.game);
    const spaces = moonData.moon.getAvailableSpacesOnLand(this.player);

    if (spaces.length === 0) {
      return undefined;
    }
    return new SelectSpace(this.title, spaces)
      .andThen((space) => {
        MoonExpansion.addTile(this.player, space.id, this.tile);
        return undefined;
      });
  }
}

================
File: moon/SellSteel.ts
================
import {DeferredAction} from '../deferredActions/DeferredAction';
import {Priority} from '../deferredActions/Priority';
import {SelectAmount} from '../inputs/SelectAmount';
import {IPlayer} from '../IPlayer';
import {Resource} from '../../common/Resource';

export class SellSteel extends DeferredAction {
  constructor(
    player: IPlayer,
    public title: string = 'Sell your steel for 3M€ each.',
  ) {
    super(player, Priority.DEFAULT);
  }

  private logSale(unitsSold: number) {
    this.player.game.log('${0} sold ${1} steel', (b) => b.player(this.player).number(unitsSold));
  }
  public execute() {
    const unitsAvailable = this.player.steel;
    if (unitsAvailable <= 0) {
      this.logSale(0);
      return undefined;
    }
    return new SelectAmount('Select a number of units of steel to sell', 'Sell steel', 0, unitsAvailable)
      .andThen((unitsSold: number) => {
        if (unitsSold > 0) {
          const cashEarned = unitsSold * 3;
          this.player.stock.add(Resource.MEGACREDITS, cashEarned);
          this.player.stock.deduct(Resource.STEEL, unitsSold);
        }
        this.logSale(unitsSold);
        return undefined;
      });
  }
}

================
File: moon/SerializedMoonData.ts
================
import {SerializedBoard} from '../boards/SerializedBoard';
import {PlayerId} from '../../common/Types';

export interface SerializedMoonData {
  moon: SerializedBoard;
  habitatRate: number;
  miningRate: number;
  logisticRate: number;
  lunaFirstPlayerId: PlayerId | undefined;
  lunaProjectOfficeLastGeneration: number | undefined;
}

================
File: pathfinders/CrashlandingBonus.ts
================
import {IGame} from '../IGame';
import {SpaceBonus} from '../../common/boards/SpaceBonus';
import {Board} from '../boards/Board';
import {Space} from '../boards/Space';

// Reward portion of Crashlanding. It's split out to prevent recursive source loading.
export class CrashlandingBonus {
  public static onTilePlacedAdjacentToCrashlanding(game: IGame, crashlandingSpace: Space, newTileSpace: Space): Array<SpaceBonus> {
    const position = this.getAdjacentPosition(game.board, crashlandingSpace, newTileSpace);
    if (position === -1) return [];
    const mod = crashlandingSpace.tile?.rotated ? 1 : 0;
    return [SpaceBonus.DATA, (position % 2 === mod) ? SpaceBonus.STEEL : SpaceBonus.TITANIUM];
  }

  /*
   * Find where b is in relation to a.
   *
   *    1 2
   *   0 a 3
   *    5 4
   *
   * If b is not next to a, return -1.
   */
  static getAdjacentPosition(board: Board, a: Space, b: Space): number {
    const spaces = board.getAdjacentSpacesClockwise(a);
    return spaces.findIndex((space) => space?.id === b.id);
  }
}

================
File: pathfinders/DeclareCloneTag.ts
================
import {IPlayer} from '../IPlayer';
import {DeferredAction} from '../deferredActions/DeferredAction';
import {Priority} from '../deferredActions/Priority';
import {OrOptions} from '../inputs/OrOptions';
import {SelectOption} from '../inputs/SelectOption';
import {ICloneTagCard} from '../cards/pathfinders/ICloneTagCard';
import {IProjectCard} from '../cards/IProjectCard';
import {isPlanetaryTag, PLANETARY_TAGS, PlanetaryTag} from '../pathfinders/PathfindersData';
import {intersection} from '../../common/utils/utils';
import {message} from '../logs/MessageBuilder';
import {Message} from '../../common/logs/Message';

/**
 * Declare what tag a new card has. Must occur before anything else, including
 * the standard behavior that comes from onCardPlayed.
 *
 * To handle the onCardPlayed nature, `Player` doesn't call onCardPlayed
 * when the card has a clone tag, and instead defers that call.
 * That's why it calls onCardPlayed here.
 */
export class DeclareCloneTag extends DeferredAction<PlanetaryTag> {
  public constructor(
    player: IPlayer,
    public card: IProjectCard & ICloneTagCard,
    public title: string | Message | undefined = undefined) {
    super(player, Priority.DECLARE_CLONE_TAG);
  }

  public execute() {
    // This finds all the valid tags in the game.
    // It also relies in `intersection` preserving order of the first array
    // which defines the order of tags in SelectOption.
    const tags = intersection(
      PLANETARY_TAGS,
      this.player.game.tags.filter(isPlanetaryTag));

    const options = tags.map((tag) => {
      return new SelectOption(tag, 'Choose').andThen(() => {
        this.card.cloneTag = tag;
        this.player.game.log('${0} turned the clone tag on ${1} into a ${2} tag',
          (b) => b.player(this.player).card(this.card).string(tag));
        this.player.onCardPlayed(this.card);
        this.cb(tag);
        return undefined;
      });
    });
    const orOptions = new OrOptions(...options);
    if (this.title === undefined) {
      this.title = message('Assign the clone tag for ${0}', (b) => b.cardName(this.card.name));
    }
    orOptions.title = this.title;
    return orOptions;
  }
}

================
File: pathfinders/GrantResourceDeferred.ts
================
import {OrOptions} from '../inputs/OrOptions';
import {SelectCard} from '../inputs/SelectCard';
import {DeferredAction} from '../deferredActions/DeferredAction';
import {Priority} from '../deferredActions/Priority';
import {IPlayer} from '../IPlayer';
import {GainResources} from '../inputs/GainResources';

// TODO(kberg): Copied from GrantVenusAltTrackBonusDeferred, get these together.
export class GrantResourceDeferred extends DeferredAction {
  constructor(player: IPlayer, public wild: boolean = true) {
    super(player, Priority.GAIN_RESOURCE_OR_PRODUCTION);
  }

  public execute() {
    const options = new OrOptions();
    options.title = 'Choose your resource bonus';
    options.options.push(new GainResources(this.player, 1, 'Gain 1 standard resource.'));
    if (this.wild) {
      const cards = this.player.getResourceCards(undefined);
      if (cards.length > 0) {
        options.options.push(new SelectCard('Add resource to card', 'Add resource', this.player.getResourceCards(undefined))
          .andThen(([card]) => {
            this.player.addResourceTo(card, {qty: 1, log: true});
            return undefined;
          }));
        options.title = 'Choose your wild resource bonus.';
      }
    }
    return options;
  }
}

================
File: pathfinders/PathfindersData.ts
================
import {PlayerId} from '../../common/Types';
import {Tag} from '../../common/cards/Tag';
import {SerializedPathfindersData} from './SerializedPathfindersData';

/**
 * The possible tags with planetary tracks.
 *
 * The order of this list matches the order of the list displayed in the UI.
 */
export const PLANETARY_TAGS = [Tag.VENUS, Tag.EARTH, Tag.MARS, Tag.JOVIAN, Tag.MOON] as const;
export type PlanetaryTag = typeof PLANETARY_TAGS[number];


export function isPlanetaryTag(tag: Tag): tag is PlanetaryTag {
  return PLANETARY_TAGS.includes(tag as PlanetaryTag);
}

export type PathfindersData = Record<PlanetaryTag, number> & {
  vps: Array<{id: PlayerId, tag: PlanetaryTag, points: number}>;
}

export namespace PathfindersData {
  export function serialize(pathfindersData: PathfindersData | undefined): SerializedPathfindersData | undefined {
    if (pathfindersData === undefined) {
      return undefined;
    }
    return {
      venus: pathfindersData.venus,
      earth: pathfindersData.earth,
      mars: pathfindersData.mars,
      jovian: pathfindersData.jovian,
      moon: pathfindersData.moon,
      vps: pathfindersData.vps,
    };
  }

  export function deserialize(pathfindersData: SerializedPathfindersData): PathfindersData {
    return {
      venus: pathfindersData.venus,
      earth: pathfindersData.earth,
      mars: pathfindersData.mars,
      jovian: pathfindersData.jovian,
      moon: pathfindersData.moon,
      vps: pathfindersData.vps,
    };
  }
}

================
File: pathfinders/PathfindersExpansion.ts
================
import {AddResourcesToCard} from '../deferredActions/AddResourcesToCard';
import {CardName} from '../../common/cards/CardName';
import {IGame} from '../IGame';
import {GameOptions} from '../game/GameOptions';
import {GrantResourceDeferred} from './GrantResourceDeferred';
import {ICard} from '../cards/ICard';
import {PathfindersData, PlanetaryTag, isPlanetaryTag} from './PathfindersData';
import {PlaceCityTile} from '../deferredActions/PlaceCityTile';
import {PlaceGreeneryTile} from '../deferredActions/PlaceGreeneryTile';
import {PlaceMoonMineTile} from '../moon/PlaceMoonMineTile';
import {PlaceMoonRoadTile} from '../moon/PlaceMoonRoadTile';
import {PlaceOceanTile} from '../deferredActions/PlaceOceanTile';
import {PlanetaryTracks} from '../../common/pathfinders/PlanetaryTracks';
import {IPlayer} from '../IPlayer';
import {Resource} from '../../common/Resource';
import {CardResource} from '../../common/CardResource';
import {Reward} from '../../common/pathfinders/Reward';
import {GainResources} from '../inputs/GainResources';
import {SendDelegateToArea} from '../deferredActions/SendDelegateToArea';
import {Tag} from '../../common/cards/Tag';
import {Turmoil} from '../turmoil/Turmoil';
import {VictoryPointsBreakdown} from '../game/VictoryPointsBreakdown';
import {GlobalEventName} from '../../common/turmoil/globalEvents/GlobalEventName';
import {Priority} from '../deferredActions/Priority';

export const TRACKS = PlanetaryTracks.initialize();

export class PathfindersExpansion {
  private constructor() {
  }

  public static initialize(gameOptions: GameOptions): PathfindersData {
    return {
      venus: gameOptions.venusNextExtension ? 0 : -1,
      earth: 0,
      mars: 0,
      jovian: 0,
      moon: gameOptions.moonExpansion ? 0 : -1,
      vps: [],
    };
  }

  public static onCardPlayed(player: IPlayer, card: ICard) {
    if (player.game.gameOptions.pathfindersExpansion === false) {
      return;
    }
    const tags = card.tags;
    tags.forEach((tag) => {
      if (isPlanetaryTag(tag)) {
        PathfindersExpansion.raiseTrack(tag, player);
      }
    });
  }

  public static raiseTrack(tag: PlanetaryTag, player: IPlayer, steps: number = 1): void {
    PathfindersExpansion.raiseTrackEssense(tag, player, player.game, steps, true);
  }

  public static raiseTrackForGlobalEvent(tag: PlanetaryTag, name: GlobalEventName, game: IGame, steps: number = 1, gainRewards: boolean = true): void {
    PathfindersExpansion.raiseTrackEssense(tag, name, game, steps, gainRewards);
  }

  private static raiseTrackEssense(tag: PlanetaryTag, from: IPlayer | GlobalEventName, game: IGame, steps: number = 1, gainRewards: boolean = true): void {
    const data = game.pathfindersData;
    if (data === undefined) {
      return;
      // throw new Error('Pathfinders not defined');
    }

    const track = TRACKS[tag];
    if (track === undefined) {
      return;
    }

    let space = data[tag];

    // Do not raise tracks unused this game.
    if (space === -1) {
      return;
    }

    const lastSpace = Math.min(track.spaces.length - 1, space + steps);
    const distance = lastSpace - space;
    if (distance === 0) return;

    if (typeof(from) === 'object') {
      game.log('${0} raised the ${1} planetary track ${2} step(s)', (b) => {
        b.player(from).string(tag).number(distance);
      });
    } else {
      game.log('Global Event ${0} raised the ${1} planetary track ${2} step(s)', (b) => {
        b.globalEventName(from).string(tag).number(distance);
      });
    }

    // game.indentation++;
    while (space < lastSpace) {
      space++;
      data[tag] = space;
      const rewards = track.spaces[space];

      // Can be false because of the Constant Struggle global event.
      if (gainRewards) {
        if (typeof(from) === 'object') {
          rewards.risingPlayer.forEach((reward) => {
            PathfindersExpansion.grant(reward, from, tag);
          });
        }
        rewards.everyone.forEach((reward) => {
          game.getPlayers().forEach((p) => {
            PathfindersExpansion.grant(reward, p, tag);
          });
        });
        if (rewards.mostTags.length > 0) {
          const players = PathfindersExpansion.playersWithMostTags(
            tag,
            game.getPlayers().slice(),
            (typeof(from) === 'object') ? from : undefined);
          rewards.mostTags.forEach((reward) => {
            players.forEach((p) => {
              PathfindersExpansion.grant(reward, p, tag);
            });
          });
        }
      }
      // game.indentation--;
    }
  }

  /**
   * Grant the specified award.
   *
   * @param reward the reward to grant
   * @param player the player gaining the reward (which may not be the same as the player who triggers the reward)
   * @param tag the tag associated with the reward (used for logging VP rewards.)
   */
  public static grant(reward: Reward, player: IPlayer, tag: PlanetaryTag): void {
    const game = player.game;

    switch (reward) {
    case '1vp':
      game.pathfindersData?.vps.push({id: player.id, tag, points: 1});
      game.log('${0} has the most ${1} tags and earns 1VP', (b) => b.player(player).string(tag));
      break;
    case '2vp':
      game.pathfindersData?.vps.push({id: player.id, tag, points: 2});
      game.log('${0} has the most ${1} tags and earns 2VP', (b) => b.player(player).string(tag));
      break;
    case '3mc':
      player.stock.add(Resource.MEGACREDITS, 3, {log: true});
      break;
    case '6mc':
      player.stock.add(Resource.MEGACREDITS, 6, {log: true});
      break;
    case 'any_resource':
      game.defer(new GrantResourceDeferred(player, false));
      break;
    case 'card':
      player.drawCard();
      break;
    case 'city':
      game.defer(new PlaceCityTile(player));
      break;
    case 'delegate':
      Turmoil.ifTurmoilElse(game,
        (turmoil) => {
          if (turmoil.hasDelegatesInReserve(player)) {
            game.defer(new SendDelegateToArea(player));
          }
        },
        () => player.stock.add(Resource.MEGACREDITS, 3, {log: true}));
      break;
    case 'energy':
      player.stock.add(Resource.ENERGY, 1, {log: true});
      break;
    case 'energy_production':
      player.production.add(Resource.ENERGY, 1, {log: true});
      break;
    case 'floater':
      game.defer(new AddResourcesToCard(player, CardResource.FLOATER));
      break;
    case 'greenery':
      game.defer(new PlaceGreeneryTile(player));
      break;
    case 'heat':
      player.stock.add(Resource.HEAT, 1, {log: true});
      break;
    case 'heat_production':
      player.production.add(Resource.HEAT, 1, {log: true});
      break;
    case 'moon_mine':
      game.defer(new PlaceMoonMineTile(player));
      break;
    case 'moon_road':
      game.defer(new PlaceMoonRoadTile(player));
      break;
    case 'ocean':
      game.defer(new PlaceOceanTile(player));
      break;
    case 'plant':
      player.stock.add(Resource.PLANTS, 1, {log: true});
      break;
    case 'plant_production':
      player.production.add(Resource.PLANTS, 1, {log: true});
      break;
    case 'resource':
      player.defer(new GainResources(player, 1, 'Gain 1 resource for your Planetary track bonus.'));
      break;
    case 'steel':
      player.stock.add(Resource.STEEL, 1, {log: true});
      break;
    case 'steel_production':
      player.production.add(Resource.STEEL, 1, {log: true});
      break;
    case 'titanium':
      player.stock.add(Resource.TITANIUM, 1, {log: true});
      break;
    case 'titanium_production':
      player.production.add(Resource.TITANIUM, 1, {log: true});
      break;
    case 'tr':
      player.increaseTerraformRating();
      break;
    case 'venus_scale':
      if (game.gameOptions.venusNextExtension) {
        game.increaseVenusScaleLevel(player, 1);
      } else {
        player.game.log('TODO: come up with some reward in place of Increase Venus Scale.');
      }
      break;
    default:
      throw new Error('Unknown reward: ' + reward);
    }
  }

  private static playersWithMostTags(tag: Tag, players: Array<IPlayer>, activePlayer: IPlayer | undefined): Array<IPlayer> {
    const counts = players.map((player) => {
      // Wild tags only apply to a player taking an action.
      const includeWildTags = player.id === activePlayer?.id;
      const count = player.tags.count(tag, includeWildTags ? 'default' : 'raw');
      return {player, count};
    });
    const max = Math.max(...counts.map((c) => c.count));
    const filtered = counts.filter((c) => c.count === max);
    const result = filtered.map((c) => c.player);
    return result;
  }

  public static calculateVictoryPoints(player: IPlayer, victoryPointsBreakdown: VictoryPointsBreakdown) {
    const data = player.game.pathfindersData;
    if (data === undefined) {
      return;
    }
    data.vps
      .filter((vp) => vp.id === player.id)
      .forEach((vp) => victoryPointsBreakdown.setVictoryPoints('planetary tracks', vp.points, vp.tag));
  }

  public static addToSolBank(player: IPlayer) {
    const solBank = player.getCorporation(CardName.SOLBANK);
    if (solBank !== undefined) {
      player.defer(
        () => player.addResourceTo(solBank, {qty: 1, log: true}),
        Priority.GAIN_RESOURCE_OR_PRODUCTION);
    }
  }
}

================
File: pathfinders/SerializedPathfindersData.ts
================
import {PlayerId} from '../../common/Types';
import {PlanetaryTag} from './PathfindersData';

export type SerializedPathfindersData = {
  venus: number;
  earth: number;
  mars: number;
  jovian: number;
  moon: number;
  vps: Array<{id: PlayerId, tag: PlanetaryTag, points: number}>;
}

================
File: Player.ts
================
import * as constants from '../common/constants';
import {PlayerId} from '../common/Types';
import {MILESTONE_COST, REDS_RULING_POLICY_COST} from '../common/constants';
import {cardsFromJSON, ceosFromJSON, corporationCardsFromJSON, newCorporationCard} from './createCard';
import {CardName} from '../common/cards/CardName';
import {CardType} from '../common/cards/CardType';
import {Color} from '../common/Color';
import {ICorporationCard} from './cards/corporation/ICorporationCard';
import {IGame} from './IGame';
import {Game} from './Game';
import {Payment, PaymentOptions, DEFAULT_PAYMENT_VALUES} from '../common/inputs/Payment';
import {SpendableResource, SPENDABLE_RESOURCES, SpendableCardResource, CARD_FOR_SPENDABLE_RESOURCE} from '../common/inputs/Spendable';
import {IAward} from './awards/IAward';
import {ICard, isIActionCard, IActionCard} from './cards/ICard';
import {IMilestone} from './milestones/IMilestone';
import {IProjectCard} from './cards/IProjectCard';
import {OrOptions} from './inputs/OrOptions';
import {PartyHooks} from './turmoil/parties/PartyHooks';
import {PartyName} from '../common/turmoil/PartyName';
import {Phase} from '../common/Phase';
import {PlayerInput} from './PlayerInput';
import {Resource} from '../common/Resource';
import {CardResource} from '../common/CardResource';
import {SelectCard} from './inputs/SelectCard';
import {SellPatentsStandardProject} from './cards/base/standardActions/standardProjects/SellPatentsStandardProject';
import {SimpleDeferredAction} from './deferredActions/DeferredAction';
import {Priority} from './deferredActions/Priority';
import {SelectPaymentDeferred} from './deferredActions/SelectPaymentDeferred';
import {SelectProjectCardToPlay} from './inputs/SelectProjectCardToPlay';
import {SelectOption} from './inputs/SelectOption';
import {SelectSpace} from './inputs/SelectSpace';
import {SelfReplicatingRobots} from './cards/promo/SelfReplicatingRobots';
import {SerializedCard} from './SerializedCard';
import {SerializedPlayer} from './SerializedPlayer';
import {StormCraftIncorporated} from './cards/colonies/StormCraftIncorporated';
import {Tag} from '../common/cards/Tag';
import {Timer} from '../common/Timer';
import {TurmoilHandler} from './turmoil/TurmoilHandler';
import {GameCards} from './GameCards';
import {AllOptions, DrawCards, DrawOptions} from './deferredActions/DrawCards';
import {Units} from '../common/Units';
import {MoonExpansion} from './moon/MoonExpansion';
import {IStandardProjectCard} from './cards/IStandardProjectCard';
import {ConvertPlants} from './cards/base/standardActions/ConvertPlants';
import {ConvertHeat} from './cards/base/standardActions/ConvertHeat';
import {GlobalParameter} from '../common/GlobalParameter';
import {LogHelper} from './LogHelper';
import {UndoActionOption} from './inputs/UndoActionOption';
import {Turmoil} from './turmoil/Turmoil';
import {PathfindersExpansion} from './pathfinders/PathfindersExpansion';
import {deserializeProjectCard, serializeProjectCard} from './cards/cardSerialization';
import {ColoniesHandler} from './colonies/ColoniesHandler';
import {MonsInsurance} from './cards/promo/MonsInsurance';
import {InputResponse} from '../common/inputs/InputResponse';
import {Tags} from './player/Tags';
import {Colonies} from './player/Colonies';
import {Production} from './player/Production';
import {Stock} from './player/Stock';
import {Merger} from './cards/promo/Merger';
import {getBehaviorExecutor} from './behavior/BehaviorExecutor';
import {CeoExtension} from './CeoExtension';
import {ICeoCard, isCeoCard} from './cards/ceos/ICeoCard';
import {message} from './logs/MessageBuilder';
import {calculateVictoryPoints} from './game/calculateVictoryPoints';
import {IVictoryPointsBreakdown} from '../common/game/IVictoryPointsBreakdown';
import {YesAnd} from './cards/requirements/CardRequirement';
import {PlayableCard} from './cards/IProjectCard';
import {CanAffordOptions, CardAction, IPlayer, ResourceSource, isIPlayer} from './IPlayer';
import {IPreludeCard} from './cards/prelude/IPreludeCard';
import {copyAndClear, inplaceRemove, sum} from '../common/utils/utils';
import {PreludesExpansion} from './preludes/PreludesExpansion';
import {ChooseCards} from './deferredActions/ChooseCards';
import {UnderworldPlayerData} from './underworld/UnderworldData';
import {UnderworldExpansion} from './underworld/UnderworldExpansion';
import {Counter} from './behavior/Counter';
import {SelectAmount} from './inputs/SelectAmount';
import {GenerationData} from './player/GenerationData';
import {TRSource} from '../common/cards/TRSource';
import {IParty} from './turmoil/parties/IParty';
import {AlliedParty} from './turmoil/AlliedParty';
import {newStandardDraft} from './Draft';

const THROW_STATE_ERRORS = Boolean(process.env.THROW_STATE_ERRORS);

export class Player implements IPlayer {
  public readonly id: PlayerId;
  protected waitingFor?: PlayerInput;
  protected waitingForCb?: () => void;
  public game: IGame;
  public tags: Tags;
  public colonies: Colonies;
  public readonly production: Production;
  public readonly stock: Stock;
  private _alliedParty: AlliedParty | undefined;

  //andy added
  
  public hasTraded: boolean = false;

  //andy helion
  public heatDiscount: number = 0;

  // Corporate identity
  public corporations: Array<ICorporationCard> = [];

  // Used only during set-up
  public pickedCorporationCard?: ICorporationCard;

  // Terraforming Rating
  private terraformRating: number = 20;

  public get megaCredits(): number {
    return this.stock.megacredits;
  }

  public get steel(): number {
    return this.stock.steel;
  }

  public get titanium(): number {
    return this.stock.titanium;
  }

  public get plants(): number {
    return this.stock.plants;
  }

  public get energy(): number {
    return this.stock.energy;
  }
  public get heat(): number {
    return this.stock.heat;
  }

  public get alliedParty(): AlliedParty | undefined {
    return this._alliedParty;
  }

  public set megaCredits(megacredits: number) {
    this.stock.megacredits = megacredits;
  }

  public set steel(steel: number) {
    this.stock.steel = steel;
  }

  public set titanium(titanium: number) {
    this.stock.titanium = titanium;
  }

  public set plants(plants: number) {
    this.stock.plants = plants;
  }

  public set energy(energy: number) {
    this.stock.energy = energy;
  }

  public set heat(heat: number) {
    this.stock.heat = heat;
  }

  public setAlliedParty(p: IParty) {
    this._alliedParty = {
      partyName: p.name,
      agenda: {
        bonusId: p.bonuses[0].id,
        policyId: p.policies[0].id,
      },
    };
    const alliedPolicy = this.game.turmoil?.getPartyByName(p.name).policies.find((t) => t.id === p.policies[0].id);

    alliedPolicy?.onPolicyStartForPlayer?.(this);
  }

  // Resource values
  private titaniumValue: number = 3;
  private steelValue: number = 2;
  // Helion
  public canUseHeatAsMegaCredits: boolean = false;
  // Martian Lumber Corp
  public canUsePlantsAsMegacredits: boolean = false;
  // Luna Trade Federation
  public canUseTitaniumAsMegacredits: boolean = false;
  // Friends in High Places
  public canUseCorruptionAsMegacredits: boolean = false;


  // This generation / this round
  public actionsTakenThisRound: number = 0;
  private actionsThisGeneration: Set<CardName> = new Set();
  public lastCardPlayed: CardName | undefined;
  public pendingInitialActions: Array<ICorporationCard> = [];

  // Cards
  public dealtCorporationCards: Array<ICorporationCard> = [];
  public dealtPreludeCards: Array<IProjectCard> = [];
  public dealtCeoCards: Array<ICeoCard> = [];
  public dealtProjectCards: Array<IProjectCard> = [];
  public cardsInHand: Array<IProjectCard> = [];
  public preludeCardsInHand: Array<IPreludeCard> = [];
  public ceoCardsInHand: Array<IProjectCard> = [];
  public playedCards: Array<IProjectCard> = [];
  public draftedCards: Array<IProjectCard> = [];
  public draftHand: Array<IProjectCard> = [];
  public cardCost: number = constants.CARD_COST;
  public needsToDraft?: boolean;

  public timer: Timer = Timer.newInstance();
  public autopass = false;

  // Turmoil
  public turmoilPolicyActionUsed: boolean = false;
  public politicalAgendasActionUsedCount: number = 0;

  public oceanBonus: number = constants.OCEAN_BONUS;

  // Custom cards
  // Community Leavitt Station and Pathfinders Leavitt Station
  // TODO(kberg): move scienceTagCount to Tags?
  public scienceTagCount: number = 0;
  // PoliticalAgendas Scientists P41
  public hasTurmoilScienceTagBonus: boolean = false;
  // Ecoline
  public plantsNeededForGreenery: number = 8;

  //andy Helion
  public heatNeededForTemperature: number = 8;
  // Lawsuit
  public removingPlayers: Array<PlayerId> = [];
  // For Playwrights corp.
  // removedFromPlayCards is a bit of a misname: it's a temporary storage for
  // cards that provide 'next card' discounts. This will clear between turns.
  public removedFromPlayCards: Array<IProjectCard> = [];

  // Underworld
  public underworldData: UnderworldPlayerData = UnderworldExpansion.initializePlayer();

  // The number of actions a player can take this round.
  // It's almost always 2, but certain cards can change this value (Mars Maths, Tool with the First Order)
  //
  // This value isn't serialized. Probably ought to be.
  public availableActionsThisRound = 2;

  // Stats
  public actionsTakenThisGame: number = 0;
  public victoryPointsByGeneration: Array<number> = [];
  public totalDelegatesPlaced: number = 0;

  public optionalEnergyConversion: boolean = false;

  public generationData: GenerationData;

  constructor(
    public name: string,
    public color: Color,
    public beginner: boolean,
    public handicap: number = 0,
    id: PlayerId) {
    this.id = id;
    // This seems pretty bad. The game will be set before the Player is actually
    // used, and if that doesn't happen, well, it's a worthy error.
    // The alterantive, to make game type Game | undefined, will cause compilation
    // issues throughout the app.
    // Ideally the right thing is to invert how players and games get created.
    // But one thing at a time.
    this.game = undefined as unknown as Game;
    this.tags = new Tags(this);
    this.colonies = new Colonies(this);
    this.production = new Production(this);
    this.stock = new Stock(this);
    this.generationData = new GenerationData();
  }

  public static initialize(
    name: string,
    color: Color,
    beginner: boolean,
    handicap: number = 0,
    id: PlayerId): Player {
    const player = new Player(name, color, beginner, handicap, id);
    return player;
  }

  public tearDown() {
    this.game = undefined as unknown as Game;
  }

  public get tableau(): Array<ICorporationCard | IProjectCard> {
    return [...this.corporations, ...this.playedCards];
  }

  public isCorporation(corporationName: CardName): boolean {
    return this.getCorporation(corporationName) !== undefined;
  }

  public getCorporation(corporationName: CardName): ICorporationCard | undefined {
    return this.corporations.find((c) => c.name === corporationName);
  }

  public getCorporationOrThrow(corporationName: CardName): ICorporationCard {
    const corporation = this.getCorporation(corporationName);
    if (corporation === undefined) {
      throw new Error(`player ${this.name} does not have corporation ${corporationName}`);
    }
    return corporation;
  }

  public getTitaniumValue(): number {
    return this.titaniumValue;
  }

  public increaseTitaniumValue(): void {
    this.titaniumValue++;
  }

  public decreaseTitaniumValue(): void {
    if (this.titaniumValue > 0) {
      this.titaniumValue--;
    }
  }

  public getSelfReplicatingRobotsTargetCards(): Array<IProjectCard> {
    const selfReplicatingRobots = this.playedCards.find((card) => card instanceof SelfReplicatingRobots);
    if (selfReplicatingRobots instanceof SelfReplicatingRobots) {
      return selfReplicatingRobots.targetCards;
    }
    return [];
  }

  public getSteelValue(): number {
    return this.steelValue;
  }

  public increaseSteelValue(): void {
    this.steelValue++;
  }

  public decreaseSteelValue(): void {
    if (this.steelValue > 0) {
      this.steelValue--;
    }
  }

  public getTerraformRating(): number {
    return this.terraformRating;
  }

  public increaseTerraformRating(steps: number = 1, opts: {log?: boolean} = {}) {
    const raiseRating = () => {
      this.terraformRating += steps;
      this.generationData.hasRaisedTR = true;

      if (opts.log === true) {
        this.game.log('${0} gained ${1} TR', (b) => b.player(this).number(steps));
      }
      this.game.getPlayersInGenerationOrder().forEach((player) => {
        player.corporations.forEach((corp) => {
          corp.onIncreaseTerraformRating?.(this, player, steps);
        });
        player.playedCards.forEach((card) => {
          card.onIncreaseTerraformRating?.(this, player, steps);
        });
      });
    };

    if (PartyHooks.shouldApplyPolicy(this, PartyName.REDS, 'rp01')) {
      if (!this.canAfford(REDS_RULING_POLICY_COST * steps)) {
        // Cannot pay Reds, will not increase TR
        return;
      }
      this.game.defer(
        new SelectPaymentDeferred(this, REDS_RULING_POLICY_COST * steps, {title: 'Select how to pay for TR increase'}),
        Priority.COST)
        .andThen(raiseRating);
    } else {
      raiseRating();
    }
  }

  public decreaseTerraformRating(steps: number = 1, opts: {log?: boolean} = {}) {
    this.terraformRating -= steps;
    if (opts.log === true) {
      this.game.log('${0} lost ${1} TR', (b) => b.player(this).number(steps));
    }
  }

  public setTerraformRating(value: number) {
    return this.terraformRating = value;
  }

  public logUnitDelta(
    resource: Resource,
    amount: number,
    unitType: 'production' | 'amount',
    from: ResourceSource | undefined,
    stealing = false,
  ) {
    if (amount === 0) {
      // Logging zero units doesn't seem to happen
      return;
    }

    const modifier = amount > 0 ? 'increased' : 'decreased';
    const absAmount = Math.abs(amount);
    let message = '${0}\'s ${1} ' + unitType + ' ${2} by ${3}';

    if (from !== undefined) {
      if (stealing === true) {
        message = message + ' stolen';
      }
      message = message + ' by ${4}';
    }

    this.game.log(message, (b) => {
      b.player(this)
        .string(resource)
        .string(modifier)
        .number(absAmount);
      if (isIPlayer(from)) {
        b.player(from);
      } else if (typeof(from) === 'object') {
        b.cardName(from.name);
      } else if (typeof(from) === 'string') {
        b.globalEventName(from);
      }
    });
  }

  public getActionsThisGeneration(): Set<CardName> {
    return this.actionsThisGeneration;
  }

  public addActionThisGeneration(cardName: CardName): void {
    this.actionsThisGeneration.add(cardName);
    return;
  }

  public getVictoryPoints(): IVictoryPointsBreakdown {
    return calculateVictoryPoints(this);
  }

  public cardIsInEffect(cardName: CardName): boolean {
    return this.playedCards.some(
      (playedCard) => playedCard.name === cardName);
  }

  public hasProtectedHabitats(): boolean {
    return this.cardIsInEffect(CardName.PROTECTED_HABITATS);
  }

  public plantsAreProtected(): boolean {
    return this.hasProtectedHabitats() || this.cardIsInEffect(CardName.ASTEROID_DEFLECTION_SYSTEM);
  }

  public alloysAreProtected(): boolean {
    return this.cardIsInEffect(CardName.LUNAR_SECURITY_STATIONS);
  }

  public canHaveProductionReduced(resource: Resource, minQuantity: number, attacker: IPlayer) {
    const reducable = this.production[resource] + (resource === Resource.MEGACREDITS ? 5 : 0);
    if (reducable < minQuantity) return false;

    if (resource === Resource.STEEL || resource === Resource.TITANIUM) {
      if (this.alloysAreProtected()) return false;
    }

    // The pathfindersExpansion test is just an optimization for non-Pathfinders games.
    if (this.game.gameOptions.pathfindersExpansion && this.productionIsProtected(attacker)) return false;
    return true;
  }


  public maybeBlockAttack(perpetrator: IPlayer, cb: (proceed: boolean) => PlayerInput | undefined): void {
    this.defer(UnderworldExpansion.maybeBlockAttack(this, perpetrator, cb));
  }

  public productionIsProtected(attacker: IPlayer): boolean {
    return attacker !== this && this.cardIsInEffect(CardName.PRIVATE_SECURITY);
  }

  public resolveInsurance() {
  // game.monsInsuranceOwner could be eliminated entirely if there
  // was a fast version of getCardPlayer().
  // I mean, it could be eliminated now, but getCardPlayer is expensive, and
  // checking for who is Mons Insurance is called often even when the card
  // is out of play.
    const game = this.game;
    if (game.monsInsuranceOwner !== undefined && game.monsInsuranceOwner !== this.id) {
      const monsInsuranceOwner = game.getPlayerById(game.monsInsuranceOwner);
      const monsInsurance = <MonsInsurance> monsInsuranceOwner.getCorporationOrThrow(CardName.MONS_INSURANCE);
      monsInsurance.payDebt(monsInsuranceOwner, this);
    }
  }
  public legalFirmEffect(attackingPlayer: IPlayer) {
    if (this.cardIsInEffect(CardName.LEGAL_FIRM) || this.cardIsInEffect(CardName.LEGAL_EXPERTS)) {
      const retribution = Math.min(attackingPlayer.stock.megacredits, 3);
      attackingPlayer.stock.deduct(Resource.MEGACREDITS, retribution, {log: false});
      this.game.log('${0} payed a retribution of ${1} M€ to ${2}', (b) => b.player(attackingPlayer).number(retribution).player(this));
      this.stock.megacredits += retribution;
      // The reason this isn't using the 'stealing' or 'from' option for resource deduction is to circumvent a possible infinite loop if 2 players both have this effect
    }
  }

  public resolveInsuranceInSoloGame() {
    const monsInsurance = <MonsInsurance> this.getCorporation(CardName.MONS_INSURANCE);
    monsInsurance?.payDebt(this, undefined);
  }

  public getColoniesCount() {
    if (!this.game.gameOptions.coloniesExtension) return 0;

    let coloniesCount = 0;

    this.game.colonies.forEach((colony) => {
      coloniesCount += colony.colonies.filter((owner) => owner === this.id).length;
    });

    return coloniesCount;
  }

  /*
   * When playing Pharmacy Union, if the card is discarded, then it sits in the event pile.
   * That's why it's included below. The FAQ describes how this applies to things like the
   * Legend Milestone, Media Archives, and NOT Media Group.
   */
  public getPlayedEventsCount(): number {
    let count = this.playedCards.filter((card) => card.type === CardType.EVENT).length;
    if (this.getCorporation(CardName.PHARMACY_UNION)?.isDisabled) count++;

    return count;
  }

  public getGlobalParameterRequirementBonus(parameter: GlobalParameter): number {
    let requirementsBonus = 0;
    for (const card of this.tableau) {
      requirementsBonus += card.getGlobalParameterRequirementBonus(this, parameter);
    }

    // PoliticalAgendas Scientists P2 hook
    if (PartyHooks.shouldApplyPolicy(this, PartyName.SCIENTISTS, 'sp02')) {
      requirementsBonus += 2;
    }

    return requirementsBonus;
  }

  public removeResourceFrom(card: ICard, count: number = 1, options?: {removingPlayer? : IPlayer, log?: boolean}): void {
    const removingPlayer = options?.removingPlayer;
    if (card.resourceCount) {
      const amountRemoved = Math.min(card.resourceCount, count);
      if (amountRemoved === 0) return;
      card.resourceCount -= amountRemoved;

      if (removingPlayer !== undefined && removingPlayer !== this) this.resolveInsurance();

      if (options?.log ?? true === true) {
        this.game.log('${0} removed ${1} resource(s) from ${2}\'s ${3}', (b) =>
          b.player(options?.removingPlayer ?? this)
            .number(amountRemoved)
            .player(this)
            .card(card));
      }

      // Lawsuit hook
      if (removingPlayer !== undefined && removingPlayer !== this && this.removingPlayers.includes(removingPlayer.id) === false) {
        this.removingPlayers.push(removingPlayer.id);
      }
    }
  }

  public addResourceTo(card: ICard, options: number | {qty?: number, log: boolean, logZero?: boolean} = 1): void {
    const count = typeof(options) === 'number' ? options : (options.qty ?? 1);

    if (card.resourceCount !== undefined) {
      card.resourceCount += count;
    }

    if (typeof(options) !== 'number' && options.log === true) {
      if (options.logZero === true || count !== 0) {
        LogHelper.logAddResource(this, card, count);
      }
    }

    if (count > 0) {
      for (const playedCard of this.tableau) {
        playedCard.onResourceAdded?.(this, card, count);
      }
    }
  }

  public getCardsWithResources(resource?: CardResource): Array<ICard> {
    let result = this.tableau.filter((card) => card.resourceType !== undefined && card.resourceCount && card.resourceCount > 0);

    if (resource !== undefined) {
      result = result.filter((card) => card.resourceType === resource);
    }

    return result;
  }

  public getResourceCards(resource?: CardResource): Array<ICard> {
    let result = this.tableau.filter((card) => card.resourceType !== undefined);

    if (resource !== undefined) {
      result = result.filter((card) => card.resourceType === resource || card.resourceType === CardResource.WARE);
    }

    return result;
  }

  public getResourceCount(resource: CardResource): number {
    return sum(this.getCardsWithResources(resource).map((card) => card.resourceCount));
  }

  public runInput(input: InputResponse, pi: PlayerInput): void {
    const result = pi.process(input, this);
    this.defer(result, Priority.DEFAULT);
  }

  public getAvailableBlueActionCount(): number {
    return this.getPlayableActionCards().length;
  }

  public getPlayableActionCards(): Array<ICard & IActionCard> {
    const result: Array<ICard & IActionCard> = [];
    for (const playedCard of this.tableau) {
      if (isIActionCard(playedCard) && !this.actionsThisGeneration.has(playedCard.name) && !isCeoCard(playedCard) && playedCard.canAct(this)) {
        result.push(playedCard);
      }
    }
    return result;
  }

  public getUsableOPGCeoCards(): Array<ICeoCard> {
    const result: Array<ICeoCard> = [];
    for (const playedCard of this.tableau) {
      if (isCeoCard(playedCard) && playedCard.canAct(this) ) {
        result.push(playedCard);
      }
    }
    return result;
  }

  public runProductionPhase(): void {
    
    this.actionsThisGeneration.clear();
    this.removingPlayers = [];

    this.turmoilPolicyActionUsed = false;
    this.politicalAgendasActionUsedCount = 0;

    if (this.optionalEnergyConversion) {
      if (this.energy === 0) {
        this.finishProductionPhase();
        return;
      }
      this.defer(new SelectAmount('Select amount of energy to convert to heat', 'OK', 0, this.energy, true).andThen((amount) => {
        this.energy -= amount;
        this.heat += amount;
        this.game.log('${0} converted ${1} units of energy to heat', (b) => b.player(this).number(amount));
        this.finishProductionPhase();
        return undefined;
      }));
    } else {
      this.heat += this.energy;
      this.energy = 0;
      this.finishProductionPhase();
    }
  }

  public finishProductionPhase() {
    this.megaCredits += this.production.megacredits + this.terraformRating;
    this.steel += this.production.steel;
    this.titanium += this.production.titanium;
    this.plants += this.production.plants;
    this.energy += this.production.energy;
    this.heat += this.production.heat;

    this.tableau.forEach((card) => card.onProductionPhase?.(this));
    // Turn off CEO OPG actions that were activated this generation
    for (const card of this.playedCards) {
      if (isCeoCard(card)) {
        card.opgActionIsActive = false;
      }
    }
  }

  private doneWorldGovernmentTerraforming(): void {
    this.game.deferredActions.runAll(() => this.game.doneWorldGovernmentTerraforming());
  }

  public worldGovernmentTerraforming(): void {
    const action = new OrOptions();
    action.title = 'Select action for World Government Terraforming';
    action.buttonLabel = 'Confirm';
    const game = this.game;
    if (game.getTemperature() < constants.MAX_TEMPERATURE) {
      action.options.push(
        new SelectOption('Increase temperature', 'Increase').andThen(() => {
          game.increaseTemperature(this, 1);
          game.log('${0} acted as World Government and increased temperature', (b) => b.player(this));
          return undefined;
        }),
      );
    }
    if (game.getOxygenLevel() < constants.MAX_OXYGEN_LEVEL) {
      action.options.push(
        new SelectOption('Increase oxygen', 'Increase').andThen(() => {
          game.increaseOxygenLevel(this, 1);
          game.log('${0} acted as World Government and increased oxygen level', (b) => b.player(this));
          return undefined;
        }),
      );
    }
    if (game.canAddOcean()) {
      action.options.push(
        new SelectSpace('Add an ocean', game.board.getAvailableSpacesForOcean(this))
          .andThen((space) => {
            game.addOcean(this, space);
            game.log('${0} acted as World Government and placed an ocean', (b) => b.player(this));
            return undefined;
          }),
      );
    }
    if (game.getVenusScaleLevel() < constants.MAX_VENUS_SCALE && game.gameOptions.venusNextExtension) {
      action.options.push(
        new SelectOption('Increase Venus scale', 'Increase').andThen(() => {
          game.increaseVenusScaleLevel(this, 1);
          game.log('${0} acted as World Government and increased Venus scale', (b) => b.player(this));
          return undefined;
        }),
      );
    }

    MoonExpansion.ifMoon(game, (moonData) => {
      if (moonData.habitatRate < constants.MAXIMUM_HABITAT_RATE) {
        action.options.push(
          new SelectOption('Increase the Moon habitat rate', 'Increase').andThen(() => {
            MoonExpansion.raiseHabitatRate(this, 1);
            return undefined;
          }),
        );
      }

      if (moonData.miningRate < constants.MAXIMUM_MINING_RATE) {
        action.options.push(
          new SelectOption('Increase the Moon mining rate', 'Increase').andThen(() => {
            MoonExpansion.raiseMiningRate(this, 1);
            return undefined;
          }),
        );
      }

      if (moonData.logisticRate < constants.MAXIMUM_LOGISTICS_RATE) {
        action.options.push(
          new SelectOption('Increase the Moon logistics rate', 'Increase').andThen(() => {
            MoonExpansion.raiseLogisticRate(this, 1);
            return undefined;
          }),
        );
      }
    });

    this.setWaitingFor(action, () => {
      this.doneWorldGovernmentTerraforming();
    });
  }

  /**
   * @return {number} the number of avaialble megacredits. Which is just a shorthand for megacredits,
   * plus any units of heat available thanks to Helion (and Stormcraft, by proxy).
   */
  public spendableMegacredits(): number {
    let total = this.megaCredits;
    if (this.canUseHeatAsMegaCredits) total += this.availableHeat();
    if (this.canUseTitaniumAsMegacredits) total += this.titanium * (this.titaniumValue - 1);
    return total;
  }

  public runResearchPhase(): void {
    if (!this.game.gameOptions.draftVariant || this.game.isSoloMode()) {
      this.draftedCards = newStandardDraft(this.game).draw(this);
    }

    let selectable = this.draftedCards.length;
    if (this.isCorporation(CardName.MARS_MATHS) && !this.isCorporation(CardName.LUNA_PROJECT_OFFICE)) {
      selectable--;
    }

    // TODO(kberg): Using .execute to rely on directly calling setWaitingFor is not great.
    // It's because each player is drafting at the same time. Once again, the server isn't ideal
    // when it comes to handling multiple players at once.
    const action = new ChooseCards(this, copyAndClear(this.draftedCards), {paying: true, keepMax: selectable}).execute();
    this.setWaitingFor(action, () => this.game.playerIsFinishedWithResearchPhase(this));
  }

  public getCardCost(card: IProjectCard): number {
    let cost = card.cost;
    cost -= this.colonies.cardDiscount;

    this.tableau.forEach((playedCard) => {
      cost -= playedCard.getCardDiscount?.(this, card) ?? 0;
    });

    // Playwrights hook
    this.removedFromPlayCards.forEach((removedFromPlayCard) => {
      if (removedFromPlayCard.getCardDiscount !== undefined) {
        cost -= removedFromPlayCard.getCardDiscount(this, card);
      }
    });

    // TODO(kberg): put this in a callback.
    if (card.tags.includes(Tag.SPACE) && PartyHooks.shouldApplyPolicy(this, PartyName.UNITY, 'up04')) {
      cost -= 2;
    }

    return Math.max(cost, 0);
  }

  private paymentOptionsForCard(card: IProjectCard): PaymentOptions {
    const heavyAerospaceTech = card.tags.includes(Tag.SPACE) && this.cardIsInEffect(CardName.HEAVY_AEROSPACE_TECH);
    const ecologicalContract = card.tags.includes(Tag.PLANT) && this.cardIsInEffect(CardName.ECOLOGICAL_CONTRACT);
    const martianLumberCorp = card.tags.includes(Tag.BUILDING) && (this.cardIsInEffect(CardName.MARTIAN_LUMBER_CORP));
    const bioengineeringStudies = card.tags.includes(Tag.ANIMAL) && this.cardIsInEffect(CardName.BIOENGINEERING_STUDIES);
    const undergroundVenusBase = card.tags.includes(Tag.VENUS) && this.cardIsInEffect(CardName.UNDERGROUND_VENUS_BASE);
    const energyLab = card.tags.includes(Tag.POWER) && this.cardIsInEffect(CardName.ENERGY_LAB);
    const standardAlloys = card.type === CardType.STANDARD_PROJECT && this.cardIsInEffect(CardName.STANDARD_ALLOYS);
    return {
      heat: this.canUseHeatAsMegaCredits,
      steel: this.lastCardPlayed === CardName.LAST_RESORT_INGENUITY || card.tags.includes(Tag.BUILDING) || heavyAerospaceTech || undergroundVenusBase || standardAlloys,
      plants: martianLumberCorp || ecologicalContract,
      titanium: this.lastCardPlayed === CardName.LAST_RESORT_INGENUITY || card.tags.includes(Tag.SPACE),
      energy: energyLab,
      lunaTradeFederationTitanium: this.canUseTitaniumAsMegacredits,
      seeds: card.tags.includes(Tag.PLANT) || card.name === CardName.GREENERY_STANDARD_PROJECT,
      dirigiblesFloaters: card.tags.includes(Tag.VENUS),
      microbes: card.tags.includes(Tag.PLANT),
      lunaArchivesScience: card.tags.includes(Tag.MOON),
      // TODO(kberg): add this.isCorporation(CardName.SPIRE)
      spireScience: card.type === CardType.STANDARD_PROJECT,
      // TODO(kberg): add this.isCorporation(CardName.AURORAI)
      auroraiData: card.type === CardType.STANDARD_PROJECT,
      graphene: card.tags.includes(Tag.CITY) || card.tags.includes(Tag.SPACE),
      kuiperAsteroids: card.name === CardName.AQUIFER_STANDARD_PROJECT || card.name === CardName.ASTEROID_STANDARD_PROJECT,
      bioengineeringStudiesAnimals: bioengineeringStudies,
      asteroidBeltColonyAsteroids: card.tags.includes(Tag.SPACE),
      jovianConstructionYardFloaters: card.tags.includes(Tag.JOVIAN),
      aerialMassDriversFloaters: card.type === CardType.STANDARD_PROJECT,
      corruption: card.tags.includes(Tag.EARTH) && this.cardIsInEffect(CardName.FRIENDS_IN_HIGH_PLACES),
    };
  }

  public checkPaymentAndPlayCard(selectedCard: IProjectCard, payment: Payment, cardAction: CardAction = 'add') {
    const cardCost = this.getCardCost(selectedCard);

    const reserved = MoonExpansion.adjustedReserveCosts(this, selectedCard);

    if (!this.canSpend(payment, reserved)) {
      throw new Error('You do not have that many resources to spend');
    }

    if (payment.dirigiblesFloaters > 0) {
      if (selectedCard.name === CardName.STRATOSPHERIC_BIRDS && payment.dirigiblesFloaters === this.getSpendable('dirigiblesFloaters')) {
        const cardsWithFloater = this.getCardsWithResources(CardResource.FLOATER);
        if (cardsWithFloater.length === 1) {
          throw new Error('Cannot spend all floaters to play Stratospheric Birds');
        }
      }
    }

    if (payment.microbes > 0) {
      if (selectedCard.name === CardName.SOIL_ENRICHMENT && payment.microbes === this.getSpendable('microbes')) {
        const cardsWithMicrobe = this.getCardsWithResources(CardResource.MICROBE);
        if (cardsWithMicrobe.length === 1) {
          throw new Error('Cannot spend all microbes to play Soil Enrichment');
        }
      }
    }

    // TODO(kberg): Move this.paymentOptionsForCard to a parameter.
    const totalToPay = this.payingAmount(payment, this.paymentOptionsForCard(selectedCard));

    if (totalToPay < cardCost) {
      throw new Error('Did not spend enough to pay for card');
    }
    return this.playCard(selectedCard, payment, cardAction);
  }

  public resourcesOnCard(name: CardName): number {
    const card = this.tableau.find((card) => card.name === name);
    return card?.resourceCount ?? 0;
  }

  public getSpendable(SpendableResource: SpendableCardResource): number {
    return this.resourcesOnCard(CARD_FOR_SPENDABLE_RESOURCE[SpendableResource]);
  }

  public pay(payment: Payment) {
    const standardUnits = Units.of({
      megacredits: payment.megaCredits,
      steel: payment.steel,
      titanium: payment.titanium,
      plants: payment.plants,
      energy: payment.energy,
    });

    this.stock.deductUnits(standardUnits);

    if (payment.heat > 0) {
      this.defer(this.spendHeat(payment.heat));
    }

    const removeResourcesOnCard = (name: CardName, count: number) => {
      if (count === 0) {
        return;
      }
      const card = this.tableau.find((card) => card.name === name);
      if (card === undefined) {
        throw new Error('Card ' + name + ' not found');
      }
      this.removeResourceFrom(card, count, {log: true});
    };

    removeResourcesOnCard(CardName.PSYCHROPHILES, payment.microbes);
    removeResourcesOnCard(CardName.DIRIGIBLES, payment.dirigiblesFloaters);
    removeResourcesOnCard(CardName.LUNA_ARCHIVES, payment.lunaArchivesScience);
    removeResourcesOnCard(CardName.SPIRE, payment.spireScience);
    removeResourcesOnCard(CardName.CARBON_NANOSYSTEMS, payment.graphene);
    removeResourcesOnCard(CardName.SOYLENT_SEEDLING_SYSTEMS, payment.seeds);
    removeResourcesOnCard(CardName.AURORAI, payment.auroraiData);
    removeResourcesOnCard(CardName.KUIPER_COOPERATIVE, payment.kuiperAsteroids);
    removeResourcesOnCard(CardName.BIOENGINEERING_STUDIES, payment.bioengineeringStudiesAnimals);
    removeResourcesOnCard(CardName.ASTEROID_BELT_COLONY, payment.asteroidBeltColonyAsteroids);
    removeResourcesOnCard(CardName.JOVIAN_CONSTRUCTION_YARD, payment.jovianConstructionYardFloaters);
    if (payment.corruption > 0) {
      UnderworldExpansion.loseCorruption(this, payment.corruption);
    }

    if (payment.megaCredits > 0 || payment.steel > 0 || payment.titanium > 0) {
      PathfindersExpansion.addToSolBank(this);
    }
  }

  public playCard(selectedCard: IProjectCard, payment?: Payment, cardAction: CardAction = 'add'): void {
    if (payment !== undefined) {
      this.pay(payment);
    }

    ColoniesHandler.maybeActivateColonies(this.game, selectedCard);

    if (selectedCard.type !== CardType.PROXY) {
      this.game.log('${0} played ${1}', (b) => b.player(this).card(selectedCard));
    }

    // Play the card
    //
    // IMPORTANT: This is the wrong place to take the play card action.
    // It should be played after putting the card into the playedCards array.
    // That makes sense because every card that has an "including this" behavior is
    // actually hacked to +1 things. That's too bad. It means all our code and tests are
    // a little busted.
    //
    // This issue is evident when playing New Partner, and drawing Double Down.
    // The issue is fixed in Double Down for the time being. But the right fix is to move this block
    // down. As I say, that's going to break a lot of things, many of which are not evident
    // in tests (because they use card.play instad of player.playCard).
    const action = selectedCard.play(this);
    this.defer(action, Priority.DEFAULT);

    // This could probably include 'nothing' but for now this will work.
    if (cardAction !== 'discard') {
      // Remove card from hand
      const projectCardIndex = this.cardsInHand.findIndex((card) => card.name === selectedCard.name);
      const preludeCardIndex = this.preludeCardsInHand.findIndex((card) => card.name === selectedCard.name);
      if (projectCardIndex !== -1) {
        this.cardsInHand.splice(projectCardIndex, 1);
      } else if (preludeCardIndex !== -1) {
        this.preludeCardsInHand.splice(preludeCardIndex, 1);
      }

      const selfReplicatingRobots = this.playedCards.find((card) => card.name === CardName.SELF_REPLICATING_ROBOTS);
      if (selfReplicatingRobots instanceof SelfReplicatingRobots) {
        if (inplaceRemove(selfReplicatingRobots.targetCards, selectedCard)) {
          selectedCard.resourceCount = 0;
        }
      }
    }

    switch (cardAction) {
    case 'add':
      if (selectedCard.name !== CardName.LAW_SUIT && selectedCard.name !== CardName.PRIVATE_INVESTIGATOR) {
        this.playedCards.push(selectedCard);
      }
      break;
    // Card is already played. Discard it.
    case 'discard':
      this.discardPlayedCard(selectedCard);
      break;
    // Do nothing. Good for fake cards and replaying events.
    case 'nothing':
      break;
    // Do nothing, used for Double Down.
    case 'action-only':
      break;
    }

    // See comment above regarding

    // See DeclareCloneTag for why this skips cards with clone tags.
    if (!selectedCard.tags.includes(Tag.CLONE) && cardAction !== 'action-only') {
      this.onCardPlayed(selectedCard);
    }

    if (selectedCard.type !== CardType.PROXY) {
      this.lastCardPlayed = selectedCard.name;
    }

    return undefined;
  }

  private triggerOtherCorpEffects(playedCorporationCard: ICorporationCard) {
    // trigger other corp's effects, e.g. SaturnSystems, PharmacyUnion, Splice
    for (const somePlayer of this.game.getPlayers()) {
      for (const corporation of somePlayer.corporations) {
        if (somePlayer === this && corporation.name === playedCorporationCard.name) {
          continue;
        }
        if (corporation.onCorpCardPlayed === undefined) {
          continue;
        }
        this.defer(corporation.onCorpCardPlayed(this, playedCorporationCard, somePlayer));
      }
    }
  }

  public onCardPlayed(card: IProjectCard) {
    if (card.type === CardType.PROXY) {
      return;
    }
    for (const playedCard of this.playedCards) {
      /* A player responding to their own cards played. */
      const actionFromPlayedCard = playedCard.onCardPlayed?.(this, card);
      this.defer(actionFromPlayedCard);
    }

    TurmoilHandler.applyOnCardPlayedEffect(this, card);

    /* A player responding to any other player's card played, for corp effects. */
    for (const somePlayer of this.game.getPlayersInGenerationOrder()) {
      for (const corporationCard of somePlayer.corporations) {
        const actionFromPlayedCard = corporationCard.onCardPlayed?.(this, card);
        this.defer(actionFromPlayedCard);
      }
      for (const someCard of somePlayer.playedCards) {
        const actionFromPlayedCard = someCard.onCardPlayedFromAnyPlayer?.(somePlayer, this, card);
        this.defer(actionFromPlayedCard);
      }
    }

    PathfindersExpansion.onCardPlayed(this, card);
  }

  /* Visible for testing */
  public playActionCard(): PlayerInput {
    return new SelectCard<ICard & IActionCard>(
      'Perform an action from a played card',
      'Take action',
      this.getPlayableActionCards(),
      {selectBlueCardAction: true})
      .andThen(([card]) => {
        this.game.log('${0} used ${1} action', (b) => b.player(this).card(card));
        const action = card.action(this);
        this.defer(action);
        this.actionsThisGeneration.add(card.name);
        return undefined;
      });
  }

  private playCeoOPGAction(): PlayerInput {
    return new SelectCard<ICeoCard>(
      'Use CEO once per game action',
      'Take action',
      this.getUsableOPGCeoCards(),
      {selectBlueCardAction: true})
      .andThen(([card]) => {
        this.game.log('${0} used ${1} action', (b) => b.player(this).card(card));
        const action = card.action?.(this);
        this.defer(action);
        this.actionsThisGeneration.add(card.name);
        return undefined;
      });
  }

  public playAdditionalCorporationCard(corporationCard: ICorporationCard): void {
    if (this.corporations.length === 0) {
      throw new Error('Cannot add additional corporation when it does not have a starting corporation.');
    }
    return this._playCorporationCard(corporationCard, true);
  }

  public playCorporationCard(corporationCard: ICorporationCard): void {
    if (this.corporations.length > 0) {
      throw new Error('Cannot add additional corporation without specifying it explicitly.');
    }
    return this._playCorporationCard(corporationCard, false);
  }

  private _playCorporationCard(corporationCard: ICorporationCard, additionalCorp = false): void {
    this.corporations.push(corporationCard);

    // There is a simpler way to deal with this block, but I'd rather not deal with the fallout of getting it wrong.
    if (additionalCorp) {
      this.megaCredits += corporationCard.startingMegaCredits;
      this.cardCost = Merger.setCardCost(this);
    } else {
      this.megaCredits = corporationCard.startingMegaCredits;
      if (corporationCard.cardCost !== undefined) {
        this.cardCost = corporationCard.cardCost;
      }
    }

    if (additionalCorp === false && corporationCard.name !== CardName.BEGINNER_CORPORATION) {
      const diff = this.cardsInHand.length * this.cardCost;
      this.stock.deduct(Resource.MEGACREDITS, diff);
    }
    this.game.log('${0} played ${1}', (b) => b.player(this).card(corporationCard));
    // Calculating this before playing the corporation card, which might change the player's hand size.
    const numberOfCardInHand = this.cardsInHand.length;
    corporationCard.play(this);
    if (corporationCard.initialAction !== undefined || corporationCard.firstAction !== undefined) {
      this.pendingInitialActions.push(corporationCard);
    }
    if (additionalCorp === false) {
      this.game.log('${0} kept ${1} project cards', (b) => b.player(this).number(numberOfCardInHand));
    }

    this.triggerOtherCorpEffects(corporationCard);
    ColoniesHandler.maybeActivateColonies(this.game, corporationCard);
    PathfindersExpansion.onCardPlayed(this, corporationCard);

    if (!additionalCorp) {
      this.game.playerIsFinishedWithResearchPhase(this);
    }
  }

  public drawCard(count?: number, options?: DrawOptions): undefined {
    return DrawCards.keepAll(this, count, options).execute();
  }

  public drawCardKeepSome(count: number, options: AllOptions): void {
    this.game.defer(DrawCards.keepSome(this, count, options));
  }

  public discardPlayedCard(card: IProjectCard) {
    const found = inplaceRemove(this.playedCards, card);
    if (found === false) {
      console.error(`Error: card ${card.name} not in ${this.id}'s hand`);
      return;
    }
    this.game.projectDeck.discard(card);
    card.onDiscard?.(this);
    this.game.log('${0} discarded ${1}', (b) => b.player(this).card(card));
  }

  public discardCardFromHand(card: IProjectCard, options?: {log?: boolean}) {
    const found = inplaceRemove(this.cardsInHand, card);
    if (found === false) {
      console.error(`Error: card ${card.name} not in ${this.id}'s hand`);
      return;
    }
    this.game.projectDeck.discard(card);
    if (options?.log === true) {
      this.game.log('${0} discarded ${1}', (b) => b.player(this).card(card), {reservedFor: this});
    }
  }

  public availableHeat(): number {
    const floaters = this.resourcesOnCard(CardName.STORMCRAFT_INCORPORATED);
    return this.heat + (floaters * 2);
  }

  public spendHeat(amount: number, cb: () => (undefined | PlayerInput) = () => undefined) : PlayerInput | undefined {
    const stormcraft = <StormCraftIncorporated> this.getCorporation(CardName.STORMCRAFT_INCORPORATED);
    if (stormcraft?.resourceCount > 0) {
      return stormcraft.spendHeat(this, amount, cb);
    }
    this.stock.deduct(Resource.HEAT, amount);
    return cb();
  }

  public claimableMilestones(): Array<IMilestone> {
    if (this.game.allMilestonesClaimed()) {
      return [];
    }
    if ((this.canAfford(this.milestoneCost()) || this.cardIsInEffect(CardName.VANALLEN))) {
      return this.game.milestones
        .filter((milestone) => !this.game.milestoneClaimed(milestone) && milestone.canClaim(this));
    }
    return [];
  }

  private claimMilestone(milestone: IMilestone) {
    if (this.game.milestoneClaimed(milestone)) {
      throw new Error(milestone.name + ' is already claimed');
    }
    this.game.claimedMilestones.push({
      player: this,
      milestone: milestone,
    });
    // VanAllen CEO Hook for Milestones
    const vanAllen = this.game.getCardPlayerOrUndefined(CardName.VANALLEN);
    if (vanAllen !== undefined) {
      vanAllen.stock.add(Resource.MEGACREDITS, 3, {log: true, from: this});
    }
    if (!this.cardIsInEffect(CardName.VANALLEN)) { // Why isn't this an else clause to the statement above?
      const cost = this.milestoneCost();
      this.game.defer(new SelectPaymentDeferred(this, cost, {title: 'Select how to pay for milestone'}));
    }
    this.game.log('${0} claimed ${1} milestone', (b) => b.player(this).milestone(milestone));
  }

  private isStagedProtestsActive() {
    const owner = this.game.getCardPlayerOrUndefined(CardName.STAGED_PROTESTS);
    if (owner === undefined) {
      return false;
    }
    const stagedProtests = owner.playedCards.find((card) => card.name === CardName.STAGED_PROTESTS);
    return stagedProtests?.generationUsed === this.game.generation;
  }

  private milestoneCost() {
    if (this.isCorporation(CardName.NIRGAL_ENTERPRISES)) {
      return 0;
    }
    return this.isStagedProtestsActive() ? MILESTONE_COST + 8 : MILESTONE_COST;
  }

  // Public for tests.
  public awardFundingCost() {
    if (this.isCorporation(CardName.NIRGAL_ENTERPRISES)) {
      return 0;
    }
    const plus8 = this.isStagedProtestsActive() ? 8 : 0;
    return this.game.getAwardFundingCost() + plus8;
  }

  private fundAward(award: IAward): PlayerInput {
    return new SelectOption(award.name, 'Fund - ' + '(' + award.name + ')').andThen(() => {
      this.game.defer(new SelectPaymentDeferred(this, this.awardFundingCost(), {title: 'Select how to pay for award'}));
      this.game.fundAward(this, award);
      return undefined;
    });
  }

  private endTurnOption(): PlayerInput {
    return new SelectOption('End Turn', 'End').andThen(() => {
      this.actionsTakenThisRound = this.availableActionsThisRound; // This allows for variable actions per turn, like Mars Maths
      this.game.log('${0} ended turn', (b) => b.player(this));
      return undefined;
    });
  }

  public pass(): void {
    this.game.playerHasPassed(this);
    this.lastCardPlayed = undefined;
    this.autopass = false;
    this.game.log('${0} passed', (b) => b.player(this));
  }

  private passOption(): PlayerInput {
    return new SelectOption('Pass for this generation', 'Pass').andThen(() => {
      this.pass();
      return undefined;
    });
  }

  public takeActionForFinalGreenery(): void {
    const resolveFinalGreeneryDeferredActions = () => {
      this.game.deferredActions.runAll(() => this.takeActionForFinalGreenery());
    };

    // Resolve any deferredAction before placing the next greenery
    // Otherwise if two tiles are placed next to Philares, only the last benefit is triggered
    // if Philares does not accept the first bonus before the second tile is down
    if (this.game.deferredActions.length > 0) {
      resolveFinalGreeneryDeferredActions();
      return;
    }

    if (this.game.canPlaceGreenery(this)) {
      const action = new OrOptions();
      action.title = 'Place any final greenery from plants';
      action.buttonLabel = 'Confirm';
      action.options.push(
        new SelectSpace(
          'Select space for greenery tile',
          this.game.board.getAvailableSpacesForGreenery(this))
          .andThen((space) => {
            // Do not raise oxygen or award TR for final greenery placements
            this.game.addGreenery(this, space, false);
            this.stock.deduct(Resource.PLANTS, this.plantsNeededForGreenery);

            this.takeActionForFinalGreenery();

            // Resolve Philares deferred actions
            if (this.game.deferredActions.length > 0) resolveFinalGreeneryDeferredActions();
            return undefined;
          }));
      action.options.push(
        new SelectOption('Don\'t place a greenery').andThen(() => {
          this.game.playerIsDoneWithGame(this);
          return undefined;
        }),
      );
      this.setWaitingForSafely(action);
      return;
    }

    if (this.game.deferredActions.length > 0) {
      resolveFinalGreeneryDeferredActions();
    } else {
      this.game.playerIsDoneWithGame(this);
    }   

  }

  private getPlayableCeoCards(): Array<IProjectCard> {
    return this.ceoCardsInHand.filter((card) => card.canPlay?.(this) === true);
  }

  public getPlayableCards(): Array<PlayableCard> {
    const candidateCards: Array<IProjectCard> = [...this.cardsInHand];
    // Self Replicating robots check
    const card = this.playedCards.find((card) => card.name === CardName.SELF_REPLICATING_ROBOTS);
    if (card instanceof SelfReplicatingRobots) {
      candidateCards.push(...card.targetCards);
    }

    const playableCards: Array<PlayableCard> = [];
    for (const card of candidateCards) {
      card.warnings.clear();
      const canPlay = this.canPlay(card);
      if (canPlay !== false) {
        playableCards.push({
          card,
          details: canPlay,
        });
      }
    }
    return playableCards;
  }

  public affordOptionsForCard(card: IProjectCard): CanAffordOptions {
    let trSource: TRSource | undefined = undefined;
    if (card.tr) {
      trSource = card.tr;
    } else {
      const computedTr = card.computeTr?.(this);
      if (computedTr !== undefined) {
        trSource = computedTr;
      } else if (card.behavior !== undefined) {
        trSource = getBehaviorExecutor().toTRSource(card.behavior, new Counter(this, card));
      }
    }
    const cost = this.getCardCost(card);
    const paymentOptionsForCard = this.paymentOptionsForCard(card);
    return {
      cost,
      ...paymentOptionsForCard,
      reserveUnits: MoonExpansion.adjustedReserveCosts(this, card),
      tr: trSource,
    };
  }

  public canPlay(card: IProjectCard): boolean | YesAnd {
    const options = this.affordOptionsForCard(card);
    const canAfford = this.newCanAfford(options);
    if (!canAfford.canAfford) {
      return false;
    }
    const canPlay = card.canPlay(this, options);
    if (canPlay === false) {
      return false;
    }
    if (canAfford.redsCost > 0) {
      if (typeof canPlay === 'boolean') {
        return {redsCost: canAfford.redsCost};
      } else {
        return {...canPlay, redsCost: canAfford.redsCost};
      }
    }
    return canPlay;
  }

  private maxSpendable(reserveUnits: Units = Units.EMPTY): Payment {
    return {
      megaCredits: this.megaCredits - reserveUnits.megacredits,
      steel: this.steel - reserveUnits.steel,
      titanium: this.titanium - reserveUnits.titanium,
      plants: this.plants - reserveUnits.plants,
      heat: this.availableHeat() - reserveUnits.heat,
      energy: this.energy - reserveUnits.energy,
      dirigiblesFloaters: this.getSpendable('dirigiblesFloaters'),
      microbes: this.getSpendable('microbes'),
      lunaArchivesScience: this.getSpendable('lunaArchivesScience'),
      spireScience: this.getSpendable('spireScience'),
      seeds: this.getSpendable('seeds'),
      auroraiData: this.getSpendable('auroraiData'),
      graphene: this.getSpendable('graphene'),
      kuiperAsteroids: this.getSpendable('kuiperAsteroids'),
      bioengineeringStudiesAnimals: this.getSpendable('bioengineeringStudiesAnimals'),
      asteroidBeltColonyAsteroids: this.getSpendable('asteroidBeltColonyAsteroids'),
      jovianConstructionYardFloaters: this.getSpendable('jovianConstructionYardFloaters'),
      aerialMassDriversFloaters: this.getSpendable('aerialMassDriversFloaters'),
      corruption: this.underworldData.corruption,
    };
  }

  public canSpend(payment: Payment, reserveUnits?: Units): boolean {
    const maxPayable = this.maxSpendable(reserveUnits);

    return SPENDABLE_RESOURCES.every((key) =>
      0 <= payment[key] && payment[key] <= maxPayable[key]);
  }

  /**
   * Returns the value of the suppled payment given the payment options.
   *
   * For example, if the payment is 3M€ and 2 steel, given that steel by default is
   * worth 2M€, this will return 7.
   *
   * @param {Payment} payment the resources being paid.
   * @param {PaymentOptions} options any configuration defining the accepted form of payment.
   * @return {number} a number representing the value of payment in M€.
   */
  public payingAmount(payment: Payment, options?: Partial<PaymentOptions>): number {
    const multiplier = {
      ...DEFAULT_PAYMENT_VALUES,
      steel: this.getSteelValue(),
      titanium: this.getTitaniumValue(),
    };

    const usable: {[key in SpendableResource]: boolean} = {
      megaCredits: true,
      steel: options?.steel ?? false,
      titanium: options?.titanium ?? false,
      heat: this.canUseHeatAsMegaCredits,
      plants: options?.plants ?? false,
      energy: options?.energy ?? false,
      microbes: options?.microbes ?? false,
      dirigiblesFloaters: options?.dirigiblesFloaters ?? false,
      lunaArchivesScience: options?.lunaArchivesScience ?? false,
      spireScience: options?.spireScience ?? false,
      seeds: options?.seeds ?? false,
      auroraiData: options?.auroraiData ?? false,
      graphene: options?.graphene ?? false,
      kuiperAsteroids: options?.kuiperAsteroids ?? false,
      bioengineeringStudiesAnimals: options?.bioengineeringStudiesAnimals ?? false,
      asteroidBeltColonyAsteroids: options?.asteroidBeltColonyAsteroids ?? false,
      jovianConstructionYardFloaters: options?.jovianConstructionYardFloaters ?? false,
      aerialMassDriversFloaters: options?.aerialMassDriversFloaters ?? false,
      corruption: options?.corruption ?? false,
    };

    // HOOK: Luna Trade Federation
    if (usable.titanium === false && payment.titanium > 0 && (this.isCorporation(CardName.LUNA_TRADE_FEDERATION) || this.cardIsInEffect(CardName.LASER_MINING))) {
      usable.titanium = true;
      multiplier.titanium -= 1;
    }

    let totalToPay = 0;
    for (const key of SPENDABLE_RESOURCES) {
      if (usable[key]) totalToPay += payment[key] * multiplier[key];
    }

    return totalToPay;
  }

  private static CANNOT_AFFORD = {canAfford: false, redsCost: 0} as const;

  /**
   * Returns information about whether a player can afford to spend money with other costs and ways to pay taken into account.
   */
  public newCanAfford(o: number | CanAffordOptions): {redsCost: number, canAfford: boolean} {
    const options: CanAffordOptions = typeof(o) === 'number' ? {cost: o} : {...o};

    // TODO(kberg): These are set both here and in SelectPayment. Consolidate, perhaps.
    options.heat = this.canUseHeatAsMegaCredits;
    options.lunaTradeFederationTitanium = this.canUseTitaniumAsMegacredits;

    const reserveUnits = options.reserveUnits ?? Units.EMPTY;
    if (reserveUnits.heat > 0) {
      // Special-case heat
      const unitsWithoutHeat = {...reserveUnits, heat: 0};
      if (!this.stock.has(unitsWithoutHeat)) {
        return Player.CANNOT_AFFORD;
      }
      if (this.availableHeat() < reserveUnits.heat) {
        return Player.CANNOT_AFFORD;
      }
    } else {
      if (!this.stock.has(reserveUnits)) {
        return Player.CANNOT_AFFORD;
      }
    }

    const maxPayable = this.maxSpendable(reserveUnits);
    const redsCost = TurmoilHandler.computeTerraformRatingBump(this, options.tr) * REDS_RULING_POLICY_COST;
    if (redsCost > 0) {
      const usableForRedsCost = this.payingAmount(maxPayable, {});
      if (usableForRedsCost < redsCost) {
        return Player.CANNOT_AFFORD;
      }
    }

    const usable = this.payingAmount(maxPayable, options);

    const canAfford = options.cost + redsCost <= usable;
    return {canAfford, redsCost};
  }

  /**
   * Returns `true` if the player can afford to pay `options.cost` mc (possibly replaceable with steel, titanium etc.)
   * and additionally pay the reserveUnits (no replaces here)
   */
  public canAfford(o: number | CanAffordOptions): boolean {
    return this.newCanAfford(o).canAfford;
  }

  private getStandardProjects(): Array<IStandardProjectCard> {
    const gameOptions = this.game.gameOptions;
    return new GameCards(gameOptions)
      .getStandardProjects()
      .filter((card) => {
        switch (card.name) {
        // sell patents is not displayed as a card
        case CardName.SELL_PATENTS_STANDARD_PROJECT:
          return false;
        // For buffer gas, show ONLY IF in solo AND 63TR mode
        case CardName.BUFFER_GAS_STANDARD_PROJECT:
          return this.game.isSoloMode() && gameOptions.soloTR;
        case CardName.AIR_SCRAPPING_STANDARD_PROJECT:
          return gameOptions.altVenusBoard === false;
        case CardName.AIR_SCRAPPING_STANDARD_PROJECT_VARIANT:
          return gameOptions.altVenusBoard === true;
        case CardName.MOON_HABITAT_STANDARD_PROJECT_VARIANT_2:
        case CardName.MOON_MINE_STANDARD_PROJECT_VARIANT_2:
        case CardName.MOON_ROAD_STANDARD_PROJECT_VARIANT_2:
          return gameOptions.moonStandardProjectVariant === true;
        case CardName.MOON_HABITAT_STANDARD_PROJECT_VARIANT_1:
        case CardName.MOON_MINE_STANDARD_PROJECT_VARIANT_1:
        case CardName.MOON_ROAD_STANDARD_PROJECT_VARIANT_1:
          return gameOptions.moonStandardProjectVariant1 === true;
        case CardName.EXCAVATE_STANDARD_PROJECT:
          return gameOptions.underworldExpansion === true;
        case CardName.COLLUSION_STANDARD_PROJECT:
          return gameOptions.underworldExpansion === true && gameOptions.turmoilExtension === true;
        default:
          return true;
        }
      })
      .sort((a, b) => a.cost - b.cost);
  }

  public getStandardProjectOption(): SelectCard<IStandardProjectCard> {
    const standardProjects: Array<IStandardProjectCard> = this.getStandardProjects();

    return new SelectCard(
      'Standard projects',
      'Confirm',
      standardProjects,
      {enabled: standardProjects.map((card) => card.canAct(this))})
      .andThen(([card]) => card.action(this));
  }

  private headStartIsInEffect() {
    if (this.game.phase === Phase.PRELUDES && this.cardIsInEffect(CardName.HEAD_START)) {
      if (this.actionsTakenThisRound < 2) {
        return true;
      }
    }
    return false;
  }

  /**
   * Set up a player taking their next action.
   *
   * This method indicates the avalilable actions by setting the `waitingFor` attribute of this player.
   *
   * @param {boolean} saveBeforeTakingAction when true, the game state is saved. Default is `true`. This
   * should only be false in testing and when this method is called during game deserialization. In other
   * words, don't set this value unless you know what you're doing.
   */
  // @ts-ignore saveBeforeTakingAction is unused at the moment.
  public takeAction(saveBeforeTakingAction: boolean = true): void {

//andy one trade
    console.log('takeAction called');
    console.log('actionsTakenThisRound:', this.actionsTakenThisRound);
    console.log('hasTraded before:', this.hasTraded);

    const game = this.game;

    if (game.deferredActions.length > 0) {
      game.deferredActions.runAll(() => this.takeAction());
      return;
    }

    if (this.actionsTakenThisRound === 0 || game.gameOptions.undoOption) game.save();
    // if (saveBeforeTakingAction) game.save();

    //andy one trade
    if (this.actionsTakenThisRound === 0) {
      this.hasTraded = false; // Reset hasTraded at the start of each turn
      console.log('Reset hasTraded to false');
    }

//andy one trade
console.log('hasTraded after:', this.hasTraded);

    if (this.autopass) {
      this.passOption().cb();
    }
    const headStartIsInEffect = this.headStartIsInEffect();

    if (!headStartIsInEffect) {
      // Prelude cards have to be played first
      if (this.preludeCardsInHand.length > 0) {
        game.phase = Phase.PRELUDES;

        const selectPrelude = PreludesExpansion.playPrelude(this, this.preludeCardsInHand);

        this.setWaitingFor(selectPrelude, () => {
          if (this.preludeCardsInHand.length === 0 && !this.headStartIsInEffect()) {
            game.playerIsFinishedTakingActions();
            return;
          }

          this.takeAction();
        });
        return;
      }

      if (this.ceoCardsInHand.length > 0) {
        // The CEO phase occurs between the Prelude phase and before the Action phase.
        // All CEO cards are played before players take their first normal actions.
        game.phase = Phase.CEOS;
        const playableCeoCards = this.getPlayableCeoCards();
        for (let i = playableCeoCards.length - 1; i >= 0; i--) {
          // start from the end of the list and work backwards, we're removing items as we go.
          const card = this.ceoCardsInHand[i];
          this.playCard(card);
        }
        // Null out ceoCardsInHand, anything left was unplayable.
        this.ceoCardsInHand = [];
        this.takeAction(); // back to top
      } else {
        game.phase = Phase.ACTION;
      }

      if (game.hasPassedThisActionPhase(this) || (this.allOtherPlayersHavePassed() === false && this.actionsTakenThisRound >= this.availableActionsThisRound)) {
        this.actionsTakenThisRound = 0;
        this.availableActionsThisRound = 2;
        game.resettable = true;
        game.playerIsFinishedTakingActions();
        return;
      }
    }

    // Terraforming Mars FAQ says:
    //   If for any reason you are not able to perform your mandatory first action (e.g. if
    //   all 3 Awards are claimed before starting your turn as Vitor), you can skip this and
    //   proceed with other actions instead.
    // This code just uses "must skip" instead of "can skip".
    const vitor = this.getCorporation(CardName.VITOR);
    if (vitor !== undefined && this.game.allAwardsFunded()) {
      this.pendingInitialActions = this.pendingInitialActions.filter((card) => card !== vitor);
    }

    if (this.pendingInitialActions.length > 0) {
      const orOptions = new OrOptions();

      this.pendingInitialActions.forEach((corp) => {
        const option = new SelectOption(
          message('Take first action of ${0}', (b) => b.card(corp)),
          corp.initialActionText)
          .andThen(() => {
            game.log('${0} took the first action of ${1} corporation', (b) => b.player(this).card(corp)),

            this.deferInitialAction(corp);
            inplaceRemove(this.pendingInitialActions, corp);
            return undefined;
          });
        orOptions.options.push(option);
      });

      if (!headStartIsInEffect) {
        orOptions.options.push(this.passOption());
      }

      this.setWaitingFor(orOptions, () => {
        if (this.pendingInitialActions.length === 0) {
          this.actionsTakenThisRound++;
          this.actionsTakenThisGame++;
        }
        this.timer.rebate(constants.BONUS_SECONDS_PER_ACTION * 1000);
        this.takeAction();
      });
      return;
    }

    this.setWaitingFor(this.getActions(), () => {
      this.incrementActionsTaken();
      this.takeAction();
    });

  }

  // TODO(kberg): perhaps move to Card
  public deferInitialAction(corp: ICorporationCard) {
    this.defer(() => {
      if (corp.initialAction) {
        return corp.initialAction(this);
      } else if (corp.firstAction !== undefined) {
        getBehaviorExecutor().execute(corp.firstAction, this, corp);
      }
      return undefined;
    });
  }

  private incrementActionsTaken(): void {
    this.actionsTakenThisRound++;
    this.actionsTakenThisGame++;
  }

  // Return possible mid-game actions like play a card and fund an award, but not play prelude card.
  public getActions() {
    const action = new OrOptions();
    action.title = this.actionsTakenThisRound === 0 ?
      'Take your first action' : 'Take your next action';
    action.buttonLabel = 'Take action';

    // VanAllen can claim milestones for free:
    const claimableMilestones = this.claimableMilestones();
    if (claimableMilestones.length > 0) {
      const milestoneOption = new OrOptions();
      milestoneOption.title = 'Claim a milestone';
      milestoneOption.options = claimableMilestones.map(
        (milestone) => new SelectOption(milestone.name, 'Claim - ' + '('+ milestone.name + ')').andThen(() => {
          this.claimMilestone(milestone);
          return undefined;
        }));
      action.options.push(milestoneOption);
    }

    // Convert Plants
    const convertPlants = new ConvertPlants();
    if (convertPlants.canAct(this)) {
      action.options.push(convertPlants.action(this));
    }

    // Convert Heat
    const convertHeat = new ConvertHeat();
    if (convertHeat.canAct(this)) {
      action.options.push(convertHeat.action(this));   
    }
      

    const turmoilInput = TurmoilHandler.partyAction(this);
    if (turmoilInput !== undefined) {
      action.options.push(turmoilInput);
    }

    if (this.getPlayableActionCards().length > 0) {
      action.options.push(this.playActionCard());
    }

    if (CeoExtension.ceoActionIsUsable(this)) {
      action.options.push(this.playCeoOPGAction());
    }

    const playableCards = this.getPlayableCards();
    if (playableCards.length !== 0) {
      action.options.push(new SelectProjectCardToPlay(this, playableCards));
    }

    const coloniesTradeAction = this.colonies.coloniesTradeAction();
    if (coloniesTradeAction !== undefined) {
      action.options.push(coloniesTradeAction);
    }

    // If you can pay to add a delegate to a party.
    Turmoil.ifTurmoil(this.game, (turmoil) => {
      const input = turmoil.getSendDelegateInput(this);
      if (input !== undefined) {
        action.options.push(input);
      }
    });

    if (this.game.getPlayers().length > 1 &&
      this.actionsTakenThisRound > 0 &&
      !this.game.gameOptions.fastModeOption &&
      this.allOtherPlayersHavePassed() === false) {
      action.options.push(this.endTurnOption());
    }

    const fundingCost = this.awardFundingCost();
    if (this.canAfford(fundingCost) && !this.game.allAwardsFunded()) {
      const remainingAwards = new OrOptions();
      remainingAwards.title = message('Fund an award (${0} M€)', (b) => b.number(fundingCost)),
      remainingAwards.buttonLabel = 'Confirm';
      remainingAwards.options = this.game.awards
        .filter((award: IAward) => this.game.hasBeenFunded(award) === false)
        .map((award: IAward) => this.fundAward(award));
      action.options.push(remainingAwards);
    }

    action.options.push(this.getStandardProjectOption());

    action.options.push(this.passOption());

    // Sell patents
    const sellPatents = new SellPatentsStandardProject();
    if (sellPatents.canAct(this)) {
      action.options.push(sellPatents.action(this));
    }

    // Propose undo action only if you have done one action this turn
    if (this.actionsTakenThisRound > 0 && this.game.gameOptions.undoOption) {
      action.options.push(new UndoActionOption());
    }

    return action;
  }

  private allOtherPlayersHavePassed(): boolean {
    const game = this.game;
    if (game.isSoloMode()) return true;
    const players = game.getPlayers();
    const passedPlayers = game.getPassedPlayers();
    return passedPlayers.length === players.length - 1 && passedPlayers.includes(this.color) === false;
  }

  public process(input: InputResponse): void {
    if (this.waitingFor === undefined || this.waitingForCb === undefined) {
      throw new Error('Not waiting for anything');
    }
    const waitingFor = this.waitingFor;
    const waitingForCb = this.waitingForCb;
    this.waitingFor = undefined;
    this.waitingForCb = undefined;
    try {
      this.timer.stop();
      this.runInput(input, waitingFor);
      waitingForCb();
    } catch (err) {
      this.setWaitingFor(waitingFor, waitingForCb);
      throw err;
    }
  }

  public getWaitingFor(): PlayerInput | undefined {
    return this.waitingFor;
  }

  public setWaitingFor(input: PlayerInput, cb: () => void = () => {}): void {
    if (this.waitingFor !== undefined) {
      const message = `Overwriting waitingFor ${this.waitingFor.type} with ${input?.type}`;
      if (THROW_STATE_ERRORS) {
        throw new Error(message);
      } else {
        console.warn(message);
      }
    }
    this.timer.start();
    this.waitingFor = input;
    this.waitingForCb = cb;
    this.game.inputsThisRound++;
  }

  // This was only built for the Philares/Final Greenery case. Might not work elsewhere.
  public setWaitingForSafely(input: PlayerInput, cb: () => void = () => {}): void {
    if (this.waitingFor === undefined) {
      this.setWaitingFor(input, cb);
    } else {
      const oldcb = this.waitingForCb;
      this.waitingForCb =
        oldcb === undefined ?
          cb :
          () => {
            oldcb();
            this.setWaitingForSafely(input, cb);
          };
    }
  }

  public serialize(): SerializedPlayer {
    const result: SerializedPlayer = {
      id: this.id,
      corporations: this.corporations.map((corporation) => {
        const serialized = {
          name: corporation.name,
          resourceCount: corporation.resourceCount,
          isDisabled: false,
        };
        corporation.serialize?.(serialized);
        return serialized;
      }),
      // Used only during set-up
      pickedCorporationCard: this.pickedCorporationCard?.name,
      // Terraforming Rating
      terraformRating: this.terraformRating,
      // Resources
      megaCredits: this.megaCredits,
      megaCreditProduction: this.production.megacredits,
      steel: this.steel,
      steelProduction: this.production.steel,
      titanium: this.titanium,
      titaniumProduction: this.production.titanium,
      plants: this.plants,
      plantProduction: this.production.plants,
      energy: this.energy,
      energyProduction: this.production.energy,
      heat: this.heat,
      heatProduction: this.production.heat,
      // Resource values
      titaniumValue: this.titaniumValue,
      steelValue: this.steelValue,
      // Helion
      canUseHeatAsMegaCredits: this.canUseHeatAsMegaCredits,
      // Martian Lumber Corp
      canUsePlantsAsMegaCredits: this.canUsePlantsAsMegacredits,
      // Luna Trade Federation
      canUseTitaniumAsMegacredits: this.canUseTitaniumAsMegacredits,
      // This generation / this round
      canUseCorruptionAsMegacredits: this.canUseCorruptionAsMegacredits,
      // This generation / this round
      actionsTakenThisRound: this.actionsTakenThisRound,
      actionsThisGeneration: Array.from(this.actionsThisGeneration),
      pendingInitialActions: this.pendingInitialActions.map((c) => c.name),
      // Cards
      dealtCorporationCards: this.dealtCorporationCards.map((c) => c.name),
      dealtPreludeCards: this.dealtPreludeCards.map((c) => c.name),
      dealtCeoCards: this.dealtCeoCards.map((c) => c.name),
      dealtProjectCards: this.dealtProjectCards.map((c) => c.name),
      cardsInHand: this.cardsInHand.map((c) => c.name),
      preludeCardsInHand: this.preludeCardsInHand.map((c) => c.name),
      ceoCardsInHand: this.ceoCardsInHand.map((c) => c.name),
      playedCards: this.playedCards.map(serializeProjectCard),
      draftedCards: this.draftedCards.map((c) => c.name),
      cardCost: this.cardCost,
      needsToDraft: this.needsToDraft,
      cardDiscount: this.colonies.cardDiscount,
      // Colonies
      // TODO(kberg): consider a ColoniesSerializer or something.
      fleetSize: this.colonies.getFleetSize(),
      tradesThisGeneration: this.colonies.tradesThisGeneration,
      colonyTradeOffset: this.colonies.tradeOffset,
      colonyTradeDiscount: this.colonies.tradeDiscount,
      colonyVictoryPoints: this.colonies.victoryPoints,
      // Turmoil
      turmoilPolicyActionUsed: this.turmoilPolicyActionUsed,
      politicalAgendasActionUsedCount: this.politicalAgendasActionUsedCount,
      hasTurmoilScienceTagBonus: this.hasTurmoilScienceTagBonus,
      oceanBonus: this.oceanBonus,
      // Custom cards
      // Leavitt Station.
      scienceTagCount: this.scienceTagCount,
      // Ecoline
      plantsNeededForGreenery: this.plantsNeededForGreenery,
      heatNeededForTemperature: this.heatNeededForTemperature,
      // Lawsuit
      removingPlayers: this.removingPlayers,
      // Playwrights
      removedFromPlayCards: this.removedFromPlayCards.map((c) => c.name),
      name: this.name,
      color: this.color,
      beginner: this.beginner,
      handicap: this.handicap,
      timer: this.timer.serialize(),
      // Stats
      actionsTakenThisGame: this.actionsTakenThisGame,
      victoryPointsByGeneration: this.victoryPointsByGeneration,
      totalDelegatesPlaced: this.totalDelegatesPlaced,
      underworldData: this.underworldData,
      generationData: this.generationData,
      alliedParty: this._alliedParty,
      draftHand: this.draftHand.map((c) => c.name),
      autoPass: this.autopass,
      //andy one trade
      hasTraded: this.hasTraded,
    };

    if (this.lastCardPlayed !== undefined) {
      result.lastCardPlayed = this.lastCardPlayed;
    }
    return result;
  }

  public static deserialize(d: SerializedPlayer): Player {
    const player = new Player(d.name, d.color, d.beginner, Number(d.handicap), d.id);

    //andy one trade
    player.hasTraded = d.hasTraded ?? false;
    
    player.actionsTakenThisGame = d.actionsTakenThisGame;
    player.actionsTakenThisRound = d.actionsTakenThisRound;
    player.canUseHeatAsMegaCredits = d.canUseHeatAsMegaCredits;
    player.canUsePlantsAsMegacredits = d.canUsePlantsAsMegaCredits;
    player.canUseTitaniumAsMegacredits = d.canUseTitaniumAsMegacredits;
    player.canUseCorruptionAsMegacredits = d.canUseCorruptionAsMegacredits;
    player.cardCost = d.cardCost;
    player.colonies.cardDiscount = d.cardDiscount;
    player.colonies.tradeDiscount = d.colonyTradeDiscount;
    player.colonies.tradeOffset = d.colonyTradeOffset;
    player.colonies.setFleetSize(d.fleetSize);
    player.colonies.victoryPoints = d.colonyVictoryPoints;
    player.victoryPointsByGeneration = d.victoryPointsByGeneration;
    player.energy = d.energy;
    player.hasTurmoilScienceTagBonus = d.hasTurmoilScienceTagBonus;
    player.heat = d.heat;
    player.megaCredits = d.megaCredits;
    player.needsToDraft = d.needsToDraft;
    player.oceanBonus = d.oceanBonus;
    player.plants = d.plants;
    player.plantsNeededForGreenery = d.plantsNeededForGreenery;
    player.production.override(Units.of({
      energy: d.energyProduction,
      heat: d.heatProduction,
      megacredits: d.megaCreditProduction,
      plants: d.plantProduction,
      steel: d.steelProduction,
      titanium: d.titaniumProduction,
    }));
    player.removingPlayers = d.removingPlayers;
    player.scienceTagCount = d.scienceTagCount;
    player.steel = d.steel;
    player.steelValue = d.steelValue;
    player.terraformRating = d.terraformRating;
    player.titanium = d.titanium;
    player.titaniumValue = d.titaniumValue;
    player.totalDelegatesPlaced = d.totalDelegatesPlaced;
    player.colonies.tradesThisGeneration = d.tradesThisGeneration;
    player.turmoilPolicyActionUsed = d.turmoilPolicyActionUsed;
    player.politicalAgendasActionUsedCount = d.politicalAgendasActionUsedCount;

    player.lastCardPlayed = d.lastCardPlayed;

    // Rebuild removed from play cards (Playwrights, Odyssey)
    player.removedFromPlayCards = cardsFromJSON(d.removedFromPlayCards);

    player.actionsThisGeneration = new Set<CardName>(d.actionsThisGeneration);

    if (d.pickedCorporationCard !== undefined) {
      player.pickedCorporationCard = newCorporationCard(d.pickedCorporationCard);
    }

    // Rebuild corporation cards
    const corporations = d.corporations;

    // This shouldn't happen
    if (corporations !== undefined) {
      for (const corporation of corporations) {
        const card = newCorporationCard(corporation.name);
        if (card === undefined) {
          continue;
        }
        if (corporation.resourceCount !== undefined) {
          card.resourceCount = corporation.resourceCount;
        }
        card.deserialize?.(corporation);
        player.corporations.push(card);
      }
    }

    player.pendingInitialActions = corporationCardsFromJSON(d.pendingInitialActions ?? []);
    player.dealtCorporationCards = corporationCardsFromJSON(d.dealtCorporationCards);
    player.dealtPreludeCards = cardsFromJSON(d.dealtPreludeCards);
    player.dealtCeoCards = ceosFromJSON(d.dealtCeoCards);
    player.dealtProjectCards = cardsFromJSON(d.dealtProjectCards);
    player.cardsInHand = cardsFromJSON(d.cardsInHand);
    // I don't like "as IPreludeCard" but this is pretty safe.
    player.preludeCardsInHand = cardsFromJSON(d.preludeCardsInHand) as Array<IPreludeCard>;
    player.ceoCardsInHand = ceosFromJSON(d.ceoCardsInHand);
    player.playedCards = d.playedCards.map((element: SerializedCard) => deserializeProjectCard(element));
    player.draftedCards = cardsFromJSON(d.draftedCards);
    player.autopass = d.autoPass ?? false;

    player.timer = Timer.deserialize(d.timer);

    if (d.underworldData !== undefined) {
      player.underworldData = d.underworldData;
    }
    player.generationData = d.generationData;
    if (d.alliedParty !== undefined) {
      player._alliedParty = d.alliedParty;
    }

    player.draftHand = cardsFromJSON(d.draftHand);

    return player;
  }

  public getOpponents(): Array<IPlayer> {
    return this.game.getPlayers().filter((p) => p !== this);
  }

  /* Shorthand for deferring things */
  public defer(input: PlayerInput | undefined | void | (() => PlayerInput | undefined), priority: Priority = Priority.DEFAULT): void {
    if (input === undefined) {
      return;
    }
    const cb = typeof(input) === 'function' ? input : () => input;
    const action = new SimpleDeferredAction(this, cb, priority);
    this.game.defer(action);
  }
}

================
File: player/Colonies.ts
================
import {MAX_FLEET_SIZE} from '../../common/constants';
import {CardName} from '../../common/cards/CardName';
import {ColoniesHandler} from '../colonies/ColoniesHandler';
import {AndOptions} from '../inputs/AndOptions';
import {IPlayer} from '../IPlayer';
import {ENERGY_TRADE_COST, MC_TRADE_COST, TITANIUM_TRADE_COST} from '../../common/constants';
import {IColony} from '../colonies/IColony';
import {SelectPaymentDeferred} from '../deferredActions/SelectPaymentDeferred';
import {Resource} from '../../common/Resource';
import {TradeWithTitanFloatingLaunchPad} from '../cards/colonies/TitanFloatingLaunchPad';
import {OrOptions} from '../inputs/OrOptions';
import {SelectOption} from '../inputs/SelectOption';
import {SelectColony} from '../inputs/SelectColony';
import {IColonyTrader} from '../colonies/IColonyTrader';
import {TradeWithCollegiumCopernicus} from '../cards/pathfinders/CollegiumCopernicus';
import {VictoryPointsBreakdown} from '../game/VictoryPointsBreakdown';
import {message} from '../logs/MessageBuilder';
import {TradeWithDarksideSmugglersUnion} from '../cards/moon/DarksideSmugglersUnion';
import {Payment} from '../../common/inputs/Payment';
import {TradeWithHectateSpeditions} from '../cards/underworld/HecateSpeditions';

export class Colonies {
  private player: IPlayer;

  // Each ship in the player's fleet allows a single trade.
  private fleetSize: number = 1;
  public tradesThisGeneration: number = 0;
  // When trading you may increase the Colony track this many steps.
  public tradeOffset: number = 0;

  // When trading you many use this many fewer resources of the trading type.
  public tradeDiscount: number = 0;

  public victoryPoints: number = 0; // Titania Colony VP
  public cardDiscount: number = 0; // Iapetus Colony

  constructor(player: IPlayer) {
    this.player = player;
  }

  /**
   * Returns `true` if this player can execute a trade.
   */
  public canTrade(): boolean {
    const game = this.player.game;
    const result = ColoniesHandler.tradeableColonies(game).length > 0 &&
      this.getFleetSize() > this.tradesThisGeneration &&
      game.tradeEmbargo !== true &&
      !(game.gameOptions.chemicalExpansion && this.player.hasTraded);
  
    console.log('canTrade called');
    console.log('canTrade result:', result);
    console.log('tradeableColonies:', ColoniesHandler.tradeableColonies(game).length);
    console.log('fleetSize:', this.getFleetSize());
    console.log('tradesThisGeneration:', this.tradesThisGeneration);
    console.log('tradeEmbargo:', game.tradeEmbargo);
    console.log('chemicalExpansion:', game.gameOptions.chemicalExpansion);
    console.log('hasTraded:', this.player.hasTraded);
  
    return result;
  }
  
  public coloniesTradeAction(): AndOptions | undefined {
    const game = this.player.game;

    console.log('coloniesTradeAction called');
    console.log('coloniesExtension:', game.gameOptions.coloniesExtension);
    console.log('canTrade:', this.canTrade());

    if (game.gameOptions.coloniesExtension && this.canTrade()) {
      return this.tradeWithColony(ColoniesHandler.tradeableColonies(game));
    }
      console.log('Returning undefined from coloniesTradeAction');
  return undefined;
  }

  private tradeWithColony(openColonies: Array<IColony>): AndOptions | undefined {
    const player = this.player;
    const handlers = [
      new TradeWithDarksideSmugglersUnion(player),
      new TradeWithTitanFloatingLaunchPad(player),
      new TradeWithCollegiumCopernicus(player),
      new TradeWithHectateSpeditions(player),
      new TradeWithEnergy(player),
      new TradeWithTitanium(player),
      new TradeWithMegacredits(player),
    ];

    let selected: IColonyTrader | undefined = undefined;

    const howToPayForTrade = new OrOptions();
    howToPayForTrade.title = 'Pay trade fee';
    howToPayForTrade.buttonLabel = 'Pay';
    handlers.forEach((handler) => {
      if (handler.canUse()) {
        howToPayForTrade.options.push(new SelectOption(
          handler.optionText()).andThen(() => {
          selected = handler;
          return undefined;
        }));
      }
    });

    if (howToPayForTrade.options.length === 0) {
      return undefined;
    }

    const selectColony = new SelectColony('Select colony tile for trade', 'trade', openColonies)
      .andThen((colony) => {
        if (selected === undefined) {
          throw new Error(`Unexpected condition: no trade funding source selected when trading with ${colony.name}.`);
        }
        selected.trade(colony);
        return undefined;
      });

    const trade = new AndOptions(howToPayForTrade, selectColony);
    trade.title = 'Trade with a colony tile';
    trade.buttonLabel = 'Trade';

    return trade;
  }

  public getPlayableColonies(allowDuplicate: boolean = false) {
    return this.player.game.colonies
      .filter((colony) => colony.isActive && !colony.isFull())
      .filter((colony) => allowDuplicate || !colony.colonies.includes(this.player.id));
  }

  public calculateVictoryPoints(victoryPointsBreakdown: VictoryPointsBreakdown) {
    // Titania Colony VP
    if (this.player.colonies.victoryPoints > 0) {
      victoryPointsBreakdown.setVictoryPoints('victoryPoints', this.victoryPoints, 'Colony VP');
    }
  }

  public getFleetSize(): number {
    return this.fleetSize;
  }

  public increaseFleetSize(): void {
    if (this.fleetSize < MAX_FLEET_SIZE) this.fleetSize++;
  }

  public decreaseFleetSize(): void {
    // This fleet size management is a little tricky, because with The Moon, it's possible to
    // have more fleets than MAX_FLEET_SIZE which are then discarded.
    if (this.fleetSize > 0) this.fleetSize--;
  }

  public setFleetSize(fleetSize: number) {
    this.fleetSize = fleetSize;
  }

  public returnTradeFleets(): void {
    const syndicatePirateRaider = this.player.game.syndicatePirateRaider;
    // Syndicate Pirate Raids hook. If it is in effect, then only the syndicate pirate raider will
    // retrieve their fleets.
    // See Colony.ts for the other half of this effect, and Game.ts which disables it.
    if (syndicatePirateRaider === undefined) {
      this.tradesThisGeneration = 0;
    } else if (syndicatePirateRaider === this.player.id) {
      this.tradesThisGeneration = 0;
    }
  }
}

export class TradeWithEnergy implements IColonyTrader {
  private tradeCost;

  constructor(private player: IPlayer) {
    this.tradeCost = ENERGY_TRADE_COST - player.colonies.tradeDiscount;
  }

  public canUse() {
    return this.player.energy >= this.tradeCost;
  }
  public optionText() {
    return message('Pay ${0} energy', (b) => b.number(this.tradeCost));
  }

  public trade(colony: IColony) {
    this.player.stock.deduct(Resource.ENERGY, this.tradeCost);
    this.player.game.log('${0} spent ${1} energy to trade with ${2}', (b) => b.player(this.player).number(this.tradeCost).colony(colony));
    colony.trade(this.player);
  }
}

export class TradeWithTitanium implements IColonyTrader {
  private tradeCost;

  constructor(private player: IPlayer) {
    this.tradeCost = TITANIUM_TRADE_COST - player.colonies.tradeDiscount;
  }

  public canUse() {
    return this.player.titanium >= this.tradeCost;
  }
  public optionText() {
    return message('Pay ${0} titanium', (b) => b.number(this.tradeCost));
  }

  public trade(colony: IColony) {
    this.player.pay(Payment.of({titanium: this.tradeCost}));
    this.player.game.log('${0} spent ${1} titanium to trade with ${2}', (b) => b.player(this.player).number(this.tradeCost).colony(colony));
    colony.trade(this.player);
  }
}


export class TradeWithMegacredits implements IColonyTrader {
  private tradeCost;

  constructor(private player: IPlayer) {
    // Fuel Subsidies hook
    const fuelSubsidies = player.cardIsInEffect(CardName.FUEL_SUBSIDIES) ? 5 : 0;

    this.tradeCost = MC_TRADE_COST- player.colonies.tradeDiscount - fuelSubsidies;
    const adhai = player.getCorporation(CardName.ADHAI_HIGH_ORBIT_CONSTRUCTIONS);
    if (adhai !== undefined) {
      const adhaiDiscount = Math.floor(adhai.resourceCount / 2);
      this.tradeCost = Math.max(0, this.tradeCost - adhaiDiscount);
    }
  }

  public canUse() {
    return this.player.canAfford(this.tradeCost);
  }
  public optionText() {
    return message('Pay ${0} M€', (b) => b.number(this.tradeCost));
  }

  public trade(colony: IColony) {
    this.player.game.defer(new SelectPaymentDeferred(this.player, this.tradeCost,
      {title: message('Select how to pay ${0} for colony trade', (b) => b.number(this.tradeCost))}))
      .andThen(() => {
        this.player.game.log('${0} spent ${1} M€ to trade with ${2}', (b) => b.player(this.player).number(this.tradeCost).colony(colony));
        colony.trade(this.player);
      });
  }
}

================
File: player/GenerationData.ts
================
import {GlobalParameter} from '../../common/GlobalParameter';
import {Resource} from '../../common/Resource';

export class GenerationData {
  public hasRaisedTR = false;
  public hasRaisedGlobalParameter = {
    [GlobalParameter.TEMPERATURE]: false,
    [GlobalParameter.OXYGEN]: false,
    [GlobalParameter.VENUS]: false,
  };
    // Project Advancement
  public hasRaisedProduction = {
    [Resource.MEGACREDITS]: false,
    [Resource.STEEL]: false,
    [Resource.TITANIUM]: false,
    [Resource.PLANTS]: false,
    [Resource.ENERGY]: false,
    [Resource.HEAT]: false,
  };
}

================
File: player/Production.ts
================
import {GlobalEventName} from '../../common/turmoil/globalEvents/GlobalEventName';
import {LawSuit} from '../cards/promo/LawSuit';
import {IPlayer} from '../IPlayer';
import {Resource} from '../../common/Resource';
import {Units} from '../../common/Units';

export class Production {
  private units: Units;
  private player: IPlayer;

  constructor(player: IPlayer, units: Units = Units.EMPTY) {
    this.player = player;
    this.units = Units.of(units);
  }
  public get megacredits() {
    return this.units.megacredits;
  }
  public get steel() {
    return this.units.steel;
  }
  public get titanium() {
    return this.units.titanium;
  }
  public get plants() {
    return this.units.plants;
  }
  public get energy() {
    return this.units.energy;
  }
  public get heat() {
    return this.units.heat;
  }

  public get(resource: Resource): number {
    return this.units[resource];
  }

  public override(units: Partial<Units>) {
    this.units = Units.of({...units});
  }

  public asUnits(): Units {
    return {...this.units};
  }

  public add(
    resource: Resource,
    amount : number,
    options? : { log: boolean, from? : IPlayer | GlobalEventName, stealing?: boolean},
  ) {
    const adj = resource === Resource.MEGACREDITS ? -5 : 0;
    const delta = (amount >= 0) ? amount : Math.max(amount, -(this.units[resource] - adj));
    this.units[resource] += delta;

    if (delta > 0) {
      this.player.generationData.hasRaisedProduction[resource] = true;
    }

    if (options?.log === true) {
      this.player.logUnitDelta(resource, amount, 'production', options.from, options.stealing);
    }

    const from = options?.from;
    if (typeof(from) === 'object') {
      LawSuit.resourceHook(this.player, resource, delta, from);
    }

    // Mons Insurance & Legal Firm hook
    if (options?.from !== undefined && delta < 0 && (typeof(from) === 'object' && from.id !== this.player.id)) {
      this.player.resolveInsurance();
      this.player.legalFirmEffect(from);
    }

    for (const card of this.player.tableau) {
      card.onProductionGain?.(this.player, resource, amount);
    }
  }

  public canAdjust(units: Units): boolean {
    return this.units.megacredits + units.megacredits >= -5 &&
      this.units.steel + units.steel >= 0 &&
      this.units.titanium + units.titanium >= 0 &&
      this.units.plants + units.plants >= 0 &&
      this.units.energy + units.energy >= 0 &&
      this.units.heat + units.heat >= 0;
  }

  public adjust(units: Units, options?: {log: boolean, from?: IPlayer}) {
    if (units.megacredits !== undefined) {
      this.add(Resource.MEGACREDITS, units.megacredits, options);
    }

    if (units.steel !== undefined) {
      this.add(Resource.STEEL, units.steel, options);
    }

    if (units.titanium !== undefined) {
      this.add(Resource.TITANIUM, units.titanium, options);
    }

    if (units.plants !== undefined) {
      this.add(Resource.PLANTS, units.plants, options);
    }

    if (units.energy !== undefined) {
      this.add(Resource.ENERGY, units.energy, options);
    }

    if (units.heat !== undefined) {
      this.add(Resource.HEAT, units.heat, options);
    }
  }
}

================
File: player/Stock.ts
================
// import {CardName} from '../../common/cards/CardName';
// import {GlobalEventName} from '../../common/turmoil/globalEvents/GlobalEventName';
import {LawSuit} from '../cards/promo/LawSuit';
import {IPlayer, ResourceSource, isIPlayer} from '../IPlayer';
import {Resource} from '../../common/Resource';
import {Units} from '../../common/Units';
import {CrashSiteCleanup} from '../cards/promo/CrashSiteCleanup';

export class Stock {
  private units: Units;
  private player: IPlayer;

  constructor(player: IPlayer, units: Units = Units.EMPTY) {
    this.player = player;
    this.units = Units.of(units);
  }
  public get megacredits() {
    return this.units.megacredits;
  }
  public get steel() {
    return this.units.steel;
  }
  public get titanium() {
    return this.units.titanium;
  }
  public get plants() {
    return this.units.plants;
  }
  public get energy() {
    return this.units.energy;
  }
  public get heat() {
    return this.units.heat;
  }

  public set megacredits(megacredits: number) {
    this.units.megacredits = megacredits;
  }

  public set steel(steel: number) {
    this.units.steel = steel;
  }

  public set titanium(titanium: number) {
    this.units.titanium = titanium;
  }

  public set plants(plants: number) {
    this.units.plants = plants;
  }

  public set energy(energy: number) {
    this.units.energy = energy;
  }

  public set heat(heat: number) {
    this.units.heat = heat;
  }

  public get(resource: Resource): number {
    return this.units[resource];
  }

  public override(units: Partial<Units>) {
    this.units = Units.of({...units});
  }

  public asUnits(): Units {
    return {...this.units};
  }

  public has(units: Units): boolean {
    return this.megacredits - units.megacredits >= 0 &&
      this.steel - units.steel >= 0 &&
      this.titanium - units.titanium >= 0 &&
      this.plants - units.plants >= 0 &&
      this.energy - units.energy >= 0 &&
      this.heat - units.heat >= 0;
  }

  public deduct(
    resource: Resource,
    amount: number,
    options? : {
      log?: boolean,
      from? : ResourceSource,
      stealing?: boolean
    }) {
    this.add(resource, -amount, options);
  }

  public add(
    resource: Resource,
    amount : number,
    options? : {
      log?: boolean,
      from? : ResourceSource,
      stealing?: boolean
    }) {
    if (amount === 0) {
      return;
    }
    // When amount is negative, sometimes the amount being asked to be removed is more than the player has.
    // delta represents an adjusted amount which basically declares that a player cannot lose more resources
    // then they have.
    const playerAmount = this[resource];
    const delta = (amount >= 0) ? amount : Math.max(amount, -playerAmount);
    // Lots of calls to addResource used to deduct resources are done by cards and/or players stealing some
    // fixed amount which, if the current player doesn't have it. it just removes as much as possible.
    // (eg. Sabotage.) That's what the delta above, is for.
    //
    // But if the intent is to remove the amount requested (spending 8 plants to place a greenery) then there
    // better be 8 units. The code outside this call is responsible in those cases for making sure the player
    // has enough resource units to pay for an action.
    //
    // In those cases, if the player calls this, but the logic is wrong, the player could wind up with a
    // negative amount of units. This will break other actions in the game. So instead, this method deducts as
    // much as possible, and lots that there was a game error.
    //
    // The shortcut for knowing if this is the case is when `options.from` is undefined.
    if (delta !== amount && options?.from === undefined) {
      this.player.game.logIllegalState(
        `Adjusting ${amount} ${resource} when player has ${playerAmount}`,
        {player: {color: this.player.color, id: this.player.id, name: this.player.name}, resource, amount});
    }

    this.units[resource] += delta;

    if (options?.log === true) {
      this.player.logUnitDelta(resource, delta, 'amount', options.from, options.stealing);
    }

    const from = options?.from;
    if (isIPlayer(from)) {
      LawSuit.resourceHook(this.player, resource, delta, from);
      CrashSiteCleanup.resourceHook(this.player, resource, delta, from);
    }

    // Mons Insurance & Legal Firm hook
    if (options?.from !== undefined && delta < 0 && (isIPlayer(from) && from.id !== this.player.id)) {
      this.player.resolveInsurance();
      this.player.legalFirmEffect(from);
    }
  }

  public addUnits(units: Units, options? : {
    log?: boolean,
    from? : ResourceSource,
  }) {
    if (units.megacredits !== 0) {
      this.add(Resource.MEGACREDITS, units.megacredits, options);
    }
    if (units.steel !== 0) {
      this.add(Resource.STEEL, units.steel, options);
    }
    if (units.titanium !== 0) {
      this.add(Resource.TITANIUM, units.titanium, options);
    }
    if (units.plants !== 0) {
      this.add(Resource.PLANTS, units.plants, options);
    }
    if (units.energy !== 0) {
      this.add(Resource.ENERGY, units.energy, options);
    }
    if (units.heat !== 0) {
      this.add(Resource.HEAT, units.heat, options);
    }
  }

  public deductUnits(units: Units) {
    this.deduct(Resource.MEGACREDITS, units.megacredits);
    this.deduct(Resource.STEEL, units.steel);
    this.deduct(Resource.TITANIUM, units.titanium);
    this.deduct(Resource.PLANTS, units.plants);
    this.deduct(Resource.ENERGY, units.energy);
    this.deduct(Resource.HEAT, units.heat);
  }


  /**
   * `from` steals up to `qty` units of `resource` from this player. Or, at least as
   * much as possible.
   */
  public steal(resource: Resource, qty: number, thief: IPlayer, options?: {log?: boolean}) {
    const qtyToSteal = Math.min(this[resource], qty);
    if (qtyToSteal > 0) {
      this.deduct(resource, qtyToSteal, {log: options?.log ?? true, from: thief, stealing: true});
      thief.stock.add(resource, qtyToSteal);
    }
  }
}

================
File: player/Tags.ts
================
// Methods for a player's relationship to their card tags

import {CardName} from '../../common/cards/CardName';
import {CardType} from '../../common/cards/CardType';
import {TagCount} from '../../common/cards/TagCount';
import {ALL_TAGS, Tag} from '../../common/cards/Tag';
import {ICorporationCard, isICorporationCard} from '../cards/corporation/ICorporationCard';
import {ICard} from '../cards/ICard';
import {IProjectCard} from '../cards/IProjectCard';
import {IPlayer} from '../IPlayer';
import {OneOrArray} from '../../common/utils/types';

export type CountingMode =
  'raw' | // Count face-up tags literally, including Leavitt Station.
  'default' | // Like raw, but include the wild tags and other deafult substitutions. Typical when performing an action.
  'milestone' | // Like raw with special conditions for milestones (Chimera)
  'award' | // Like raw with special conditions for awards (Chimera)
  'raw-pf'; // Like raw, but includes Mars Tags when tag is Science (Habitat Marte)

export type DistinctCountMode =
  'default' | // Count all tags in played cards, and then add in all the wild tags.
  'milestone' | // Like default with special conditions for milestones (Chimera)
  'globalEvent'; // Like default, but does not apply wild tags, which are used in the action phase.

export type MultipleCountMode =
  'default' | // Count each tag individually, add wild tags, and (Moon) Earth Embassy.
  'milestone' | // Like default, including Chimera.
  'award'; // Like default, including Chimera.

/**
 * Provides common behaviors for analyzing tags on cards.
 *
 * Most everything is meant to match observable behavior. It also takes into account some special
 * card behaviors:
 *
 * 1. Odyssey (PF) leaves events face up, so their tags count.
 * 2. Earth Embassy (Moon) counts Moon tags count as Earth tags.
 * 3. Habitat Marte (PF) Mars tags count as science tags.
 * 4. Chimera (PF) has two wild tags, but only count as one tag for milestones and (funding) awards.
 *
 */
export class Tags {
  private static COUNTED_TAGS = ALL_TAGS.filter((tag) => tag !== Tag.CLONE && tag !== Tag.EVENT);

  private player: IPlayer;
  constructor(player: IPlayer) {
    this.player = player;
  }

  /**
   * Returns a count of tags on face-up cards, plus a count of events.
   *
   * Excludes Clone tags.
   */
  public countAllTags(): Array<TagCount> {
    const counts = Tags.COUNTED_TAGS.map((tag) => {
      return {tag, count: this.count(tag, 'raw')};
    }).filter((tag) => tag.count > 0);
    counts.push({tag: Tag.EVENT, count: this.player.getPlayedEventsCount()});
    return counts;
  }

  /*
   * Get the number of tags this player has.
   */
  public count(tag: Tag, mode: CountingMode = 'default') {
    const includeEvents = this.player.isCorporation(CardName.ODYSSEY);
    const includeTagSubstitutions = (mode === 'default' || mode === 'milestone');

    let tagCount = this.rawCount(tag, includeEvents);

    // Leavitt Station hook
    if (tag === Tag.SCIENCE && this.player.scienceTagCount > 0) {
      tagCount += this.player.scienceTagCount;
    }

    if (includeTagSubstitutions) {
      // Earth Embassy hook
      if (tag === Tag.EARTH && this.player.cardIsInEffect(CardName.EARTH_EMBASSY)) {
        tagCount += this.rawCount(Tag.MOON, includeEvents);
      }

      if (tag !== Tag.WILD) {
        tagCount += this.rawCount(Tag.WILD, includeEvents);
      }
      // Public Records hook
      if (this.player.lastCardPlayed === CardName.PUBLIC_RECORDS) {
        tagCount += 1;
      }
    }

    // Habitat Marte hook
    if (mode !== 'raw') {
      if (tag === Tag.SCIENCE && this.player.isCorporation(CardName.HABITAT_MARTE)) {
        tagCount += this.rawCount(Tag.MARS, includeEvents);
      }
    }

    // Chimera hook
    if (this.player.isCorporation(CardName.CHIMERA)) {
      // Awards do not count wild tags, so in this case one will be added.
      if (mode === 'award') {
        tagCount++;
      }
      // Milestones count wild tags, so in this case one will be deducted.
      if (mode === 'milestone') {
        tagCount--;
      }
    }
    return tagCount;
  }

  /**
   * Returns true if `card` has `tag`. This does not include wild tags, but it includes
   * Habitat Marte and Earth Embassy exceptions.
   */
  public cardHasTag(card: ICard, target: Tag): boolean {
    for (const tag of card.tags) {
      if (tag === target) return true;
      if (tag === Tag.MARS &&
        target === Tag.SCIENCE &&
        this.player.isCorporation(CardName.HABITAT_MARTE)) {
        return true;
      }
      if (tag === Tag.MOON &&
        target === Tag.EARTH &&
        this.player.cardIsInEffect(CardName.EARTH_EMBASSY)) {
        return true;
      }
    }
    if (target === Tag.EVENT && card.type === CardType.EVENT) {
      return true;
    }

    return false;
  }

  public cardTagCount(card: ICard, target: OneOrArray<Tag>): number {
    let count = 0;
    for (const tag of card.tags) {
      if (tag === target) {
        count++;
      } else if (Array.isArray(target) && target.includes(tag)) {
        count++;
      } else if (tag === Tag.MARS && target === Tag.SCIENCE &&
        this.player.isCorporation(CardName.HABITAT_MARTE)) {
        count++;
      } else if (tag === Tag.MOON && target === Tag.EARTH &&
        this.player.cardIsInEffect(CardName.EARTH_EMBASSY)) {
        count++;
      }
    }
    return count;
  }

  // Counts the tags in the player's play area only.
  protected rawCount(tag: Tag, includeEventsTags: boolean) {
    let tagCount = 0;

    this.player.tableau.forEach((card: IProjectCard | ICorporationCard) => {
      if (!includeEventsTags && card.type === CardType.EVENT) return;
      if (isICorporationCard(card) && card.isDisabled) return;
      tagCount += card.tags.filter((cardTag) => cardTag === tag).length;
    });

    return tagCount;
  }

  /**
   * Return the total number of tags associated with these types.
   * Tag substitutions are included, and not counted repeatedly.
    */
  public multipleCount(tags: Array<Tag>, mode: MultipleCountMode = 'default'): number {
    const includeEvents = this.player.isCorporation(CardName.ODYSSEY);

    let tagCount = 0;
    tags.forEach((tag) => {
      tagCount += this.rawCount(tag, includeEvents);
    });

    // This is repeated behavior from getTagCount, sigh, OK.
    if (tags.includes(Tag.EARTH) && !tags.includes(Tag.MOON) && this.player.cardIsInEffect(CardName.EARTH_EMBASSY)) {
      tagCount += this.rawCount(Tag.MOON, includeEvents);
    }

    if (mode !== 'award') {
      // Public Records hook
      if (this.player.lastCardPlayed === CardName.PUBLIC_RECORDS) tagCount += 1;

      tagCount += this.rawCount(Tag.WILD, false);
      // Chimera has 2 wild tags but should only count as one for milestones.
      if (this.player.isCorporation(CardName.CHIMERA) && mode === 'milestone') tagCount--;
    } else {
      // Chimera counts as one wild tag for awards
      if (this.player.isCorporation(CardName.CHIMERA)) tagCount++;
    }

    return tagCount;
  }

  /**
   * Counts the number of distinct tags the player has.
   *
   * `extraTag` (optional) represents a tag from a card that is in the middle of being played. If the card had multiple tags,
   * this API could change, but right the additional argument is only used once.
   */
  public distinctCount(mode: DistinctCountMode, extraTag?: Tag): number {
    const uniqueTags = new Set<Tag>();
    let wildTagCount = 0;

    const addTag = (tag: Tag) => {
      if (tag === Tag.WILD) {
        wildTagCount++;
      } else {
        uniqueTags.add(tag);
      }
    };

    for (const card of this.player.corporations) {
      if (!card.isDisabled) {
        card.tags.forEach(addTag);
      }
    }
    for (const card of this.player.playedCards) {
      if (card.type !== CardType.EVENT) {
        card.tags.forEach(addTag);
      }
    }
    if (this.player.isCorporation(CardName.ODYSSEY)) {
      for (const card of this.player.playedCards) {
        if (card.type === CardType.EVENT) {
          card.tags.forEach(addTag);
        }
      }
    }

    if (extraTag !== undefined) {
      uniqueTags.add(extraTag);
    }

    // Leavitt Station hook
    if (this.player.scienceTagCount > 0) uniqueTags.add(Tag.SCIENCE);

    // Global events occur outside the action phase. Stop counting here, before wild tags apply.
    if (mode === 'globalEvent') return uniqueTags.size;

    if (mode === 'milestone' && this.player.isCorporation(CardName.CHIMERA)) wildTagCount--;

    // Public Records hook
    if (this.player.lastCardPlayed === CardName.PUBLIC_RECORDS) wildTagCount++;

    // TODO(kberg): it might be more correct to count all the tags
    // in a game regardless of expansion? But if that happens it needs
    // to be done once, during set-up so that this operation doesn't
    // always go through every tag every time.
    let maxTagCount = 10;
    const game = this.player.game;
    if (game.gameOptions.venusNextExtension) maxTagCount++;
    if (game.gameOptions.moonExpansion) maxTagCount++;
    if (game.gameOptions.pathfindersExpansion) maxTagCount++;
    return Math.min(uniqueTags.size + wildTagCount, maxTagCount);
  }

  // Return true if this player has all the tags in `tags` showing.
  public playerHas(tags: Array<Tag>): boolean {
    let distinctCount = 0;
    tags.forEach((tag) => {
      if (this.count(tag, 'raw') > 0) {
        distinctCount++;
      } else if (tag === Tag.SCIENCE && this.player.hasTurmoilScienceTagBonus) {
        distinctCount++;
      }
    });
    if (this.player.lastCardPlayed === CardName.PUBLIC_RECORDS) distinctCount++;
    if (distinctCount + this.count(Tag.WILD) >= tags.length) {
      return true;
    }
    return false;
  }

  public gainScienceTag(count: number) {
    this.player.scienceTagCount += count;
  }

  /**
   * Return the number of cards in the player's hand without tags.
   *
   * Wild tags are ignored in this computation because in every known case, more cards without
   * tags is better.
   *
   * Does not include Odyssey behavior.
   */
  public numberOfCardsWithNoTags(): number {
    const filtered = this.player.tableau.filter((card) => {
      // Special-case pharmacy union which is out of play once it's disabled.
      if (card.name === CardName.PHARMACY_UNION && card.isDisabled === true) {
        return false;
      }
      return card.type !== CardType.EVENT && card.tags.every((tag) => tag === Tag.WILD);
    });
    return filtered.length;
  }
}

================
File: PlayerInput.ts
================
import {ICard} from './cards/ICard';
import {Message} from '../common/logs/Message';
import {PlayerInputType} from '../common/input/PlayerInputType';
import {InputResponse} from '../common/inputs/InputResponse';
import {IPlayer} from './IPlayer';
import {PlayerInputModel} from '../common/models/PlayerInputModel';

export interface PlayerInput {
    type: PlayerInputType;
    buttonLabel: string;
    title: string | Message;
    /**
     * When false, this input should not be the default selected PlayerInput.
     * When unset or true, this input may be the default selected PlayerInput.
     *
     * Used only when this option is a child option of an OrOptions.
     */
    eligibleForDefault?: boolean;

    cb(...item: any): PlayerInput | undefined;

    /**
     * Converts this PlayerInput to the model received by the UI.
     */
    toModel(player: IPlayer): PlayerInputModel;

    /**
     * Processes and validates `response` for this PlayerInput which is meant for the given `player`.
     *
     * This is another mechainsm for calling cb() with a client-side response.
     */
    process(response: InputResponse, player: IPlayer): PlayerInput | undefined;
}

const NULL_FUNCTION = () => undefined;

export abstract class BasePlayerInput<T> implements PlayerInput {
  public readonly type: PlayerInputType;
  public buttonLabel: string = 'Save';
  public title: string | Message;
  public cb: (param: T) => PlayerInput | undefined = NULL_FUNCTION;
  public eligibleForDefault: boolean | undefined = undefined;

  public abstract toModel(player: IPlayer): PlayerInputModel;
  public abstract process(response: InputResponse, player: IPlayer): PlayerInput | undefined;

  constructor(type: PlayerInputType, title: string | Message = '') {
    this.type = type;
    this.title = title;
  }

  public andThen(cb: (param: T) => PlayerInput | undefined): this {
    if (this.cb !== NULL_FUNCTION) {
      const THROW_STATE_ERRORS = Boolean(process.env.THROW_STATE_ERRORS);
      if (THROW_STATE_ERRORS) {
        throw new Error('andThen called twice');
      } else {
        console.error('andThen called twice');
        return this;
      }
    }
    this.cb = cb;
    return this;
  }
}


export function getCardFromPlayerInput<T extends ICard>(cards: ReadonlyArray<T>, cardName: string): {card: T, idx: number} {
  const idx = cards.findIndex((card) => card.name === cardName);
  if (idx === -1) {
    throw new Error(`Card ${cardName} not found`);
  }
  const card = cards[idx];
  return {card, idx};
}

================
File: preludes/PreludesExpansion.ts
================
import {inplaceRemove} from '../../common/utils/utils';
import {Resource} from '../../common/Resource';
import {CardAction, IPlayer} from '../IPlayer';
import {IPreludeCard} from '../cards/prelude/IPreludeCard';
import {SelectCard} from '../inputs/SelectCard';
import {ICorporationCard} from '../cards/corporation/ICorporationCard';

export class PreludesExpansion {
  public static fizzle(player: IPlayer, card: IPreludeCard): void {
    player.game.log('${0} fizzled. ${1} gains 15 M€.', (b) => b.card(card).player(player));
    player.stock.add(Resource.MEGACREDITS, 15);
    player.defer(() => {
      // This is deferred because it is possible for the parent card to
      // be moved from hand to play area. So, wait until this action finishes and
      // then follow up with cleanup.
      inplaceRemove(player.preludeCardsInHand, card);
      inplaceRemove(player.playedCards, card);
    });
  }

  public static playPrelude(
    player: IPlayer,
    cards: Array<IPreludeCard>,
    cardAction: CardAction = 'add'): SelectCard<IPreludeCard> {
    // This preps the warning attribute in preludes.
    // All preludes can be presented. Unplayable ones just fizzle.
    for (const card of cards) {
      card.warnings.clear();
      if (!card.canPlay(player)) {
        card.warnings.add('preludeFizzle');
      }
    }

    return new SelectCard(
      'Select prelude card to play', 'Play', cards)
      .andThen(([card]) => {
        if (card.canPlay?.(player) === false) {
          PreludesExpansion.fizzle(player, card);
        } else {
          if (card.initialAction) {
            player.pendingInitialActions.push(card as any as ICorporationCard);
          }
          player.playCard(card, undefined, cardAction);
        }
        return undefined;
      },
      );
  }
}

================
File: Request.ts
================
import type * as http from 'http';

/**
 * Limits Request to what we use. This is used to ease in unit testing
 * and to allow for javascript without 'http' to run the server code.
 */
export type Request = Pick<http.IncomingMessage, 'headers' | 'method' | 'url'> & {
  once: (type: 'end', func: () => void) => void;
  on: (type: 'data', func: (dat: Buffer) => void) => void;
  socket: {
    address(): string | {
      address: string;
      family: string;
      port: number;
    };
  }
};

================
File: Response.ts
================
import type * as http from 'http';

/**
 * Limits Response to what we use. This is used to ease in unit testing
 * and to allow for javascript without 'http' to run the server code.
 */
export type Response = Pick<http.ServerResponse, 'setHeader' | 'write' | 'writeHead'> & {
  end: (data?: string | Buffer) => void;
};

================
File: routes/ApiCloneableGame.ts
================
import * as responses from '../server/responses';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {Database} from '../database/Database';
import {isGameId} from '../../common/Types';
import {Request} from '../Request';
import {Response} from '../Response';

export class ApiCloneableGame extends Handler {
  public static readonly INSTANCE = new ApiCloneableGame();
  private constructor() {
    super();
  }

  public override async get(req: Request, res: Response, ctx: Context): Promise<void> {
    const gameId = ctx.url.searchParams.get('id');
    if (gameId === null) {
      responses.badRequest(req, res, 'missing id parameter');
      return;
    }
    if (!isGameId(gameId)) {
      responses.badRequest(req, res, 'invalid game id');
      return;
    }
    await Database.getInstance().getPlayerCount(gameId)
      .then((playerCount) => {
        responses.writeJson(res, {gameId, playerCount});
      })
      .catch((err) => {
        console.warn('Could not load cloneable game: ', err);
        responses.notFound(req, res);
      });
  }
}

================
File: routes/ApiGame.ts
================
import * as responses from '../server/responses';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {Server} from '../models/ServerModel';
import {isGameId} from '../../common/Types';
import {IGame} from '../IGame';
import {Request} from '../Request';
import {Response} from '../Response';

export class ApiGame extends Handler {
  public static readonly INSTANCE = new ApiGame();
  private constructor() {
    super();
  }

  public override async get(req: Request, res: Response, ctx: Context): Promise<void> {
    const gameId = ctx.url.searchParams.get('id');
    if (!gameId) {
      responses.badRequest(req, res, 'missing id parameter');
      return;
    }

    let game: IGame | undefined;
    if (isGameId(gameId)) {
      game = await ctx.gameLoader.getGame(gameId);
    }
    if (game === undefined) {
      responses.notFound(req, res, 'game not found');
      return;
    }
    const model = Server.getSimpleGameModel(game);
    responses.writeJson(res, model);
  }
}

================
File: routes/ApiGameHistory.ts
================
import * as responses from '../server/responses';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {Database} from '../database/Database';
import {isGameId} from '../../common/Types';
import {Request} from '../Request';
import {Response} from '../Response';

export class ApiGameHistory extends Handler {
  public static readonly INSTANCE = new ApiGameHistory();
  private constructor() {
    super({validateServerId: true});
  }

  public override async get(req: Request, res: Response, ctx: Context): Promise<void> {
    const gameId = ctx.url.searchParams.get('id');
    if (!gameId) {
      responses.badRequest(req, res, 'missing id parameter');
      return;
    }

    if (!isGameId(gameId)) {
      responses.badRequest(req, res, 'Invalid game id');
      return;
    }
    try {
      const saveIds = await Database.getInstance().getSaveIds(gameId);
      responses.writeJson(res, [...saveIds].sort());
    } catch (err) {
      console.error(err);
      responses.badRequest(req, res, 'could not load admin stats');
    }
  }
}

================
File: routes/ApiGameLogs.ts
================
import * as responses from '../server/responses';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {GameLogs} from './GameLogs';
import {isPlayerId, isSpectatorId} from '../../common/Types';
import {Request} from '../Request';
import {Response} from '../Response';

export class ApiGameLogs extends Handler {
  public static readonly INSTANCE = new ApiGameLogs();
  private constructor(private gameLogs = new GameLogs()) {
    super();
  }

  public override async get(req: Request, res: Response, ctx: Context): Promise<void> {
    const searchParams = ctx.url.searchParams;
    const id = searchParams.get('id');
    if (!id) {
      responses.badRequest(req, res, 'missing id parameter');
      return;
    }
    if (!isPlayerId(id) && !isSpectatorId(id)) {
      responses.badRequest(req, res, 'invalid player id');
      return;
    }
    const game = await ctx.gameLoader.getGame(id);
    if (game === undefined) {
      responses.notFound(req, res, 'game not found');
      return;
    }

    if (searchParams.get('full') !== null) {
      let logs = '';
      try {
        logs = this.gameLogs.getLogsForGameEnd(game).join('\n');
      } catch (e) {
        responses.badRequest(req, res, 'cannot fetch game-end log');
        return;
      }
      res.setHeader('Content-Type', 'text/plain');
      res.end(logs);
    } else {
      const generation = searchParams.get('generation');
      const logs = this.gameLogs.getLogsForGameView(id, game, generation);
      responses.writeJson(res, logs);
    }
  }
}

================
File: routes/ApiGames.ts
================
import * as responses from '../server/responses';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {Request} from '../Request';
import {Response} from '../Response';

export class ApiGames extends Handler {
  public static readonly INSTANCE = new ApiGames();
  private constructor() {
    super({validateServerId: true});
  }

  public override async get(req: Request, res: Response, ctx: Context): Promise<void> {
    const list = await ctx.gameLoader.getIds();
    if (list === undefined) {
      responses.notFound(req, res, 'could not load game list');
      return;
    }
    responses.writeJson(res, list);
  }
}

================
File: routes/ApiIPs.ts
================
import * as responses from '../server/responses';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {Request} from '../Request';
import {Response} from '../Response';

export class ApiIPs extends Handler {
  public static readonly INSTANCE = new ApiIPs();
  private constructor() {
    super({validateServerId: true});
  }

  public override get(_req: Request, res: Response, ctx: Context): Promise<void> {
    responses.writeJson(res, ctx.ipTracker.toJSON(), 2);
    return Promise.resolve();
  }
}

================
File: routes/ApiMetrics.ts
================
import * as prometheus from 'prom-client';
import * as responses from '../server/responses';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {Request} from '../Request';
import {Response} from '../Response';

export class ApiMetrics extends Handler {
  public static readonly INSTANCE = new ApiMetrics();
  private constructor() {
    super({validateServerId: true});
  }

  public override async get(req: Request, res: Response, _ctx: Context): Promise<void> {
    try {
      const register = prometheus.register;
      res.setHeader('Content-Type', register.contentType);
      res.end(await register.metrics());
    } catch (err) {
      console.error(err);
      responses.badRequest(req, res, 'could not load metrics');
    }
  }
}

================
File: routes/ApiPlayer.ts
================
import * as responses from '../server/responses';
import {isPlayerId} from '../../common/Types';
import {Server} from '../models/ServerModel';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {Request} from '../Request';
import {Response} from '../Response';

export class ApiPlayer extends Handler {
  public static readonly INSTANCE = new ApiPlayer();

  private constructor() {
    super();
  }

  public override async get(req: Request, res: Response, ctx: Context): Promise<void> {
    const playerId = ctx.url.searchParams.get('id');
    if (playerId === null) {
      responses.badRequest(req, res, 'missing id parameter');
      return;
    }
    if (!isPlayerId(playerId)) {
      responses.badRequest(req, res, 'invalid player id');
      return;
    }
    const game = await ctx.gameLoader.getGame(playerId);
    if (game === undefined) {
      responses.notFound(req, res);
      return;
    }
    try {
      ctx.ipTracker.addParticipant(playerId, ctx.ip);
      const player = game.getPlayerById(playerId);
      responses.writeJson(res, Server.getPlayerModel(player));
    } catch (err) {
      console.warn(`unable to find player ${playerId}`, err);
      responses.notFound(req, res);
      return;
    }
  }
}

================
File: routes/ApiSpectator.ts
================
import * as responses from '../server/responses';
import {Server} from '../models/ServerModel';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {IGame} from '../IGame';
import {isSpectatorId} from '../../common/Types';
import {Request} from '../Request';
import {Response} from '../Response';

export class ApiSpectator extends Handler {
  public static readonly INSTANCE = new ApiSpectator();

  private constructor() {
    super();
  }

  public override async get(req: Request, res: Response, ctx: Context): Promise<void> {
    const id = ctx.url.searchParams.get('id');
    if (!id) {
      responses.badRequest(req, res, 'invalid id');
      return;
    }
    let game: IGame | undefined;
    if (isSpectatorId(id)) {
      game = await ctx.gameLoader.getGame(id);
    }
    if (game === undefined) {
      responses.notFound(req, res);
      return;
    }
    responses.writeJson(res, Server.getSpectatorModel(game));
  }
}

================
File: routes/ApiStats.ts
================
import * as responses from '../server/responses';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {Database} from '../database/Database';
import {Request} from '../Request';
import {Response} from '../Response';

export class ApiStats extends Handler {
  public static readonly INSTANCE = new ApiStats();
  private constructor() {
    super({validateStatsId: true});
  }

  public override async get(req: Request, res: Response, _ctx: Context): Promise<void> {
    try {
      const stats = await Database.getInstance().stats();
      responses.writeJson(res, stats, 2);
    } catch (err) {
      console.error(err);
      responses.badRequest(req, res, 'could not load admin stats');
    }
  }
}

================
File: routes/ApiWaitingFor.ts
================
import * as responses from '../server/responses';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {Phase} from '../../common/Phase';
import {IPlayer} from '../IPlayer';
import {WaitingForModel} from '../../common/models/WaitingForModel';
import {IGame} from '../IGame';
import {isPlayerId, isSpectatorId} from '../../common/Types';
import {Request} from '../Request';
import {Response} from '../Response';

export class ApiWaitingFor extends Handler {
  public static readonly INSTANCE = new ApiWaitingFor();
  private constructor() {
    super();
  }

  private timeToGo(player: IPlayer): boolean {
    return player.getWaitingFor() !== undefined || player.game.phase === Phase.END;
  }

  private playersWithInputs(game: IGame) {
    return game.getPlayersInGenerationOrder().filter((player) => player.getWaitingFor() !== undefined).map((player) => player.color);
  }

  private getPlayerWaitingForModel(player: IPlayer, game: IGame, gameAge: number, undoCount: number): WaitingForModel {
    const inputs = this.playersWithInputs(game);
    if (this.timeToGo(player)) {
      return {result: 'GO', waitingFor: inputs};
    } else if (game.gameAge > gameAge || game.undoCount > undoCount) {
      return {result: 'REFRESH', waitingFor: inputs};
    }
    return {result: 'WAIT', waitingFor: inputs};
  }

  private getSpectatorWaitingForModel(game: IGame, gameAge: number, undoCount: number): WaitingForModel {
    const inputs = this.playersWithInputs(game);

    if (game.gameAge > gameAge || game.undoCount > undoCount) {
      return {result: 'REFRESH', waitingFor: inputs};
    }
    return {result: 'WAIT', waitingFor: inputs};
  }

  public override async get(req: Request, res: Response, ctx: Context): Promise<void> {
    const id = String(ctx.url.searchParams.get('id'));
    const gameAge = Number(ctx.url.searchParams.get('gameAge'));
    const undoCount = Number(ctx.url.searchParams.get('undoCount'));

    let game: IGame | undefined;
    if (isSpectatorId(id) || isPlayerId(id)) {
      game = await ctx.gameLoader.getGame(id);
    }
    if (game === undefined) {
      responses.notFound(req, res, 'cannot find game for that player');
      return;
    }
    try {
      if (isPlayerId(id)) {
        ctx.ipTracker.addParticipant(id, ctx.ip);
        responses.writeJson(res, this.getPlayerWaitingForModel(game.getPlayerById(id), game, gameAge, undoCount));
      } else if (isSpectatorId(id)) {
        responses.writeJson(res, this.getSpectatorWaitingForModel(game, gameAge, undoCount));
      } else {
        responses.internalServerError(req, res, 'id not found');
      }
    } catch (err) {
      // This is basically impossible since getPlayerById ensures that the player is on that game.
      console.warn(`unable to find player ${id}`, err);
      responses.notFound(req, res, 'player not found');
    }
  }
}

================
File: routes/Autopass.ts
================
import * as responses from '../server/responses';
import {IPlayer} from '../IPlayer';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {isPlayerId} from '../../common/Types';
import {Request} from '../Request';
import {Response} from '../Response';

/**
 * Toggle the player's autopass setting.
 */
export class Autopass extends Handler {
  public static readonly INSTANCE = new Autopass();

  public override async get(req: Request, res: Response, ctx: Context): Promise<void> {
    const playerId = ctx.url.searchParams.get('id');
    if (playerId === null) {
      responses.badRequest(req, res, 'missing id parameter');
      return;
    }

    if (!isPlayerId(playerId)) {
      responses.badRequest(req, res, 'invalid player id');
      return;
    }

    ctx.ipTracker.addParticipant(playerId, ctx.ip);

    const autopass = ctx.url.searchParams.get('autopass') === 'true';

    // This is the exact same code as in `ApiPlayer`. I bet it's not the only place.
    const game = await ctx.gameLoader.getGame(playerId);
    if (game === undefined) {
      responses.notFound(req, res, 'cannot find game for that player');
      return;
    }
    let player: IPlayer | undefined;
    try {
      player = game.getPlayerById(playerId);
    } catch (err) {
      console.warn(`unable to find player ${playerId}`, err);
    }
    if (player === undefined) {
      responses.notFound(req, res, 'player not found');
      return;
    }

    // This doesn't get saved.
    player.autopass = autopass;
  }
}

================
File: routes/BufferCache.ts
================
import * as crypto from 'crypto';

interface BufferHash {
  buffer: Buffer,
  hash: string
}

export class BufferCache {
  private storage = new Map<string, BufferHash>();
  public get(key: string): BufferHash | undefined {
    return this.storage.get(key);
  }
  public set(key: string, buffer: Buffer) {
    this.storage.set(key, {
      buffer,
      hash: this.hash(buffer),
    });
  }
  private hash(data: Buffer): string {
    return crypto.createHash('md5').update(data).digest('hex');
  }
}

================
File: routes/ContentType.ts
================
const CONTENT_TYPES: Map<string /* file extension */, string /* content type*/> = new Map([
  ['ico', 'image/x-icon'],
  ['css', 'text/css'],
  ['html', 'text/html; charset=utf-8'],
  ['js', 'text/javascript'],
  ['map', 'text/javascript'],
  ['ttf', 'font/ttf'],
  ['jpg', 'image/jpeg'],
  ['jpeg', 'image/jpeg'],
  ['png', 'image/png'],
]);

export class ContentType {
  public static getContentType(filename: string): string | undefined {
    const parts = filename.split('.');
    let idx = parts.length - 1;
    if (parts[idx] === 'br' || parts[idx] === 'gz') {
      idx--;
    }
    if (idx < 0) {
      return undefined;
    }
    const suffix = parts[idx];
    return CONTENT_TYPES.get(suffix);
  }
}

================
File: routes/Game.ts
================
import * as responses from '../server/responses';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {Database} from '../database/Database';
import {BoardName} from '../../common/boards/BoardName';
import {RandomBoardOption} from '../../common/boards/RandomBoardOption';
import {Cloner} from '../database/Cloner';
import {GameLoader} from '../database/GameLoader';
import {Game} from '../Game';
import {GameOptions} from '../game/GameOptions';
import {Player} from '../Player';
import {Server} from '../models/ServerModel';
import {ServeAsset} from './ServeAsset';
import {NewGameConfig} from '../../common/game/NewGameConfig';
import {safeCast, isGameId, isSpectatorId, isPlayerId} from '../../common/Types';
import {generateRandomId} from '../utils/server-ids';
import {IGame} from '../IGame';
import {Request} from '../Request';
import {Response} from '../Response';
import {QuotaConfig, QuotaHandler} from '../server/QuotaHandler';
import {durationToMilliseconds} from '../utils/durations';

function get(): QuotaConfig {
  const defaultQuota = {limit: 1, perMs: 1}; // Effectively, no limit.
  const val = process.env.GAME_QUOTA;
  try {
    if (val !== undefined) {
      const struct = JSON.parse(val);
      let {limit, per} = struct;
      if (limit === undefined) {
        throw new Error('limit is absent');
      }
      limit = Number.parseInt(limit);
      if (isNaN(limit)) {
        throw new Error('limit is invalid');
      }
      if (per === undefined) {
        throw new Error('per is absent');
      }
      const perMs = durationToMilliseconds(per);
      if (isNaN(perMs)) {
        throw new Error('perMillis is invalid');
      }
      return {limit, perMs};
    }
    return defaultQuota;
  } catch (e) {
    console.warn('While initialzing quota:', (e instanceof Error ? e.message : e));
    return defaultQuota;
  }
}

// Oh, this could be called Game, but that would introduce all kinds of issues.
// Calling get() feeds the game to the player (I think, and calling put creates a game.)
// So, that should be fixed, you know.
export class GameHandler extends Handler {
  public static readonly INSTANCE = new GameHandler();
  private quotaHandler;

  private constructor(quotaConfig: QuotaConfig = get()) {
    super();
    this.quotaHandler = new QuotaHandler(quotaConfig);
  }

  public static boardOptions(board: RandomBoardOption | BoardName): Array<BoardName> {
    const allBoards = Object.values(BoardName);

    if (board === RandomBoardOption.ALL) return allBoards;
    if (board === RandomBoardOption.OFFICIAL) {
      return allBoards.filter((name) => {
        return name === BoardName.THARSIS ||
          name === BoardName.HELLAS ||
          name === BoardName.ELYSIUM;
      });
    }
    return [board];
  }

  public override get(req: Request, res: Response, ctx: Context): Promise<void> {
    req.url = '/assets/index.html';
    return ServeAsset.INSTANCE.get(req, res, ctx);
  }

  // TODO(kberg): much of this code can be moved outside of handler, and that
  // would be better.
  public override put(req: Request, res: Response, ctx: Context): Promise<void> {
    return new Promise((resolve) => {
      if (this.quotaHandler.measure(ctx) === false) {
        responses.quotaExceeded(req, res);
        resolve();
        return;
      }

      let body = '';
      req.on('data', function(data) {
        body += data.toString();
      });
      req.once('end', async () => {
        try {
          const gameReq = JSON.parse(body) as NewGameConfig;
          const gameId = safeCast(generateRandomId('g'), isGameId);
          const spectatorId = safeCast(generateRandomId('s'), isSpectatorId);
          const players = gameReq.players.map((obj: any) => {
            return new Player(
              obj.name,
              obj.color,
              obj.beginner,
              Number(obj.handicap), // For some reason handicap is coming up a string.
              safeCast(generateRandomId('p'), isPlayerId),
            );
          });
          let firstPlayerIdx = 0;
          for (let i = 0; i < gameReq.players.length; i++) {
            if (gameReq.players[i].first === true) {
              firstPlayerIdx = i;
              break;
            }
          }

          const boards = GameHandler.boardOptions(gameReq.board);
          gameReq.board = boards[Math.floor(Math.random() * boards.length)];

          const gameOptions: GameOptions = {
            altVenusBoard: gameReq.altVenusBoard,
            aresExtension: gameReq.aresExtension,
            aresHazards: true, // Not a runtime option.
            bannedCards: gameReq.bannedCards,
            boardName: gameReq.board,
            ceoExtension: gameReq.ceoExtension,
            clonedGamedId: gameReq.clonedGamedId,
            coloniesExtension: gameReq.colonies,
            communityCardsOption: gameReq.communityCardsOption,
            corporateEra: gameReq.corporateEra,
            customCeos: gameReq.customCeos,
            customColoniesList: gameReq.customColoniesList,
            customCorporationsList: gameReq.customCorporationsList,
            customPreludes: gameReq.customPreludes,
            draftVariant: gameReq.draftVariant,
            escapeVelocityBonusSeconds: gameReq.escapeVelocityBonusSeconds,
            escapeVelocityMode: gameReq.escapeVelocityMode,
            escapeVelocityPenalty: gameReq.escapeVelocityPenalty,
            escapeVelocityPeriod: gameReq.escapeVelocityPeriod,
            escapeVelocityThreshold: gameReq.escapeVelocityThreshold,
            fastModeOption: gameReq.fastModeOption,
            includedCards: gameReq.includedCards,
            includeFanMA: gameReq.includeFanMA,
            includeVenusMA: gameReq.includeVenusMA,
            initialDraftVariant: gameReq.initialDraft,
            moonExpansion: gameReq.moonExpansion,
            moonStandardProjectVariant: gameReq.moonStandardProjectVariant,
            moonStandardProjectVariant1: gameReq.moonStandardProjectVariant1,
            pathfindersExpansion: gameReq.pathfindersExpansion,
            politicalAgendasExtension: gameReq.politicalAgendasExtension,
            prelude2Expansion: gameReq.prelude2Expansion,
            preludeDraftVariant: gameReq.preludeDraftVariant,
            preludeExtension: gameReq.prelude,
            promoCardsOption: gameReq.promoCardsOption,
            randomMA: gameReq.randomMA,
            removeNegativeGlobalEventsOption: gameReq.removeNegativeGlobalEventsOption,
            requiresMoonTrackCompletion: gameReq.requiresMoonTrackCompletion,
            requiresVenusTrackCompletion: gameReq.requiresVenusTrackCompletion,
            showOtherPlayersVP: gameReq.showOtherPlayersVP,
            showTimers: gameReq.showTimers,
            shuffleMapOption: gameReq.shuffleMapOption,
            solarPhaseOption: gameReq.solarPhaseOption,
            soloTR: gameReq.soloTR,
            startingCeos: gameReq.startingCeos,
            startingCorporations: gameReq.startingCorporations,
            starWarsExpansion: gameReq.starWarsExpansion,
            turmoilExtension: gameReq.turmoil,
            twoCorpsVariant: gameReq.twoCorpsVariant,
            underworldExpansion: gameReq.underworldExpansion,
            undoOption: gameReq.undoOption,
            venusNextExtension: gameReq.venusNext,
            chemicalExpansion: gameReq.chemicalExpansion,
          };

          let game: IGame;
          if (gameOptions.clonedGamedId !== undefined && !gameOptions.clonedGamedId.startsWith('#')) {
            const serialized = await Database.getInstance().getGameVersion(gameOptions.clonedGamedId, 0);
            game = Cloner.clone(gameId, players, firstPlayerIdx, serialized);
          } else {
            const seed = Math.random();
            game = Game.newInstance(gameId, players, players[firstPlayerIdx], gameOptions, seed, spectatorId);
          }
          GameLoader.getInstance().add(game);
          responses.writeJson(res, Server.getSimpleGameModel(game));
        } catch (error) {
          responses.internalServerError(req, res, error);
        }
        resolve();
      });
    });
  }
}

================
File: routes/GameLogs.ts
================
import {LogMessage} from '../../common/logs/LogMessage';
import {LogMessageType} from '../../common/logs/LogMessageType';
import {ParticipantId} from '../../common/Types';
import {IGame} from '../IGame';
import {Phase} from '../../common/Phase';
import {Log} from '../../common/logs/Log';
import {LogMessageData} from '../../common/logs/LogMessageData';
import {LogMessageDataType} from '../../common/logs/LogMessageDataType';

export class GameLogs {
  private getLogsForGeneration(messages: Array<LogMessage>, generation: number): Array<LogMessage> {
    let foundStart = generation === 1;
    const newMessages = [];
    for (const message of messages) {
      if (message.type === LogMessageType.NEW_GENERATION) {
        const value = Number(message.data[0]?.value);
        if (value === generation) {
          foundStart = true;
        } else if (value === generation + 1) {
          break;
        }
      }
      if (foundStart === true) {
        newMessages.push(message);
      }
    }
    return newMessages;
  }

  public getLogsForGameView(playerId: ParticipantId, game: IGame, generation: string | null): Array<LogMessage> {
    const messagesForPlayer = ((message: LogMessage) => message.playerId === undefined || message.playerId === playerId);

    // for most recent generation pull last 50 log messages
    if (generation === null || Number(generation) === game.generation) {
      return game.gameLog.filter(messagesForPlayer).slice(-50);
    } else { // pull all logs for generation
      return this.getLogsForGeneration(game.gameLog, Number(generation)).filter(messagesForPlayer);
    }
  }

  public getLogsForGameEnd(game: IGame): Array<string> {
    if (game.phase !== Phase.END) {
      throw new Error('Game is not over');
    }

    return game.gameLog.map((message) => Log.applyData(message, (datum: LogMessageData) => {
      if (datum.type === undefined || datum.value === undefined) {
        return '';
      }

      switch (datum.type) {
      case LogMessageDataType.PLAYER:
        for (const player of game.getPlayers()) {
          if (datum.value === player.color) {
            return player.name;
          }
        }
        // Fall-back, show the player color.
        return datum.value;

      case LogMessageDataType.CARD:
      case LogMessageDataType.GLOBAL_EVENT:
      case LogMessageDataType.TILE_TYPE:
      case LogMessageDataType.COLONY:
      default:
        return datum.value.toString();
      }
    }));
  }
}

================
File: routes/GamesOverview.ts
================
import {Handler} from './Handler';
import {Context} from './IHandler';
import {ServeApp} from './ServeApp';
import {ServeAsset} from './ServeAsset';
import {Request} from '../Request';
import {Response} from '../Response';

// A strange way to get a games overview, by serving index.html with a validated server id.
// Is this hackable?
export class GamesOverview extends Handler {
  public static INSTANCE: ServeApp = new GamesOverview();
  private constructor() {
    super({validateServerId: true});
  }
  public override get(req: Request, res: Response, ctx: Context): Promise<void> {
    req.url = '/assets/index.html';
    return ServeAsset.INSTANCE.get(req, res, ctx);
  }
}

================
File: routes/Handler.ts
================
import * as responses from '../server/responses';
import {IHandler, Context} from './IHandler';
import {Request} from '../Request';
import {Response} from '../Response';

export type Options = {
  validateServerId: boolean;
  validateStatsId: boolean;
}

export abstract class Handler implements IHandler {
  private options: Options;
  constructor(options?: Partial<Options>) {
    this.options = {
      validateServerId: options?.validateServerId === true,
      validateStatsId: options?.validateStatsId === true,
    };
  }

  private isServerIdValid(ctx: Context): boolean {
    const serverId = ctx.url.searchParams.get('serverId');
    return serverId !== null && serverId === ctx.ids.serverId;
  }

  private isStatsIdValid(ctx: Context): boolean {
    const serverId = ctx.url.searchParams.get('serverId');
    return serverId !== null && serverId === ctx.ids.statsId;
  }

  processRequest(req: Request, res: Response, ctx: Context): Promise<void> {
    if (this.options.validateServerId && !this.isServerIdValid(ctx)) {
      responses.notAuthorized(req, res);
      return Promise.resolve();
    }

    if (this.options.validateStatsId) {
      if (this.isServerIdValid(ctx)) {
        responses.downgradeRedirect(req, res, ctx);
        return Promise.resolve();
      }

      if (!this.isStatsIdValid(ctx)) {
        responses.notAuthorized(req, res);
        return Promise.resolve();
      }
    }

    switch (req.method) {
    case 'GET':
      return this.get(req, res, ctx);
    case 'PUT':
      return this.put(req, res, ctx);
    case 'POST':
      return this.post(req, res, ctx);
    default:
      responses.badRequest(req, res, 'Bad method');
      return Promise.resolve();
    }
  }

  public get(req: Request, res: Response, _ctx: Context): Promise<void> {
    responses.notFound(req, res);
    return Promise.resolve();
  }
  public put(req: Request, res: Response, _ctx: Context): Promise<void> {
    responses.notFound(req, res);
    return Promise.resolve();
  }
  public post(req: Request, res: Response, _ctx: Context): Promise<void> {
    responses.notFound(req, res);
    return Promise.resolve();
  }
}

================
File: routes/IHandler.ts
================
import {IGameLoader} from '../database/IGameLoader';
import {IPTracker} from '../server/IPTracker';
import {Request} from '../Request';
import {Response} from '../Response';
import {Clock} from '../../common/Timer';

export interface IHandler {
  processRequest(req: Request, res: Response, ctx: Context): Promise<void>;
}

export type Context = {
  url: URL,
  ip: string,
  gameLoader: IGameLoader,
  ipTracker: IPTracker,
  ids: {
    serverId: string,
    statsId: string,
  },
  clock: Clock;
}

================
File: routes/Load.ts
================
import {Handler} from './Handler';
import {Context} from './IHandler';
import {ServeApp} from './ServeApp';
import {Request} from '../Request';
import {Response} from '../Response';

export class Load extends Handler {
  public static readonly INSTANCE = new Load();
  private constructor() {
    super({validateServerId: true});
  }

  public override get(req: Request, res: Response, ctx: Context): Promise<void> {
    req.url = '/assets/index.html';
    return ServeApp.INSTANCE.get(req, res, ctx);
  }
}

================
File: routes/LoadGame.ts
================
import * as responses from '../server/responses';
import {Database} from '../database/Database';
import {GameLoader} from '../database/GameLoader';
import {Server} from '../models/ServerModel';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {LoadGameFormModel} from '../../common/models/LoadGameFormModel';
import {Request} from '../Request';
import {Response} from '../Response';
import {isGameId} from '../../common/Types';

export class LoadGame extends Handler {
  public static readonly INSTANCE = new LoadGame();
  private constructor() {
    super();
  }

  public override put(req: Request, res: Response, _ctx: Context): Promise<void> {
    return new Promise((resolve) => {
      let body = '';
      req.on('data', function(data) {
        body += data.toString();
      });
      req.once('end', async () => {
        try {
          const gameReq: LoadGameFormModel = JSON.parse(body);

          const gameId = gameReq.gameId;
          if (!isGameId(gameId)) {
            throw new Error('Invalid game id');
          }
          // This should probably be behind some kind of verification that prevents just
          // anyone from rolling back a large number of steps.
          const rollbackCount = gameReq.rollbackCount;
          if (rollbackCount > 0) {
            Database.getInstance().deleteGameNbrSaves(gameId, rollbackCount);
          }
          const game = await GameLoader.getInstance().getGame(gameId, /* bypassCache */ true);
          if (game === undefined) {
            console.warn(`unable to find ${gameId} in database`);
            responses.notFound(req, res, 'game_id not found');
          } else {
            responses.writeJson(res, Server.getSimpleGameModel(game));
          }
        } catch (error) {
          responses.internalServerError(req, res, error);
        }
        resolve();
      });
    });
  }
}

================
File: routes/PlayerInput.ts
================
import * as responses from '../server/responses';
import {IPlayer} from '../IPlayer';
import {Server} from '../models/ServerModel';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {OrOptions} from '../inputs/OrOptions';
import {UndoActionOption} from '../inputs/UndoActionOption';
import {InputResponse} from '../../common/inputs/InputResponse';
import {isPlayerId} from '../../common/Types';
import {Request} from '../Request';
import {Response} from '../Response';
import {runId} from '../utils/server-ids';
import {AppError} from '../server/AppError';
import {statusCode} from '../../common/http/statusCode';
import {InputError} from '../inputs/InputError';

export class PlayerInput extends Handler {
  public static readonly INSTANCE = new PlayerInput();

  public override async post(req: Request, res: Response, ctx: Context): Promise<void> {
    const playerId = ctx.url.searchParams.get('id');
    if (playerId === null) {
      responses.badRequest(req, res, 'missing id parameter');
      return;
    }

    if (!isPlayerId(playerId)) {
      responses.badRequest(req, res, 'invalid player id');
      return;
    }

    ctx.ipTracker.addParticipant(playerId, ctx.ip);

    // This is the exact same code as in `ApiPlayer`. I bet it's not the only place.
    const game = await ctx.gameLoader.getGame(playerId);
    if (game === undefined) {
      responses.notFound(req, res);
      return;
    }
    let player: IPlayer | undefined;
    try {
      player = game.getPlayerById(playerId);
    } catch (err) {
      console.warn(`unable to find player ${playerId}`, err);
    }
    if (player === undefined) {
      responses.notFound(req, res);
      return;
    }
    return this.processInput(req, res, ctx, player);
  }

  private isWaitingForUndo(player: IPlayer, entity: InputResponse): boolean {
    const waitingFor = player.getWaitingFor();
    if (entity.type === 'or' && waitingFor instanceof OrOptions) {
      const idx = entity.index;
      return waitingFor.options[idx] instanceof UndoActionOption;
    }
    return false;
  }

  private async performUndo(_req: Request, res: Response, ctx: Context, player: IPlayer): Promise<void> {
    /**
     * The `lastSaveId` property is incremented during every `takeAction`.
     * The first save being decremented is the increment during `takeAction` call
     * The second save being decremented is the action that was taken
     */
    const lastSaveId = player.game.lastSaveId - 2;
    try {
      const game = await ctx.gameLoader.restoreGameAt(player.game.id, lastSaveId);
      if (game === undefined) {
        player.game.log('Unable to perform undo operation. Error retrieving game from database. Please try again.', () => {}, {reservedFor: player});
      } else {
        // pull most recent player instance
        player = game.getPlayerById(player.id);
      }
    } catch (err) {
      console.error(err);
    }
    responses.writeJson(res, Server.getPlayerModel(player));
  }

  private processInput(req: Request, res: Response, ctx: Context, player: IPlayer): Promise<void> {
    // TODO(kberg): Find a better place for this optimization.
    player.tableau.forEach((card) => card.warnings.clear());
    return new Promise((resolve) => {
      let body = '';
      req.on('data', (data) => {
        body += data.toString();
      });
      req.once('end', async () => {
        try {
          const entity = JSON.parse(body);
          validateRunId(entity);
          if (this.isWaitingForUndo(player, entity)) {
            await this.performUndo(req, res, ctx, player);
          } else {
            player.process(entity);
            responses.writeJson(res, Server.getPlayerModel(player));
          }
          resolve();
        } catch (e) {
          if (!(e instanceof AppError || e instanceof InputError)) {
            console.warn('Error processing input from player', e);
          }
          // TODO(kberg): use responses.ts, though that changes the output.
          res.writeHead(statusCode.badRequest, {
            'Content-Type': 'application/json',
          });

          const id = e instanceof AppError ? e.id : undefined;
          const message = e instanceof Error ? e.message : String(e);
          res.write(JSON.stringify({id: id, message: message}));
          res.end();
          resolve();
        }
      });
    });
  }
}
function validateRunId(entity: any) {
  if (entity.runId !== undefined && runId !== undefined) {
    if (entity.runId !== runId) {
      throw new AppError('#invalid-run-id', 'The server has restarted. Click OK to refresh this page.');
    }
  }
  // Clearing this out to be compatible with the input response processors.
  delete entity.runId;
}

================
File: routes/Reset.ts
================
import * as responses from '../server/responses';
import {Server} from '../models/ServerModel';
import {Handler} from './Handler';
import {Context} from './IHandler';
import {IPlayer} from '../IPlayer';
import {isPlayerId} from '../../common/Types';
import {Request} from '../Request';
import {Response} from '../Response';

/**
 * Reloads the game from the last action.
 *
 * This may only be called by the active player. It reloads the game.
 * Now, given the current save behavior. The game isn't saved after every action.
 * I think it's saved after every action when undo is on. So, there's that.
 * But I forget when the game is saved in solo. Probably all will be well.
 *
 * Eventually, this will not be callable once cards are drawn.
 */
export class Reset extends Handler {
  public static readonly INSTANCE = new Reset();
  private constructor() {
    super();
  }

  public override async get(req: Request, res: Response, ctx: Context): Promise<void> {
    const playerId = ctx.url.searchParams.get('id');
    if (playerId === null) {
      responses.badRequest(req, res, 'missing id parameter');
      return;
    }

    if (!isPlayerId(playerId)) {
      responses.badRequest(req, res, 'invalid player id');
      return;
    }

    // This is the exact same code as in `ApiPlayer`. I bet it's not the only place.
    const game = await ctx.gameLoader.getGame(playerId);
    if (game === undefined) {
      responses.notFound(req, res);
      return;
    }

    // While prototyping, this is only available for solo games
    if (game.getPlayers().length > 1) {
      throw new Error('Reset is only available for solo games at the moment.');
    }

    let player: IPlayer | undefined;
    try {
      player = game.getPlayerById(playerId);
    } catch (err) {
      console.warn(`unable to find player ${playerId}`, err);
    }
    if (player === undefined) {
      responses.notFound(req, res);
      return;
    }
    if (player.game.activePlayer !== player.id) {
      responses.badRequest(req, res, 'Not the active player');
      return;
    }

    try {
      const game = await ctx.gameLoader.getGame(player.game.id, /** force reload */ true);
      if (game !== undefined) {
        const reloadedPlayer = game.getPlayerById(player.id);
        game.inputsThisRound = 0;
        responses.writeJson(res, Server.getPlayerModel(reloadedPlayer));
        return;
      }
    } catch (err) {
      console.error(err);
    }
    responses.badRequest(req, res, 'Could not reset');
  }
}

================
File: routes/ServeApp.ts
================
import {Handler} from './Handler';
import {Context} from './IHandler';
import {ServeAsset} from './ServeAsset';
import {Request} from '../Request';
import {Response} from '../Response';

export class ServeApp extends Handler {
  public static INSTANCE: ServeApp = new ServeApp();
  private constructor() {
    super();
  }
  public override get(req: Request, res: Response, ctx: Context): Promise<void> {
    req.url = '/assets/index.html';
    return ServeAsset.INSTANCE.get(req, res, ctx);
  }
}

================
File: routes/ServeAsset.ts
================
import * as fs from 'fs';
import * as path from 'path';
import * as responses from '../server/responses';

import {Context} from './IHandler';
import {BufferCache} from './BufferCache';
import {ContentType} from './ContentType';
import {Handler} from './Handler';
import {isProduction} from '../utils/server';
import {Request} from '../Request';
import {Response} from '../Response';

type Encoding = 'gzip' | 'br';

export class FileAPI {
  public static readonly INSTANCE: FileAPI = new FileAPI();

  protected constructor() {}

  public readFileSync(path: string): Buffer {
    return fs.readFileSync(path);
  }
  public readFile(path: string): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      fs.readFile(path, (err, data) => {
        if (err) {
          reject(err);
        } else {
          resolve(data);
        }
      });
    });
  }
  public existsSync(path: string): boolean {
    return fs.existsSync(path);
  }
}
export class ServeAsset extends Handler {
  public static readonly INSTANCE: ServeAsset = new ServeAsset();
  private readonly cache = new BufferCache();

  // Public for tests
  public constructor(private cacheAgeSeconds: string | number = process.env.ASSET_CACHE_MAX_AGE || 0,
    // only production caches resources
    private cacheAssets: boolean = isProduction(),
    private fileApi: FileAPI = FileAPI.INSTANCE) {
    super();
    // prime the cache with styles.css and a compressed copy of it styles.css
    const styles = fileApi.readFileSync('build/styles.css');
    this.cache.set('build/styles.css', styles);
    const compressed = fileApi.readFileSync('build/styles.css.gz');
    this.cache.set('build/styles.css.gz', compressed);
    const brotli = fileApi.readFileSync('build/styles.css.br');
    this.cache.set('build/styles.css.br', brotli);
  }

  public override async get(req: Request, res: Response, _ctx: Context): Promise<void> {
    if (req.url === undefined) {
      responses.internalServerError(req, res, new Error('no url on request'));
      return;
    }

    // Remove leading slash.
    const path = req.url.substring(1);

    const supportedEncodings = this.supportedEncodings(req);
    const toFile: {file?: string, encoding?: Encoding } = this.toFile(path, supportedEncodings);

    if (toFile.file === undefined) {
      return responses.notFound(req, res);
    }

    const file = toFile.file;

    // asset caching
    const buffer = this.cacheAssets ? this.cache.get(file) : undefined;
    if (buffer !== undefined) {
      if (req.headers['if-none-match'] === buffer.hash) {
        responses.notModified(res);
        return;
      }
      res.setHeader('Cache-Control', 'must-revalidate');
      res.setHeader('ETag', buffer.hash);
    } else if (this.cacheAssets === false && req.url !== '/main.js' && req.url !== '/main.js.map') {
      res.setHeader('Cache-Control', 'max-age=' + this.cacheAgeSeconds);
    }

    const contentType = ContentType.getContentType(file);
    if (contentType !== undefined) {
      res.setHeader('Content-Type', contentType);
    }

    if (toFile.encoding !== undefined) {
      res.setHeader('Content-Encoding', toFile.encoding);
    }

    if (buffer !== undefined) {
      res.setHeader('Content-Length', buffer.buffer.length);
      res.end(buffer.buffer);
      return;
    }

    try {
      const data = await this.fileApi.readFile(file);
      res.setHeader('Content-Length', data.length);
      res.end(data);
      if (this.cacheAssets === true) {
        this.cache.set(file, data);
      }
    } catch (err) {
      console.log(err);
      responses.internalServerError(req, res, 'Cannot serve ' + path);
    }
  }

  private toMainFile(urlPath: string, encodings: Set<Encoding>): { file?: string, encoding?: Encoding } {
    let file = `build/${urlPath}`;
    let encoding: Encoding | undefined;
    if (encodings.has('br')) {
      encoding = 'br';
      file += '.br';
    } else if (encodings.has('gzip')) {
      encoding = 'gzip';
      file += '.gz';
    }

    // Return not-compressed .js files for development mode
    if (!isProduction() && !this.fileApi.existsSync(file)) {
      encoding = undefined;
      file = `build/${urlPath}`;
    }

    return {file, encoding};
  }

  private toServiceWorkerFile(urlPath: string): { file?: string, encoding?: Encoding } {
    const file = `build/src/client/${urlPath}`;

    return {file};
  }

  private toFile(urlPath: string, encodings: Set<Encoding>): { file?: string, encoding?: Encoding } {
    switch (urlPath) {
    case 'assets/index.html':
    case 'assets/Prototype.ttf':
    case 'assets/Prototype-ru.ttf':
    case 'assets/Prototype-pl.ttf':
    case 'assets/futureforces.ttf':
      return {file: urlPath};

    case 'styles.css':
      if (encodings.has('br')) {
        return {file: 'build/styles.css.br', encoding: 'br'};
      }
      if (encodings.has('gzip')) {
        return {file: 'build/styles.css.gz', encoding: 'gzip'};
      }
      return {file: 'build/styles.css'};

    case 'main.js':
    case 'main.js.map':
      return this.toMainFile(urlPath, encodings);

    case 'sw.js':
      return this.toServiceWorkerFile(urlPath);

    case 'favicon.ico':
      return {file: 'assets/favicon.ico'};

    default:
      if (urlPath.endsWith('.png') || urlPath.endsWith('.jpg') || urlPath.endsWith('.json')) {
        const assetsRoot = path.resolve('./assets');
        const resolvedFile = path.resolve(path.normalize(urlPath));

        // Only allow assets inside of assets directory
        if (resolvedFile.startsWith(assetsRoot)) {
          return {file: resolvedFile};
        }
      }
    }

    return {};
  }

  private supportedEncodings(req: Request): Set<Encoding> {
    const result = new Set<Encoding>();
    for (const header of String(req.headers['accept-encoding']).split(', ')) {
      if (header === 'br' || header === 'gzip') {
        result.add(header);
      }
    }
    return result;
  }
}

================
File: SerializedCard.ts
================
import {CardName} from '../common/cards/CardName';
import {Resource} from '../common/Resource';
import {Tag} from '../common/cards/Tag';
import {OneOrArray} from '../common/utils/types';
import {JSONValue} from '../common/Types';

export type SerializedCard = {
  allTags?: Array<Tag>; // For Aridor
  bonusResource?: OneOrArray<Resource>; // For Robotic Workforce / Mining Area / Mining Rights / Specialized Settlement
  cloneTag?: Tag; // For Pathfinders' clone tag
  isDisabled?: boolean; // For Pharmacy Union and CEO Cards.
  name: CardName;
  opgActionIsActive?: boolean; // For CEO Cards.
  generationUsed?: number; // For CEO and Underworld Cards.
  resourceCount?: number;
  targetCards?: Array<SerializedRobotCard>;
  data?: JSONValue;
}

export type SerializedRobotCard = {
  card: SerializedCard;
  resourceCount: number;
}

================
File: SerializedColony.ts
================
import {ColonyName} from '../common/colonies/ColonyName';
import {PlayerId} from '../common/Types';

export type SerializedColony = {
    name: ColonyName;
    colonies: Array<PlayerId>;
    isActive: boolean;
    trackPosition: number;
    visitor: undefined | PlayerId;
}

================
File: SerializedGame.ts
================
import {Phase} from '../common/Phase';
import {CardName} from '../common/cards/CardName';
import {SerializedClaimedMilestone} from './milestones/ClaimedMilestone';
import {SerializedFundedAward} from './awards/FundedAward';
import {DeferredAction} from './deferredActions/DeferredAction';
import {SerializedColony} from './SerializedColony';
import {SerializedPlayer} from './SerializedPlayer';
import {SerializedTurmoil} from './turmoil/SerializedTurmoil';
import {PlayerId, GameId, SpectatorId, SpaceId} from '../common/Types';
import {GameOptions} from './game/GameOptions';
import {AresData} from '../common/ares/AresData';
import {LogMessage} from '../common/logs/LogMessage';
import {SerializedBoard} from './boards/SerializedBoard';
import {SerializedMoonData} from './moon/SerializedMoonData';
import {SerializedPathfindersData} from './pathfinders/SerializedPathfindersData';
import {SerializedDeck} from './cards/SerializedDeck';
import {UnderworldData} from './underworld/UnderworldData';
import {AwardName} from '../common/ma/AwardName';
import {GlobalParameter} from '../common/GlobalParameter';

export type SerializedGame = {
    activePlayer: PlayerId;
    aresData?: AresData;
    awards: Array<AwardName>;
    beholdTheEmperor?: boolean;
    board: SerializedBoard;
    ceoDeck: SerializedDeck;
    currentSeed: number;
    claimedMilestones: Array<SerializedClaimedMilestone>;
    clonedGamedId?: string;
    colonies: Array<SerializedColony>;
    corporationDeck: SerializedDeck,
    createdTimeMs: number;
    deferredActions: Array<DeferredAction>;
    donePlayers: Array<PlayerId>;
    draftRound: number;
    first: PlayerId;
    fundedAwards: Array<SerializedFundedAward>;
    gagarinBase: Array<SpaceId>;
    gameAge: number;
    gameLog: Array<LogMessage>;
    gameOptions: GameOptions;
    generation: number;
    globalsPerGeneration: Array<Partial<Record<GlobalParameter, number>>>;
    id: GameId;
    initialDraftIteration: number;
    lastSaveId: number;
    milestones: Array<string>;
    moonData: SerializedMoonData | undefined;
    nomadSpace: SpaceId | undefined;
    pathfindersData: SerializedPathfindersData | undefined;
    oxygenLevel: number;
    passedPlayers: Array<PlayerId>;
    phase: Phase;
    players: Array<SerializedPlayer>;
    preludeDeck: SerializedDeck,
    projectDeck: SerializedDeck,
    researchedPlayers: Array<PlayerId>;
    seed: number;
    someoneHasRemovedOtherPlayersPlants: boolean;
    spectatorId: SpectatorId | undefined;
    stJosephCathedrals: Array<SpaceId>;
    syndicatePirateRaider: PlayerId | undefined;
    temperature: number;
    tradeEmbargo?: boolean;
    turmoil?: SerializedTurmoil;
    undoCount: number;
    underworldData: UnderworldData;
    // TODO(kberg): remove unDraftedCards after 2024-08-01
    unDraftedCards?: Array<[PlayerId, Array<CardName>]>;
    venusScaleLevel: number;
}

================
File: SerializedPlayer.ts
================
import {PlayerId} from '../common/Types';
import {CardName} from '../common/cards/CardName';
import {Color} from '../common/Color';
import {SerializedCard} from './SerializedCard';
import {SerializedTimer} from '../common/SerializedTimer';
import {UnderworldPlayerData} from './underworld/UnderworldData';
import {AlliedParty} from './turmoil/AlliedParty';
import {GenerationData} from './player/GenerationData';

interface DeprecatedFields {
}

export interface SerializedPlayer extends DeprecatedFields{
    actionsTakenThisGame: number;
    actionsTakenThisRound: number;
    actionsThisGeneration: Array<CardName>;
    alliedParty: AlliedParty | undefined;
    // TODO(kberg): remove ? by 2024-10-01
    autoPass?: boolean;
    beginner: boolean;
    canUseCorruptionAsMegacredits: boolean;
    canUseHeatAsMegaCredits: boolean;
    canUseTitaniumAsMegacredits: boolean;
    canUsePlantsAsMegaCredits: boolean;
    cardCost: number;
    cardDiscount: number;
    cardsInHand: Array<CardName>;
    colonyTradeDiscount: number;
    colonyTradeOffset: number;
    colonyVictoryPoints: number;
    color: Color;
    corporations: Array<SerializedCard>;
    dealtCorporationCards: Array<CardName>;
    dealtCeoCards: Array<CardName>;
    dealtPreludeCards: Array<CardName>;
    dealtProjectCards: Array<CardName>;
    draftedCards: Array<CardName>;
    draftHand: Array<CardName>,
    energy: number;
    energyProduction: number;
    fleetSize: number;
    handicap: number;
    hasTurmoilScienceTagBonus: boolean;
    heat: number;
    heatProduction: number;
    id: PlayerId;
    lastCardPlayed?: CardName;
    ceoCardsInHand: Array<CardName>;
    megaCreditProduction: number;
    megaCredits: number;
    name: string;
    needsToDraft: boolean | undefined;
    oceanBonus: number;
    pendingInitialActions: Array<CardName> | undefined;
    pickedCorporationCard: CardName | undefined;
    plantProduction: number;
    plants: number;
    plantsNeededForGreenery: number;
    //andy helion
    heatNeededForTemperature: number;
    playedCards: Array<SerializedCard>;
    politicalAgendasActionUsedCount: number;
    preludeCardsInHand: Array<CardName>;
    removedFromPlayCards: Array<CardName>;
    removingPlayers: Array<PlayerId>;
    scienceTagCount: number;
    steel: number;
    steelProduction: number;
    steelValue: number;
    terraformRating: number;
    timer: SerializedTimer;
    titanium: number;
    titaniumProduction: number;
    titaniumValue: number;
    totalDelegatesPlaced: number;
    tradesThisGeneration: number;
    turmoilPolicyActionUsed: boolean;
    underworldData: UnderworldPlayerData;
    victoryPointsByGeneration: Array<number>;
    generationData: GenerationData;

    //andy one trade
    hasTraded: boolean;
}

================
File: server.ts
================
require('dotenv').config();
require('console-stamp')(
  console,
  {format: ':date(yyyy-mm-dd HH:MM:ss Z)'},
);

import * as https from 'https';
import * as http from 'http';
import * as fs from 'fs';
import * as raw_settings from '../genfiles/settings.json';
import * as prometheus from 'prom-client';
import * as responses from './server/responses';

import {Database} from './database/Database';
import {runId, serverId} from './utils/server-ids';
import {processRequest} from './server/requestProcessor';
import {timeAsync} from './utils/timer';
import {registerBehaviorExecutor} from './behavior/BehaviorExecutor';
import {Executor} from './behavior/Executor';
import {GameLoader} from './database/GameLoader';
import {ALL_MODULE_MANIFESTS} from './cards/AllManifests';
import {initializeGlobalEventDealer} from './turmoil/globalEvents/GlobalEventDealer';

process.on('uncaughtException', (err: any) => {
  console.error('UNCAUGHT EXCEPTION', err);
});

function requestHandler(req: http.IncomingMessage, res: http.ServerResponse): void {
  try {
    processRequest(req, res);
  } catch (error) {
    responses.internalServerError(req, res, error);
  }
}

const metrics = {
  startServer: new prometheus.Gauge({
    name: 'server_start_server',
    help: 'Time to initialize the server',
    registers: [prometheus.register],
  }),
  startDatabase: new prometheus.Gauge({
    name: 'server_start_database',
    help: 'Time to initialize the database',
    registers: [prometheus.register],
  }),

};

function createServer(): http.Server | https.Server {
// If they've set up https
  if (process.env.KEY_PATH && process.env.CERT_PATH) {
    const httpsHowto =
  'https://nodejs.org/en/knowledge/HTTP/servers/how-to-create-a-HTTPS-server/';
    if (!fs.existsSync(process.env.KEY_PATH)) {
      console.error(
        'TLS KEY_PATH is set in .env, but cannot find key! Check out ' +
    httpsHowto,
      );
    } else if (!fs.existsSync(process.env.CERT_PATH)) {
      console.error(
        'TLS CERT_PATH is set in .env, but cannot find cert! Check out' +
    httpsHowto,
      );
    }
    const options = {
      key: fs.readFileSync(process.env.KEY_PATH),
      cert: fs.readFileSync(process.env.CERT_PATH),
    };
    return https.createServer(options, requestHandler);
  } else {
    return http.createServer(requestHandler);
  }
}

async function start() {
  prometheus.register.setDefaultLabels({
    app: 'terraforming-mars-app',
  });
  prometheus.collectDefaultMetrics();
  initializeGlobalEventDealer(ALL_MODULE_MANIFESTS);
  registerBehaviorExecutor(new Executor());

  const server = createServer();

  await timeAsync(Database.getInstance().initialize())
    .then((v) => {
      metrics.startDatabase.set(v.duration);
    });

  try {
    const stats = await Database.getInstance().stats();
    console.log(JSON.stringify(stats, undefined, 2));
  } catch (err) {
    // Do not fail. Just continue. Stats aren't vital.
    console.error(err);
  }
  GameLoader.getInstance().maintenance();

  const port = process.env.PORT || 8080;
  console.log(`Starting ${raw_settings.head}, built at ${raw_settings.builtAt}`);
  console.log(`Starting server on port ${port}`);

  server.listen(port);

  if (!process.env.SERVER_ID) {
    console.log(`The secret serverId for this server is \x1b[1m${serverId}\x1b[0m.`);
    console.log(`Administrative routes can be found at admin?serverId=${serverId}`);
  }
  console.log(`The public run ID is ${runId}`);
  console.log('Server is ready.');
}

try {
  start();
} catch (err) {
  console.error('Cannot start server:');
  console.error(err);
}

================
File: server/AppError.ts
================
import {AppErrorId} from '../../common/app/AppErrorId';

export class AppError extends Error {
  public id: AppErrorId;
  constructor(id: AppErrorId, message?: string) {
    super(message);
    this.id = id;
  }
}

================
File: server/heroku.ts
================
import {asArray} from '../../common/utils/utils';
import {Request} from '../Request';

export function getHerokuIpAddress(req: Request): string | undefined {
  const address = asArray(req.headers['x-forwarded-for'])[0];
  if (address === undefined) {
    return undefined;
  }
  return address;
}

================
File: server/IPBlocklist.ts
================
import {AddressInfo} from 'net';

export interface IPBlockList {
  isBlocked(id: string | AddressInfo): boolean;
  block(id: string | AddressInfo): void;
  unblock(id: string | AddressInfo): void;
  get(): Array<string>;
}

export function newIpBlocklist(ips: Array<string>): IPBlockList {
  console.log('Creating IP Blocklist with IPs ' + ips.join(', '));
  const blocklist = new BlockList();
  for (const ip of ips) {
    blocklist.block(ip);
  }
  return blocklist;
}

class BlockList implements IPBlockList {
  private ips: Set<string> = new Set();

  private toString(id: string | AddressInfo): string {
    if (typeof id === 'string') {
      return id;
    }
    return id.address;
  }
  public isBlocked(id: string | AddressInfo) {
    return this.ips.has(this.toString(id));
  }
  public block(id: string | AddressInfo) {
    this.ips.add(this.toString(id));
  }

  public unblock(id: string | AddressInfo) {
    this.ips.delete(this.toString(id));
  }

  public get(): Array<string> {
    return Array.from(this.ips);
  }
}

================
File: server/IPTracker.ts
================
import {ParticipantId} from '../../common/Types';

export interface IPTracker {
  addParticipant(participantId: ParticipantId, ip: string): void;
  add(ip: string): void;
  toJSON(): any;
}

type Value = {
  count: number,
  participantIds: Set<ParticipantId>;
}

class IPTrackerImpl implements IPTracker {
  private map = new Map<string, Value>();

  private get(k: string): Value {
    const v = this.map.get(k);
    if (v !== undefined) {
      return v;
    }
    return {count: 0, participantIds: new Set()};
  }

  public add(ip: string): void {
    const value = this.get(ip);
    value.count++;
    this.map.set(ip, value);
  }

  public addParticipant(participantId: ParticipantId, ip: string): void {
    const value = this.get(ip);
    value.participantIds.add(participantId);
    this.map.set(ip, value);
  }

  public toJSON(): any {
    const json: any = {};
    this.map.forEach((v, k) => {
      json[k] = {
        count: v.count,
        ids: Array.from(v.participantIds),
      };
    });
    return json;
  }
}

export function newIpTracker(): IPTracker {
  return new IPTrackerImpl();
}

================
File: server/QuotaHandler.ts
================
import {Context} from '../routes/IHandler';

export type QuotaConfig = {
  limit: number;
  perMs: number;
}

export class QuotaHandler {
  private times = new Map<string, Array<number | undefined>>();

  private limit: number;
  private perMs: number;

  constructor(config: QuotaConfig) {
    this.limit = config.limit;
    this.perMs = config.perMs;
    console.log(`Initialzing quota handler with {limit: ${this.limit}, perMs: ${this.perMs}}`);
  }

  measure(ctx: Context): boolean {
    const ip = ctx.ip;
    const now = ctx.clock.now();

    const times = this.times.get(ip) || [];
    times.unshift(now);
    times.length = this.limit + 1; // Trims the end, keeps the array the right size. (There are more efficient ways to do this, especially in C.)
    this.times.set(ip, times);

    const earliest = now - this.perMs;
    const oldestInCache = times[times.length - 1];
    if (oldestInCache !== undefined && oldestInCache > earliest) {
      return false;
    }

    return true;
  }
}

================
File: server/requestProcessor.ts
================
import * as prometheus from 'prom-client';
import * as responses from './responses';

import {paths} from '../../common/app/paths';

import {ApiCloneableGame} from '../routes/ApiCloneableGame';
import {ApiGameLogs} from '../routes/ApiGameLogs';
import {ApiGames} from '../routes/ApiGames';
import {ApiGame} from '../routes/ApiGame';
import {ApiGameHistory} from '../routes/ApiGameHistory';
import {ApiPlayer} from '../routes/ApiPlayer';
import {ApiStats} from '../routes/ApiStats';
import {ApiMetrics} from '../routes/ApiMetrics';
import {ApiSpectator} from '../routes/ApiSpectator';
import {ApiWaitingFor} from '../routes/ApiWaitingFor';
import {GameHandler} from '../routes/Game';
import {GameLoader} from '../database/GameLoader';
import {GamesOverview} from '../routes/GamesOverview';
import {Context, IHandler} from '../routes/IHandler';
import {Load} from '../routes/Load';
import {LoadGame} from '../routes/LoadGame';
import {PlayerInput} from '../routes/PlayerInput';
import {ServeApp} from '../routes/ServeApp';
import {ServeAsset} from '../routes/ServeAsset';
import {serverId, statsId} from '../utils/server-ids';
import {Reset} from '../routes/Reset';
import {newIpBlocklist} from './IPBlocklist';
import {ApiIPs} from '../routes/ApiIPs';
import {newIpTracker} from './IPTracker';
import {getHerokuIpAddress} from './heroku';
import {Request} from '../Request';
import {Response} from '../Response';
import {Clock} from '../../common/Timer';
import {Autopass} from '../routes/Autopass';

const metrics = {
  count: new prometheus.Counter({
    name: 'http_request_count',
    help: 'Request count',
    registers: [prometheus.register],
    labelNames: ['path', 'method'],
  }),
  latency: new prometheus.Histogram({
    name: 'http_request_latency',
    help: 'Request latency',
    registers: [prometheus.register],
    labelNames: ['path'],
    buckets: [0.1, 0.25, 0.5, 1, 2.5, 5, 10, 25, 50, 100, 250, 500, 1000],
  }),
};

const clock = new Clock();

const ips = (process.env.IP_BLOCKLIST ?? '').trim().split(' ');
const ipBlocklist = newIpBlocklist(ips);
const ipTracker = newIpTracker();

const handlers: Map<string, IHandler> = new Map(
  [
    ['', ServeApp.INSTANCE],
    [paths.ADMIN, ServeApp.INSTANCE],
    [paths.API_CLONEABLEGAME, ApiCloneableGame.INSTANCE],
    [paths.API_GAME, ApiGame.INSTANCE],
    [paths.API_GAME_HISTORY, ApiGameHistory.INSTANCE],
    [paths.API_GAME_LOGS, ApiGameLogs.INSTANCE],
    [paths.API_GAMES, ApiGames.INSTANCE],
    [paths.API_IPS, ApiIPs.INSTANCE],
    [paths.API_METRICS, ApiMetrics.INSTANCE],
    [paths.API_PLAYER, ApiPlayer.INSTANCE],
    [paths.API_STATS, ApiStats.INSTANCE],
    [paths.API_SPECTATOR, ApiSpectator.INSTANCE],
    [paths.API_WAITING_FOR, ApiWaitingFor.INSTANCE],
    [paths.AUTOPASS, Autopass.INSTANCE],
    [paths.CARDS, ServeApp.INSTANCE],
    ['favicon.ico', ServeAsset.INSTANCE],
    [paths.GAME, GameHandler.INSTANCE],
    [paths.GAMES_OVERVIEW, GamesOverview.INSTANCE],
    [paths.HELP, ServeApp.INSTANCE],
    [paths.LOAD, Load.INSTANCE],
    [paths.LOAD_GAME, LoadGame.INSTANCE],
    ['main.js', ServeAsset.INSTANCE],
    ['main.js.map', ServeAsset.INSTANCE],
    [paths.NEW_GAME, ServeApp.INSTANCE],
    [paths.PLAYER, ServeApp.INSTANCE],
    [paths.PLAYER_INPUT, PlayerInput.INSTANCE],
    [paths.RESET, Reset.INSTANCE],
    [paths.SPECTATOR, ServeApp.INSTANCE],
    ['styles.css', ServeAsset.INSTANCE],
    ['sw.js', ServeAsset.INSTANCE],
    [paths.THE_END, ServeApp.INSTANCE],
  ],
);

function getIPAddress(req: Request): string {
  const herokuIpAddress = getHerokuIpAddress(req);
  if (herokuIpAddress !== undefined) {
    return herokuIpAddress;
  }
  const socketIpAddress = req.socket.address();
  if (typeof socketIpAddress === 'object') {
    return '!' + socketIpAddress.address + '!';
  }
  return socketIpAddress;
}

function getHandler(pathname: string): IHandler | undefined {
  const handler: IHandler | undefined = handlers.get(pathname);
  if (handler !== undefined) {
    return handler;
  }
  if (pathname.startsWith('assets/')) {
    return ServeAsset.INSTANCE;
  }
  return undefined;
}

export function processRequest(
  req: Request,
  res: Response): void {
  const start = process.hrtime.bigint();
  let pathnameForLatency: string | undefined = undefined;
  try {
    const ipAddress = getIPAddress(req);
    ipTracker.add(ipAddress);
    if (ipBlocklist.isBlocked(ipAddress)) {
      responses.notFound(req, res);
    }

    if (req.method === 'HEAD') {
      res.end();
      return;
    }
    if (req.url === undefined) {
      responses.notFound(req, res);
      return;
    }

    const url = new URL(req.url, `http://${req.headers.host}`);
    const ctx: Context = {
      url: url,
      clock,
      gameLoader: GameLoader.getInstance(),
      ip: getIPAddress(req),
      ipTracker: ipTracker,
      ids: {
        serverId,
        statsId,
      }};

    const pathname = url.pathname.substring(1); // Remove leading '/'
    pathnameForLatency = pathname;
    const handler = getHandler(pathname);
    if (handler !== undefined) {
      metrics.count.inc({path: pathname, method: req.method});
      handler.processRequest(req, res, ctx);
    } else {
      pathnameForLatency = undefined;
      responses.notFound(req, res);
    }
  } finally {
    const duration = Number(process.hrtime.bigint() - start) / 1_000_000;
    metrics.latency.observe({path: pathnameForLatency}, Number(duration));
  }
}

================
File: server/responses.ts
================
import {escape} from 'html-escaper';
import {Context} from '../routes/IHandler';
import {Request} from '../Request';
import {Response} from '../Response';
import {statusCode} from '../../common/http/statusCode';

export function badRequest(req: Request, res: Response, err?: string): void {
  console.warn('bad request', req.url);
  res.writeHead(statusCode.badRequest);
  res.write('Bad request');
  if (err) {
    res.write(': ');
    res.write(err);
  }
  res.end();
}

export function notFound(req: Request, res: Response, err?: string): void {
  if (!process.argv.includes('hide-not-found-warnings')) {
    console.warn('Not found', req.method, req.url);
  }
  res.writeHead(statusCode.notFound);
  res.write('Not found');
  if (err) {
    res.write(': ');
    res.write(err);
  }
  res.end();
}

export function notModified(res: Response): void {
  res.writeHead(statusCode.notModified);
  res.end();
}

export function internalServerError(
  req: Request,
  res: Response,
  err: unknown): void {
  console.warn('internal server error: ', req.url, err);
  res.writeHead(statusCode.internalServerError);

  res.write('Internal server error: ');

  if (err instanceof Error) {
    res.write(escape(err.message));
  } else if (typeof(err) === 'string') {
    res.write(escape(err));
  } else {
    res.write('unknown error');
  }

  res.end();
}

export function notAuthorized(req: Request, res: Response): void {
  console.warn('Not authorized', req.method, req.url);
  res.writeHead(statusCode.forbidden);
  res.write('Not authorized');
  res.end();
}

export function downgradeRedirect(_req: Request, res: Response, ctx: Context): void {
  const url = new URL(ctx.url); // defensive copty
  url.searchParams.set('serverId', ctx.ids.statsId);
  res.writeHead(statusCode.movedPermanently, {Location: url.pathname + url.search});
  res.end();
}

export function writeJson(res: Response, json: any, space?: string | number | undefined) {
  res.setHeader('Content-Type', 'application/json');
  const s = JSON.stringify(json, undefined, space);
  res.end(s);
}

export function quotaExceeded(req: Request, res: Response) {
  console.warn('Quota exceeded for', req.method, req.url);
  res.writeHead(statusCode.tooManyRequests);
  res.write('Quota exceeded');
  res.end();
}

================
File: SpaceName.ts
================
export enum SpaceName {
    ARSIA_MONS = '29',
    ASCRAEUS_MONS = '14',
    GANYMEDE_COLONY = '01',
    NOCTIS_CITY = '31',
    PAVONIS_MONS = '21',
    PHOBOS_SPACE_HAVEN = '02',
    THARSIS_THOLUS = '09',
    LUNA_METROPOLIS = '70',
    DAWN_CITY = '71',
    STRATOPOLIS = '72',
    MAXWELL_BASE = '73',
    ARSIA_MONS_ELYSIUM = '37',
    HECATES_THOLUS = '08',
    ELYSIUM_MONS = '14',
    OLYMPUS_MONS = '20',
    HELLAS_OCEAN_TILE = '61',

    STANFORD_TORUS = '69',

    // Vastitas Borealis Novus

    VASTITAS_BOREALIS_NOVUS_HECATES_THOLUS = '05',
    VASTITAS_BOREALIS_NOVUS_ELYSIUM_MONS = '13',
    VASTITAS_BOREALIS_NOVUS_ALBA_MONS = '21',
    VASTITAS_BOREALIS_NOVUS_URANIUS_THOULS = '46',
    VASTITAS_BOREALIS_NOVUS_NORTH_POLE = '33',

    // Vastitas Borealis
    VASTITAS_BOREALIS_NORTH_POLE = '33',
    ELYSIUM_MONS_VASTITAS_BOREALIS = '07',
    ALBA_FOSSAE = '12',
    CERANIUS_FOSSAE = '21',
    ALBA_MONS = '22',

    // Arabia Terra
    TIKHONAROV = '20',
    LADON = '55',
    FLAUGERGUES = '58',
    CHARYBDIS = '63',

    // Pathfinders
    CERES_SPACEPORT = '75',
    DYSON_SCREENS = '76',
    LUNAR_EMBASSY = '77',
    VENERA_BASE = '78',
    // MARTIAN_TRANSHIPMENT_STATION = '79',

    // Amazonis
    MEDUSAE_FOSSAE = '33',
    ALBOR_THOLUS = '09',
    ANSERIS_MONS = '35',
    PINDUS_MONS = '43',
    ULYSSES_THOLUS = '49',

    // Terra Cimmeria
    ALBOR_THOLUS_TERRACIMMERIA = '05',
    APOLLINARIS_MONS = '27',
    HADRIACUS_MONS = '38',
    TYRRHENUS_MONS = '21',

    // Chemical Off-world Cities
    TOWERS_OF_FREYJA = '80',
    OVDA_CITY = '81',
    CAPITAL_OF_VENUS = '82',
    JUPITER_FLOATING_CITY = '83',
}

================
File: Tile.ts
================
import {CardName} from '../common/cards/CardName';
import {TileType} from '../common/TileType';

export type Tile = {
  tileType: TileType;
  card?: CardName;

  protectedHazard?: boolean; // For Desperate Measures
  rotated?: boolean; // For Crashlanding
  covers?: Tile; // For Ares tiles
}

================
File: tools/analyze_ma.html
================
<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <head>
    <script src="https://d3js.org/d3.v4.js"></script>
  </head>
  <body>
    <form>
      <label for="runs">Runs: </label><input type="text" id="runs" value="10000" name="runs"><br/>
      <label for="venus">Venus: </label><input type="checkbox" id="venus" name="venus"><br/>
      <label for="ares">Ares: </label><input type="checkbox" id="ares" name="ares"><br/>
      <label for="moon">The Moon: </label><input type="checkbox" id="moon" name="moon"><br/>
      <label for="fan-maps">Fan maps: </label><input type="checkbox" id="fan-maps" name="fan-maps"><br/>

      <input type="radio" id="none" name="type" value="NONE"><label for="none">None</label>&nbsp;
      <input type="radio" id="limited" name="type" value="LIMITED" checked><label for="limited">Limited</label>&nbsp;
      <input type="radio" id="full" name="type" value="FULL"><label for="full">Full</label></br>

    </form>
    <button onclick="submit()">Submit</button>
    <div id="viz"></div>
    <div id="raw"></div>

    <script type="text/javascript">
      // set the dimensions and margins of the graph
      var margin = {top: 30, right: 30, bottom: 70, left: 60};
      var width = 1200 - margin.left - margin.right;
      var height = 400 - margin.top - margin.bottom;

      function submit() {
        var svg = d3.select("#viz")
          .html("")
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");

        var url = "http://localhost:8081/data";
        url = url + "?runs=" + d3.select("#runs").property("value");
        url = url + "&venus=" + d3.select("#venus").property("checked");
        url = url + "&ares=" + d3.select("#ares").property("checked");
        url = url + "&moon=" + d3.select("#moon").property("checked");
        url = url + "&fan-maps=" + d3.select("#fan-maps").property("checked");
        url = url + "&type=" + d3.select('input[name="type"]:checked').node().value

        d3.csv(url, (data) => process(svg, data));
      }

      function process(svg, data) {
        // X axis
        var x = d3.scaleBand()
          .range([0, width])
          .domain(data.map((d) => d.name))
          .padding(0.2);
        svg.append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x))
          .selectAll("text")
            .attr("transform", "translate(-10,0)rotate(-45)")
            .style("text-anchor", "end");

        // Add Y axis
        var y = d3.scaleLinear()
          .domain([0, Math.max(...data.map((d) => d.count))])
          .range([height, 0]);
        svg.append("g")
          .call(d3.axisLeft(y));

        // Bars
        svg.selectAll("mybar")
          .data(data)
          .enter()
          .append("rect")
            .attr("x", (d) => x(d.name))
            .attr("y", (d) => y(d.count))
            .attr("width", x.bandwidth())
            .attr("height", (d) => height - y(d.count))
            .attr("fill", "#69b3a2");

          d3.select("#raw").html("").append("code").text(data.map((e) => `${e.name}: ${e.count}`).join('\n'));
        }
    </script>
  </body>
</html>

================
File: tools/analyze_ma.ts
================
require('dotenv').config();

import * as http from 'http';
import * as fs from 'fs';
import * as responses from '../server/responses';

import {chooseMilestonesAndAwards} from '../ma/MilestoneAwardSelector';
import {DEFAULT_GAME_OPTIONS, GameOptions} from '../game/GameOptions';
import {BoardName} from '../../common/boards/BoardName';
import {RandomMAOptionType} from '../../common/ma/RandomMAOptionType';
import {MultiSet} from 'mnemonist';
import {Request} from '../Request';
import {Response} from '../Response';

function processRequest(req: Request, res: Response): void {
  if (req.url === undefined) {
    return;
  }
  const url = new URL(req.url, `http://localhost`);
  if (url.pathname === '/') {
    fs.readFile('src/server/tools/analyze_ma.html', (err, data) => {
      if (err) {
        responses.internalServerError(req, res, err);
      }
      res.setHeader('Content-Length', data.length);
      res.end(data);
    });
  } else if (url.pathname === '/data') {
    const data = calc(url.searchParams);
    res.setHeader('Content-type', 'text/csv');
    res.setHeader('Content-Length', data.length);
    res.end(data);
  } else {
    responses.notFound(req, res);
  }
}

const server = http.createServer(processRequest);
console.log('Starting server on port ' + (process.env.PORT || 8081));
server.listen(process.env.PORT || 8081);

function calc(params: URLSearchParams): string {
  const runs = Number(params.get('runs') || 100);
  const options = simpleGameOptions();

  if (params.get('venus') === 'true') {
    options.venusNextExtension = true;
    options.includeVenusMA = true;
  }

  if (params.get('ares') === 'true') {
    options.aresExtension = true;
  }

  if (params.get('moon') === 'true') {
    options.moonExpansion = true;
  }
  if (params.get('fan-maps') === 'true') {
    options.includeFanMA = true;
  }

  const type = params.get('type');
  switch (type) {
  case 'NONE':
    options.randomMA = RandomMAOptionType.NONE;
    break;
  case 'LIMITED':
    options.randomMA = RandomMAOptionType.LIMITED;
    break;
  case 'FULL':
    options.randomMA = RandomMAOptionType.UNLIMITED;
    break;
  }
  const results = new MultiSet<string>();
  for (let nth = 1; nth <= runs; nth++) {
    if (nth % 100 === 0) {
      console.log(`#${nth}`);
    }
    try {
      const mas = chooseMilestonesAndAwards(options);
      mas.awards.forEach((award) => results.add(award.name));
      mas.milestones.forEach((milestone) => results.add(milestone.name));
    } catch (err) {
      console.log(err);
      results.add('ERROR');
    }
  }

  const copy: Array<[string, number]> = new Array(...results.multiplicities());
  copy.sort((a, b) => b[1] - a[1]);
  return 'name,count\n' + copy.map(([name, count]) => `${name},${count}`).join('\n');
}

function simpleGameOptions(): GameOptions {
  return {
    ...DEFAULT_GAME_OPTIONS,
    aresHazards: false,
    corporateEra: false,
    initialDraftVariant: false,
    preludeDraftVariant: false,
    showTimers: false,
    startingCorporations: 0,

    // The options that can change, should be parameters.
    boardName: BoardName.THARSIS,
    venusNextExtension: false,
    aresExtension: false,
    includeVenusMA: false,
    moonExpansion: false,
    pathfindersExpansion: false,
    includeFanMA: false,
    randomMA: RandomMAOptionType.NONE,
  };
}

================
File: tools/check_locales.ts
================
import * as path from 'path';
import * as fs from 'fs';
import * as raw_translations from '../../genfiles/translations.json';

const LOCALES_DIR = path.resolve('./src/locales/');
const locales: Array<string> = [];

fs.readdirSync(LOCALES_DIR).forEach((localeName) => {
  locales.push(localeName);
});

const args = process.argv.slice(2);
let localesToWarn = locales;

if (args[0] === '--locales') {
  localesToWarn = args[1].split(',');
  localesToWarn.forEach((locale) => {
    if ( ! locales.includes(locale)) {
      console.error(`Invalid locale ${locale}`);
      process.exit(1);
    }
  });
} else if (args[0] !== undefined) {
  console.error(`invalid arg ${args[0]}`);
  process.exit(1);
}

let sourceString: keyof typeof raw_translations;
let missingLocales: Array<string>;

for (sourceString in raw_translations) {
  if ( ! raw_translations.hasOwnProperty(sourceString)) continue;
  const translations = raw_translations[sourceString];
  missingLocales = [];
  for (const localeName of localesToWarn) {
    const trans: string = (translations as any)[localeName];
    if (!trans) {
      missingLocales.push(localeName);
    }
  }
  if (missingLocales.length > 0) {
    console.log('"' + sourceString + '": "' + missingLocales + '"');
  }
}

================
File: tools/create_game_ids_table.ts
================
require('dotenv').config();

import {GameLoader} from '../database/GameLoader';
import {Database} from '../database/Database';

const db = Database.getInstance();

async function main() {
  await db.initialize();
  const loader = GameLoader.getInstance();
  const ledger = await loader.getIds();
  let count = 0;
  for (const entry of ledger) {
    db.storeParticipants({gameId: entry.gameId, participantIds: entry.participantIds})
      .catch((err) => {
        if (err instanceof Error && err.message.includes('duplicate key value')) {
          // ignore
          return;
        }
        console.error(`Could not save ${entry.gameId}: ${err}`);
      }).then(() => {
        count++;
        if (count === ledger.length || count % 1000 === 0) {
          console.log(`Completed ${count} of ${ledger.length}`);
        }
      });
  }
}

main();

================
File: tools/dump_log.ts
================
// Prints out the entire game log for review.
// e.g. node build/src/server/tools/dump_log.js g4940001dbc
require('dotenv').config();

import {Log} from '../../common/logs/Log';
import {isGameId} from '../../common/Types';
import {Database} from '../database/Database';
import {IDatabase} from '../database/IDatabase';

const args = process.argv.slice(2);
const [gameId] = args;

if (gameId === undefined) {
  throw new Error('missing game id');
}

const db: IDatabase = Database.getInstance();

async function main() {
  await db.initialize();

  if (!isGameId(gameId)) {
    throw new Error('game ids start with \'g\'');
  }
  const saveIds = await db.getSaveIds(gameId);
  let lastIdx = 0;
  for (const saveId of saveIds) {
    const {gameLog} = await db.getGameVersion(gameId, saveId);
    for (let idx = lastIdx; idx < gameLog.length; idx++) {
      const logEntry = gameLog[idx];
      const text = Log.applyData(logEntry, (datum) => datum.value.toString());
      console.log(`[${saveId}/${idx}]: ${text}`);
    }
    lastIdx = gameLog.length;
  }
}

main();

================
File: tools/export_card_rendering.ts
================
require('dotenv').config();
import * as fs from 'fs';

import {ALL_MODULE_MANIFESTS} from '../cards/AllManifests';
import {CardManifest, GlobalEventManifest, ModuleManifest} from '../cards/ModuleManifest';
import {ICard} from '../cards/ICard';
import {GameModule} from '../../common/cards/GameModule';
import {IGlobalEvent} from '../turmoil/globalEvents/IGlobalEvent';
import {IClientGlobalEvent} from '../../common/turmoil/IClientGlobalEvent';
import {ClientCard} from '../../common/cards/ClientCard';
import {isICorporationCard} from '../cards/corporation/ICorporationCard';
import {isPreludeCard} from '../cards/prelude/IPreludeCard';
import {IColonyMetadata} from '../../common/colonies/IColonyMetadata';
import {Units} from '../../common/Units';
import {ALL_COLONIES_TILES, getColonyModule} from '../colonies/ColonyManifest';
import {ALL_MILESTONES} from '../milestones/Milestones';
import {ALL_AWARDS} from '../awards/Awards';
import {MilestoneAwardMetadata} from '../../common/ma/MilestoneAwardMetadata';
import {AwardName} from '../../common/ma/AwardName';
import {MilestoneName} from '../../common/ma/MilestoneName';
import {CardType} from '../../common/cards/CardType';
import {OneOrArray} from '../../common/utils/types';
import {initializeGlobalEventDealer} from '../turmoil/globalEvents/GlobalEventDealer';

class CardProcessor {
  public static json: Array<ClientCard> = [];
  public static makeJson() {
    ALL_MODULE_MANIFESTS.forEach(this.processManifest);
  }

  private static processManifest(manifest: ModuleManifest) {
    CardProcessor.processDeck(manifest.module, manifest.projectCards);
    CardProcessor.processDeck(manifest.module, manifest.corporationCards);
    CardProcessor.processDeck(manifest.module, manifest.preludeCards);
    CardProcessor.processDeck(manifest.module, manifest.ceoCards);
    CardProcessor.processDeck(manifest.module, manifest.standardActions);
    CardProcessor.processDeck(manifest.module, manifest.standardProjects);
  }

  private static processDeck(module: GameModule, cardManifest: CardManifest<ICard>) {
    for (const factory of CardManifest.values(cardManifest)) {
      CardProcessor.processCard(module, new factory.Factory(), factory.compatibility);
    }
  }

  private static processCard(module: GameModule, card: ICard, compatibility: undefined | OneOrArray<GameModule>) {
    if (card.type === CardType.PROXY) return;
    let startingMegaCredits = undefined;
    let cardCost = undefined;
    if (isPreludeCard(card)) {
      startingMegaCredits = card.startingMegaCredits;
    }
    if (isICorporationCard(card)) {
      startingMegaCredits = card.startingMegaCredits;
      cardCost = card.cardCost;
    }

    const production = card.behavior?.production;
    const clientCard: ClientCard = {
      module: module,
      name: card.name,
      tags: card.tags,
      cardDiscount: card.cardDiscount,
      victoryPoints: card.victoryPoints,
      cost: card.cost,
      type: card.type,
      requirements: card.requirements ?? [],
      metadata: card.metadata,
      productionBox: Units.isUnits(production) ? production : Units.EMPTY, // Dynamic units aren't used on on the client side.
      resourceType: card.resourceType,
      startingMegaCredits: startingMegaCredits,
      cardCost: cardCost,
      compatibility: [],
    };

    if (Array.isArray(compatibility)) {
      clientCard.compatibility.push(...compatibility);
    } else if (compatibility !== undefined) {
      clientCard.compatibility.push(compatibility);
    }
    CardProcessor.json.push(clientCard);
  }
}

class GlobalEventProcessor {
  public static json: Array<IClientGlobalEvent> = [];
  public static makeJson() {
    ALL_MODULE_MANIFESTS.forEach(this.processManifest);
  }

  private static processManifest(manifest: ModuleManifest) {
    for (const cf of GlobalEventManifest.values(manifest.globalEvents)) {
      GlobalEventProcessor.processGlobalEvent(manifest.module, new cf.Factory());
    }
  }

  private static processGlobalEvent(module: GameModule, globalEvent: IGlobalEvent) {
    const event: IClientGlobalEvent = {
      module: module,
      name: globalEvent.name,
      description: globalEvent.description,
      revealedDelegate: globalEvent.revealedDelegate,
      currentDelegate: globalEvent.currentDelegate,
      renderData: globalEvent.renderData,
    };

    GlobalEventProcessor.json.push(event);
  }
}

class ColoniesProcessor {
  public static json: Array<IColonyMetadata> = [];
  public static makeJson() {
    ALL_COLONIES_TILES.forEach((entry) => {
      const colony = new entry.Factory();
      ColoniesProcessor.processColony(colony.metadata);
    });
  }

  private static processColony(metadata: IColonyMetadata) {
    // This seems extraneous but it prevents extra fields from creeping
    // into the JSON. Could do some other form, but this works and matches
    // the patterns above.
    const clientMetadata: IColonyMetadata = {
      module: getColonyModule(metadata.name),
      name: metadata.name,
      description: metadata.description,
      buildType: metadata.buildType,
      buildQuantity: metadata.buildQuantity,
      buildResource: metadata.buildResource,
      cardResource: metadata.cardResource,
      tradeType: metadata.tradeType,
      tradeQuantity: metadata.tradeQuantity,
      tradeResource: metadata.tradeResource,
      colonyBonusType: metadata.colonyBonusType,
      colonyBonusQuantity: metadata.colonyBonusQuantity,
      colonyBonusResource: metadata.colonyBonusResource,
      shouldIncreaseTrack: metadata.shouldIncreaseTrack,
    };

    ColoniesProcessor.json.push(clientMetadata);
  }
}

class MAProcessor {
  public static json: Array<MilestoneAwardMetadata> = [];
  public static makeJson() {
    ALL_MILESTONES.forEach((entry) => {
      MAProcessor.processEntry(entry);
    });

    ALL_AWARDS.forEach((entry) => {
      MAProcessor.processEntry(entry);
    });
  }

  private static processEntry(metadata: {name: MilestoneName | AwardName, description: string}) {
    MAProcessor.json.push({
      name: metadata.name,
      description: metadata.description,
    });
  }
}

if (!fs.existsSync('src/genfiles')) {
  fs.mkdirSync('src/genfiles');
}

initializeGlobalEventDealer(ALL_MODULE_MANIFESTS);
CardProcessor.makeJson();
GlobalEventProcessor.makeJson();
ColoniesProcessor.makeJson();
MAProcessor.makeJson();

fs.writeFileSync('src/genfiles/cards.json', JSON.stringify(CardProcessor.json, null, 2));
fs.writeFileSync('src/genfiles/events.json', JSON.stringify(GlobalEventProcessor.json, null, 2));
fs.writeFileSync('src/genfiles/colonies.json', JSON.stringify(ColoniesProcessor.json, null, 2));
fs.writeFileSync('src/genfiles/ma.json', JSON.stringify(MAProcessor.json, null, 2));

================
File: tools/export_game.sh
================
#!/bin/sh

die() { echo "$*" 1>&2 ; exit 1; }

[ "$#" -eq 2 ] || die "parameters required: [app] [player id | spectator id | game id]"
APP=$1
ID=$2

# xargs trims the string
POSTGRES_HOST=$(heroku pg:credentials:url --app $1 | grep postgres: | xargs)

echo POSTGRES_HOST is ${POSTGRES_HOST}

POSTGRES_HOST=${POSTGRES_HOST} node build/src/server/tools/export_game.js $2

================
File: tools/export_game.ts
================
// Exports a game locally for debugging.
// See README.md for instructions.

import {GameId, isGameId, isPlayerId, isSpectatorId} from '../../common/Types';
import {Database} from '../database/Database';
import {IDatabase} from '../database/IDatabase';
import {LocalFilesystem} from '../database/LocalFilesystem';

const args = process.argv.slice(2);
const id = args[0];

if (id === undefined) {
  throw new Error('missing game id');
}
if (process.env.LOCAL_FS_DB !== undefined) {
  throw new Error('Do not run exportGame on local filesystem. Just access the files themselves');
}

const db: IDatabase = Database.getInstance();
const localDb = new LocalFilesystem();

async function getGameId(id: string): Promise<GameId | undefined> {
  if (isGameId(id)) {
    return id;
  }
  if (isPlayerId(id) || isSpectatorId(id)) {
    console.log(`Finding game for player/spectator ${id}`);
    return await db.getGameId(id);
  }
  return undefined;
}

async function main() {
  await db.initialize();
  const gameId = await getGameId(id);
  if (gameId === undefined) {
    console.log('Game is undefined');
    process.exit(1);
  }
  await load(gameId);
}

async function load(gameId: GameId) {
  await localDb.initialize();
  console.log(`Loading game ${gameId}`);
  const game = await db.getGame(gameId);

  console.log(`Last version is ${game.lastSaveId}`);
  let errors = 0;
  let writes = 0;

  // The output might not be returned in order, because the
  // inner call is async, but it is faster than forcing the
  // results to come in order.
  const saveIds = await db.getSaveIds(gameId);
  for (const saveId of saveIds) {
    try {
      const serialized = await db.getGameVersion(gameId, saveId);
      console.log(`Storing version ${saveId}`);
      localDb.saveSerializedGame(serialized);
      writes++;
    } catch (err) {
      console.log(`failed to process saveId ${saveId}: ${err}`);
      errors++;
    }
  }
  console.log(`Wrote ${writes} records and had ${errors} failures.`);
  console.log(`id: ${gameId}`);
}

main();

================
File: tools/gzip.js
================
// Operating system agnostic version of gzip.

const fs = require('fs');
const zlib = require('zlib');

const fileContents = fs.createReadStream('./build/styles.css');
const writeStreamGz = fs.createWriteStream('./build/styles.css.gz');
const writeStreamBr = fs.createWriteStream('./build/styles.css.br');
const zip = zlib.createGzip();

fileContents.pipe(zip).pipe(writeStreamGz);

const br = zlib.createBrotliCompress({
  chunkSize: 16 * 1024,
  params: {
    [zlib.constants.BROTLI_PARAM_MODE]: zlib.constants.BROTLI_MODE_TEXT,
    [zlib.constants.BROTLI_PARAM_QUALITY]: zlib.constants.BROTLI_MAX_QUALITY,
  },
});

fileContents.pipe(br).pipe(writeStreamBr);

================
File: tools/ma_synergies.ts
================
require('dotenv').config();

import {synergies} from '../ma/MilestoneAwardSynergies';
import {MilestoneName, milestoneNames} from '../../common/ma/MilestoneName';
import {AwardName, awardNames} from '../../common/ma/AwardName';
import {Milestones} from '../milestones/Milestones';
import {Awards} from '../awards/Awards';

function get(name: MilestoneName | AwardName) {
  try {
    return Milestones.getByName(name);
  } catch (err) {
    return Awards.getByName(name);
  }
}
const manames = [...milestoneNames, ...awardNames];
for (const name of manames) {
  const first = get(name);
  console.log(`${first.name} (${first.description}):`);
  const entries = [];
  for (const name2 of manames) {
    const second = get(name2);
    const x = synergies.get(name, name2);
    if (x === 1000 || x === 0) continue;
    entries.push(` ${x} ${second.name} (${second.description})`);
  }
  entries.sort().reverse();
  entries.forEach((x) => console.log(x));
  console.log();
}

================
File: tools/read_turmoil.ts
================
// Searches through a game's log for an event.
// e.g. node build/src/server/tools/read_turmoil.js ge120f6729fca
require('dotenv').config();

import {MultiSet} from 'mnemonist';
import {isGameId} from '../../common/Types';
import {Database} from '../database/Database';
import {IDatabase} from '../database/IDatabase';
import {SerializedDelegate} from '../turmoil/SerializedTurmoil';

const args = process.argv.slice(2);
const [gameId] = args;

if (gameId === undefined) {
  throw new Error('missing game id');
}

const db: IDatabase = Database.getInstance();

async function main() {
  await db.initialize();

  if (!isGameId(gameId)) {
    throw new Error('game ids start with \'g\'');
  }
  const saveIds = await db.getSaveIds(gameId);
  for (const saveId of saveIds) {
    const serialized = await db.getGameVersion(gameId, saveId);
    const turmoil = serialized.turmoil;
    if (turmoil === undefined) {
      throw new Error('!');
    }
    const set = new MultiSet<SerializedDelegate>();
    if (turmoil.chairman) set.add(turmoil.chairman);
    turmoil.lobby?.forEach((delegate) => set.add(delegate));
    turmoil.delegateReserve.forEach((delegate) => set.add(delegate));
    turmoil.parties.forEach((party) => {
      party.delegates.forEach((delegate) => set.add(delegate));
    });
    console.log('       ', Array.from(set.multiplicities()).sort().join(', '));
    console.log();
  }
  console.log('Not found');
}

main();

================
File: tools/README.md
================
# Terraforming-mars maintenance tools

Tool directory is for specific scripts for project maintenance.

Before use them build the project `npm run build`

... then run any of compilled scripts from build directory `node <path-to-the-toolname>.js`

For example check_locales.ts tool can be run like this: `node build/src/server/tools/check_locales.js`

It is possible to run these tools "directly" by using ts-node package

1. Install ts-node on your machine `npm install -g ts-node`
2. Run the script `ts-node src/server/tools/check_locales.ts`

## Check locales tool

#### Check locales tool compares localizations and shows missing translations.

How to run: `node build/src/server/tools/check_locales.js`

Result will be something like this:
```
"Select a Mars First bonus.": "es,nl,ru"
"Gain 1 M€ for each building tag you have": "es,nl,ru"
...
```
The languages in quotes are missing that translation. (In this case, Spanish, Dutch, and Russian are missing the translation.)


#### If you want to see warnings for given locale only use --locales switch

`node build/src/server/tools/check_locales.js --locales cn,ru`

as result you will see the warnings for Chinese and Russian languages only.

## Export game

### Usage

```
npm run build
sh src/server/tools/export_game.sh <heroku-app-name>  <game id | player id | spectator id>
```

or

```
heroku pg:credentials:url --app <heroku-app-name>
POSTGRES_HOST=<postges:...> node build/src/tools/export_game.js <game id | player id | spectator id>
```

### Description
This tool extracts the entire history of a game from a database and stores it in the local filesystem database.

If you plan to extract from the local SQLite database, have no environment variables. If you're extracting
from PostgreSQL, use the `POSTGRES_HOST` environment variable. You cannot export from a local filesystem database.
You might as well then just run `cp -R`

(Read https://github.com/terraforming-mars/terraforming-mars/wiki/Databases#maintenance
to get advice on setting up your `POSTGRES_HOST` environment variable.)

## Analyze MA

Starts a local web server that you can use to get results of MA synergy. To run,

```sh
npm run build:server
node build/src/server/tools/analyze_ma.js
```

And then point your browser to http://localhost:8081

Warning: this is a fragile tool, and it might fail or hide errors.

================
File: turmoil/AlliedParty.ts
================
import {Agenda} from '../../common/turmoil/Types';
import {PartyName} from '../../common/turmoil/PartyName';

/** When player has Mars Frontier Alliance, this is their political party alliance. */
export type AlliedParty = {
  partyName: PartyName;
  agenda: Agenda;
};

================
File: turmoil/Bonus.ts
================
import {IGame} from '../IGame';
import {IPlayer} from '../IPlayer';
import {BonusId} from '../../common/turmoil/Types';

// Represents a Turmoil Chairman bonus.
export interface IBonus {
  id: BonusId;
  description: string;
  grantForPlayer?(player: IPlayer): void;
  grant(game: IGame): void;
  getScore(player: IPlayer): number;
}

export abstract class Bonus implements IBonus {
  abstract id: BonusId;
  abstract description: string;
  public abstract grantForPlayer(player: IPlayer): void;
  public abstract getScore(player: IPlayer): number;

  public grant(game: IGame): void {
    for (const player of game.getPlayersInGenerationOrder()) {
      if (player.alliedParty === undefined) {
        this.grantForPlayer?.(player);
      }
    }
  }
}

================
File: turmoil/ChooseRulingPartyDeferred.ts
================
import {IPlayer} from '../IPlayer';
import {DeferredAction} from '../deferredActions/DeferredAction';
import {OrOptions} from '../inputs/OrOptions';
import {Turmoil} from './Turmoil';
import {PoliticalAgendas} from './PoliticalAgendas';
import {IParty} from './parties/IParty';
import {SelectOption} from '../inputs/SelectOption';

export class ChooseRulingPartyDeferred extends DeferredAction<IParty> {
  private turmoil: Turmoil;
  constructor(player: IPlayer, turmoil: Turmoil) {
    super(player);
    this.turmoil = turmoil;
  }

  public execute() {
    const setRulingParty = new OrOptions();

    // Interesting that this doesn't use SelectParty. Perhaps that's the right choice.
    setRulingParty.title = 'Select new ruling party';
    setRulingParty.options = this.turmoil.parties.map((p: IParty) => new SelectOption(p.name).andThen(() => {
      this.turmoil.rulingPolicy().onPolicyEnd?.(this.player.game);
      this.turmoil.rulingParty = p;
      PoliticalAgendas.setNextAgenda(this.turmoil, this.player.game);
      this.cb(p);
      return undefined;
    }));
    return setRulingParty;
  }
}

================
File: turmoil/globalEvents/AquiferReleasedByPublicCouncil.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {PlaceOceanTile} from '../../deferredActions/PlaceOceanTile';
import {CardRenderer} from '../../cards/render/CardRenderer';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.oceans(1).nbsp.plants(1).steel(1).slash().influence();
});

export class AquiferReleasedByPublicCouncil extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.AQUIFER_RELEASED_BY_PUBLIC_COUNCIL,
      description: 'First player places an ocean tile. Gain 1 plant and 1 steel per influence.',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.defer(new PlaceOceanTile(game.getPlayersInGenerationOrder()[0], {title: 'Select space for ocean tile for Global Event'}));
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.stock.add(Resource.PLANTS, turmoil.getPlayerInfluence(player), {log: true, from: GlobalEventName.AQUIFER_RELEASED_BY_PUBLIC_COUNCIL});
      player.stock.add(Resource.STEEL, turmoil.getPlayerInfluence(player), {log: true, from: GlobalEventName.AQUIFER_RELEASED_BY_PUBLIC_COUNCIL});
    });
  }
}

================
File: turmoil/globalEvents/AsteroidMining.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {Turmoil} from '../Turmoil';

import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.titanium(1).slash().tag(Tag.JOVIAN).influence({size: Size.SMALL});
});

export class AsteroidMining extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.ASTEROID_MINING,
      description: 'Gain 1 titanium for each Jovian tag (max 5) and influence.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.stock.add(Resource.TITANIUM, Math.min(5, player.tags.count(Tag.JOVIAN, 'raw')) + turmoil.getPlayerInfluence(player), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/CelebrityLeaders.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {Tag} from '../../../common/cards/Tag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().tag(Tag.EVENT).influence({size: Size.SMALL});
});

export class CelebrityLeaders extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.CELEBRITY_LEADERS,
      description: 'Gain 2 M€ for each event played (max 5) and influence.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const eventsCards = player.playedCards.filter((card) => card.type === CardType.EVENT).length;
      player.stock.add(Resource.MEGACREDITS, 2 * (Math.min(5, eventsCards) + turmoil.getPlayerInfluence(player)), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/CloudSocieties.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../Turmoil';
import {CardResource} from '../../../common/CardResource';
import {AddResourcesToCard} from '../../deferredActions/AddResourcesToCard';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.cards(1, {secondaryTag: AltSecondaryTag.FLOATER}).colon().resource(CardResource.FLOATER).nbsp;
  b.resource(CardResource.FLOATER).slash().influence();
});

export class CloudSocieties extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.CLOUD_SOCIETIES,
      description: 'Add a floater to each card that can collect floaters. Add 1 floater for each influence to a card.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const resourceCards = player.getResourceCards(CardResource.FLOATER);
      resourceCards.forEach((card) => {
        player.addResourceTo(card, 1);
      });
      const amount = turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        game.defer(new AddResourcesToCard(player, CardResource.FLOATER, {count: amount}));
      }
    });
  }
}

================
File: turmoil/globalEvents/CorrosiveRain.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../Turmoil';
import {CorrosiveRainDeferredAction} from '../../deferredActions/CorrosiveRainDeferredAction';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {CardResource} from '../../../common/CardResource';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().resource(CardResource.FLOATER, 2).or().megacredits(-10).nbsp.nbsp.cards(1).slash().influence();
});

export class CorrosiveRain extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.CORROSIVE_RAIN,
      description: 'Lose 2 floaters from a card or 10 M€. Draw 1 card for each influence.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.drawCard(turmoil.getPlayerInfluence(player));
      game.defer(new CorrosiveRainDeferredAction(player));
    });
  }
}

================
File: turmoil/globalEvents/Diversity.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.text('9').diverseTag(1).influence({size: Size.SMALL}).colon().megacredits(10);
});

export class Diversity extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.DIVERSITY,
      description: 'Gain 10 M€ if you have 9 or more different tags. Influence counts as unique tags.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      if (player.tags.distinctCount('globalEvent') + turmoil.getPlayerInfluence(player) >= 9) {
        player.stock.add(Resource.MEGACREDITS, 10, {log: true, from: this.name});
      }
    });
  }
}

================
File: turmoil/globalEvents/DryDeserts.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../Turmoil';
import {RemoveOceanTile} from '../../deferredActions/RemoveOceanTile';
import {GainResources} from '../../inputs/GainResources';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {message} from '../../logs/MessageBuilder';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().oceans(1).nbsp.nbsp.wild(1).slash().influence();
});

export class DryDeserts extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.DRY_DESERTS,
      description: 'First player removes 1 ocean tile from the gameboard. Gain 1 standard resource per influence.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    if (game.canRemoveOcean()) {
      game.defer(new RemoveOceanTile(game.getPlayersInGenerationOrder()[0], 'Dry Deserts Global Event - Remove an Ocean tile from the board'));
    }

    game.getPlayersInGenerationOrder().forEach((player) => {
      const count = turmoil.getPlayerInfluence(player);
      if (count > 0) {
        player.defer(new GainResources(
          player,
          count,
          message('Dry Deserts Global Event - Gain ${0} resource(s) for influence', (b) => b.number(count)),
        ));
      }
    });
  }
}

================
File: turmoil/globalEvents/EcoSabotage.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.text('max 3').plants(1).influence({size: Size.SMALL});
});

export class EcoSabotage extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.ECO_SABOTAGE,
      description: 'Lose all plants except 3 + influence.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const plants = player.plants;
      const maxPlants = 3 + turmoil.getPlayerInfluence(player);
      const plantDecrease = Math.max(0, plants - maxPlants);
      player.stock.deduct(Resource.PLANTS, plantDecrease, {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/Election.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Tag} from '../../../common/cards/Tag';
import {Turmoil} from '../Turmoil';
import {IPlayer} from '../../IPlayer';
import {Board} from '../../boards/Board';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.influence().plus().tag(Tag.BUILDING, {size: Size.SMALL}).plus().city({size: Size.MEDIUM}).colon().br;
  b.text('1st:', Size.SMALL).tr(2, {size: Size.TINY}).nbsp.text('2nd:', Size.SMALL).tr(1, {size: Size.TINY});
});

export class Election extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.ELECTION,
      description: 'Count your influence plus building tags and city tiles (no limits). The player with most (or 10 in solo) gains 2 TR, the 2nd (or 5 in solo) gains 1 TR (ties are friendly).',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    // Solo
    if (game.isSoloMode()) {
      const player = game.getPlayers()[0];
      const score = this.getScore(player, turmoil, game);
      if (score >= 10) {
        player.increaseTerraformRating(2, {log: true});
      } else if (score >= 5) {
        player.increaseTerraformRating(1, {log: true});
      }
    } else {
      const players = game.getPlayers().slice().sort(
        (p1, p2) => this.getScore(p2, turmoil, game) - this.getScore(p1, turmoil, game),
      );

      // We have one rank 1 player
      if (this.getScore(players[0], turmoil, game) > this.getScore(players[1], turmoil, game)) {
        players[0].increaseTerraformRating(2, {log: true});
        players.shift();

        if (players.length === 1) {
          players[0].increaseTerraformRating(1, {log: true});
        } else if (players.length > 1) {
          // We have one rank 2 player
          if (this.getScore(players[0], turmoil, game) > this.getScore(players[1], turmoil, game)) {
            players[0].increaseTerraformRating(1, {log: true});
            // We have at least two rank 2 players
          } else {
            const score = this.getScore(players[0], turmoil, game);
            while (players.length > 0 && this.getScore(players[0], turmoil, game) === score) {
              players[0].increaseTerraformRating(1, {log: true});
              players.shift();
            }
          }
        }
        // We have at least two rank 1 players
      } else {
        const score = this.getScore(players[0], turmoil, game);
        while (players.length > 0 && this.getScore(players[0], turmoil, game) === score) {
          players[0].increaseTerraformRating(2, {log: true});
          players.shift();
        }
      }
    }
  }

  public getScore(player: IPlayer, turmoil: Turmoil, game: IGame) {
    const score = player.tags.count(Tag.BUILDING, 'raw') + turmoil.getPlayerInfluence(player);

    const cities = game.board.spaces.filter(
      (space) => Board.isCitySpace(space) && space.player === player,
    ).length;

    return score + cities;
  }
}

================
File: turmoil/globalEvents/GenerousFunding.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {digit} from '../../cards/Options';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().influence().plus().tr(5, {digit, over: 15}).br.br;
});

export class GenerousFunding extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.GENEROUS_FUNDING,
      description: 'Gain 2 M€ for each influence and set of 5 TR over 15 (max 5 sets).',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }

  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const trSets = Math.max(0, Math.floor((player.getTerraformRating() - 15) / 5));
      const maxTRSets = 5;
      const totalSets = Math.min(maxTRSets, trSets) + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.MEGACREDITS, 2 * totalSets, {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/GlobalDustStorm.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.text('Lose all').heat(1).nbsp.megacredits(-2).slash().tag(Tag.BUILDING).influence({size: Size.SMALL});
});

export class GlobalDustStorm extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.GLOBAL_DUST_STORM,
      description: 'Lose all heat. Lose 2 M€ for each building tag (max 5, then reduced by influence).',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil): void {
    game.getPlayersInGenerationOrder().forEach((player) => {
      if (player.heat > 0) {
        player.stock.deduct(Resource.HEAT, player.heat, {log: true, from: this.name});
      }
      const maxedSteelTags = Math.min(5, player.tags.count(Tag.BUILDING, 'raw'));
      player.stock.deduct(Resource.MEGACREDITS, 2 * Math.max(0, maxedSteelTags - turmoil.getPlayerInfluence(player)), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/GlobalEvent.ts
================
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {ICardRenderRoot} from '../../../common/cards/render/Types';

type StaticGlobalEventProperties = {
  name: GlobalEventName,
  description: string,
  revealedDelegate: PartyName,
  currentDelegate: PartyName,
  renderData: ICardRenderRoot;
}

const staticGlobalEventProperties = new Map<GlobalEventName, StaticGlobalEventProperties>();

export abstract class GlobalEvent {
  private readonly properties: StaticGlobalEventProperties;
  constructor(properties: StaticGlobalEventProperties) {
    let staticInstance = staticGlobalEventProperties.get(properties.name);
    if (staticInstance === undefined) {
      staticGlobalEventProperties.set(properties.name, properties);
      staticInstance = properties;
    }
    this.properties = staticInstance;
  }
  public get name() {
    return this.properties.name;
  }
  public get description() {
    return this.properties.description;
  }
  public get revealedDelegate() {
    return this.properties.revealedDelegate;
  }
  public get currentDelegate() {
    return this.properties.currentDelegate;
  }
  public get renderData() {
    return this.properties.renderData;
  }
}

================
File: turmoil/globalEvents/GlobalEventDealer.ts
================
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {IGlobalEvent} from './IGlobalEvent';
import {IGame} from '../../IGame';
import {SerializedGlobalEventDealer} from './SerializedGlobalEventDealer';
import {GlobalEventManifest, ModuleManifest} from '../../cards/ModuleManifest';
import {isCompatibleWith} from '../../cards/ICardFactory';
import {inplaceShuffle} from '../../utils/shuffle';
import {GameModule} from '@/common/cards/GameModule';

// When renaming, add the rename here and add a TODO (like the example below)
// And remember to add a test in GlobalEventDealer.spec.ts
const RENAMED_GLOBAL_EVENTS: Array<[GlobalEventName, GlobalEventFactory]> = [
  // ['Miners Of Strike' as GlobalEventName, MinersOnStrike],
];

type GlobalEventFactory = new () => IGlobalEvent;

const ALL_EVENTS = new Map<GlobalEventName, GlobalEventFactory>();
// A local copy supplied to prevent import cycles
const ALL_MODULE_MANIFESTS: Array<ModuleManifest> = [];

// Only called once during setup. Call with ALL_MODULE_MANIFESTS
export function initializeGlobalEventDealer(allModuleManifests: Array<ModuleManifest>) {
  if (ALL_EVENTS.size > 0) {
    return;
  }
  ALL_MODULE_MANIFESTS.push(...allModuleManifests);
  for (const manifest of allModuleManifests) {
    for (const card of GlobalEventManifest.entries(manifest.globalEvents)) {
      ALL_EVENTS.set(card[0], card[1].Factory);
    }
  }
  for (const card of RENAMED_GLOBAL_EVENTS) {
    ALL_EVENTS.set(card[0], card[1]);
  }
}

export function getGlobalEventByName(globalEventName: GlobalEventName): IGlobalEvent | undefined {
  const Factory = ALL_EVENTS.get(globalEventName);

  if (Factory !== undefined) return new Factory();
  console.warn(`unable to find global event ${globalEventName}`);
  return undefined;
}

export class GlobalEventDealer {
  constructor(
    public readonly deck: Array<IGlobalEvent>,
    public readonly discards: Array<IGlobalEvent>) {}

  public static newInstance(game: IGame): GlobalEventDealer {
    const events: Array<IGlobalEvent> = [];

    const gameOptions = game.gameOptions;
    // TODO(kberg): Merge with GameCards.
    const includes: Record<GameModule, boolean> = {
      base: true,
      corpera: gameOptions.corporateEra,
      prelude: gameOptions.preludeExtension,
      prelude2: gameOptions.prelude2Expansion,
      venus: gameOptions.venusNextExtension,
      colonies: gameOptions.coloniesExtension,
      turmoil: gameOptions.turmoilExtension,
      ares: gameOptions.aresExtension,
      promo: gameOptions.promoCardsOption,
      community: gameOptions.communityCardsOption,
      moon: gameOptions.moonExpansion,
      pathfinders: gameOptions.pathfindersExpansion,
      ceo: gameOptions.ceoExtension,
      starwars: gameOptions.starWarsExpansion,
      underworld: gameOptions.underworldExpansion,
      chemical: gameOptions.chemicalExpansion,
    };

    for (const manifest of ALL_MODULE_MANIFESTS) {
      if (includes[manifest.module] !== true) {
        continue;
      }
      for (const card of GlobalEventManifest.entries(manifest.globalEvents)) {
        const factory = card[1];
        if (game.gameOptions.removeNegativeGlobalEventsOption && factory.negative === true) {
          continue;
        }
        if (isCompatibleWith(factory, game.gameOptions)) {
          events.push(new factory.Factory());
        }
      }
    }
    inplaceShuffle(events, game.rng);
    return new GlobalEventDealer(events, []);
  }

  public draw(): IGlobalEvent | undefined {
    return this.deck.pop();
  }

  public discard(globalEvent: IGlobalEvent) {
    this.discards.push(globalEvent);
  }

  public serialize(): SerializedGlobalEventDealer {
    return {
      deck: this.deck.map((card) => card.name),
      discarded: this.discards.map((card) => card.name),
    };
  }

  public static deserialize(d: SerializedGlobalEventDealer): GlobalEventDealer {
    const deck: Array<IGlobalEvent> = [];
    d.deck.forEach((element: GlobalEventName) => {
      const globalEvent = getGlobalEventByName(element);
      if (globalEvent !== undefined) deck.push(globalEvent);
    });
    const discardPile: Array<IGlobalEvent> = [];
    d.discarded.forEach((element: GlobalEventName) => {
      const globalEvent = getGlobalEventByName(element);
      if (globalEvent !== undefined) discardPile.push(globalEvent);
    });
    return new GlobalEventDealer(deck, discardPile);
  }
}

================
File: turmoil/globalEvents/HomeworldSupport.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().tag(Tag.EARTH).influence({size: Size.SMALL});
});

export class HomeworldSupport extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.HOMEWORLD_SUPPORT,
      description: 'Gain 2 M€ for each Earth tag (max 5) and influence.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(5, player.tags.count(Tag.EARTH, 'raw')) + turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        player.stock.add(Resource.MEGACREDITS, 2 * amount, {log: true, from: this.name});
      }
    });
  }
}

================
File: turmoil/globalEvents/IGlobalEvent.ts
================
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {ICardRenderRoot} from '../../../common/cards/render/Types';
import {IGame} from '../../IGame';
import {Turmoil} from '../Turmoil';

export interface IGlobalEvent {
  name: GlobalEventName,
  description: string,
  revealedDelegate: PartyName,
  currentDelegate: PartyName,
  renderData: ICardRenderRoot;
  resolve: (game: IGame, turmoil: Turmoil) => void;
}

================
File: turmoil/globalEvents/ImprovedEnergyTemplates.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.production((pb) => pb.energy(1)).slash().tag(Tag.POWER, 2).influence({size: Size.SMALL});
});

export class ImprovedEnergyTemplates extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.IMPROVED_ENERGY_TEMPLATES,
      description: 'Increase energy production 1 step per 2 power tags (no limit). Influence counts as power tags.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.production.add(Resource.ENERGY, Math.floor((player.tags.count(Tag.POWER, 'raw') + turmoil.getPlayerInfluence(player)) / 2), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/InterplanetaryTrade.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().tag(Tag.SPACE).influence({size: Size.SMALL});
});

export class InterplanetaryTrade extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.INTERPLANETARY_TRADE,
      description: 'Gain 2 M€ for each space tag (max 5) and influence.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.stock.add(Resource.MEGACREDITS, 2 * (Math.min(5, player.tags.count(Tag.SPACE, 'raw')) + turmoil.getPlayerInfluence(player)), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/JovianTaxRights.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.production((pb) => pb.megacredits(1)).slash().colonies(1).nbsp.titanium(1).slash().influence();
});

export class JovianTaxRights extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.JOVIAN_TAX_RIGHTS,
      description: 'Increase M€ production 1 step for each colony. Gain 1 titanium for each influence.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      let coloniesCount = 0;
      game.colonies.forEach((colony) => {
        coloniesCount += colony.colonies.filter((owner) => owner === player.id).length;
      });
      player.production.add(Resource.MEGACREDITS, coloniesCount, {log: true, from: this.name});
      player.stock.add(Resource.TITANIUM, turmoil.getPlayerInfluence(player), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/MicrogravityHealthProblems.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-3).slash().colonies(1).influence({size: Size.SMALL});
});

export class MicrogravityHealthProblems extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.MICROGRAVITY_HEALTH_PROBLEMS,
      description: 'Lose 3 M€ for each colony (max 5, then reduced by influence).',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      let coloniesCount = 0;
      game.colonies.forEach((colony) => {
        coloniesCount += colony.colonies.filter((owner) => owner === player.id).length;
      });
      player.stock.deduct(Resource.MEGACREDITS, 3 * Math.max(0, Math.min(5, coloniesCount) - turmoil.getPlayerInfluence(player)), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/MinersOnStrike.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().titanium(1).slash().tag(Tag.JOVIAN).influence({size: Size.SMALL});
});

export class MinersOnStrike extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.MINERS_ON_STRIKE,
      description: 'Lose 1 titanium for each Jovian tag (max 5, then reduced by influence).',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(5, player.tags.count(Tag.JOVIAN, 'raw')) - turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        player.stock.deduct(Resource.TITANIUM, amount, {log: true, from: this.name});
      }
    });
  }
}

================
File: turmoil/globalEvents/MudSlides.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {Board} from '../../boards/Board';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().megacredits(4).slash().oceans(1).emptyTile().influence({size: Size.SMALL});
});

export class MudSlides extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.MUD_SLIDES,
      description: 'Lose 4 M€ for each tile adjacent to ocean (max 5, then reduced by influence).',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const tiles = game.board.spaces.filter(Board.ownedBy(player))
        .filter((space) => space.tile !== undefined &&
          game.board.getAdjacentSpaces(space)
            .filter((space) => Board.isOceanSpace(space)).length > 0,
        ).length;
      const amount = Math.min(5, tiles) - turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        player.stock.deduct(Resource.MEGACREDITS, 4 * amount, {log: true, from: this.name});
      }
    });
  }
}

================
File: turmoil/globalEvents/Pandemic.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-3).slash().tag(Tag.BUILDING).influence({size: Size.SMALL});
});

export class Pandemic extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.PANDEMIC,
      description: 'Lose 3 M€ for each building tag (max 5, then reduced by influence).',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const maxedSteelTags = Math.min(5, player.tags.count(Tag.BUILDING, 'raw'));
      player.stock.deduct(Resource.MEGACREDITS, 3 * Math.max(0, maxedSteelTags - turmoil.getPlayerInfluence(player)), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/ParadigmBreakdown.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {DiscardCards} from '../../deferredActions/DiscardCards';
import {CardRenderer} from '../../cards/render/CardRenderer';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().cards(2).nbsp.megacredits(2).slash().influence();
});

export class ParadigmBreakdown extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.PARADIGM_BREAKDOWN,
      description: 'Discard 2 cards from hand. Gain 2 M€ per influence.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      if (player.cardsInHand.length >= 2) {
        game.defer(new DiscardCards(player, 2, 2, 'Global Event - Select 2 cards to discard'));
      } else if (player.cardsInHand.length === 1) {
        game.defer(new DiscardCards(player, 1, 1, 'Global Event - Select a card to discard'));
      }
      player.stock.add(Resource.MEGACREDITS, 2 * (turmoil.getPlayerInfluence(player)), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/Productivity.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.steel(1).slash().production((pb) => pb.steel(1)).nbsp.influence({size: Size.SMALL});
});

export class Productivity extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.PRODUCTIVITY,
      description: 'Gain 1 steel for each steel production (max 5) and influence.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.stock.add(Resource.STEEL, Math.min(5, player.production.steel) + turmoil.getPlayerInfluence(player), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/RedInfluence.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {digit} from '../../cards/Options';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(-3).slash().tr(5, {digit, over: 10}).nbsp.production((pb) => pb.megacredits(1)).slash().influence().br;
});


export class RedInfluence extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.RED_INFLUENCE,
      description: 'Lose 3 M€ for each set of 5 TR over 10 (max 5 sets). Increase M€ production 1 step per influence.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const sets = Math.floor((player.getTerraformRating() - 10)/5);
      if (sets > 0) {
        const amount = Math.min(sets, 5);
        player.stock.deduct(Resource.MEGACREDITS, amount * 3, {log: true, from: this.name});
      }
      player.production.add(Resource.MEGACREDITS, turmoil.getPlayerInfluence(player), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/Revolution.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../Turmoil';
import {Tag} from '../../../common/cards/Tag';
import {IPlayer} from '../../IPlayer';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.tag(Tag.EARTH, {size: Size.SMALL}).plus().influence().colon().br;
  b.text('1st:', Size.SMALL).minus().tr(2, {size: Size.TINY}).nbsp;
  b.text('2nd:', Size.SMALL).minus().tr(1, {size: Size.TINY});
});

export class Revolution extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.REVOLUTION,
      description: 'Count Earth tags and ADD(!) influence. The player(s) with most (at least 1) loses 2 TR, and 2nd most (at least 1) loses 1 TR. SOLO: Lose 2 TR if the sum is 4 or more.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    if (game.isSoloMode()) {
      if (this.getScore(game.getPlayersInGenerationOrder()[0], turmoil) >= 4 ) {
        game.getPlayersInGenerationOrder()[0].decreaseTerraformRating(2, {log: true});
      }
    } else {
      const players = [...game.getPlayersInGenerationOrder()].sort(
        (p1, p2) => this.getScore(p2, turmoil) - this.getScore(p1, turmoil),
      );

      // We have one rank 1 player
      if (this.getScore(players[0], turmoil) > this.getScore(players[1], turmoil)) {
        players[0].decreaseTerraformRating(2, {log: true});
        players.shift();

        if (players.length === 1 && this.getScore(players[0], turmoil) > 0) {
          players[0].decreaseTerraformRating(1, {log: true});
        } else if (players.length > 1) {
          // We have one rank 2 player
          if (this.getScore(players[0], turmoil) > this.getScore(players[1], turmoil)) {
            players[0].decreaseTerraformRating(1, {log: true});
            // We have at least two rank 2 players
          } else {
            const score = this.getScore(players[0], turmoil);
            while (players.length > 0 && this.getScore(players[0], turmoil) === score) {
              if (this.getScore(players[0], turmoil) > 0) {
                players[0].decreaseTerraformRating(1, {log: true});
              }
              players.shift();
            }
          }
        }
        // We have at least two rank 1 players
      } else {
        const score = this.getScore(players[0], turmoil);
        while (players.length > 0 && this.getScore(players[0], turmoil) === score) {
          if (this.getScore(players[0], turmoil) > 0) {
            players[0].decreaseTerraformRating(2, {log: true});
          }
          players.shift();
        }
      }
    }
  }
  public getScore(player: IPlayer, turmoil: Turmoil) {
    return player.tags.count(Tag.EARTH, 'raw') + turmoil.getPlayerInfluence(player);
  }
}

================
File: turmoil/globalEvents/Riots.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {Board} from '../../boards/Board';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().megacredits(4).slash().city().influence({size: Size.SMALL});
});

export class Riots extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.RIOTS,
      description: 'Lose 4 M€ for each city tile (max 5, then reduced by influence).',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const city = game.board.spaces.filter(
        (space) => Board.isCitySpace(space) &&
                         space.player === player,
      ).length;
      const amount = Math.min(5, city) - turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        player.stock.deduct(Resource.MEGACREDITS, 4 * amount, {log: true, from: this.name});
      }
    });
  }
}

================
File: turmoil/globalEvents/Sabotage.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.production((pb) => pb.minus().energy(1).steel(1)).nbsp.nbsp;
  b.steel(1).slash().influence({size: Size.MEDIUM});
});

export class Sabotage extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SABOTAGE,
      description: 'Decrease steel and energy production 1 step each. Gain 1 steel per influence.',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.REDS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      // This conditional isn't to prevent negative production, but to prevent misleading logging when the production diff is zero.
      if (player.production.energy >= 1) {
        player.production.add(Resource.ENERGY, -1, {log: true, from: this.name});
      }
      if (player.production.steel >= 1) {
        player.production.add(Resource.STEEL, -1, {log: true, from: this.name});
      }
      player.stock.add(Resource.STEEL, turmoil.getPlayerInfluence(player), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/ScientificCommunity.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(1).slash().cards(1).influence({size: Size.SMALL});
});

export class ScientificCommunity extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SCIENTIFIC_COMMUNITY,
      description: 'Gain 1 M€ for each card in hand (no limit) and influence.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = player.cardsInHand.length + turmoil.getPlayerInfluence(player);
      player.stock.add(Resource.MEGACREDITS, amount, {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/SerializedGlobalEventDealer.ts
================
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';

export type SerializedGlobalEventDealer = {
  deck: Array<GlobalEventName>;
  discarded: Array<GlobalEventName>;
}

================
File: turmoil/globalEvents/SnowCover.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().temperature(2).nbsp.cards(1).slash().influence();
});

export class SnowCover extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SNOW_COVER,
      description: 'Decrease temperature 2 steps. Draw 1 card per influence.',
      revealedDelegate: PartyName.KELVINISTS,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.increaseTemperature(game.getPlayersInGenerationOrder()[0], -2);

    game.getPlayersInGenerationOrder().forEach((player) => {
      player.drawCard(turmoil.getPlayerInfluence(player));
    });
  }
}

================
File: turmoil/globalEvents/SolarFlare.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().megacredits(3).slash().tag(Tag.SPACE).influence({size: Size.SMALL});
});

export class SolarFlare extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SOLAR_FLARE,
      description: 'Lose 3 M€ for each space tag (max 5, then reduced by influence).',
      revealedDelegate: PartyName.UNITY,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(5, player.tags.count(Tag.SPACE, 'raw')) - turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        player.stock.deduct(Resource.MEGACREDITS, amount * 3, {log: true, from: this.name});
      }
    });
  }
}

================
File: turmoil/globalEvents/SolarnetShutdown.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardType} from '../../../common/cards/CardType';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().megacredits(3).slash().cards(1, {secondaryTag: AltSecondaryTag.BLUE}).influence({size: Size.SMALL});
});

export class SolarnetShutdown extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SOLARNET_SHUTDOWN,
      description: 'Lose 3 M€ for each blue card (max 5, then reduced by influence).',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(5, player.playedCards.filter((card) => card.type === CardType.ACTIVE).length) - turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        player.stock.deduct(Resource.MEGACREDITS, amount * 3, {log: true, from: this.name});
      }
    });
  }
}

================
File: turmoil/globalEvents/SpinoffProducts.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Tag} from '../../../common/cards/Tag';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().tag(Tag.SCIENCE).influence({size: Size.SMALL});
});

export class SpinoffProducts extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SPINOFF_PRODUCTS,
      description: 'Gain 2 M€ for each science tag (max 5) and influence.',
      revealedDelegate: PartyName.GREENS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.stock.add(Resource.MEGACREDITS, 2 * (Math.min(5, player.tags.count(Tag.SCIENCE, 'raw-pf')) + turmoil.getPlayerInfluence(player)), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/SponsoredProjects.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {AltSecondaryTag} from '../../../common/cards/render/AltSecondaryTag';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.cards(1, {secondaryTag: AltSecondaryTag.WILD_RESOURCE}).colon().wild(1).nbsp;
  b.cards(1).slash().influence();
});

export class SponsoredProjects extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SPONSORED_PROJECTS,
      description: 'All cards with resources on them gain 1 resource. Draw 1 card for each influence.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.GREENS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.getCardsWithResources().forEach((card) => card.resourceCount && player.addResourceTo(card));
      player.drawCard(turmoil.getPlayerInfluence(player));
    });
  }
}

================
File: turmoil/globalEvents/StrongSociety.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().city().influence({size: Size.SMALL});
});

export class StrongSociety extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.STRONG_SOCIETY,
      description: 'Gain 2 M€ for each city tile (max 5) and influence.',
      revealedDelegate: PartyName.REDS,
      currentDelegate: PartyName.MARS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(5, player.game.board.getCities(player).length) + turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        player.stock.add(Resource.MEGACREDITS, amount * 2, {log: true, from: this.name});
      }
    });
  }
}

================
File: turmoil/globalEvents/SuccessfulOrganisms.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.plants(1).slash().production((pb) => pb.plants(1)).nbsp.influence({size: Size.SMALL});
});


export class SuccessfulOrganisms extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.SUCCESSFUL_ORGANISMS,
      description: 'Gain 1 plant per plant production (max 5) and influence.',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.SCIENTISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.stock.add(Resource.PLANTS, Math.min(5, player.production.plants) + turmoil.getPlayerInfluence(player), {log: true, from: this.name});
    });
  }
}

================
File: turmoil/globalEvents/VenusInfrastructure.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {Tag} from '../../../common/cards/Tag';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.megacredits(2).slash().tag(Tag.VENUS).influence({size: Size.SMALL});
});

export class VenusInfrastructure extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.VENUS_INFRASTRUCTURE,
      description: 'Gain 2 M€ per Venus tag (max 5) and influence.',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.UNITY,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = Math.min(5, player.tags.count(Tag.VENUS, 'raw')) + turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        player.stock.add(Resource.MEGACREDITS, amount * 2, {log: true, from: this.name});
      }
    });
  }
}

================
File: turmoil/globalEvents/VolcanicEruptions.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Resource} from '../../../common/Resource';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.temperature(2).nbsp.production((pb)=>pb.heat(1)).slash().influence();
});

export class VolcanicEruptions extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.VOLCANIC_ERUPTIONS,
      description: 'Increase temperature 2 steps. Increase heat production 1 step per influence.',
      revealedDelegate: PartyName.SCIENTISTS,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.increaseTemperature(game.getPlayersInGenerationOrder()[0], 2);
    game.getPlayersInGenerationOrder().forEach((player) => {
      const amount = turmoil.getPlayerInfluence(player);
      if (amount > 0) {
        player.production.add(Resource.HEAT, amount, {log: true, from: this.name});
      }
    });
  }
}

================
File: turmoil/globalEvents/WarOnEarth.ts
================
import {IGlobalEvent} from './IGlobalEvent';
import {GlobalEvent} from './GlobalEvent';
import {GlobalEventName} from '../../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Turmoil} from '../Turmoil';
import {CardRenderer} from '../../cards/render/CardRenderer';
import {Size} from '../../../common/cards/render/Size';

const RENDER_DATA = CardRenderer.builder((b) => {
  b.minus().text('4').tr(1).influence({size: Size.SMALL});
});

export class WarOnEarth extends GlobalEvent implements IGlobalEvent {
  constructor() {
    super({
      name: GlobalEventName.WAR_ON_EARTH,
      description: 'Reduce TR 4 steps. Each influence prevents 1 step.',
      revealedDelegate: PartyName.MARS,
      currentDelegate: PartyName.KELVINISTS,
      renderData: RENDER_DATA,
    });
  }
  public resolve(game: IGame, turmoil: Turmoil) {
    game.getPlayersInGenerationOrder().forEach((player) => {
      player.decreaseTerraformRating(4 - turmoil.getPlayerInfluence(player), {log: true});
    });
  }
}

================
File: turmoil/parties/Greens.ts
================
import {IParty} from './IParty';
import {Party} from './Party';
import {PartyName} from '../../../common/turmoil/PartyName';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {Bonus} from '../Bonus';
import {IPolicy} from '../Policy';
import {Space} from '../../boards/Space';
import {IPlayer} from '../../IPlayer';
import {IProjectCard} from '../../cards/IProjectCard';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectCard} from '../../inputs/SelectCard';
import {SelectOption} from '../../inputs/SelectOption';
import {CardResource} from '../../../common/CardResource';
import {Phase} from '../../../common/Phase';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {POLITICAL_AGENDAS_MAX_ACTION_USES} from '../../../common/constants';
import {Board} from '../../boards/Board';
import {TITLES} from '../../inputs/titles';
import {message} from '../../logs/MessageBuilder';

export class Greens extends Party implements IParty {
  readonly name = PartyName.GREENS;
  readonly bonuses = [GREENS_BONUS_1, GREENS_BONUS_2];
  readonly policies = [GREENS_POLICY_1, GREENS_POLICY_2, GREENS_POLICY_3, GREENS_POLICY_4];
}

class GreensBonus01 extends Bonus {
  readonly id = 'gb01' as const;
  readonly description = 'Gain 1 M€ for each Plant, Microbe and Animal tag you have';

  getScore(player: IPlayer) {
    return player.tags.count(Tag.PLANT, 'raw') +
      player.tags.count(Tag.MICROBE, 'raw') +
      player.tags.count(Tag.ANIMAL, 'raw');
  }

  grantForPlayer(player: IPlayer): void {
    player.stock.add(Resource.MEGACREDITS, this.getScore(player));
  }
}

class GreensBonus02 extends Bonus {
  readonly id = 'gb02' as const;
  readonly description = 'Gain 2 M€ for each greenery tile you have';

  getScore(player: IPlayer) {
    const boardSpaces = player.game.board.spaces;
    const count = boardSpaces.filter((space) => Board.isGreenerySpace(space) && Board.spaceOwnedBy(space, player)).length;
    return count * 2;
  }

  grantForPlayer(player: IPlayer): void {
    player.stock.add(Resource.MEGACREDITS, this.getScore(player));
  }
}

class GreensPolicy01 implements IPolicy {
  readonly id = 'gp01' as const;
  readonly description = 'When you place a greenery tile, gain 4 M€';

  onTilePlaced(player: IPlayer, space: Space) {
    if (Board.isGreenerySpace(space) && player.game.phase === Phase.ACTION) {
      player.stock.add(Resource.MEGACREDITS, 4);
    }
  }
}

class GreensPolicy02 implements IPolicy {
  readonly id = 'gp02' as const;
  readonly description = 'When you place a tile, gain 1 plant';

  onTilePlaced(player: IPlayer) {
    player.stock.add(Resource.PLANTS, 1);
  }
}

class GreensPolicy03 implements IPolicy {
  readonly id = 'gp03' as const;
  readonly description = 'When you play an animal, plant or microbe tag, gain 2 M€';

  onCardPlayed(player: IPlayer, card: IProjectCard) {
    const tags = [Tag.ANIMAL, Tag.PLANT, Tag.MICROBE];
    const tagCount = card.tags.filter((tag) => tags.includes(tag)).length;

    player.defer(() => player.stock.add(Resource.MEGACREDITS, tagCount * 2));
  }
}

class GreensPolicy04 implements IPolicy {
  readonly id = 'gp04' as const;
  readonly description = 'Spend 5 M€ to gain 3 plants or add 2 microbes to ANY card (Turmoil Greens)';

  canAct(player: IPlayer) {
    return player.canAfford(5) && player.politicalAgendasActionUsedCount < POLITICAL_AGENDAS_MAX_ACTION_USES;
  }

  action(player: IPlayer) {
    const game = player.game;
    game.log('${0} used Turmoil ${1} action', (b) => b.player(player).partyName(PartyName.GREENS));
    player.politicalAgendasActionUsedCount += 1;

    game.defer(new SelectPaymentDeferred(player, 5, {title: TITLES.payForPartyAction(PartyName.GREENS)}))
      .andThen(() => {
        const availableMicrobeCards = player.getResourceCards(CardResource.MICROBE);
        const orOptions = new OrOptions();

        if (availableMicrobeCards.length === 1) {
          orOptions.options.push(
            new SelectOption(message('Add ${0} microbes to ${1}', (b) => b.number(2).card(availableMicrobeCards[0]))).andThen(() => {
              player.addResourceTo(availableMicrobeCards[0], {qty: 2, log: true});

              return undefined;
            }),
          );
        } else if (availableMicrobeCards.length > 1) {
          orOptions.options.push(
            new SelectOption('Add 2 microbes to a card').andThen(() => {
              return new SelectCard('Select card to add 2 microbes', 'Add microbes', availableMicrobeCards)
                .andThen(([card]) => {
                  player.addResourceTo(card, {qty: 2, log: true});
                  return undefined;
                });
            }),
          );
        }

        orOptions.options.push(new SelectOption('Gain 3 plants').andThen(() => {
          player.stock.add(Resource.PLANTS, 3);
          game.log('${0} gained 3 plants', (b) => b.player(player));
          return undefined;
        }));

        if (orOptions.options.length === 1) return orOptions.options[0].cb();

        player.defer(orOptions);
        return undefined;
      });

    return undefined;
  }
}

export const GREENS_BONUS_1 = new GreensBonus01();
export const GREENS_BONUS_2 = new GreensBonus02();
export const GREENS_POLICY_1 = new GreensPolicy01();
export const GREENS_POLICY_2 = new GreensPolicy02();
export const GREENS_POLICY_3 = new GreensPolicy03();
export const GREENS_POLICY_4 = new GreensPolicy04();

================
File: turmoil/parties/IParty.ts
================
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {IBonus} from '../Bonus';
import {IPolicy} from '../Policy';
import {Delegate} from '../Turmoil';
import {MultiSet} from 'mnemonist';

export interface IParty {
    name: PartyName;
    delegates: MultiSet<Delegate>;
    partyLeader: undefined | Delegate;
    sendDelegate(playerId: Delegate, game: IGame): void;
    removeDelegate(playerId: Delegate, game: IGame): void;
    bonuses: ReadonlyArray<IBonus>;
    policies: ReadonlyArray<IPolicy>;
}

================
File: turmoil/parties/Kelvinists.ts
================
import {IParty} from './IParty';
import {Party} from './Party';
import {PartyName} from '../../../common/turmoil/PartyName';
import {Resource} from '../../../common/Resource';
import {Bonus} from '../Bonus';
import {Policy, IPolicy} from '../Policy';
import {IPlayer} from '../../IPlayer';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {CardName} from '../../../common/cards/CardName';
import {TITLES} from '../../inputs/titles';

export class Kelvinists extends Party implements IParty {
  readonly name = PartyName.KELVINISTS;
  readonly bonuses = [KELVINISTS_BONUS_1, KELVINISTS_BONUS_2];
  readonly policies = [KELVINISTS_POLICY_1, KELVINISTS_POLICY_2, KELVINISTS_POLICY_3, KELVINISTS_POLICY_4];
}

class KelvinistsBonus01 extends Bonus {
  readonly id = 'kb01' as const;
  readonly description = 'Gain 1 M€ for each heat production you have';

  getScore(player: IPlayer) {
    return player.production.heat;
  }

  grantForPlayer(player: IPlayer): void {
    player.stock.add(Resource.MEGACREDITS, this.getScore(player));
  }
}

class KelvinistsBonus02 extends Bonus {
  readonly id = 'kb02' as const;
  readonly description = 'Gain 1 heat for each heat production you have';

  getScore(player: IPlayer) {
    return player.production.heat;
  }

  grantForPlayer(player: IPlayer): void {
    player.stock.add(Resource.HEAT, this.getScore(player));
  }
}

class KelvinistsPolicy01 implements IPolicy {
  readonly id = 'kp01' as const;
  description(player: IPlayer | undefined): string {
    const cost = player === undefined ? 10 : this.cost(player);
    return `Pay ${cost} M€ to increase your energy and heat production 1 step (Turmoil Kelvinists)`;
  }

  cost(player: IPlayer): number {
    return player.cardIsInEffect(CardName.HIGH_TEMP_SUPERCONDUCTORS) ? 7: 10;
  }
  canAct(player: IPlayer) {
    return player.canAfford(this.cost(player));
  }

  action(player: IPlayer) {
    const game = player.game;
    game.log('${0} used Turmoil ${1} action', (b) => b.player(player).partyName(PartyName.KELVINISTS));
    game.defer(new SelectPaymentDeferred(player, this.cost(player), {title: TITLES.payForPartyAction(PartyName.KELVINISTS)}))
      .andThen(() => {
        player.production.add(Resource.ENERGY, 1);
        player.production.add(Resource.HEAT, 1);
        game.log('${0} increased heat and energy production 1 step', (b) => b.player(player));
      });

    return undefined;
  }
}

class KelvinistsPolicy02 implements IPolicy {
  readonly id = 'kp02' as const;
  readonly description = 'When you raise temperature, gain 3 M€ per step raised';
}

class KelvinistsPolicy03 extends Policy {
  readonly id = 'kp03' as const;
  readonly description = 'Reduce heat required to raise temperature by 2';
  override onPolicyStartForPlayer(player: IPlayer): void {
    player.heatNeededForTemperature -= 2;
    player.heatDiscount = 2;
  }

  override onPolicyEndForPlayer(player: IPlayer): void {
    player.heatNeededForTemperature += 2;
    player.heatDiscount = 0;
  }
}

class KelvinistsPolicy04 implements IPolicy {
  readonly id = 'kp04' as const;
  readonly description = 'When you place a tile, gain 2 heat';

  onTilePlaced(player: IPlayer) {
    player.stock.add(Resource.HEAT, 2);
  }
}

export const KELVINISTS_BONUS_1 = new KelvinistsBonus01();
export const KELVINISTS_BONUS_2 = new KelvinistsBonus02();
export const KELVINISTS_POLICY_1 = new KelvinistsPolicy01();
export const KELVINISTS_POLICY_2 = new KelvinistsPolicy02();
export const KELVINISTS_POLICY_3 = new KelvinistsPolicy03();
export const KELVINISTS_POLICY_4 = new KelvinistsPolicy04();

================
File: turmoil/parties/MarsFirst.ts
================
import {IParty} from './IParty';
import {Party} from './Party';
import {PartyName} from '../../../common/turmoil/PartyName';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {Bonus} from '../Bonus';
import {SpaceType} from '../../../common/boards/SpaceType';
import {Space} from '../../boards/Space';
import {IPlayer} from '../../IPlayer';
import {Policy, IPolicy} from '../Policy';
import {Phase} from '../../../common/Phase';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {IProjectCard} from '../../cards/IProjectCard';
import {POLITICAL_AGENDAS_MAX_ACTION_USES} from '../../../common/constants';
import {TITLES} from '../../inputs/titles';

export class MarsFirst extends Party implements IParty {
  readonly name = PartyName.MARS;
  readonly bonuses = [MARS_FIRST_BONUS_1, MARS_FIRST_BONUS_2];
  readonly policies = [MARS_FIRST_POLICY_1, MARS_FIRST_POLICY_2, MARS_FIRST_POLICY_3, MARS_FIRST_POLICY_4];
}

// TODO(nwai90): Mars First bonus IDs start with 'm' and policies start with 'mp'.
class MarsFirstBonus01 extends Bonus {
  readonly id = 'mb01' as const;
  readonly description = 'Gain 1 M€ for each building tag you have';

  getScore(player: IPlayer) {
    return player.tags.count(Tag.BUILDING, 'raw');
  }

  grantForPlayer(player: IPlayer): void {
    player.stock.add(Resource.MEGACREDITS, this.getScore(player));
  }
}

class MarsFirstBonus02 extends Bonus {
  readonly id = 'mb02' as const;
  readonly description = 'Gain 1 M€ for each tile you have ON MARS';

  getScore(player: IPlayer) {
    const boardSpaces = player.game.board.spaces;
    return boardSpaces.filter((space) => space.tile !== undefined && space.player === player && space.spaceType !== SpaceType.COLONY).length;
  }

  grantForPlayer(player: IPlayer): void {
    player.stock.add(Resource.MEGACREDITS, this.getScore(player));
  }
}

class MarsFirstPolicy01 implements IPolicy {
  readonly id = 'mfp01' as const;
  readonly description = 'When you place a tile ON MARS, gain 1 steel';

  onTilePlaced(player: IPlayer, space: Space) {
    if (space.tile && space.spaceType !== SpaceType.COLONY && player.game.phase === Phase.ACTION) {
      player.stock.add(Resource.STEEL, 1);
    }
  }
}

class MarsFirstPolicy02 implements IPolicy {
  readonly id = 'mfp02' as const;
  readonly description = 'When you play a building tag, gain 2 M€';

  onCardPlayed(player: IPlayer, card: IProjectCard) {
    if (card.tags.includes(Tag.BUILDING)) player.stock.add(Resource.MEGACREDITS, 2);
  }
}

class MarsFirstPolicy03 extends Policy {
  readonly id = 'mfp03' as const;
  readonly description = 'Your steel resources are worth 1 M€ extra';

  override onPolicyStartForPlayer(player: IPlayer): void {
    player.increaseSteelValue();
  }

  override onPolicyEndForPlayer(player: IPlayer): void {
    player.decreaseSteelValue();
  }
}

class MarsFirstPolicy04 implements IPolicy {
  readonly id = 'mfp04' as const;
  readonly description = 'Spend 4 M€ to draw a Building card (Turmoil Mars First)';

  canAct(player: IPlayer) {
    return player.canAfford(4) && player.politicalAgendasActionUsedCount < POLITICAL_AGENDAS_MAX_ACTION_USES;
  }

  action(player: IPlayer) {
    const game = player.game;
    game.log('${0} used Turmoil Mars First action', (b) => b.player(player));
    player.politicalAgendasActionUsedCount += 1;

    game.defer(new SelectPaymentDeferred(player, 4, {title: TITLES.payForPartyAction(PartyName.MARS)}))
      .andThen(() => player.drawCard(1, {tag: Tag.BUILDING}));
    return undefined;
  }
}

export const MARS_FIRST_BONUS_1 = new MarsFirstBonus01();
export const MARS_FIRST_BONUS_2 = new MarsFirstBonus02();
export const MARS_FIRST_POLICY_1 = new MarsFirstPolicy01();
export const MARS_FIRST_POLICY_2 = new MarsFirstPolicy02();
export const MARS_FIRST_POLICY_3 = new MarsFirstPolicy03();
export const MARS_FIRST_POLICY_4 = new MarsFirstPolicy04();

================
File: turmoil/parties/Party.ts
================
import {MultiSet} from 'mnemonist';
import {IGame} from '../../IGame';
import {IPlayer} from '../../IPlayer';
import {Delegate, NeutralPlayer} from '../Turmoil';
import {CardName} from '../../../common/cards/CardName';

export abstract class Party {
  public partyLeader: undefined | Delegate = undefined;
  public delegates = new MultiSet<Delegate>();

  // Send a delegate in the area
  public sendDelegate(delegate: Delegate, game: IGame): void {
    this.delegates.add(delegate);
    this.checkPartyLeader(delegate, game);
  }

  // Remove a delegate from the area
  public removeDelegate(delegate: Delegate, game: IGame): void {
    this.delegates.remove(delegate);
    this.checkPartyLeader(delegate, game);
  }

  private setPartyLeader(delegate: Delegate, game: IGame) {
    this.partyLeader = delegate;
    const cardPlayer = game.getCardPlayerOrUndefined(CardName.CORRIDORS_OF_POWER);
    if (cardPlayer === delegate) {
      cardPlayer.drawCard();
    }
  }

  // Check if you are the new party leader
  public checkPartyLeader(delegate: Delegate, game: IGame): void {
    const players = game.getPlayersInGenerationOrder();
    if (this.delegates.size === 0) {
      this.partyLeader = undefined;
      return;
    }
    if (this.partyLeader === undefined) {
      this.setPartyLeader(delegate, game);
      if (this.partyLeader === undefined) {
        // Satisfies Typescript
        throw new Error('Assertion error, party leader is defined');
      }
    }

    const max = this.delegates.top(1)[0][1];

    if (this.delegates.count(this.partyLeader) !== max) {
      let currentIndex = 0;
      if (this.partyLeader === 'NEUTRAL') {
        currentIndex = players.indexOf(game.getPlayerById(game.activePlayer));
      } else {
        currentIndex = players.indexOf(this.partyLeader);
      }

      let playersToCheck: Array<IPlayer | NeutralPlayer> = [];

      // Manage if it's the first player or the last
      if (players.length === 1 || currentIndex === 0) {
        playersToCheck = [...players];
      } else if (currentIndex === players.length - 1) {
        playersToCheck = players.slice(0, currentIndex);
        playersToCheck.unshift(players[currentIndex]);
      } else {
        const left = players.slice(0, currentIndex);
        const right = players.slice(currentIndex);
        playersToCheck = right.concat(left);
      }

      // Add NEUTRAL in the list
      playersToCheck.push('NEUTRAL');

      playersToCheck.some((nextPlayer) => {
        if (this.delegates.get(nextPlayer) === max) {
          this.setPartyLeader(nextPlayer, game);
          return true;
        }
        return false;
      });
    }
  }
}

================
File: turmoil/parties/PartyHooks.ts
================
import {IPlayer} from '../../IPlayer';
import {PartyName} from '../../../common/turmoil/PartyName';
import {SpaceType} from '../../../common/boards/SpaceType';
import {Phase} from '../../../common/Phase';
import {PolicyId} from '../Policy';
import {Resource} from '../../../common/Resource';
import {Space} from '../../boards/Space';
import {GREENS_POLICY_1} from './Greens';
import {PoliticalAgendas} from '../PoliticalAgendas';
import {Turmoil} from '../Turmoil';
import {CardName} from '../../../common/cards/CardName';

export class PartyHooks {
  static applyMarsFirstRulingPolicy(player: IPlayer, spaceType: SpaceType) {
    if (this.shouldApplyPolicy(player, PartyName.MARS, 'mfp01') &&
        spaceType !== SpaceType.COLONY) {
      player.stock.add(Resource.STEEL, 1);
    }
  }

  static applyGreensRulingPolicy(player: IPlayer, space: Space) {
    if (this.shouldApplyPolicy(player, PartyName.GREENS, 'gp01')) {
      const greensPolicy = GREENS_POLICY_1;
      greensPolicy.onTilePlaced(player, space);
    }
  }

  /**
   * Return true when `policy` is active.
   */
  static shouldApplyPolicy(player: IPlayer, partyName: PartyName, policyId: PolicyId): boolean {
    if (player.game.phase !== Phase.ACTION) {
      return false;
    }
    return Turmoil.ifTurmoilElse(player.game, (turmoil) => {
      // Hook for CEO Zan's effect (Skip all Reds Policy effects)
      if (partyName === PartyName.REDS && player.cardIsInEffect(CardName.ZAN)) {
        return false;
      }

      // Mars Alliance hook, always apply a policy when player is allied.
      // Reds policy is excluded as its passive effect is negative and its application is optional.
      const alliedPartyPolicy = player.alliedParty?.agenda.policyId;
      if (policyId === alliedPartyPolicy && player.alliedParty?.partyName !== PartyName.REDS) {
        return true;
      }
      const currentPolicyId = PoliticalAgendas.currentAgenda(turmoil).policyId;
      return turmoil.rulingParty.name === partyName && currentPolicyId === policyId;
    }, () => false);
  }
}

================
File: turmoil/parties/Reds.ts
================
import {IParty} from './IParty';
import {Party} from './Party';
import {PartyName} from '../../../common/turmoil/PartyName';
import {IGame} from '../../IGame';
import {Bonus, IBonus} from '../Bonus';
import {IPolicy} from '../Policy';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {IPlayer} from '../../IPlayer';
import {CardName} from '../../../common/cards/CardName';
import {MAXIMUM_HABITAT_RATE, MAXIMUM_LOGISTICS_RATE, MAXIMUM_MINING_RATE, MAX_OXYGEN_LEVEL, MAX_TEMPERATURE, MAX_VENUS_SCALE, MIN_OXYGEN_LEVEL, MIN_TEMPERATURE, MIN_VENUS_SCALE, POLITICAL_AGENDAS_MAX_ACTION_USES} from '../../../common/constants';
import {RemoveOceanTile} from '../../deferredActions/RemoveOceanTile';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectOption} from '../../inputs/SelectOption';
import {MoonExpansion} from '../../moon/MoonExpansion';
import {GlobalParameter} from '../../../common/GlobalParameter';
import {TITLES} from '../../inputs/titles';

export class Reds extends Party implements IParty {
  readonly name = PartyName.REDS;
  readonly bonuses = [REDS_BONUS_1, REDS_BONUS_2];
  readonly policies = [REDS_POLICY_1, REDS_POLICY_2, REDS_POLICY_3, REDS_POLICY_4];
}

class RedsBonus01 extends Bonus {
  readonly id = 'rb01' as const;
  readonly description = 'The player(s) with the lowest TR gains 1 TR';

  getScore(player: IPlayer) {
    const game = player.game;
    const players = [...game.getPlayersInGenerationOrder()];

    if (game.isSoloMode() && players[0].getTerraformRating() <= 20) return 1;

    players.sort((p1, p2) => p1.getTerraformRating() - p2.getTerraformRating());
    const min = players[0].getTerraformRating();

    if (player.getTerraformRating() === min) return 1;
    return 0;
  }

  override grant(game: IGame) {
    const players = game.getPlayersInGenerationOrder();
    const scores = players.map((player) => this.getScore(player));

    players.forEach((player, idx) => {
      if (scores[idx] > 0) {
        player.increaseTerraformRating(1, {log: true});
      }
    });
  }

  grantForPlayer(player: IPlayer): void {
    if (this.getScore(player) > 0) {
      player.increaseTerraformRating(1, {log: true});
    }
  }
}

class RedsBonus02 implements IBonus {
  readonly id = 'rb02' as const;
  readonly description = 'The player(s) with the highest TR loses 1 TR';

  getScore(player: IPlayer) {
    const game = player.game;
    const players = [...game.getPlayersInGenerationOrder()];

    if (game.isSoloMode() && players[0].getTerraformRating() > 20) return -1;

    players.sort((p1, p2) => p2.getTerraformRating() - p1.getTerraformRating());
    const max = players[0].getTerraformRating();

    if (player.getTerraformRating() === max) return -1;
    return 0;
  }

  grant(game: IGame) {
    const players = game.getPlayersInGenerationOrder();
    const scores = players.map((player) => this.getScore(player));

    players.forEach((player, idx) => {
      if (scores[idx] < 0) player.decreaseTerraformRating();
    });
  }
}

class RedsPolicy01 implements IPolicy {
  readonly id = 'rp01' as const;
  readonly description = 'When you take an action that raises TR, you MUST pay 3 M€ per step raised';
}

class RedsPolicy02 implements IPolicy {
  readonly id = 'rp02' as const;
  readonly description = 'When you place a tile, pay 3 M€ or as much as possible';

  onTilePlaced(player: IPlayer) {
    let amountPlayerHas = player.megaCredits;
    if (player.isCorporation(CardName.HELION)) amountPlayerHas += player.heat;

    const amountToPay = Math.min(amountPlayerHas, 3);
    if (amountToPay > 0) {
      player.game.defer(new SelectPaymentDeferred(player, amountToPay, {title: 'Select how to pay for tile placement'}));
    }
  }
}

class RedsPolicy03 implements IPolicy {
  readonly id = 'rp03' as const;
  readonly description = 'Pay 4 M€ to reduce a non-maxed global parameter 1 step (do not gain any track bonuses)';

  private canDecrease(game: IGame, parameter: GlobalParameter) {
    switch (parameter) {
    case GlobalParameter.TEMPERATURE:
      const temp = game.getTemperature();
      return temp > MIN_TEMPERATURE && temp !== MAX_TEMPERATURE;
    case GlobalParameter.OCEANS:
      return game.canRemoveOcean();
    case GlobalParameter.OXYGEN:
      const oxygenLevel = game.getOxygenLevel();
      return oxygenLevel > MIN_OXYGEN_LEVEL && oxygenLevel !== MAX_OXYGEN_LEVEL;
    case GlobalParameter.VENUS:
      const venusScaleLevel = game.getVenusScaleLevel();
      return game.gameOptions.venusNextExtension === true && venusScaleLevel > MIN_VENUS_SCALE && venusScaleLevel !== MAX_VENUS_SCALE;
    case GlobalParameter.MOON_HABITAT_RATE:
      return MoonExpansion.ifElseMoon(game, (moonData) => {
        const rate = moonData.habitatRate;
        return rate > 0 && rate !== MAXIMUM_HABITAT_RATE;
      },
      () => false);
    case GlobalParameter.MOON_LOGISTICS_RATE:
      return MoonExpansion.ifElseMoon(game, (moonData) => {
        const rate = moonData.logisticRate;
        return rate > 0 && rate !== MAXIMUM_LOGISTICS_RATE;
      },
      () => false);
    case GlobalParameter.MOON_MINING_RATE:
      return MoonExpansion.ifElseMoon(game, (moonData) => {
        const rate = moonData.miningRate;
        return rate > 0 && rate !== MAXIMUM_MINING_RATE;
      },
      () => false);
    }
  }

  canAct(player: IPlayer) {
    const game = player.game;
    if (game.marsIsTerraformed()) return false;

    const temperature = game.getTemperature();
    const oceansPlaced = game.board.getOceanSpaces().length;
    const oxygenLevel = game.getOxygenLevel();
    const venusScaleLevel = game.getVenusScaleLevel();

    const basicParametersAtMinimum =
      temperature === MIN_TEMPERATURE &&
      oceansPlaced === 0 &&
      oxygenLevel === MIN_OXYGEN_LEVEL &&
      venusScaleLevel === MIN_VENUS_SCALE;

    const moonParametersAtMinimum= MoonExpansion.ifElseMoon(
      game,
      (moonData) => moonData.habitatRate === 0 && moonData.logisticRate === 0 && moonData.miningRate === 0,
      () => false);

    if (basicParametersAtMinimum && moonParametersAtMinimum) {
      return false;
    }

    return player.canAfford(4) && player.politicalAgendasActionUsedCount < POLITICAL_AGENDAS_MAX_ACTION_USES;
  }

  action(player: IPlayer) {
    const game = player.game;
    game.log('${0} used Turmoil ${1} action', (b) => b.player(player).partyName(PartyName.REDS));
    player.politicalAgendasActionUsedCount += 1;

    game.defer(new SelectPaymentDeferred(player, 4, {title: TITLES.payForPartyAction(PartyName.REDS)}))
      .andThen(() => {
        const orOptions = new OrOptions();

        // Decrease temperature option
        if (this.canDecrease(game, GlobalParameter.TEMPERATURE)) {
          orOptions.options.push(new SelectOption('Decrease temperature').andThen(() => {
            game.increaseTemperature(player, -1);
            game.log('${0} decreased temperature 1 step', (b) => b.player(player));
            return undefined;
          }));
        }

        // Remove ocean option
        if (this.canDecrease(game, GlobalParameter.OCEANS)) {
          orOptions.options.push(new SelectOption('Remove an ocean tile').andThen(() => {
            game.defer(new RemoveOceanTile(player, 'Turmoil Reds action - Remove an Ocean tile from the board'));
            return undefined;
          }));
        }

        // Decrease oxygen level option
        if (this.canDecrease(game, GlobalParameter.OXYGEN)) {
          orOptions.options.push(new SelectOption('Decrease oxygen level').andThen(() => {
            game.increaseOxygenLevel(player, -1);
            game.log('${0} decreased oxygen level 1 step', (b) => b.player(player));
            return undefined;
          }));
        }

        // Decrease Venus scale option
        if (this.canDecrease(game, GlobalParameter.VENUS)) {
          orOptions.options.push(new SelectOption('Decrease Venus scale').andThen(() => {
            game.increaseVenusScaleLevel(player, -1);
            game.log('${0} decreased Venus scale level 1 step', (b) => b.player(player));
            return undefined;
          }));
        }

        if (this.canDecrease(game, GlobalParameter.MOON_HABITAT_RATE)) {
          orOptions.options.push(new SelectOption('Decrease Moon habitat rate').andThen(() => {
            MoonExpansion.lowerHabitatRate(player, 1);
            return undefined;
          }));
        }

        if (this.canDecrease(game, GlobalParameter.MOON_MINING_RATE)) {
          orOptions.options.push(new SelectOption('Decrease Moon mining rate').andThen(() => {
            MoonExpansion.lowerMiningRate(player, 1);
            return undefined;
          }));
        }

        if (this.canDecrease(game, GlobalParameter.MOON_LOGISTICS_RATE)) {
          orOptions.options.push(new SelectOption('Decrease Moon Logistics Rate').andThen(() => {
            MoonExpansion.lowerLogisticRate(player, 1);
            return undefined;
          }));
        }

        if (orOptions.options.length === 1) return orOptions.options[0].cb();

        player.defer(orOptions);
        return undefined;
      });

    return undefined;
  }
}

class RedsPolicy04 implements IPolicy {
  readonly id = 'rp04' as const;
  readonly description = 'When you raise a global parameter, decrease your M€ production 1 step per step raised if possible';
}

export const REDS_BONUS_1 = new RedsBonus01();
export const REDS_BONUS_2 = new RedsBonus02();
export const REDS_POLICY_1 = new RedsPolicy01();
export const REDS_POLICY_2 = new RedsPolicy02();
export const REDS_POLICY_3 = new RedsPolicy03();
export const REDS_POLICY_4 = new RedsPolicy04();

================
File: turmoil/parties/Scientists.ts
================
import {IParty} from './IParty';
import {Party} from './Party';
import {PartyName} from '../../../common/turmoil/PartyName';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {Bonus} from '../Bonus';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {IPlayer} from '../../IPlayer';
import {Policy, IPolicy} from '../Policy';
import {TITLES} from '../../inputs/titles';

export class Scientists extends Party implements IParty {
  readonly name = PartyName.SCIENTISTS as const;
  readonly bonuses = [SCIENTISTS_BONUS_1, SCIENTISTS_BONUS_2];
  readonly policies = [SCIENTISTS_POLICY_1, SCIENTISTS_POLICY_2, SCIENTISTS_POLICY_3, SCIENTISTS_POLICY_4];
}

class ScientistsBonus01 extends Bonus {
  readonly id = 'sb01' as const;
  readonly description = 'Gain 1 M€ for each science tag you have';

  getScore(player: IPlayer) {
    return player.tags.count(Tag.SCIENCE, 'raw-pf');
  }

  grantForPlayer(player: IPlayer) {
    player.stock.add(Resource.MEGACREDITS, this.getScore(player));
  }
}

class ScientistsBonus02 extends Bonus {
  readonly id = 'sb02' as const;
  readonly description = 'Gain 1 M€ for every 3 cards in hand';

  getScore(player: IPlayer) {
    return Math.floor(player.cardsInHand.length / 3);
  }

  grantForPlayer(player: IPlayer) {
    player.stock.add(Resource.MEGACREDITS, this.getScore(player));
  }
}

class ScientistsPolicy01 implements IPolicy {
  readonly id = 'sp01' as const;
  readonly description = 'Pay 10 M€ to draw 3 cards (Turmoil Scientists)';

  canAct(player: IPlayer) {
    return player.canAfford(10) && player.turmoilPolicyActionUsed === false;
  }

  action(player: IPlayer) {
    const game = player.game;
    game.log('${0} used Turmoil ${1} action', (b) => b.player(player).partyName(PartyName.SCIENTISTS));
    game.defer(new SelectPaymentDeferred(player, 10, {title: TITLES.payForPartyAction(PartyName.SCIENTISTS)}))
      .andThen(() => {
        player.drawCard(3);
        player.turmoilPolicyActionUsed = true;
      });

    return undefined;
  }
}

class ScientistsPolicy02 implements IPolicy {
  readonly id = 'sp02' as const;
  readonly description = 'Your global requirements are +/- 2 steps';
}

class ScientistsPolicy03 implements IPolicy {
  readonly id = 'sp03' as const;
  readonly description = 'When you raise a global parameter, draw a card per step raised';
}

class ScientistsPolicy04 extends Policy {
  readonly id = 'sp04' as const;
  readonly description = 'Cards with Science tag requirements may be played with 1 less Science tag';

  override onPolicyStartForPlayer(player: IPlayer) {
    player.hasTurmoilScienceTagBonus = true;
  }

  override onPolicyEndForPlayer(player: IPlayer) {
    player.hasTurmoilScienceTagBonus = false;
  }
}

export const SCIENTISTS_BONUS_1 = new ScientistsBonus01();
export const SCIENTISTS_BONUS_2 = new ScientistsBonus02();
export const SCIENTISTS_POLICY_1 = new ScientistsPolicy01();
export const SCIENTISTS_POLICY_2 = new ScientistsPolicy02();
export const SCIENTISTS_POLICY_3 = new ScientistsPolicy03();
export const SCIENTISTS_POLICY_4 = new ScientistsPolicy04();

================
File: turmoil/parties/Unity.ts
================
import {IParty} from './IParty';
import {Party} from './Party';
import {PartyName} from '../../../common/turmoil/PartyName';
import {Tag} from '../../../common/cards/Tag';
import {Resource} from '../../../common/Resource';
import {Bonus} from '../Bonus';
import {Policy, IPolicy} from '../Policy';
import {SelectPaymentDeferred} from '../../deferredActions/SelectPaymentDeferred';
import {IPlayer} from '../../IPlayer';
import {POLITICAL_AGENDAS_MAX_ACTION_USES} from '../../../common/constants';
import {OrOptions} from '../../inputs/OrOptions';
import {SelectCard} from '../../inputs/SelectCard';
import {SelectOption} from '../../inputs/SelectOption';
import {CardResource} from '../../../common/CardResource';
import {sum} from '../../../common/utils/utils';
import {TITLES} from '../../inputs/titles';
import {message} from '../../logs/MessageBuilder';

export class Unity extends Party implements IParty {
  name = PartyName.UNITY;
  bonuses = [UNITY_BONUS_1, UNITY_BONUS_2];
  policies = [UNITY_POLICY_1, UNITY_POLICY_2, UNITY_POLICY_3, UNITY_POLICY_4];
}

class UnityBonus01 extends Bonus {
  id = 'ub01' as const;
  description = 'Gain 1 M€ for each Venus, Earth and Jovian tag you have';

  getScore(player: IPlayer) {
    const tags = [Tag.VENUS, Tag.EARTH, Tag.JOVIAN];
    return sum(tags.map((tag) => player.tags.count(tag, 'raw')));
  }

  grantForPlayer(player: IPlayer) {
    player.stock.add(Resource.MEGACREDITS, this.getScore(player));
  }
}

class UnityBonus02 extends Bonus {
  id = 'ub02' as const;
  description = 'Gain 1 M€ for each Space tag you have';

  getScore(player: IPlayer) {
    return player.tags.count(Tag.SPACE, 'raw');
  }

  grantForPlayer(player: IPlayer) {
    player.stock.add(Resource.MEGACREDITS, this.getScore(player));
  }
}

class UnityPolicy01 extends Policy {
  id = 'up01' as const;
  description = 'Your titanium resources are worth 1 M€ extra';

  override onPolicyStartForPlayer(player: IPlayer): void {
    player.increaseTitaniumValue();
  }
  override onPolicyEndForPlayer(player: IPlayer): void {
    player.decreaseTitaniumValue();
  }
}

class UnityPolicy02 implements IPolicy {
  id = 'up02' as const;
  description = 'Spend 4 M€ to gain 2 titanium or add 2 floaters to ANY card (Turmoil Unity)';

  canAct(player: IPlayer) {
    return player.canAfford(4) && player.politicalAgendasActionUsedCount < POLITICAL_AGENDAS_MAX_ACTION_USES;
  }

  action(player: IPlayer) {
    const game = player.game;
    game.log('${0} used Turmoil ${1} action', (b) => b.player(player).partyName(PartyName.UNITY));
    player.politicalAgendasActionUsedCount += 1;

    game.defer(new SelectPaymentDeferred(player, 4, {title: TITLES.payForPartyAction(PartyName.UNITY)}))
      .andThen(() => {
        const availableFloaterCards = player.getResourceCards(CardResource.FLOATER);
        const orOptions = new OrOptions();

        if (availableFloaterCards.length === 1) {
          orOptions.options.push(
            new SelectOption(message('Add ${0} floaters to ${1}', (b) => b.number(2).card(availableFloaterCards[0]))).andThen(() => {
              player.addResourceTo(availableFloaterCards[0], {qty: 2, log: true});

              return undefined;
            }),
          );
        } else if (availableFloaterCards.length > 1) {
          orOptions.options.push(
            new SelectOption('Add 2 floaters to a card').andThen(() => {
              return new SelectCard('Select card to add 2 floaters', 'Add floaters', availableFloaterCards)
                .andThen(([card]) => {
                  player.addResourceTo(card, {qty: 2, log: true});
                  return undefined;
                });
            }),
          );
        }

        orOptions.options.push(new SelectOption('Gain 2 titanium').andThen(() => {
          player.stock.add(Resource.TITANIUM, 2);
          game.log('${0} gained 2 titanium', (b) => b.player(player));
          return undefined;
        }));

        if (orOptions.options.length === 1) return orOptions.options[0].cb();

        player.defer(orOptions);
        return undefined;
      });

    return undefined;
  }
}

class UnityPolicy03 implements IPolicy {
  id = 'up03' as const;
  description = 'Spend 4 M€ to draw a Space card (Turmoil Unity)';

  canAct(player: IPlayer) {
    return player.canAfford(4) && player.politicalAgendasActionUsedCount < POLITICAL_AGENDAS_MAX_ACTION_USES;
  }

  action(player: IPlayer) {
    const game = player.game;
    game.log('${0} used Turmoil ${1} action', (b) => b.player(player).partyName(PartyName.UNITY));
    player.politicalAgendasActionUsedCount += 1;

    game.defer(new SelectPaymentDeferred(player, 4, {title: TITLES.payForPartyAction(PartyName.UNITY)}))
      .andThen(() => player.drawCard(1, {tag: Tag.SPACE}));

    return undefined;
  }
}

class UnityPolicy04 implements IPolicy {
  id = 'up04' as const;
  description = 'Cards with Space tags cost 2 M€ less to play';
}

export const UNITY_BONUS_1 = new UnityBonus01();
export const UNITY_BONUS_2 = new UnityBonus02();
export const UNITY_POLICY_1 = new UnityPolicy01();
export const UNITY_POLICY_2 = new UnityPolicy02();
export const UNITY_POLICY_3 = new UnityPolicy03();
export const UNITY_POLICY_4 = new UnityPolicy04();

================
File: turmoil/Policy.ts
================
import {IProjectCard} from '../cards/IProjectCard';
import {IGame} from '../IGame';
import {Space} from '../boards/Space';
import {IPlayer} from '../IPlayer';
import {PlayerInput} from '../PlayerInput';

type Party = 'mf' | 's' | 'u' | 'k' | 'r' | 'g';
type Suffix = 'p01' | 'p02' | 'p03' | 'p04';
export type PolicyId = `${Party}${Suffix}`

// Represents a Turmoil policy.
export interface IPolicy {
  id: PolicyId;
  description: string | ((player: IPlayer | undefined) => string);
  onTilePlaced?(player: IPlayer, space: Space): void;
  onCardPlayed?(player: IPlayer, card: IProjectCard): void;
  action?(player: IPlayer): PlayerInput | undefined;
  canAct?(player: IPlayer): boolean;
  onPolicyStart?(game: IGame): void;
  onPolicyStartForPlayer?(player: IPlayer): void;
  onPolicyEnd?(game: IGame): void;
  onPolicyEndForPlayer?(player: IPlayer): void;
  }

// TODO(kberg): Rename to Policy
export abstract class Policy implements IPolicy {
  abstract readonly id: PolicyId;
  abstract readonly description: string | ((player: IPlayer | undefined) => string);

  public onPolicyStart(game: IGame): void {
    game.getPlayersInGenerationOrder().forEach((p) => this.onPolicyStartForPlayer(p));
  }

  public abstract onPolicyStartForPlayer(_player: IPlayer): void;

  public onPolicyEnd(game: IGame): void {
    game.getPlayersInGenerationOrder().forEach((p) => this.onPolicyEndForPlayer(p));
  }

  public abstract onPolicyEndForPlayer(_player: IPlayer): void;
}

export function policyDescription(policy: IPolicy, player: IPlayer | undefined): string {
  return typeof(policy.description) === 'string' ? policy.description : policy.description(player);
}

================
File: turmoil/PoliticalAgendas.ts
================
import {ChoosePoliticalAgenda} from '../deferredActions/ChoosePoliticalAgenda';
import {IGame} from '../IGame';
import {IBonus} from './Bonus';
import {IParty} from './parties/IParty';
import {PartyName} from '../../common/turmoil/PartyName';
import {IPolicy} from './Policy';
import {Turmoil} from './Turmoil';
import {Agenda, AgendaStyle} from '../../common/turmoil/Types';

export type PoliticalAgendasData = {
  agendas: Map<PartyName, Agenda>;
  agendaStyle: AgendaStyle;
}

export type SerializedPoliticalAgendasData = {
  agendas: Array<[PartyName, Agenda]>;
  agendaStyle: AgendaStyle;
}

export class PoliticalAgendas {
  public static randomElement = PoliticalAgendas.defaultRandomElement;

  public static newInstance(
    agendaStyle: AgendaStyle,
    parties: ReadonlyArray<IParty>): PoliticalAgendasData {
    const agendas: Map<PartyName, Agenda> = new Map();

    parties.forEach((p) => {
      if (agendaStyle === AgendaStyle.STANDARD) {
        agendas.set(p.name, {bonusId: p.bonuses[0].id, policyId: p.policies[0].id});
      } else {
        agendas.set(p.name, PoliticalAgendas.getRandomAgenda(p));
      }
    });

    return {
      agendas: agendas,
      agendaStyle: agendaStyle,
    };
  }

  private static getRandomAgenda(party: IParty): Agenda {
    const bonus: IBonus = PoliticalAgendas.randomElement(party.bonuses);
    const policy: IPolicy = PoliticalAgendas.randomElement(party.policies);

    return {bonusId: bonus.id, policyId: policy.id};
  }

  public static currentAgenda(turmoil: Turmoil): Agenda {
    return this.getAgenda(turmoil, turmoil.rulingParty.name);
  }

  public static getAgenda(turmoil: Turmoil, partyName: PartyName): Agenda {
    const agenda = turmoil.politicalAgendasData.agendas.get(partyName);
    if (agenda === undefined) {
      throw new Error('Invalid party: ' + partyName);
    }
    return agenda;
  }

  // The ruling party is already in power, and now it is time for the party to select an agenda.
  // Do not expect the method to return an activated agenda if the current agenda style is chairman
  // And a person is the chairman -- the end of this method will just defer selection until later.
  public static setNextAgenda(turmoil: Turmoil, game: IGame): void {
    const rulingParty = turmoil.rulingParty;
    const politicalAgendasData = turmoil.politicalAgendasData;
    const chairman = turmoil.chairman;
    if (chairman === undefined) {
      throw new Error('Chairman not defined');
    }

    // Agendas are static unless it's chosen by a chairperson, in which case
    // defer the selection.
    if (politicalAgendasData.agendaStyle === AgendaStyle.CHAIRMAN && chairman !== 'NEUTRAL') {
      const agenda = this.getAgenda(turmoil, rulingParty.name);
      game.defer(new ChoosePoliticalAgenda(
        chairman,
        rulingParty,
        (bonusId) => {
          agenda.bonusId = bonusId;
          turmoil.onAgendaSelected(game);
        },
        (policyId) => {
          agenda.policyId = policyId;
          turmoil.onAgendaSelected(game);
        }));
    } else {
      turmoil.onAgendaSelected(game);
    }
  }

  public static serialize(agenda: PoliticalAgendasData): SerializedPoliticalAgendasData {
    return {
      agendas: Array.from(agenda.agendas.entries()),
      agendaStyle: agenda.agendaStyle,
    };
  }

  public static deserialize(d: SerializedPoliticalAgendasData): PoliticalAgendasData {
    return {
      agendas: new Map(d.agendas),
      agendaStyle: d.agendaStyle,
    };
  }

  // Overridable for tests
  public static defaultRandomElement<T>(list: ReadonlyArray<T>): T {
    const rng = Math.floor(Math.random() * list.length);
    return list[rng];
  }
}

================
File: turmoil/SerializedTurmoil.ts
================
import {GlobalEventName} from '../../common/turmoil/globalEvents/GlobalEventName';
import {PartyName} from '../../common/turmoil/PartyName';
import {SerializedGlobalEventDealer} from './globalEvents/SerializedGlobalEventDealer';
import {SerializedPoliticalAgendasData} from './PoliticalAgendas';
import {PlayerId} from '../../common/Types';

export type SerializedParty = {
    name: PartyName;
    delegates: Array<SerializedDelegate>;
    partyLeader?: SerializedDelegate;
}

export type SerializedDelegate = PlayerId | 'NEUTRAL';

export type SerializedTurmoil = {
    chairman: undefined | SerializedDelegate;
    rulingParty: PartyName;
    dominantParty: PartyName;
    lobby?: Array<PlayerId>;
    usedFreeDelegateAction: Array<PlayerId>;
    delegateReserve: Array<SerializedDelegate>;
    parties: Array<SerializedParty>;
    playersInfluenceBonus: Array<[string, number]>;
    globalEventDealer: SerializedGlobalEventDealer;
    distantGlobalEvent: GlobalEventName | undefined;
    comingGlobalEvent: GlobalEventName | undefined;
    currentGlobalEvent?: GlobalEventName;
    politicalAgendasData: SerializedPoliticalAgendasData;
}

================
File: turmoil/Turmoil.ts
================
import {PartyName} from '../../common/turmoil/PartyName';
import {IParty} from './parties/IParty';
import {MarsFirst} from './parties/MarsFirst';
import {Scientists} from './parties/Scientists';
import {Unity} from './parties/Unity';
import {Kelvinists} from './parties/Kelvinists';
import {Reds} from './parties/Reds';
import {Greens} from './parties/Greens';
import {IGame} from '../IGame';
import {GlobalEventDealer, getGlobalEventByName} from './globalEvents/GlobalEventDealer';
import {IGlobalEvent} from './globalEvents/IGlobalEvent';
import {SerializedDelegate, SerializedTurmoil} from './SerializedTurmoil';
import {DELEGATES_FOR_NEUTRAL_PLAYER, DELEGATES_PER_PLAYER} from '../../common/constants';
import {PoliticalAgendasData, PoliticalAgendas} from './PoliticalAgendas';
import {AgendaStyle} from '../../common/turmoil/Types';
import {CardName} from '../../common/cards/CardName';
import {MultiSet} from 'mnemonist';
import {IPlayer} from '../IPlayer';
import {SendDelegateToArea} from '../deferredActions/SendDelegateToArea';
import {SelectParty} from '../inputs/SelectParty';
import {IPolicy, PolicyId, policyDescription} from './Policy';
import {PlayerId} from '../../common/Types';
import {ChoosePolicyBonus} from '../deferredActions/ChoosePolicyBonus';

export type NeutralPlayer = 'NEUTRAL';
export type Delegate = IPlayer | NeutralPlayer;

export type PartyFactory = new() => IParty;

export const ALL_PARTIES: Record<PartyName, PartyFactory> = {
  [PartyName.MARS]: MarsFirst,
  [PartyName.SCIENTISTS]: Scientists,
  [PartyName.UNITY]: Unity,
  [PartyName.GREENS]: Greens,
  [PartyName.REDS]: Reds,
  [PartyName.KELVINISTS]: Kelvinists,
};

function createParties(): ReadonlyArray<IParty> {
  return [new MarsFirst(), new Scientists(), new Unity(), new Greens(), new Reds(), new Kelvinists()];
}

const UNINITIALIZED_POLITICAL_AGENDAS_DATA: PoliticalAgendasData = {
  agendas: new Map(),
  agendaStyle: AgendaStyle.CHAIRMAN,
};

export class Turmoil {
  public chairman: undefined | Delegate = undefined;
  public rulingParty: IParty;
  public dominantParty: IParty;
  public usedFreeDelegateAction = new Set<IPlayer>();
  public delegateReserve = new MultiSet<Delegate>();
  public parties = createParties();
  public playersInfluenceBonus = new Map<string, number>();
  public readonly globalEventDealer: GlobalEventDealer;
  public distantGlobalEvent: IGlobalEvent | undefined;
  public comingGlobalEvent: IGlobalEvent | undefined;
  public currentGlobalEvent: IGlobalEvent | undefined;
  public politicalAgendasData: PoliticalAgendasData = UNINITIALIZED_POLITICAL_AGENDAS_DATA;

  private constructor(
    rulingPartyName: PartyName,
    chairman: Delegate,
    dominantPartyName: PartyName,
    globalEventDealer: GlobalEventDealer) {
    this.rulingParty = this.getPartyByName(rulingPartyName);
    this.chairman = chairman;
    this.dominantParty = this.getPartyByName(dominantPartyName);
    this.globalEventDealer = globalEventDealer;
  }

  public static newInstance(game: IGame, agendaStyle: AgendaStyle = AgendaStyle.STANDARD): Turmoil {
    const dealer = GlobalEventDealer.newInstance(game);

    // The game begins with Greens in power and a Neutral chairman
    const turmoil = new Turmoil(PartyName.GREENS, 'NEUTRAL', PartyName.GREENS, dealer);

    game.log('A neutral delegate is the new chairman.');
    game.log('Greens are in power in the first generation.');

    // Init parties
    turmoil.parties = createParties();

    game.getPlayersInGenerationOrder().forEach((player) => {
      turmoil.delegateReserve.add(player, DELEGATES_PER_PLAYER);
    });
    // One Neutral delegate is already Chairman
    turmoil.delegateReserve.add('NEUTRAL', DELEGATES_FOR_NEUTRAL_PLAYER - 1);

    turmoil.politicalAgendasData = PoliticalAgendas.newInstance(agendaStyle, turmoil.parties);
    // Note: this call relies on an instance of Game that will not be fully formed.
    // TODO(kberg): split newInstance into create/set-up so this can be done once the whole thing is ready.
    turmoil.onAgendaSelected(game);
    turmoil.initGlobalEvent(game);
    return turmoil;
  }

  public static getTurmoil(game: IGame): Turmoil {
    if (game.turmoil === undefined) {
      throw new Error(`Assertion error: Turmoil not defined for ${game.id}`);
    }
    return game.turmoil;
  }

  public static ifTurmoil(game: IGame, cb: (turmoil: Turmoil) => void) {
    if (game.gameOptions.turmoilExtension !== false) {
      if (game.turmoil === undefined) {
        console.log(`Assertion failure: game.turmoil is undefined for ${game.id}`);
      } else {
        return cb(game.turmoil);
      }
    }
  }

  public static ifTurmoilElse<T>(game: IGame, cb: (turmoil: Turmoil) => T, elseCb: () => T): T {
    if (game.gameOptions.turmoilExtension !== false) {
      if (game.turmoil === undefined) {
        console.log(`Assertion failure: game.turmoil is undefined for ${game.id}`);
      } else {
        return cb(game.turmoil);
      }
    }
    return elseCb();
  }

  public initGlobalEvent(game: IGame) {
    // Draw the first global event to setup the game
    this.comingGlobalEvent = this.globalEventDealer.draw();
    this.addNeutralDelegate(this.comingGlobalEvent?.revealedDelegate, game);
    this.distantGlobalEvent = this.globalEventDealer.draw();
    this.addNeutralDelegate(this.distantGlobalEvent?.revealedDelegate, game);
  }

  public getPartyByName(name: PartyName): IParty {
    const party = this.parties.find((party) => party.name === name);
    if (party === undefined) {
      throw new Error(`Cannot find party with name {${name}}`);
    }
    return party;
  }

  rulingPolicy(): IPolicy {
    const rulingParty = this.rulingParty;
    const rulingPolicyId: PolicyId = PoliticalAgendas.currentAgenda(this).policyId;
    const policy = rulingParty.policies.find((policy) => policy.id === rulingPolicyId);
    if (policy === undefined) {
      throw new Error(`Policy ${rulingPolicyId} not found in ${rulingParty.name}`);
    }
    return policy;
  }

  public sendDelegateToParty(playerId: Delegate, partyName: PartyName, game: IGame, throwIfError = false): void {
    const party = this.getPartyByName(partyName);
    if (this.delegateReserve.has(playerId)) {
      this.delegateReserve.remove(playerId);
    } else {
      console.log(`${playerId}/${game.id} tried to get a delegate from an empty reserve.`);
      if (throwIfError) {
        throw new Error('No available delegate');
      }
      return;
    }
    party.sendDelegate(playerId, game);
    this.checkDominantParty();
  }

  /**
   * Remove one `delegate` from `partyName`.
   *
   * Will re-evaluate the dominant party.
   */
  public removeDelegateFromParty(delegate: Delegate, partyName: PartyName, game: IGame): void {
    const party = this.getPartyByName(partyName);
    this.delegateReserve.add(delegate);
    party.removeDelegate(delegate, game);
    this.checkDominantParty();
  }

  /**
   * Replace one `outgoingDelegate` delegate with one `incomingDelegate` in `party` without changing
   * dominance. (I don't think it prevents checking dominance, really.)
   */
  public replaceDelegateFromParty(
    outgoingDelegate: Delegate,
    incomingDelegate: Delegate,
    partyName: PartyName,
    game: IGame): void {
    const party = this.getPartyByName(partyName);
    this.delegateReserve.add(outgoingDelegate);
    party.removeDelegate(outgoingDelegate, game);
    this.sendDelegateToParty(incomingDelegate, partyName, game);
  }

  /**
   * Updates the dominant party. Called as part of delegate changes.
   */
  public checkDominantParty(): void {
    // If there is a dominant party
    const sortParties = [...this.parties].sort(
      (p1, p2) => p2.delegates.size - p1.delegates.size,
    );
    const max = sortParties[0].delegates.size;
    if (this.dominantParty.delegates.size !== max) {
      this.setNextPartyAsDominant(this.dominantParty);
    }
  }

  /**
   * Set the next dominanant party taking into account that
   * `currentDominantParty` is the current dominant party, taking
   * clockwise order into account.
   */
  // Function to get next dominant party taking into account the clockwise order
  private setNextPartyAsDominant(currentDominantParty: IParty) {
    const sortParties = [...this.parties].sort(
      (p1, p2) => p2.delegates.size - p1.delegates.size,
    );
    const max = sortParties[0].delegates.size;

    const currentIndex = this.parties.indexOf(currentDominantParty);

    let partiesToCheck = [];

    // Manage if it's the first party or the last
    if (currentIndex === 0) {
      partiesToCheck = this.parties.slice(currentIndex + 1);
    } else if (currentIndex === this.parties.length - 1) {
      partiesToCheck = this.parties.slice(0, currentIndex);
    } else {
      const left = this.parties.slice(0, currentIndex);
      const right = this.parties.slice(currentIndex + 1);
      partiesToCheck = right.concat(left);
    }

    // Take the clockwise order
    const partiesOrdered = partiesToCheck.reverse();

    partiesOrdered.some((newParty) => {
      if (newParty.delegates.size === max) {
        this.dominantParty = newParty;
        return true;
      }
      return false;
    });
  }

  // Launch the turmoil phase
  public endGeneration(game: IGame): void {
    // 1 - All player lose 1 TR
    game.getPlayers().forEach((player) => {
      player.decreaseTerraformRating();
    });

    // 2 - Global Event
    if (this.currentGlobalEvent !== undefined) {
      const currentGlobalEvent: IGlobalEvent = this.currentGlobalEvent;
      game.log('Resolving global event ${0}', (b) => b.globalEvent(currentGlobalEvent));
      // TODO(kberg): if current global event adds an action, all of the rest of this should wait.
      currentGlobalEvent.resolve(game, this);
    }

    // WOW THIS BREAKS THINGS
    //   this.startNewGovernment(game);
    // }
    // private startNewGovernment(game: IGame) {
    //   if (game.deferredActions.length > 0) {
    //     game.deferredActions.runAll(() => {
    //       this.startNewGovernment(game);
    //     });
    //     return;
    //   }

    // 3 - New Government

    // 3.a - Ruling Policy change
    this.setRulingParty(game);

    // 3.b - New dominant party
    this.setNextPartyAsDominant(this.rulingParty);

    // 3.c - Fill the lobby
    this.usedFreeDelegateAction.clear();

    // 4 - Changing Time
    if (this.currentGlobalEvent) {
      this.globalEventDealer.discard(this.currentGlobalEvent);
    }
    // 4.a - Coming Event is now Current event. Add neutral delegate.
    this.currentGlobalEvent = this.comingGlobalEvent;
    this.addNeutralDelegate(this.currentGlobalEvent?.currentDelegate, game);
    // 4.b - Distant Event is now Coming Event
    this.comingGlobalEvent = this.distantGlobalEvent;
    // 4.c - Draw the new distant event and add neutral delegate
    this.distantGlobalEvent = this.globalEventDealer.draw();
    this.addNeutralDelegate(this.distantGlobalEvent?.revealedDelegate, game);
  }

  private addNeutralDelegate(partyName: PartyName | undefined, game: IGame) {
    if (partyName) {
      this.sendDelegateToParty('NEUTRAL', partyName, game);
      game.log('A neutral delegate was added to the ${0} party', (b) => b.partyName(partyName));
    }
  }

  private executeAlliedOnPolicyEnd(player: IPlayer | undefined): void {
    if (player?.alliedParty) {
      const {alliedParty} = player;
      const alliedPolicy = player.game.turmoil?.getPartyByName(alliedParty.partyName)?.policies.find((p) => p.id === alliedParty.agenda.policyId);
      alliedPolicy?.onPolicyEndForPlayer?.(player);
    }
  }

  /**
   * Set the next ruling party as part of the Turmoil phase.
   */
  public setRulingParty(game: IGame): void {
    this.rulingPolicy().onPolicyEnd?.(game);

    // Mars Frontier Alliance ends allied party policy
    const alliedPlayer = game.getPlayers().find((p) => p.alliedParty !== undefined);
    this.executeAlliedOnPolicyEnd(alliedPlayer);

    // Behold the Emperor Hook prevents changing the ruling party.
    if (game.beholdTheEmperor !== true) {
      this.rulingParty = this.dominantParty;
    }

    let newChairman = this.rulingParty.partyLeader || 'NEUTRAL';
    if (game.beholdTheEmperor === true && this.chairman !== undefined) {
      newChairman = this.chairman;
    }

    if (game.beholdTheEmperor !== true) {
      // Fill the delegate reserve with everyone except the party leader
      if (this.rulingParty.partyLeader !== undefined) {
        this.rulingParty.delegates.remove(this.rulingParty.partyLeader);
      }
      this.rulingParty.delegates.forEachMultiplicity((count, playerId) => {
        this.delegateReserve.add(playerId, count);
      });

      // Clean the party
      this.rulingParty.partyLeader = undefined;
      this.rulingParty.delegates.clear();
    }
    this.setNewChairman(newChairman, game, /* setAgenda*/ true);
  }

  public setNewChairman(newChairman : Delegate, game: IGame, setAgenda: boolean = true, gainTR: boolean = true) {
    // Change the chairman
    if (this.chairman && game.beholdTheEmperor !== true) {
      // Return the current Chairman to reserve
      this.delegateReserve.add(this.chairman);
    }
    this.chairman = newChairman;

    // Set Agenda
    if (setAgenda) {
      PoliticalAgendas.setNextAgenda(this, game);
    }

    // Finally, award Chairman benefits
    if (this.chairman !== 'NEUTRAL') {
      const chairman = this.chairman;
      let steps = gainTR ? 1 : 0;
      // Tempest Consultancy Hook (gains an additional TR when they become chairman)
      if (chairman.isCorporation(CardName.TEMPEST_CONSULTANCY)) steps += 1;

      // Raise TR
      chairman.defer(() => {
        if (steps > 0) {
          chairman.increaseTerraformRating(steps);
          game.log('${0} is the new chairman and gains ${1} TR', (b) => b.player(chairman).number(steps));
        } else {
          game.log('${0} is the new chairman', (b) => b.player(chairman));
        }
      });
    } else {
      game.log('A neutral delegate is the new chairman.');
    }
  }

  // Returns the second-most dominant party. Used for Mars Frontier Alliance
  private findSecondDominantParty(currentDominantParty: IParty): IParty | undefined {
    const currentIndex = this.parties.indexOf(currentDominantParty);

    let partiesToCheck: Array<IParty> = [];
    if (currentIndex === 0) {
      partiesToCheck = this.parties.slice(1);
    } else if (currentIndex === this.parties.length - 1) {
      partiesToCheck = this.parties.slice(0, -1);
    } else {
      partiesToCheck = [...this.parties.slice(currentIndex + 1), ...this.parties.slice(0, currentIndex)];
    }

    const sortParties = [...this.parties].sort(
      (p1, p2) => p2.delegates.size - p1.delegates.size,
    );
    const first = sortParties[0].delegates.size;

    const partiesOrdered = partiesToCheck.reverse();
    return partiesOrdered.find((p) => p.delegates.size === first);
  }

  private applyRulingBonus(game: IGame, alliedPlayer: IPlayer | undefined): void {
    if (game.turmoil && alliedPlayer) {
      const currentDominantParty = game.turmoil.dominantParty;
      const secondDominantParty = this.findSecondDominantParty(currentDominantParty);

      if (secondDominantParty) {
        alliedPlayer.setAlliedParty(secondDominantParty);
      }
    }
  }

  // Called either directly during generation change, or after asking chairperson player
  // to choose an agenda.
  public onAgendaSelected(game: IGame): void {
    const rulingParty = this.rulingParty;

    // Ruling bonus should be chosen between global or allied party if MFA is in play
    const alliedPlayer = game.getPlayers().find((p) => p.alliedParty !== undefined);
    this.applyRulingBonus(game, alliedPlayer);

    // Resolve Ruling Bonus
    const bonusId = PoliticalAgendas.currentAgenda(this).bonusId;
    const bonus = rulingParty.bonuses.find((b) => b.id === bonusId);
    if (bonus === undefined) {
      throw new Error(`Bonus id ${bonusId} not found in party ${rulingParty.name}`);
    }
    game.log('The ruling bonus is: ${0}', (b) => b.string(bonus.description));

    // Mars Frontier Alliance
    if (alliedPlayer?.alliedParty) {
      const alliedParty = this.parties.find((p) => p.name === alliedPlayer.alliedParty?.partyName);
      if (alliedParty) {
        const bonuses = [bonus, alliedParty.bonuses[0]];
        game.defer(new ChoosePolicyBonus(alliedPlayer, bonuses, (bonusId) => {
          const chosenBonus = this.parties.flatMap((p) => p.bonuses).find((b) => b.id === bonusId);
          chosenBonus?.grantForPlayer?.(alliedPlayer);
        }));
      }
    }
    bonus.grant(game);

    const policyId = PoliticalAgendas.currentAgenda(this).policyId;
    const policy = rulingParty.policies.find((p) => p.id === policyId);
    if (policy === undefined) {
      throw new Error(`Policy id ${policyId} not found in party ${rulingParty.name}`);
    }
    const description = policyDescription(policy, undefined);
    game.log('The ruling policy is: ${0}', (b) => b.string(description));
    policy.onPolicyStart?.(game);
  }

  public getPlayerInfluence(player: IPlayer) {
    let influence = 0;
    if (this.chairman === player) influence++;

    const dominantParty : IParty = this.dominantParty;
    const isPartyLeader = dominantParty.partyLeader === player;
    const delegateCount = dominantParty.delegates.get(player);

    if (isPartyLeader) {
      influence++;
      if (delegateCount > 1) influence++; // at least 1 non-leader delegate
    } else {
      if (delegateCount > 0) influence++;
    }

    if (this.playersInfluenceBonus.has(player.id)) {
      const bonus = this.playersInfluenceBonus.get(player.id);
      if (bonus) {
        influence+= bonus;
      }
    }

    player.tableau.forEach((card) => {
      const bonus = card.getInfluenceBonus?.(player);
      if (bonus !== undefined) {
        influence += bonus;
      }
    });

    // Committee coalition hook
    if (player.cardIsInEffect(CardName.COMMITTEE_COALITION)) {
      let nonDominantPartyLeader = false;
      this.parties.filter((party) => party !== dominantParty).forEach((party) => {
        if (party.partyLeader === player) nonDominantPartyLeader = true;
      });
      if (nonDominantPartyLeader) influence++;
    }
    return influence;
  }

  public addInfluenceBonus(player: IPlayer, bonus:number = 1) {
    if (this.playersInfluenceBonus.has(player.id)) {
      let current = this.playersInfluenceBonus.get(player.id);
      if (current) {
        current += bonus;
        this.playersInfluenceBonus.set(player.id, current);
      }
    } else {
      this.playersInfluenceBonus.set(player.id, bonus);
    }
    
  }

  /** Return the number of delegates for `delegate` in the reserve. */
  public getAvailableDelegateCount(delegate: Delegate): number {
    return this.delegateReserve.get(delegate);
  }

  /** List the delegates present in the reserve */
  public getPresentPlayersInReserve(): Array<Delegate> {
    return Array.from(new Set(this.delegateReserve));
  }

  /** Return true if `player` has delegates in reserve. */
  public hasDelegatesInReserve(player: Delegate): boolean {
    return this.getAvailableDelegateCount(player) > 0;
  }

  /**
   * End-game victory points for `player`.
   *
   * Players get 1 VP at the end of the game for each chairman and party leader they have.
   */
  public getPlayerVictoryPoints(player: IPlayer): number {
    let victory = 0;
    if (this.chairman === player) victory++;
    this.parties.forEach((party) => {
      if (party.partyLeader === player) {
        victory++;
      }
    });
    return victory;
  }

  public getSendDelegateInput(player: IPlayer): SelectParty | undefined {
    if (this.hasDelegatesInReserve(player)) {
      let sendDelegate;
      if (!this.usedFreeDelegateAction.has(player)) {
        sendDelegate = new SendDelegateToArea(player, 'Send a delegate in an area (from lobby)', {freeStandardAction: true});
      } else if (player.isCorporation(CardName.INCITE) && player.canAfford(3)) {
        sendDelegate = new SendDelegateToArea(player, 'Send a delegate in an area (3 M€)', {cost: 3});
      } else if (player.canAfford(5)) {
        sendDelegate = new SendDelegateToArea(player, 'Send a delegate in an area (5 M€)', {cost: 5});
      }
      if (sendDelegate) {
        return sendDelegate.execute();
      }
    }
    return undefined;
  }

  public serialize(): SerializedTurmoil {
    const result: SerializedTurmoil = {
      chairman: serializeDelegateOrUndefined(this.chairman),
      rulingParty: this.rulingParty.name,
      dominantParty: this.dominantParty.name,
      usedFreeDelegateAction: Array.from(this.usedFreeDelegateAction).map((p) => p.id),
      delegateReserve: Array.from(this.delegateReserve.values()).map(serializeDelegate),
      parties: this.parties.map((p) => {
        return {
          name: p.name,
          delegates: Array.from(p.delegates.values()).map(serializeDelegate),
          partyLeader: serializeDelegateOrUndefined(p.partyLeader),
        };
      }),
      playersInfluenceBonus: Array.from(this.playersInfluenceBonus.entries()),
      globalEventDealer: this.globalEventDealer.serialize(),
      distantGlobalEvent: this.distantGlobalEvent?.name,
      comingGlobalEvent: this.comingGlobalEvent?.name,
      politicalAgendasData: PoliticalAgendas.serialize(this.politicalAgendasData),
    };
    if (this.currentGlobalEvent !== undefined) {
      result.currentGlobalEvent = this.currentGlobalEvent.name;
    }
    return result;
  }

  public static deserialize(d: SerializedTurmoil, players: Array<IPlayer>): Turmoil {
    const dealer = GlobalEventDealer.deserialize(d.globalEventDealer);
    const chairman = deserializeDelegateOrUndefined(d.chairman, players);
    const turmoil = new Turmoil(d.rulingParty, chairman || 'NEUTRAL', d.dominantParty, dealer);

    turmoil.usedFreeDelegateAction = new Set(d.usedFreeDelegateAction.map((p) => deserializePlayerId(p, players)));

    turmoil.delegateReserve = MultiSet.from(d.delegateReserve.map((p) => deserializeDelegate(p, players)));

    if (d.lobby !== undefined) {
      turmoil.usedFreeDelegateAction.clear();
      const legacyLobby = new Set(d.lobby);
      for (const player of players) {
        if (legacyLobby.has(player.id)) {
          turmoil.delegateReserve.add(player);
        } else {
          turmoil.usedFreeDelegateAction.add(player);
        }
      }
    }

    turmoil.politicalAgendasData = PoliticalAgendas.deserialize(d.politicalAgendasData);

    d.parties.forEach((sp) => {
      const tp = turmoil.getPartyByName(sp.name);
      tp.delegates = MultiSet.from(sp.delegates.map((p) => deserializeDelegate(p, players)));
      tp.partyLeader = deserializeDelegateOrUndefined(sp.partyLeader, players);
    });

    turmoil.playersInfluenceBonus = new Map<string, number>(d.playersInfluenceBonus);

    if (d.distantGlobalEvent) {
      turmoil.distantGlobalEvent = getGlobalEventByName(d.distantGlobalEvent);
    }
    if (d.comingGlobalEvent) {
      turmoil.comingGlobalEvent = getGlobalEventByName(d.comingGlobalEvent);
    }
    if (d.currentGlobalEvent) {
      turmoil.currentGlobalEvent = getGlobalEventByName(d.currentGlobalEvent);
    }

    return turmoil;
  }
}

function serializeDelegate(delegate: Delegate): SerializedDelegate {
  return delegate === 'NEUTRAL' ? 'NEUTRAL' : delegate.id;
}

function serializeDelegateOrUndefined(delegate: Delegate | undefined): SerializedDelegate | undefined {
  if (delegate === undefined) {
    return undefined;
  }
  return serializeDelegate(delegate);
}

function deserializePlayerId(playerId: PlayerId, players: Array<IPlayer>): IPlayer {
  const player = players.find((p) => p.id === playerId);
  if (player === undefined) {
    throw new Error('Delegate not found');
  }
  return player;
}

function deserializeDelegate(serializedDelegate: SerializedDelegate, players: Array<IPlayer>): Delegate {
  if (serializedDelegate === 'NEUTRAL') {
    return 'NEUTRAL';
  }
  return deserializePlayerId(serializedDelegate, players);
}

function deserializeDelegateOrUndefined(serializedDelegate: SerializedDelegate | undefined, players: Array<IPlayer>): Delegate | undefined {
  if (serializedDelegate === undefined) {
    return undefined;
  }
  return deserializeDelegate(serializedDelegate, players);
}

================
File: turmoil/TurmoilHandler.ts
================
import * as constants from '../../common/constants';
import {IProjectCard} from '../cards/IProjectCard';
import {GlobalParameter} from '../../common/GlobalParameter';
import {SelectOption} from '../inputs/SelectOption';
import {IPlayer} from '../IPlayer';
import {PlayerInput} from '../PlayerInput';
import {Resource} from '../../common/Resource';
import {SpaceType} from '../../common/boards/SpaceType';
import {GREENS_POLICY_2, GREENS_POLICY_3} from './parties/Greens';
import {KELVINISTS_POLICY_4} from './parties/Kelvinists';
import {MARS_FIRST_POLICY_2} from './parties/MarsFirst';
import {PartyHooks} from './parties/PartyHooks';
import {PartyName} from '../../common/turmoil/PartyName';
import {REDS_POLICY_2} from './parties/Reds';
import {MoonExpansion} from '../moon/MoonExpansion';
import {TRSource} from '../../common/cards/TRSource';
import {IPolicy, policyDescription} from './Policy';

export class TurmoilHandler {
  private constructor() {}

  public static partyAction(player: IPlayer): PlayerInput | undefined {
    const turmoil = player.game.turmoil;
    if (turmoil === undefined) {
      return undefined;
    }
    const policy: IPolicy = turmoil.rulingPolicy();
    if (policy.canAct?.(player)) {
      return new SelectOption(policyDescription(policy, player), 'Pay').andThen(() => policy.action?.(player));
    }
    return undefined;
  }

  public static applyOnCardPlayedEffect(player: IPlayer, selectedCard: IProjectCard): void {
    // PoliticalAgendas Greens P3 hook
    if (PartyHooks.shouldApplyPolicy(player, PartyName.GREENS, 'gp03')) {
      GREENS_POLICY_3.onCardPlayed(player, selectedCard);
    }

    // PoliticalAgendas MarsFirst P2 hook
    if (PartyHooks.shouldApplyPolicy(player, PartyName.MARS, 'mfp02')) {
      MARS_FIRST_POLICY_2.onCardPlayed(player, selectedCard);
    }
  }

  public static resolveTilePlacementCosts(player: IPlayer): void {
    // PoliticalAgendas Reds P2 hook
    if (PartyHooks.shouldApplyPolicy(player, PartyName.REDS, 'rp02')) {
      REDS_POLICY_2.onTilePlaced(player);
    }
  }

  public static resolveTilePlacementBonuses(player: IPlayer, spaceType: SpaceType): void {
    PartyHooks.applyMarsFirstRulingPolicy(player, spaceType);

    // PoliticalAgendas Greens P2 hook
    if (PartyHooks.shouldApplyPolicy(player, PartyName.GREENS, 'gp02')) {
      GREENS_POLICY_2.onTilePlaced(player);
    }

    // PoliticalAgendas Kelvinists P4 hook
    if (PartyHooks.shouldApplyPolicy(player, PartyName.KELVINISTS, 'kp04')) {
      KELVINISTS_POLICY_4.onTilePlaced(player);
    }
  }

  public static onGlobalParameterIncrease(player: IPlayer, parameter: GlobalParameter, steps: number = 1): void {
    if (parameter === GlobalParameter.TEMPERATURE) {
      // PoliticalAgendas Kelvinists P2 hook
      if (PartyHooks.shouldApplyPolicy(player, PartyName.KELVINISTS, 'kp02')) {
        player.stock.add(Resource.MEGACREDITS, steps * 3);
      }
    }

    // PoliticalAgendas Reds P4 hook
    if (PartyHooks.shouldApplyPolicy(player, PartyName.REDS, 'rp04')) {
      player.production.add(Resource.MEGACREDITS, -1 * steps, {log: true});
    }

    // PoliticalAgendas Scientists P3 hook
    if (PartyHooks.shouldApplyPolicy(player, PartyName.SCIENTISTS, 'sp03')) {
      player.drawCard(steps);
    }
  }

  // TODO(kberg): Add a test where if you raise oxygen to max temperature but temperature is maxed you do not have to pay for it.
  // It works, but4 a test would be helpful.
  public static computeTerraformRatingBump(player: IPlayer, tr: TRSource = {}): number {
    if (!PartyHooks.shouldApplyPolicy(player, PartyName.REDS, 'rp01')) return 0;

    // Making a local copy since it's going to get mutated.
    tr = {...tr};

    let total = 0;

    if (tr.oxygen !== undefined) {
      const availableSteps = constants.MAX_OXYGEN_LEVEL - player.game.getOxygenLevel();
      const steps = Math.min(availableSteps, tr.oxygen);
      total = total + steps;
      if (player.game.getOxygenLevel() < constants.OXYGEN_LEVEL_FOR_TEMPERATURE_BONUS &&
          player.game.getOxygenLevel() + steps >= constants.OXYGEN_LEVEL_FOR_TEMPERATURE_BONUS) {
        tr.temperature = (tr.temperature ?? 0) + 1;
      }
    }

    if (tr.temperature !== undefined) {
      const availableSteps = Math.floor((constants.MAX_TEMPERATURE - player.game.getTemperature()) / 2);
      const steps = Math.min(availableSteps, tr.temperature);
      total = total + steps;
      if (player.game.getTemperature() < constants.TEMPERATURE_FOR_OCEAN_BONUS &&
        player.game.getTemperature() + (steps * 2) >= constants.TEMPERATURE_FOR_OCEAN_BONUS) {
        tr.oceans = (tr.oceans ?? 0) + 1;
      }
    }

    if (tr.oceans !== undefined) {
      const availableSteps = constants.MAX_OCEAN_TILES - player.game.board.getOceanSpaces().length;
      const steps = Math.min(availableSteps, tr.oceans);
      total = total + steps;
    }

    if (tr.venus !== undefined) {
      const availableSteps = Math.floor((constants.MAX_VENUS_SCALE - player.game.getVenusScaleLevel()) / 2);
      const steps = Math.min(availableSteps, tr.venus);
      total = total + steps;
      if (player.game.getVenusScaleLevel() < constants.VENUS_LEVEL_FOR_TR_BONUS &&
        player.game.getVenusScaleLevel() + (steps * 2) >= constants.VENUS_LEVEL_FOR_TR_BONUS) {
        tr.tr = (tr.tr ?? 0) + 1;
      }
    }

    MoonExpansion.ifMoon(player.game, (moonData) => {
      if (tr.moonHabitat !== undefined) {
        const availableSteps = constants.MAXIMUM_HABITAT_RATE - moonData.habitatRate;
        total = total + Math.min(availableSteps, tr.moonHabitat);
      }

      if (tr.moonMining !== undefined) {
        const availableSteps = constants.MAXIMUM_MINING_RATE - moonData.miningRate;
        total = total + Math.min(availableSteps, tr.moonMining);
      }

      if (tr.moonLogistics !== undefined) {
        const availableSteps = constants.MAXIMUM_LOGISTICS_RATE - moonData.logisticRate;
        total = total + Math.min(availableSteps, tr.moonLogistics);
      }
    });

    total += tr.tr ?? 0;

    return total;
  }
}

================
File: underworld/ErodeSpacesDeferred.ts
================
import {IPlayer} from '../IPlayer';
import {PlayerInput} from '../PlayerInput';
import {Space} from '../boards/Space';
import {RunNTimes} from '../deferredActions/RunNTimes';
import {SelectSpace} from '../inputs/SelectSpace';
import {SpaceType} from '../../common/boards/SpaceType';
import {LogHelper} from '../LogHelper';

export class ErodeSpacesDeferred extends RunNTimes<Space> {
  constructor(player: IPlayer, count: number) {
    super(player, count);
  }

  protected run(): PlayerInput | undefined {
    const game = this.player.game;

    const spaces: Set<Space> = new Set();
    for (const hazardTile of game.board.getHazards()) {
      for (const space of game.board.getAdjacentSpaces(hazardTile)) {
        if (space.spaceType === SpaceType.LAND && space.tile === undefined) {
          spaces.add(space);
        }
      }
    }

    if (spaces.size === 0) {
      return undefined;
    }

    return new SelectSpace('Select space to erode' + this.titleSuffix(), Array.from(spaces))
      .andThen((space) => {
        space.bonus.forEach((spaceBonus) => game.grantSpaceBonus(this.player, spaceBonus));
        // game.erodedSpaces.push(space.id);
        LogHelper.logBoardTileAction(this.player, space, 'space', 'eroded');
        return this.next();
      });
  }
}

================
File: underworld/ExcavateSpaceDeferred.ts
================
import {IPlayer} from '../IPlayer';
import {PlayerInput} from '../PlayerInput';
import {Space} from '../boards/Space';
import {DeferredAction} from '../deferredActions/DeferredAction';
import {Priority} from '../deferredActions/Priority';
import {SelectSpace} from '../inputs/SelectSpace';
import {UnderworldExpansion} from './UnderworldExpansion';

export class ExcavateSpaceDeferred extends DeferredAction<Space> {
  constructor(
    player: IPlayer,
    private excavatableSpaces: Array<Space>,
    private title: string = 'Select space to excavate',
  ) {
    super(player, Priority.EXCAVATE_UNDERGROUND_RESOURCE);
  }

  public execute(): PlayerInput {
    return new SelectSpace(this.title,
      this.excavatableSpaces)
      .andThen((space) => {
        UnderworldExpansion.excavate(this.player, space);
        this.cb(space);
        return undefined;
      });
  }
}

================
File: underworld/ExcavateSpacesDeferred.ts
================
import {IPlayer} from '../IPlayer';
import {Priority} from '../deferredActions/Priority';
import {RunNTimes} from '../deferredActions/RunNTimes';
import {SelectSpace} from '../inputs/SelectSpace';
import {UnderworldExpansion} from '../underworld/UnderworldExpansion';

export class ExcavateSpacesDeferred extends RunNTimes<void> {
  constructor(
    player: IPlayer,
    count: number,
    private ignorePlacementRestrictions: boolean = false,
  ) {
    super(player, count, Priority.EXCAVATE_UNDERGROUND_RESOURCE);
  }

  protected run() {
    const title = 'Select space to excavate' + this.titleSuffix();
    this.player.defer(() => {
      return new SelectSpace(title,
        UnderworldExpansion.excavatableSpaces(this.player, this.ignorePlacementRestrictions))
        .andThen((space) => {
          UnderworldExpansion.excavate(this.player, space);
          this.next();
          return undefined;
        });
    });
    return undefined;
  }
}

================
File: underworld/IdentifySpacesDeferred.ts
================
import {IPlayer} from '../IPlayer';
import {PlayerInput} from '../PlayerInput';
import {Space} from '../boards/Space';
import {Priority} from '../deferredActions/Priority';
import {RunNTimes} from '../deferredActions/RunNTimes';
import {SelectSpace} from '../inputs/SelectSpace';
import {UnderworldExpansion} from './UnderworldExpansion';

export class IdentifySpacesDeferred extends RunNTimes<Space> {
  constructor(player: IPlayer, count: number) {
    super(player, count, Priority.IDENTIFY_UNDERGROUND_RESOURCE);
  }

  protected run(): PlayerInput | undefined {
    const title = 'Select space to identify' + this.titleSuffix();

    const identifiableSpaces = UnderworldExpansion.identifiableSpaces(this.player);
    if (identifiableSpaces.length === 0) {
      return undefined;
    }
    return new SelectSpace(title, identifiableSpaces)
      .andThen((space) => {
        UnderworldExpansion.identify(this.player.game, space, this.player);
        this.collection.push(space);
        return this.next();
      });
  }
}

================
File: underworld/UnderworldData.ts
================
import {UndergroundResourceToken} from '../../common/underworld/UndergroundResourceToken';

export type UnderworldData = {
  tokens: Array<UndergroundResourceToken>;
};

type TemperatureBonuses = 'data1pertemp' | 'microbe1pertemp' | 'plant2pertemp' | 'steel2pertemp' | 'titanium1pertemp';

export type UnderworldPlayerData = {
  corruption: number;
  temperatureBonus?: TemperatureBonuses,
}

================
File: underworld/UnderworldExpansion.ts
================
import {Board} from '../boards/Board';
import {IPlayer} from '../IPlayer';
import {Space} from '../boards/Space';
import {UnderworldData, UnderworldPlayerData} from './UnderworldData';
import {Random} from '../../common/utils/Random';
import {UndergroundResourceToken, undergroundResourceTokenDescription} from '../../common/underworld/UndergroundResourceToken';
import {inplaceShuffle} from '../utils/shuffle';
import {Resource} from '../../common/Resource';
import {AddResourcesToCard} from '../deferredActions/AddResourcesToCard';
import {CardResource} from '../../common/CardResource';
import {PlaceOceanTile} from '../deferredActions/PlaceOceanTile';
import {IGame} from '../IGame';
import {SpaceType} from '../../common/boards/SpaceType';
import {CardName} from '../../common/cards/CardName';
import {PlayerInput} from '../PlayerInput';
import {OrOptions} from '../inputs/OrOptions';
import {SelectOption} from '../inputs/SelectOption';
import {message} from '../logs/MessageBuilder';
import {SelectPaymentDeferred} from '../deferredActions/SelectPaymentDeferred';
import {Phase} from '../../common/Phase';
import {Units} from '../../common/Units';
import {LogHelper} from '../LogHelper';

export class UnderworldExpansion {
  private constructor() {}

  public static initialize(rnd: Random): UnderworldData {
    const tokens = this.allTokens();
    inplaceShuffle(tokens, rnd);
    return {
      tokens: tokens,
    };
  }

  /**
   * Creates an empty UnderworldData for games that don't include it.
   */
  public static initializeGameWithoutUnderworld(): UnderworldData {
    return {tokens: []};
  }

  private static allTokens(): Array<UndergroundResourceToken> {
    const tokens: Array<UndergroundResourceToken> = [];
    function add(count: number, token: UndergroundResourceToken) {
      for (let idx = 0; idx < count; idx++) {
        tokens.push(token);
      }
    }

    add(5, 'nothing');
    add(13, 'data1');
    add(4, 'data2');
    add(1, 'data3');

    add(10, 'corruption1');
    add(2, 'corruption2');

    add(4, 'card1');
    add(1, 'card2');

    add(3, 'steel2');
    add(1, 'steel1production');

    add(3, 'titaniumandplant');
    add(3, 'titanium2');
    add(1, 'titanium1production');

    add(4, 'plant2');
    add(1, 'plant3');
    add(4, 'plant1production');

    add(5, 'energy1production');
    add(3, 'heat2production');

    add(4, 'microbe2');

    add(2, 'tr');
    add(2, 'ocean');

    add(3, 'data1pertemp');
    add(1, 'microbe1pertemp');
    add(3, 'plant2pertemp');
    add(3, 'steel2pertemp');
    add(3, 'titanium1pertemp');

    return tokens;
  }

  public static initializePlayer(): UnderworldPlayerData {
    return {
      corruption: 0,
    };
  }

  /**
   * Return the spaces that have not yet been identified.
   *
   * For the most part, the opposite of `identifiedSpaces`.
   */
  public static identifiableSpaces(player: IPlayer): ReadonlyArray<Space> {
    const spaces = player.game.board.spaces.filter((space) => space.spaceType !== SpaceType.COLONY);
    if (player.cardIsInEffect(CardName.NEUTRINOGRAPH)) {
      return spaces.filter((space) => space.excavator === undefined);
    } else {
      return spaces.filter((space) => space.undergroundResources === undefined);
    }
  }

  /**
   * Return the spaces that not yet been identified.
   *
   * For the most part, the opposite of `identifiableSpaces`.
   */
  public static identifiedSpaces(game: IGame): ReadonlyArray<Space> {
    return game.board.spaces.filter(
      (space) => space.undergroundResources !== undefined,
    );
  }

  /** Identify the token at `space`, optionally trigger callbacks */
  public static identify(game: IGame, space: Space, player: IPlayer | undefined, fromExcavate: boolean = false): void {
    if (game.gameOptions.underworldExpansion !== true) {
      throw new Error('Underworld expansion not in this game');
    }

    if (space.undergroundResources !== undefined) {
      if (player?.cardIsInEffect(CardName.NEUTRINOGRAPH) && space.excavator === undefined) {
        UnderworldExpansion.addTokens(game, [space.undergroundResources]);
        space.undergroundResources = undefined;
      } else {
        return;
      }
    }
    const undergroundResource = game.underworldData?.tokens.pop();
    if (undergroundResource === undefined) {
      // TODO(kberg): collect tokens from all players
      throw new Error('Cannot identify excavation space, no available tokens.');
    }
    space.undergroundResources = undergroundResource;
    for (const p of game.getPlayersInGenerationOrder()) {
      for (const card of p.tableau) {
        card.onIdentification?.(player, p, space, fromExcavate);
      }
    }
  }

  /**
   * Return a list of spaces `player` may excavate.
   *
   * If `ignorePlacementRestictions` is true, `player` can excavate any space on Mars that has
   * not yet been excavated, even unidentified spaces.
   *
   * Otherwise, it may excavate any unexcavated space (even unidentified spaces) that
   *   1. they own
   *   2. next to a space they own
   *   3. next to their excavation markers
   *   4. that is not antother player's city.
   *
   * If a player played Concession Rights this generation, they automatically ignore placement restrictions.
   */
  public static excavatableSpaces(player: IPlayer, ignorePlacementRestrictions: boolean = false, ignoreConcsesionRights: boolean = false) {
    const board = player.game.board;

    // Compute any space that any player can excavate.
    const anyExcavatableSpaces = board.spaces.filter((space) => {
      if (space.excavator !== undefined) {
        return false;
      }

      if (space.undergroundResources === 'ocean' && !player.canAfford({cost: 4, tr: {oceans: 1}})) {
        return false;
      }

      return space.spaceType !== SpaceType.COLONY;
    });

    if (ignorePlacementRestrictions === true) {
      return anyExcavatableSpaces;
    }

    const concessionRights = player.playedCards.find((card) => card.name === CardName.CONCESSION_RIGHTS);
    if (concessionRights?.generationUsed === player.game.generation) {
      if (ignoreConcsesionRights === false) {
        return anyExcavatableSpaces;
      }
    }

    // Filter out the set of excavatable spaces that other players control.
    const commonExcavatableSpaces = anyExcavatableSpaces.filter((space) => {
      return !Board.isCitySpace(space) || space.player === player;
    });
    const spaces = commonExcavatableSpaces.filter((space) => {
      if (space.tile !== undefined && space.player === player) {
        return true;
      }
      return board.getAdjacentSpaces(space).some((s) => s.excavator === player);
    });
    if (spaces.length === 0) {
      return commonExcavatableSpaces;
    }
    return spaces;
  }

  public static excavate(player: IPlayer, space: Space) {
    const game = player.game;
    if (game.gameOptions.underworldExpansion !== true) {
      throw new Error('Underworld expansion not in this game');
    }

    if (space.undergroundResources === undefined) {
      this.identify(player.game, space, player, /* fromExcavate= */ true);
    }

    const undergroundResource = space.undergroundResources;
    if (undergroundResource === undefined) {
      throw new Error('No available identification tokens');
    }

    LogHelper.logBoardTileAction(player, space, `${undergroundResourceTokenDescription[undergroundResource]}`, 'excavated');
    this.grant(player, undergroundResource);

    space.excavator = player;
    player.tableau.forEach((card) => card.onExcavation?.(player, space));

    // TODO(kberg): The identification is supposed to be resolved after the benefit.
    game.board
      .getAdjacentSpaces(space)
      .forEach((s) => UnderworldExpansion.identify(game, s, player, /* fromExcavate= */ true));
    const leaser = game.getCardPlayerOrUndefined(CardName.EXCAVATOR_LEASING);
    if (leaser !== undefined) {
      leaser.stock.add(Resource.MEGACREDITS, 1, {log: true});
    }
  }

  public static grant(player: IPlayer, token: UndergroundResourceToken): void {
    switch (token) {
    case 'nothing':
      break;
    case 'card1':
      player.drawCard(1);
      break;
    case 'card2':
      player.drawCard(2);
      break;
    case 'corruption1':
      UnderworldExpansion.gainCorruption(player, 1, {log: true});
      break;
    case 'corruption2':
      UnderworldExpansion.gainCorruption(player, 2, {log: true});
      break;
    case 'data1':
      player.game.defer(new AddResourcesToCard(player, CardResource.DATA, {count: 1}));
      break;
    case 'data2':
      player.game.defer(new AddResourcesToCard(player, CardResource.DATA, {count: 2}));
      break;
    case 'data3':
      player.game.defer(new AddResourcesToCard(player, CardResource.DATA, {count: 3}));
      break;
    case 'steel2':
      player.stock.add(Resource.STEEL, 2, {log: true});
      break;
    case 'steel1production':
      player.production.add(Resource.STEEL, 1, {log: true});
      break;
    case 'titanium2':
      player.stock.add(Resource.TITANIUM, 2, {log: true});
      break;
    case 'titanium1production':
      player.production.add(Resource.TITANIUM, 1, {log: true});
      break;
    case 'plant1':
      player.stock.add(Resource.PLANTS, 1, {log: true});
      break;
    case 'plant2':
      player.stock.add(Resource.PLANTS, 2, {log: true});
      break;
    case 'plant3':
      player.stock.add(Resource.PLANTS, 3, {log: true});
      break;
    case 'plant1production':
      player.production.add(Resource.PLANTS, 1, {log: true});
      break;
    case 'titaniumandplant':
      player.stock.addUnits(Units.of({plants: 1, titanium: 1}), {log: true});
      break;
    case 'energy1production':
      player.production.add(Resource.ENERGY, 1, {log: true});
      break;
    case 'heat2production':
      player.production.add(Resource.HEAT, 2, {log: true});
      break;
    case 'microbe1':
      player.game.defer(new AddResourcesToCard(player, CardResource.MICROBE, {count: 1}));
      break;
    case 'microbe2':
      player.game.defer(new AddResourcesToCard(player, CardResource.MICROBE, {count: 2}));
      break;
    case 'tr':
      player.increaseTerraformRating();
      break;
    case 'ocean':
      if (player.canAfford({cost: 4, tr: {oceans: 1}})) {
        if (player.game.canAddOcean() || player.cardIsInEffect(CardName.WHALES)) {
          player.game.defer(new SelectPaymentDeferred(player, 4, {title: message('Select how to pay 4 M€ for ocean bonus')}))
            .andThen(() => player.game.defer(new PlaceOceanTile(player)));
        }
      }
      break;
    case 'data1pertemp':
    case 'microbe1pertemp':
    case 'plant2pertemp':
    case 'steel2pertemp':
    case 'titanium1pertemp':
      player.underworldData.temperatureBonus = token;
      player.game.log('For the rest of this generation, ${0} will gain ${1}', (b) => b.player(player).string(undergroundResourceTokenDescription[token]));
      break;
    default:
      throw new Error('Unknown reward: ' + token);
    }
  }

  // TODO(kberg): turn into a deferred action?
  public static maybeBlockAttack(target: IPlayer, perpetrator: IPlayer, cb: (proceed: boolean) => PlayerInput | undefined): PlayerInput | undefined {
    if (target.game.gameOptions.underworldExpansion === false) {
      return cb(true);
    }
    const privateMilitaryContractor = target.playedCards.find((card) => card.name === CardName.PRIVATE_MILITARY_CONTRACTOR);
    const militaryContractorFighters = privateMilitaryContractor?.resourceCount ?? 0;
    if (target.underworldData.corruption === 0 && militaryContractorFighters === 0) {
      return cb(true);
    }
    const options = new OrOptions();
    options.title = message('Spend 1 corruption to block an attack by ${0}?', (b) => b.player(perpetrator));
    if (privateMilitaryContractor !== undefined && militaryContractorFighters > 0) {
      options.options.push(
        new SelectOption(
          message('Block with ${0} fighters.', (b) => b.cardName(CardName.PRIVATE_MILITARY_CONTRACTOR)),
          'Spend fighter')
          .andThen(() => {
            target.removeResourceFrom(privateMilitaryContractor, 1);
            target.game.log(
              '${0} spent 1 fighter on ${1} to block an attack by ${2}',
              (b) => b.player(target).cardName(CardName.PRIVATE_MILITARY_CONTRACTOR).player(perpetrator));
            return cb(false);
          }),
      );
    }
    if (target.underworldData.corruption > 0) {
      options.options.push(
        new SelectOption('Block with corruption', 'Spend corruption')
          .andThen(() => {
            target.underworldData.corruption--;
            target.game.log(
              '${0} spent 1 corruption to block an attack by ${1}',
              (b) => b.player(target).player(perpetrator));
            return cb(false);
          }),
      );
    }
    options.options.push(
      new SelectOption('Do not block', 'Do not block')
        .andThen(() => {
          return cb(true);
        }),
    );
    return options;
  }

  public static gainCorruption(player: IPlayer, count: number, options?: {log: boolean}) {
    player.underworldData.corruption += count;
    if (options?.log === true) {
      player.game.log('${0} gained ${1} corruption', (b) => b.player(player).number(count));
    }
  }

  public static loseCorruption(player: IPlayer, count: number, options?: {log: boolean}) {
    player.underworldData.corruption -= count;
    if (options?.log === true) {
      player.game.log('${0} spent ${1} corruption', (b) => b.player(player).number(count));
    }
  }

  static removeAllUnclaimedTokens(game: IGame) {
    if (game.underworldData === undefined) {
      return;
    }
    for (const space of UnderworldExpansion.identifiedSpaces(game)) {
      if (space.undergroundResources !== undefined && space.excavator === undefined) {
        game.underworldData.tokens.push(space.undergroundResources);
        space.undergroundResources = undefined;
      }
    }
    inplaceShuffle(game.underworldData.tokens, game.rng);
    game.log('All unidentified underground resources have been shuffled back into the pile.');
  }

  static removeUnclaimedToken(game: IGame, space: Space) {
    if (game.underworldData === undefined) {
      return;
    }
    if (space.undergroundResources !== undefined && space.excavator === undefined) {
      game.underworldData.tokens.push(space.undergroundResources);
      space.undergroundResources = undefined;
    } else {
      throw new Error('Cannot reclaim that space');
    }
    inplaceShuffle(game.underworldData.tokens, game.rng);
  }

  /** Add the set of tokens to the pool, and then shuffle the pool */
  static addTokens(game: IGame, tokens: Array<UndergroundResourceToken>) {
    if (game.underworldData === undefined) {
      return;
    }
    game.underworldData.tokens.push(...tokens);
    inplaceShuffle(game.underworldData.tokens, game.rng);
  }

  static excavationMarkerCount(player: IPlayer): number {
    return this.excavatedSpaces(player).length;
  }

  static excavatedSpaces(player: IPlayer) {
    return player.game.board.spaces.filter((space) => space.excavator === player);
  }

  static endGeneration(game: IGame) {
    game.getPlayersInGenerationOrder().forEach((player) => player.underworldData.temperatureBonus = undefined);
  }

  //   // TODO(kberg): add viz for temperature bonus.
  static onTemperatureChange(game: IGame, steps: number) {
    if (game.phase !== Phase.ACTION) {
      return;
    }
    game.getPlayersInGenerationOrder().forEach((player) => {
      switch (player.underworldData.temperatureBonus) {
      case 'data1pertemp':
      case 'microbe1pertemp':
        const resource = player.underworldData.temperatureBonus === 'data1pertemp' ? CardResource.DATA : CardResource.MICROBE;
        for (let i = 0; i < steps; i++) {
          player.game.defer(new AddResourcesToCard(player, resource));
        }
        break;
      case 'plant2pertemp':
        player.stock.add(Resource.PLANTS, 2 * steps, {log: true});
        break;
      case 'steel2pertemp':
        player.stock.add(Resource.STEEL, 2 * steps, {log: true});
        break;
      case 'titanium1pertemp':
        player.stock.add(Resource.TITANIUM, steps, {log: true});
        break;
      case undefined:
        break;
      default:
        throw new Error('Unknown temperatore bonus: ' + player.underworldData.temperatureBonus);
      }
    });
  }
}

================
File: utils/durations.ts
================
// Expected format
//
// `{number}{suffix}`...
// Suffix is h or H for hour, m or M for minute, s or S for second.
//
export function durationToMilliseconds(input: string): number {
  const re = /^([0-9]+[Hh])?([0-9]+[Mm])?([0-9]+[Ss])?$/;
  const parsed = re.exec(input);
  if (parsed === null) return NaN;
  let total = 0;
  const [hours, minutes, seconds] = parsed.slice(1, 4);

  let valid = false;
  for (const entry of [hours, minutes, seconds]) {
    if (entry === undefined) continue;
    const [value, unit] = [parseFloat(entry.slice(0, -1)), entry.slice(-1)];
    if (isNaN(value)) return NaN;

    switch (unit) {
    case 'h':
    case 'H':
      total += value * 60 * 60 * 1000;
      break;
    case 'm':
    case 'M':
      total += value * 60 * 1000;
      break;
    case 's':
    case 'S':
      total += value * 1000;
      break;
    default:
      return NaN;
    }
    valid = true;
  }
  return valid ? total : NaN;
}

================
File: utils/server-ids.ts
================
export function generateRandomId(prefix: string): string {
  // 281474976710656 possible values.
  return prefix + Math.floor(Math.random() * Math.pow(16, 12)).toString(16);
}

export const serverId = process.env.SERVER_ID || generateRandomId('');
export const statsId = process.env.STATS_ID || generateRandomId('');
export const runId = generateRandomId('r');

================
File: utils/server.ts
================
export function isProduction(): boolean {
  return process.env.NODE_ENV === 'production';
}

================
File: utils/shuffle.ts
================
// in-place shuffle using the Fisher-Yates algorithm..
// See https://bost.ocks.org/mike/shuffle/ for details.

import {Random} from '../../common/utils/Random';

export function inplaceShuffle(array: Array<unknown>, rng: Random) {
  let last = array.length;

  // While there remain elements to shuffle…
  while (last > 0) {
    // Pick a remaining element…
    const idx = rng.nextInt(last);
    last--;

    // And swap it with the current element.
    [array[last], array[idx]] = [array[idx], array[last]];
  }
}

================
File: utils/timer.ts
================
export function timeSync<T>(cb: () => T): {value: T, duration: number} {
  const startMs = Date.now();
  return {
    value: cb(),
    duration: Date.now() - startMs,
  };
}

export function timeAsync<T>(promise: Promise<T>): Promise<{value: T, duration: number}> {
  const startMs = Date.now();
  return promise.then((value) => {
    return {value, duration: Date.now() - startMs};
  });
}

================
File: venusNext/GrantVenusAltTrackBonusDeferred.ts
================
import {OrOptions} from '../inputs/OrOptions';
import {SelectCard} from '../inputs/SelectCard';
import {DeferredAction} from '../deferredActions/DeferredAction';
import {Priority} from '../deferredActions/Priority';
import {IPlayer} from '../IPlayer';
import {GainResources} from '../inputs/GainResources';
import {message} from '../logs/MessageBuilder';

export class GrantVenusAltTrackBonusDeferred extends DeferredAction {
  constructor(
    player: IPlayer,
    public standardResourceCount: number,
    public wildResource: boolean,
  ) {
    super(player, Priority.GAIN_RESOURCE_OR_PRODUCTION);
  }

  private selectStandardResources(count: number) {
    return new GainResources(
      this.player,
      count,
      message('Gain ${0} resource(s) for your Venus track bonus', (b) => b.number(count)),
    );
  }

  public execute() {
    const resourceCards = this.player.getResourceCards(undefined);

    if (this.wildResource === false || resourceCards.length === 0) {
      return this.selectStandardResources(this.standardResourceCount);
    }

    const selectCard = new SelectCard('Add resource to card', 'Add resource', resourceCards)
      .andThen(([card]) => {
        this.player.addResourceTo(card, {qty: 1, log: true});
        return undefined;
      });
    const wild = new OrOptions(selectCard, this.selectStandardResources(1));
    if (this.standardResourceCount > 0) {
      wild.andThen(() => {
        return this.standardResourceCount > 0 ?
          this.selectStandardResources(this.standardResourceCount) :
          undefined;
      });
      wild.title = message(
        'Choose your wild resource bonus, after which you will gain ${0} more distinct standard resources.',
        (b) => b.number(this.standardResourceCount));
    } else {
      wild.title = 'Choose your wild resource bonus.';
    }
    return wild;
  }
}
